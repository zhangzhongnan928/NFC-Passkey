"use strict";var e=require("../../utils/encodings.js"),t=require("../../wallet-api/rpc.js"),a=require("./wallet-api-eth-transaction.js"),s=require("./wallet-api-eth-typed-data.js");require("canonicalize"),require("@privy-io/public-api"),exports.walletRpc=async function({context:n,account:r,rpcRequest:i}){switch(i.chainType){case"ethereum":return async function({context:n,account:r,rpcRequest:i}){switch(i.method){case"personal_sign":{let[e]=i.params,a=await t.rpc(n,n.signRequest,{chain_type:"ethereum",method:"personal_sign",wallet_id:r.id,params:e.startsWith("0x")?{message:e.slice(2),encoding:"hex"}:{message:e,encoding:"utf-8"}});if("personal_sign"!==a.method)throw Error("Unable to sign message");return{data:a.data.signature}}case"eth_signTransaction":{let[e]=i.params,s=await t.rpc(n,n.signRequest,{chain_type:"ethereum",method:"eth_signTransaction",wallet_id:r.id,params:{transaction:a.toWalletApiUnsignedEthTransaction(e)}});if("eth_signTransaction"!==s.method)throw Error("Unable to sign transaction");return{data:s.data.signed_transaction}}case"eth_signTypedData_v4":{let[,e]=i.params,a=await t.rpc(n,n.signRequest,{chain_type:"ethereum",method:i.method,wallet_id:r.id,params:{typed_data:s.toWalletApiTypedData(e)}});if("eth_signTypedData_v4"!==a.method)throw Error("Unable to sign typed data");return{data:a.data.signature}}case"eth_sign":{let[,a]=i.params,s=await t.rpc(n,n.signRequest,{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:r.id,params:{hash:e.isHexEncoded(a)?a:e.bytesToHex(e.utf8ToBytes(a))}});if("secp256k1_sign"!==s.method)throw Error("Unable to sign message");return{data:s.data.signature}}case"secp256k1_sign":{let[a]=i.params,s=await t.rpc(n,n.signRequest,{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:r.id,params:{hash:e.isHexEncoded(a)?a:e.bytesToHex(e.utf8ToBytes(a))}});if("secp256k1_sign"!==s.method)throw Error("Unable to sign message");return{data:s.data.signature}}case"csw_signUserOperation":case"eth_sendTransaction":case"eth_populateTransactionRequest":throw Error(`This wallet does not support the method: ${i.method}`)}}({context:n,account:r,rpcRequest:i.request});case"solana":return async function({context:e,account:a,rpcRequest:s}){if("signMessage"===s.method){let{message:n}=s.params,r=await t.rpc(e,e.signRequest,{chain_type:"solana",method:"signMessage",wallet_id:a.id,params:{message:n,encoding:"base64"}});if("signMessage"!==r.method)throw Error("Unable to sign message");return{data:r.data.signature}}}({context:n,account:r,rpcRequest:i.request})}};
