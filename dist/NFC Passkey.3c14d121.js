// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (
  modules,
  entry,
  mainEntry,
  parcelRequireName,
  externals,
  distDir,
  publicUrl,
  devServer
) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var importMap = previousRequire.i || {};
  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        if (externals[name]) {
          return externals[name];
        }
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.require = nodeRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.distDir = distDir;
  newRequire.publicUrl = publicUrl;
  newRequire.devServer = devServer;
  newRequire.i = importMap;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  // Only insert newRequire.load when it is actually used.
  // The code in this file is linted against ES5, so dynamic import is not allowed.
  // INSERT_LOAD_HERE

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });
    }
  }
})({"n0fw4":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SERVER_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "439701173a9199ea";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "5e0263af3c14d121";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_SERVER_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_SERVER_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ , bundleNotFound = false;
function getHostname() {
    return HMR_HOST || (typeof location !== 'undefined' && location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || (typeof location !== 'undefined' ? location.port : HMR_SERVER_PORT);
}
// eslint-disable-next-line no-redeclare
let WebSocket = globalThis.WebSocket;
if (!WebSocket && typeof module.bundle.root === 'function') try {
    // eslint-disable-next-line no-global-assign
    WebSocket = module.bundle.root('ws');
} catch  {
// ignore.
}
var hostname = getHostname();
var port = getPort();
var protocol = HMR_SECURE || typeof location !== 'undefined' && location.protocol === 'https:' && ![
    'localhost',
    '127.0.0.1',
    '0.0.0.0'
].includes(hostname) ? 'wss' : 'ws';
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if (!parent || !parent.isParcelRequire) {
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        // If we're running in the dev server's node runner, listen for messages on the parent port.
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) {
            parentPort.on('message', async (message)=>{
                try {
                    await handleMessage(message);
                    parentPort.postMessage('updated');
                } catch  {
                    parentPort.postMessage('restart');
                }
            });
            // After the bundle has finished running, notify the dev server that the HMR update is complete.
            queueMicrotask(()=>parentPort.postMessage('ready'));
        }
    } catch  {
        if (typeof WebSocket !== 'undefined') try {
            ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
        } catch (err) {
            // Ignore cloudflare workers error.
            if (err.message && !err.message.includes('Disallowed operation called within global scope')) console.error(err.message);
        }
    }
    if (ws) {
        // $FlowFixMe
        ws.onmessage = async function(event /*: {data: string, ...} */ ) {
            var data /*: HMRMessage */  = JSON.parse(event.data);
            await handleMessage(data);
        };
        if (ws instanceof WebSocket) {
            ws.onerror = function(e) {
                if (e.message) console.error(e.message);
            };
            ws.onclose = function() {
                console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
            };
        }
    }
}
async function handleMessage(data /*: HMRMessage */ ) {
    checkedAssets = {} /*: {|[string]: boolean|} */ ;
    disposedAssets = {} /*: {|[string]: boolean|} */ ;
    assetsToAccept = [];
    assetsToDispose = [];
    bundleNotFound = false;
    if (data.type === 'reload') fullReload();
    else if (data.type === 'update') {
        // Remove error overlay if there is one
        if (typeof document !== 'undefined') removeErrorOverlay();
        let assets = data.assets;
        // Handle HMR Update
        let handled = assets.every((asset)=>{
            return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
        });
        // Dispatch a custom event in case a bundle was not found. This might mean
        // an asset on the server changed and we should reload the page. This event
        // gives the client an opportunity to refresh without losing state
        // (e.g. via React Server Components). If e.preventDefault() is not called,
        // we will trigger a full page reload.
        if (handled && bundleNotFound && assets.some((a)=>a.envHash !== HMR_ENV_HASH) && typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') handled = !window.dispatchEvent(new CustomEvent('parcelhmrreload', {
            cancelable: true
        }));
        if (handled) {
            console.clear();
            // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
            if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
            await hmrApplyUpdates(assets);
            hmrDisposeQueue();
            // Run accept callbacks. This will also re-execute other disposed assets in topological order.
            let processedAssets = {};
            for(let i = 0; i < assetsToAccept.length; i++){
                let id = assetsToAccept[i][1];
                if (!processedAssets[id]) {
                    hmrAccept(assetsToAccept[i][0], id);
                    processedAssets[id] = true;
                }
            }
        } else fullReload();
    }
    if (data.type === 'error') {
        // Log parcel errors to console
        for (let ansiDiagnostic of data.diagnostics.ansi){
            let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
            console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
        }
        if (typeof document !== 'undefined') {
            // Render the fancy html overlay
            removeErrorOverlay();
            var overlay = createErrorOverlay(data.diagnostics.html);
            // $FlowFixMe
            document.body.appendChild(overlay);
        }
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="${protocol === 'wss' ? 'https' : 'http'}://${hostname}:${port}/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if (typeof location !== 'undefined' && 'reload' in location) location.reload();
    else if (typeof extCtx !== 'undefined' && extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
    else try {
        let { workerData, parentPort } = module.bundle.root('node:worker_threads') /*: any*/ ;
        if (workerData !== null && workerData !== void 0 && workerData.__parcel) parentPort.postMessage('restart');
    } catch (err) {
        console.error("[parcel] \u26A0\uFE0F An HMR update was not accepted. Please restart the process.");
    }
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout || typeof document === 'undefined') return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    checkedAssets = {};
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else if (a !== null) {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) {
            bundleNotFound = true;
            return true;
        }
        return hmrAcceptCheckOne(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return null;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    if (!cached) return true;
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
    return false;
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"kTBnD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _jsSdkCore = require("@privy-io/js-sdk-core");
var _jsSdkCoreDefault = parcelHelpers.interopDefault(_jsSdkCore);
// Add PrivyClient if you were to use the SDK directly
// For now, we simulate the Privy interaction.
document.addEventListener('DOMContentLoaded', ()=>{
    const claimButton = document.getElementById('claimButton');
    const statusMessage = document.getElementById('statusMessage');
    const privyAppId = 'cmb9z52y600o1ky0m78whsb08'; // Your Privy App ID
    let privy = null;
    // Custom LocalStorage Adapter for Privy
    const localStorageAdapter = {
        get: (key)=>{
            try {
                return window.localStorage.getItem(key);
            } catch (error) {
                console.error('LocalStorageAdapter: Error getting item', key, error);
                // Potentially update UI or status message if storage is completely blocked
                statusMessage.textContent = 'Error: Browser storage is inaccessible. Please check your browser settings (e.g., disable "Block all cookies").';
                claimButton.disabled = true;
                return null;
            }
        },
        put: (key, value)=>{
            try {
                window.localStorage.setItem(key, value);
            } catch (error) {
                console.error('LocalStorageAdapter: Error setting item', key, error);
                statusMessage.textContent = 'Error: Browser storage is inaccessible. Please check your browser settings.';
                claimButton.disabled = true;
            }
        },
        del: (key)=>{
            try {
                window.localStorage.removeItem(key);
            } catch (error) {
                console.error('LocalStorageAdapter: Error deleting item', key, error);
                statusMessage.textContent = 'Error: Browser storage is inaccessible. Please check your browser settings.';
                claimButton.disabled = true;
            }
        },
        // getKeys is optional, but good to have if Privy uses it.
        getKeys: ()=>{
            try {
                return Object.keys(window.localStorage);
            } catch (error) {
                console.error('LocalStorageAdapter: Error getting keys', error);
                statusMessage.textContent = 'Error: Browser storage is inaccessible. Please check your browser settings.';
                claimButton.disabled = true;
                return [];
            }
        }
    };
    try {
        privy = new (0, _jsSdkCoreDefault.default)({
            appId: privyAppId,
            storage: localStorageAdapter // Use the custom adapter
        });
        console.log('Privy SDK initialized with custom storage adapter.');
        console.log('Inspecting Privy object:', privy); // Log the privy object for inspection
    } catch (error) {
        statusMessage.textContent = 'Error: Account system components failed to initialize. Please refresh.';
        claimButton.disabled = true;
        console.error('Error initializing Privy SDK:', error);
        return;
    }
    // Helper function to convert string to Uint8Array
    function stringToUint8Array(str) {
        const encoder = new TextEncoder();
        return encoder.encode(str);
    }
    async function createGuestUserAndWallet() {
        statusMessage.textContent = 'Setting up your secure account...';
        let user;
        let walletAddress;
        try {
            statusMessage.textContent = 'Creating new guest account...';
            console.log('Attempting guest account creation directly...');
            if (privy.auth && typeof privy.createGuestAccount === 'function') {
                console.log('Attempting privy.createGuestAccount()...');
                user = await privy.createGuestAccount();
                console.log('privy.createGuestAccount() completed. User:', user);
            } else if (privy.unstable_createGuestAccount && typeof privy.unstable_createGuestAccount === 'function') {
                console.log('Attempting privy.unstable_createGuestAccount()...');
                user = await privy.unstable_createGuestAccount();
                console.log('privy.unstable_createGuestAccount() completed. User:', user);
            } else {
                // This else block implies neither createGuestAccount nor unstable_createGuestAccount is a function.
                // This is a critical failure for the desired headless flow.
                console.error('FATAL: No method found for direct guest account creation (privy.createGuestAccount or privy.unstable_createGuestAccount).');
                throw new Error('Headless guest account creation method not available in SDK.');
            }
            if (!user) {
                // This case means createGuestAccount was called but returned a falsy value (e.g. null/undefined)
                console.error('Guest account creation function was called but returned no user.');
                throw new Error('Guest account creation attempt returned no user.');
            }
            console.log('Guest user session active. User ID:', user.id);
            statusMessage.textContent = 'Guest account active. Setting up secure storage...';
            // Now that we have a user (guest), check if they already have a wallet from a previous session
            if (user.wallet && user.wallet.address) {
                walletAddress = user.wallet.address;
                console.log('Guest user already has a wallet:', walletAddress);
            } else {
                console.log('Attempting privy.embeddedWallet.create() for guest user...');
                const embeddedWallet = await privy.embeddedWallet.create();
                console.log('privy.embeddedWallet.create() completed. Wallet:', embeddedWallet);
                if (!embeddedWallet || !embeddedWallet.address) throw new Error('Secure storage (wallet) creation failed for guest.');
                walletAddress = embeddedWallet.address;
                console.log('New secure storage (wallet) created for guest:', walletAddress);
            }
            statusMessage.textContent = `Account ready: ${walletAddress.substring(0, 10)}...`;
            await new Promise((resolve)=>setTimeout(resolve, 1000));
            return walletAddress;
        } catch (error) {
            console.error('Privy guest/wallet setup error:', error);
            statusMessage.textContent = `Account setup error: ${error.message || 'An unknown error occurred.'}`;
            claimButton.disabled = false;
            throw error;
        }
    }
    claimButton.addEventListener('click', async ()=>{
        statusMessage.textContent = 'Initializing...';
        claimButton.disabled = true;
        try {
            const walletAddress = await createGuestUserAndWallet();
            if (!walletAddress) {
                // Error message already set by createGuestUserAndWallet
                claimButton.disabled = false;
                return;
            }
            statusMessage.textContent = 'Initializing secure sign-in method...';
            if (!navigator.credentials || !navigator.credentials.create) {
                statusMessage.textContent = 'Secure sign-in method (WebAuthn) is not supported.';
                claimButton.disabled = false;
                return;
            }
            const challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);
            const rp = {
                name: 'NFC Passkey Demo',
                id: window.location.hostname
            };
            const userId = stringToUint8Array(walletAddress); // Use wallet address as user ID for passkey
            const passkeyUser = {
                id: userId,
                name: walletAddress,
                displayName: `User (${walletAddress.substring(0, 6)}...${walletAddress.substring(walletAddress.length - 4)})`
            };
            const pubKeyCredParams = [
                {
                    type: 'public-key',
                    alg: -7
                },
                {
                    type: 'public-key',
                    alg: -257
                }
            ];
            const creationOptions = {
                challenge,
                rp,
                user: passkeyUser,
                pubKeyCredParams,
                authenticatorSelection: {
                    authenticatorAttachment: 'platform',
                    requireResidentKey: true,
                    userVerification: 'preferred'
                },
                timeout: 60000,
                attestation: 'direct'
            };
            statusMessage.textContent = 'Please follow browser prompts to set up your secure sign-in.';
            const credential = await navigator.credentials.create({
                publicKey: creationOptions
            });
            if (credential) {
                statusMessage.textContent = 'Sign-in method created! Opening your Stamp Card...';
                console.log('Passkey credential created:', credential);
                console.log('User ID (Wallet Address) used for passkey:', walletAddress);
                // TODO: Here you might want to link the created passkey credential to the Privy guest user
                // This typically involves sending credential details to your backend, which then uses Privy's admin SDK.
                // Or, check if Privy client-side SDK has a method to link a newly created passkey.
                // For now, we proceed directly to opening the pkpass file.
                window.location.href = 'demo.pkpass';
                claimButton.textContent = 'Claimed & Pass Opened!';
                setTimeout(()=>{
                    if (document.hasFocus()) statusMessage.textContent = 'Stamp Card initiated. Check downloads or Wallet app (iOS).';
                }, 3000);
            } else {
                statusMessage.textContent = 'Secure sign-in setup failed or was cancelled.';
                claimButton.disabled = false;
            }
        } catch (error) {
            console.error('Overall process error:', error);
            if (!statusMessage.textContent.startsWith('Account setup error:')) statusMessage.textContent = `Error: ${error.message || 'An unexpected error occurred.'}`;
            if (error.name === 'NotAllowedError') statusMessage.textContent = 'Operation was cancelled or not allowed. Please try again.';
            claimButton.disabled = false;
        }
    });
});

},{"@privy-io/js-sdk-core":"gwvep","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gwvep":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BICONOMY", ()=>(0, _publicApi.BICONOMY));
parcelHelpers.export(exports, "COINBASE_SMART_WALLET", ()=>(0, _publicApi.COINBASE_SMART_WALLET));
parcelHelpers.export(exports, "KERNEL", ()=>(0, _publicApi.KERNEL));
parcelHelpers.export(exports, "LIGHT_ACCOUNT", ()=>(0, _publicApi.LIGHT_ACCOUNT));
parcelHelpers.export(exports, "SAFE", ()=>(0, _publicApi.SAFE));
parcelHelpers.export(exports, "THIRDWEB", ()=>(0, _publicApi.THIRDWEB));
parcelHelpers.export(exports, "LocalStorage", ()=>(0, _localStorageMjs.LocalStorage));
parcelHelpers.export(exports, "InMemoryCache", ()=>(0, _inMemoryStorageMjs.InMemoryCache));
parcelHelpers.export(exports, "MoonpayApiError", ()=>(0, _errorMjs.MoonpayApiError));
parcelHelpers.export(exports, "PrivyApiError", ()=>(0, _errorMjs.PrivyApiError));
parcelHelpers.export(exports, "PrivyClientError", ()=>(0, _errorMjs.PrivyClientError));
parcelHelpers.export(exports, "createErrorFormatter", ()=>(0, _errorMjs.createErrorFormatter));
parcelHelpers.export(exports, "errorIndicatesMfaCanceled", ()=>(0, _errorMjs.errorIndicatesMfaCanceled));
parcelHelpers.export(exports, "EmbeddedProviderError", ()=>(0, _errorsMjs.EmbeddedProviderError));
parcelHelpers.export(exports, "PrivyConnectorError", ()=>(0, _errorsMjs.PrivyConnectorError));
parcelHelpers.export(exports, "PrivyEmbeddedWalletErrorCode", ()=>(0, _errorsMjs.PrivyEmbeddedWalletErrorCode));
parcelHelpers.export(exports, "PrivyProviderRpcError", ()=>(0, _errorsMjs.PrivyProviderRpcError));
parcelHelpers.export(exports, "ProviderErrors", ()=>(0, _errorsMjs.ProviderErrors));
parcelHelpers.export(exports, "errorIndicatesMaxMfaRetries", ()=>(0, _errorsMjs.errorIndicatesMaxMfaRetries));
parcelHelpers.export(exports, "errorIndicatesMfaRateLimit", ()=>(0, _errorsMjs.errorIndicatesMfaRateLimit));
parcelHelpers.export(exports, "errorIndicatesMfaTimeout", ()=>(0, _errorsMjs.errorIndicatesMfaTimeout));
parcelHelpers.export(exports, "errorIndicatesMfaVerificationFailed", ()=>(0, _errorsMjs.errorIndicatesMfaVerificationFailed));
parcelHelpers.export(exports, "errorIndicatesRecoveryIsNeeded", ()=>(0, _errorsMjs.errorIndicatesRecoveryIsNeeded));
parcelHelpers.export(exports, "getUserEmbeddedEthereumWallet", ()=>(0, _getUserEmbeddedEthereumWalletMjs.getUserEmbeddedEthereumWallet));
parcelHelpers.export(exports, "getUserEmbeddedWallet", ()=>(0, _getUserEmbeddedEthereumWalletMjs.getUserEmbeddedWallet));
parcelHelpers.export(exports, "getAllUserEmbeddedEthereumWallets", ()=>(0, _getAllUserEmbeddedEthereumWalletsMjs.getAllUserEmbeddedEthereumWallets));
parcelHelpers.export(exports, "getAllUserEmbeddedSolanaWallets", ()=>(0, _getAllUserEmbeddedSolanaWalletsMjs.getAllUserEmbeddedSolanaWallets));
parcelHelpers.export(exports, "getAllUserEmbeddedBitcoinWallets", ()=>(0, _getAllUserEmbeddedBitcoinWalletsMjs.getAllUserEmbeddedBitcoinWallets));
parcelHelpers.export(exports, "getEntropyDetailsFromAccount", ()=>(0, _entropyMjs.getEntropyDetailsFromAccount));
parcelHelpers.export(exports, "getEntropyDetailsFromUser", ()=>(0, _entropyMjs.getEntropyDetailsFromUser));
parcelHelpers.export(exports, "getUserSmartWallet", ()=>(0, _getUserSmartWalletMjs.getUserSmartWallet));
parcelHelpers.export(exports, "getJsonRpcEndpointFromChain", ()=>(0, _indexMjs.getJsonRpcEndpointFromChain));
parcelHelpers.export(exports, "populateTransactionRequest", ()=>(0, _indexMjs.populateTransactionRequest));
parcelHelpers.export(exports, "throwIfInvalidRecoveryUpgradePath", ()=>(0, _indexMjs.throwIfInvalidRecoveryUpgradePath));
parcelHelpers.export(exports, "countryCodesAndNumbers", ()=>(0, _phoneNumberUtilsMjs.countryCodesAndNumbers));
parcelHelpers.export(exports, "formatPhoneNumber", ()=>(0, _phoneNumberUtilsMjs.formatPhoneNumber));
parcelHelpers.export(exports, "getPhoneCountryCodeAndNumber", ()=>(0, _phoneNumberUtilsMjs.getPhoneCountryCodeAndNumber));
parcelHelpers.export(exports, "getPlaceholderPhoneNumber", ()=>(0, _phoneNumberUtilsMjs.getPlaceholderPhoneNumber));
parcelHelpers.export(exports, "lastFourDigits", ()=>(0, _phoneNumberUtilsMjs.lastFourDigits));
parcelHelpers.export(exports, "phoneNumberTypingFormatter", ()=>(0, _phoneNumberUtilsMjs.phoneNumberTypingFormatter));
parcelHelpers.export(exports, "validatePhoneNumber", ()=>(0, _phoneNumberUtilsMjs.validatePhoneNumber));
parcelHelpers.export(exports, "getUserEmbeddedSolanaWallet", ()=>(0, _getUserEmbeddedSolanaWalletMjs.getUserEmbeddedSolanaWallet));
parcelHelpers.export(exports, "toObjectKeys", ()=>(0, _toObjectKeysMjs.toObjectKeys));
parcelHelpers.export(exports, "calculateTotalGasEstimate", ()=>(0, _gasMjs.calculateTotalGasEstimate));
parcelHelpers.export(exports, "QuantityToBigNumber", ()=>(0, _ethersMjs.QuantityToBigNumber));
parcelHelpers.export(exports, "convertBigNumberish", ()=>(0, _ethersMjs.convertBigNumberish));
parcelHelpers.export(exports, "toEthersUnsignedTransaction", ()=>(0, _ethersMjs.toEthersUnsignedTransaction));
parcelHelpers.export(exports, "SolanaUsdcAddressMap", ()=>(0, _getIsTokenUsdcMjs.SolanaUsdcAddressMap));
parcelHelpers.export(exports, "UsdcAddressMap", ()=>(0, _getIsTokenUsdcMjs.UsdcAddressMap));
parcelHelpers.export(exports, "getIsTokenUsdc", ()=>(0, _getIsTokenUsdcMjs.getIsTokenUsdc));
parcelHelpers.export(exports, "chainToMoonpayCurrency", ()=>(0, _moonpayMjs.chainToMoonpayCurrency));
parcelHelpers.export(exports, "fundingMethodToMoonpayPaymentMethod", ()=>(0, _moonpayMjs.fundingMethodToMoonpayPaymentMethod));
parcelHelpers.export(exports, "isSupportedChainIdForMoonpay", ()=>(0, _moonpayMjs.isSupportedChainIdForMoonpay));
parcelHelpers.export(exports, "getCoinbaseOnRampUrl", ()=>(0, _coinbaseMjs.getCoinbaseOnRampUrl));
parcelHelpers.export(exports, "isSupportedChainIdForCoinbaseOnramp", ()=>(0, _coinbaseMjs.isSupportedChainIdForCoinbaseOnramp));
parcelHelpers.export(exports, "toCoinbaseAssetId", ()=>(0, _coinbaseMjs.toCoinbaseAssetId));
parcelHelpers.export(exports, "toCoinbaseBlockchainFromChainId", ()=>(0, _coinbaseMjs.toCoinbaseBlockchainFromChainId));
parcelHelpers.export(exports, "SolanaClient", ()=>(0, _clientMjs.SolanaClient));
parcelHelpers.export(exports, "createSiwsMessage", ()=>(0, _createSiwsMessageMjs.createSiwsMessage));
parcelHelpers.export(exports, "getSolanaRpcEndpointForCluster", ()=>(0, _getSolanaRpcEndpointForClusterMjs.getSolanaRpcEndpointForCluster));
parcelHelpers.export(exports, "getSolanaUsdcMintAddressForCluster", ()=>(0, _getSolanaUsdcMintAddressForClusterMjs.getSolanaUsdcMintAddressForCluster));
parcelHelpers.export(exports, "getSolanaClusterDisplayName", ()=>(0, _getSolanaClusterDisplayNameMjs.getSolanaClusterDisplayName));
parcelHelpers.export(exports, "ALL_WALLET_CLIENT_TYPES", ()=>(0, _typesMjs.ALL_WALLET_CLIENT_TYPES));
parcelHelpers.export(exports, "SUPPORTED_CONNECTOR_TYPES", ()=>(0, _typesMjs.SUPPORTED_CONNECTOR_TYPES));
parcelHelpers.export(exports, "formatLamportsAmount", ()=>(0, _formattersMjs.formatLamportsAmount));
parcelHelpers.export(exports, "formatTokenAmount", ()=>(0, _formattersMjs.formatTokenAmount));
parcelHelpers.export(exports, "formatWalletAddress", ()=>(0, _formattersMjs.formatWalletAddress));
parcelHelpers.export(exports, "formatWeiAmount", ()=>(0, _formattersMjs.formatWeiAmount));
parcelHelpers.export(exports, "create", ()=>(0, _createMjs.create));
parcelHelpers.export(exports, "rpc", ()=>(0, _rpcMjs.rpc));
parcelHelpers.export(exports, "getWallet", ()=>(0, _getWalletMjs.getWallet));
parcelHelpers.export(exports, "updateWallet", ()=>(0, _updateWalletMjs.updateWallet));
parcelHelpers.export(exports, "isUnifiedWallet", ()=>(0, _unifiedWalletMjs.isUnifiedWallet));
parcelHelpers.export(exports, "addSessionSigners", ()=>(0, _sessionSignersMjs.addSessionSigners));
parcelHelpers.export(exports, "removeSessionSigners", ()=>(0, _sessionSignersMjs.removeSessionSigners));
parcelHelpers.export(exports, "getCountryCallingCode", ()=>(0, _min.getCountryCallingCode));
parcelHelpers.export(exports, "delegatedActions", ()=>(0, _indexG0CxoRWQMjs.i));
parcelHelpers.export(exports, "crossApp", ()=>(0, _indexBu3YSxLMMjs.i));
parcelHelpers.export(exports, "default", ()=>(0, _privyMjsDefault.default));
var _privyMjs = require("./client/Privy.mjs");
var _privyMjsDefault = parcelHelpers.interopDefault(_privyMjs);
var _publicApi = require("@privy-io/public-api");
var _localStorageMjs = require("./storage/LocalStorage.mjs");
var _inMemoryStorageMjs = require("./storage/InMemoryStorage.mjs");
var _errorMjs = require("./Error.mjs");
var _errorsMjs = require("./embedded/errors.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("./utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("./utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("./utils/getAllUserEmbeddedSolanaWallets.mjs");
var _getAllUserEmbeddedBitcoinWalletsMjs = require("./utils/getAllUserEmbeddedBitcoinWallets.mjs");
var _entropyMjs = require("./utils/entropy.mjs");
var _getUserSmartWalletMjs = require("./utils/getUserSmartWallet.mjs");
var _indexMjs = require("./embedded/utils/index.mjs");
var _phoneNumberUtilsMjs = require("./utils/phoneNumberUtils.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("./utils/getUserEmbeddedSolanaWallet.mjs");
var _toObjectKeysMjs = require("./utils/toObjectKeys.mjs");
var _gasMjs = require("./embedded/utils/gas.mjs");
var _ethersMjs = require("./embedded/utils/ethers.mjs");
var _getIsTokenUsdcMjs = require("./utils/getIsTokenUsdc.mjs");
var _moonpayMjs = require("./funding/moonpay.mjs");
var _coinbaseMjs = require("./funding/coinbase.mjs");
var _clientMjs = require("./solana/client.mjs");
var _createSiwsMessageMjs = require("./solana/createSiwsMessage.mjs");
var _getSolanaRpcEndpointForClusterMjs = require("./solana/getSolanaRpcEndpointForCluster.mjs");
var _getSolanaUsdcMintAddressForClusterMjs = require("./solana/getSolanaUsdcMintAddressForCluster.mjs");
var _getSolanaClusterDisplayNameMjs = require("./solana/getSolanaClusterDisplayName.mjs");
var _typesMjs = require("./types.mjs");
var _chains = require("@privy-io/chains");
parcelHelpers.exportAll(_chains, exports);
var _formattersMjs = require("./utils/formatters.mjs");
var _createMjs = require("./wallet-api/create.mjs");
var _rpcMjs = require("./wallet-api/rpc.mjs");
var _getWalletMjs = require("./wallet-api/get-wallet.mjs");
var _updateWalletMjs = require("./wallet-api/update-wallet.mjs");
var _unifiedWalletMjs = require("./wallet-api/unified-wallet.mjs");
var _sessionSignersMjs = require("./embedded/stack/session-signers.mjs");
var _min = require("libphonenumber-js/min");
var _indexG0CxoRWQMjs = require("./index-g0cxoRWQ.mjs");
var _indexBu3YSxLMMjs = require("./index-Bu3ySxLM.mjs");
var _appApiMjs = require("./client/AppApi.mjs");
var _crossAppApiMjs = require("./client/CrossAppApi.mjs");
var _tokenMjs = require("./Token.mjs");
var _jose = require("jose");
var _delegatedWalletsApiMjs = require("./client/DelegatedWalletsApi.mjs");
var _embeddedWalletApiMjs = require("./client/EmbeddedWalletApi.mjs");
var _embeddedBitcoinWalletProviderMjs = require("./embedded/EmbeddedBitcoinWalletProvider.mjs");
var _walletCreateMjs = require("./embedded/stack/walletCreate.mjs");
var _embeddedWalletProxyMjs = require("./embedded/EmbeddedWalletProxy.mjs");
var _sleepMjs = require("./utils/sleep.mjs");
var _eventCallbackQueueMjs = require("./embedded/EventCallbackQueue.mjs");
var _withMfaMjs = require("./embedded/withMfa.mjs");
var _embeddedWalletProviderMjs = require("./embedded/EmbeddedWalletProvider.mjs");
var _eventemitter3 = require("eventemitter3");
var _methodsMjs = require("./embedded/methods.mjs");
var _walletRpcMjs = require("./embedded/stack/walletRpc.mjs");
var _encodingsMjs = require("./utils/encodings.mjs");
var _walletApiEthTransactionMjs = require("./embedded/stack/wallet-api-eth-transaction.mjs");
var _walletApiEthTypedDataMjs = require("./embedded/stack/wallet-api-eth-typed-data.mjs");
var _embeddedSolanaWalletProviderMjs = require("./embedded/EmbeddedSolanaWalletProvider.mjs");
var _getWalletPublicKeyFromTransactionMjs = require("./solana/getWalletPublicKeyFromTransaction.mjs");
var _isVersionedTransactionMjs = require("./solana/isVersionedTransaction.mjs");
var _mfaPromisesMjs = require("./client/MfaPromises.mjs");
var _privyInternalMjs = require("./client/PrivyInternal.mjs");
var _fetchRetry = require("fetch-retry");
var _uuid = require("uuid");
var _apiBase = require("@privy-io/api-base");
var _sessionMjs = require("./Session.mjs");
var _jsCookie = require("js-cookie");
var _allSettledMjs = require("./utils/allSettled.mjs");
var _toAbortSignalTimeoutMjs = require("./toAbortSignalTimeout.mjs");
var _toSearchParamsMjs = require("./utils/toSearchParams.mjs");
var _loggerMjs = require("./client/logger.mjs");
var _noopMjs = require("./utils/noop.mjs");
var _userApiMjs = require("./client/UserApi.mjs");
var _authApiMjs = require("./client/auth/AuthApi.mjs");
var _customProviderApiMjs = require("./client/auth/CustomProviderApi.mjs");
var _maybeCreateWalletOnLoginMjs = require("./client/auth/maybeCreateWalletOnLogin.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("./utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("./utils/shouldCreateEmbeddedSolWallet.mjs");
var _emailApiMjs = require("./client/auth/EmailApi.mjs");
var _farcasterApiMjs = require("./client/auth/FarcasterApi.mjs");
var _farcasterV2ApiMjs = require("./client/auth/FarcasterV2Api.mjs");
var _guestApiMjs = require("./client/auth/GuestApi.mjs");
var _oauthApiMjs = require("./client/auth/OAuthApi.mjs");
var _pkceMjs = require("./pkce.mjs");
var _passkeyApiMjs = require("./client/auth/PasskeyApi.mjs");
var _phoneApiMjs = require("./client/auth/PhoneApi.mjs");
var _siweApiMjs = require("./client/auth/SiweApi.mjs");
var _siwsApiMjs = require("./client/auth/SiwsApi.mjs");
var _smartWalletApiMjs = require("./client/auth/SmartWalletApi.mjs");
var _fundingApiMjs = require("./client/funding/FundingApi.mjs");
var _coinbaseOnRampApiMjs = require("./client/funding/CoinbaseOnRampApi.mjs");
var _moonpayOnRampApiMjs = require("./client/funding/MoonpayOnRampApi.mjs");
var _mfaApiMjs = require("./client/mfa/MfaApi.mjs");
var _mfaPasskeyApiMjs = require("./client/mfa/MfaPasskeyApi.mjs");
var _mfaSmsApiMjs = require("./client/mfa/MfaSmsApi.mjs");
var _recoveryApiMjs = require("./client/recovery/RecoveryApi.mjs");
var _recoveryICloudApiMjs = require("./client/recovery/RecoveryICloudApi.mjs");
var _recoveryOAuthApiMjs = require("./client/recovery/RecoveryOAuthApi.mjs");
var _typesMjs1 = require("./embedded/types.mjs");
var _abstractSigner = require("@ethersproject/abstract-signer");
var _providers = require("@ethersproject/providers");
var _arbitrumMjs = require("./embedded/gas/arbitrum.mjs");
var _bignumber = require("@ethersproject/bignumber");
var _bscMjs = require("./embedded/gas/bsc.mjs");
var _opStackMjs = require("./embedded/gas/op-stack.mjs");
var _contracts = require("@ethersproject/contracts");
var _transactions = require("@ethersproject/transactions");
var _polygonMjs = require("./embedded/gas/polygon.mjs");
var _units = require("@ethersproject/units");
var _examplesMobileJson = require("libphonenumber-js/examples.mobile.json");
var _viem = require("viem");
var _canonicalize = require("canonicalize");
var _utilsMjs = require("./action/delegatedActions/utils.mjs");
var _delegateWalletMjs = require("./action/delegatedActions/delegateWallet.mjs");
var _revokeWalletsMjs = require("./action/delegatedActions/revokeWallets.mjs");
var _loginWithCrossAppAuthMjs = require("./action/crossApp/loginWithCrossAppAuth.mjs");
var _linkWithCrossAppAuthMjs = require("./action/crossApp/linkWithCrossAppAuth.mjs");
var _indexDTAjYY8ZMjs = require("./index-DTAjYY8z.mjs");
var _signMessageMjs = require("./action/crossApp/wallet/signMessage.mjs");
var _isCrossAppWalletSmartMjs = require("./action/crossApp/wallet/utils/isCrossAppWalletSmart.mjs");
var _sendCrossAppRequestMjs = require("./action/crossApp/wallet/utils/sendCrossAppRequest.mjs");
var _getCrossAppAccountByWalletAddressMjs = require("./action/crossApp/wallet/utils/getCrossAppAccountByWalletAddress.mjs");
var _getProviderAccessTokenOrRelinkMjs = require("./action/crossApp/wallet/utils/getProviderAccessTokenOrRelink.mjs");
var _throwIfNotLoggedInMjs = require("./action/crossApp/wallet/utils/throwIfNotLoggedIn.mjs");
var _signTypedDataMjs = require("./action/crossApp/wallet/signTypedData.mjs");
var _generateDomainTypeMjs = require("./utils/typedData/generateDomainType.mjs");
var _sendTransactionMjs = require("./action/crossApp/wallet/sendTransaction.mjs");

},{"./client/Privy.mjs":"9jRS6","@privy-io/public-api":false,"./storage/LocalStorage.mjs":false,"./storage/InMemoryStorage.mjs":false,"./Error.mjs":false,"./embedded/errors.mjs":false,"./utils/getUserEmbeddedEthereumWallet.mjs":false,"./utils/getAllUserEmbeddedEthereumWallets.mjs":false,"./utils/getAllUserEmbeddedSolanaWallets.mjs":false,"./utils/getAllUserEmbeddedBitcoinWallets.mjs":false,"./utils/entropy.mjs":false,"./utils/getUserSmartWallet.mjs":false,"./embedded/utils/index.mjs":false,"./utils/phoneNumberUtils.mjs":false,"./utils/getUserEmbeddedSolanaWallet.mjs":false,"./utils/toObjectKeys.mjs":false,"./embedded/utils/gas.mjs":false,"./embedded/utils/ethers.mjs":false,"./utils/getIsTokenUsdc.mjs":false,"./funding/moonpay.mjs":false,"./funding/coinbase.mjs":false,"./solana/client.mjs":false,"./solana/createSiwsMessage.mjs":false,"./solana/getSolanaRpcEndpointForCluster.mjs":false,"./solana/getSolanaUsdcMintAddressForCluster.mjs":false,"./solana/getSolanaClusterDisplayName.mjs":false,"./types.mjs":false,"@privy-io/chains":false,"./utils/formatters.mjs":false,"./wallet-api/create.mjs":false,"./wallet-api/rpc.mjs":false,"./wallet-api/get-wallet.mjs":false,"./wallet-api/update-wallet.mjs":false,"./wallet-api/unified-wallet.mjs":false,"./embedded/stack/session-signers.mjs":false,"libphonenumber-js/min":false,"./index-g0cxoRWQ.mjs":false,"./index-Bu3ySxLM.mjs":false,"./client/AppApi.mjs":false,"./client/CrossAppApi.mjs":false,"./Token.mjs":false,"jose":false,"./client/DelegatedWalletsApi.mjs":false,"./client/EmbeddedWalletApi.mjs":false,"./embedded/EmbeddedBitcoinWalletProvider.mjs":false,"./embedded/stack/walletCreate.mjs":false,"./embedded/EmbeddedWalletProxy.mjs":false,"./utils/sleep.mjs":false,"./embedded/EventCallbackQueue.mjs":false,"./embedded/withMfa.mjs":false,"./embedded/EmbeddedWalletProvider.mjs":false,"eventemitter3":"8mZjp","./embedded/methods.mjs":false,"./embedded/stack/walletRpc.mjs":false,"./utils/encodings.mjs":false,"./embedded/stack/wallet-api-eth-transaction.mjs":false,"./embedded/stack/wallet-api-eth-typed-data.mjs":false,"./embedded/EmbeddedSolanaWalletProvider.mjs":false,"./solana/getWalletPublicKeyFromTransaction.mjs":false,"./solana/isVersionedTransaction.mjs":false,"./client/MfaPromises.mjs":false,"./client/PrivyInternal.mjs":false,"fetch-retry":"knqh8","uuid":false,"@privy-io/api-base":false,"./Session.mjs":false,"js-cookie":"cEALr","./utils/allSettled.mjs":false,"./toAbortSignalTimeout.mjs":false,"./utils/toSearchParams.mjs":false,"./client/logger.mjs":false,"./utils/noop.mjs":false,"./client/UserApi.mjs":false,"./client/auth/AuthApi.mjs":false,"./client/auth/CustomProviderApi.mjs":false,"./client/auth/maybeCreateWalletOnLogin.mjs":false,"./utils/shouldCreateEmbeddedEthWallet.mjs":false,"./utils/shouldCreateEmbeddedSolWallet.mjs":false,"./client/auth/EmailApi.mjs":false,"./client/auth/FarcasterApi.mjs":false,"./client/auth/FarcasterV2Api.mjs":false,"./client/auth/GuestApi.mjs":false,"./client/auth/OAuthApi.mjs":false,"./pkce.mjs":false,"./client/auth/PasskeyApi.mjs":false,"./client/auth/PhoneApi.mjs":false,"./client/auth/SiweApi.mjs":false,"./client/auth/SiwsApi.mjs":false,"./client/auth/SmartWalletApi.mjs":false,"./client/funding/FundingApi.mjs":false,"./client/funding/CoinbaseOnRampApi.mjs":false,"./client/funding/MoonpayOnRampApi.mjs":false,"./client/mfa/MfaApi.mjs":false,"./client/mfa/MfaPasskeyApi.mjs":false,"./client/mfa/MfaSmsApi.mjs":false,"./client/recovery/RecoveryApi.mjs":false,"./client/recovery/RecoveryICloudApi.mjs":false,"./client/recovery/RecoveryOAuthApi.mjs":false,"./embedded/types.mjs":false,"@ethersproject/abstract-signer":false,"@ethersproject/providers":false,"./embedded/gas/arbitrum.mjs":false,"@ethersproject/bignumber":false,"./embedded/gas/bsc.mjs":false,"./embedded/gas/op-stack.mjs":false,"@ethersproject/contracts":false,"@ethersproject/transactions":false,"./embedded/gas/polygon.mjs":false,"@ethersproject/units":false,"libphonenumber-js/examples.mobile.json":false,"viem":false,"canonicalize":"jVWhK","./action/delegatedActions/utils.mjs":false,"./action/delegatedActions/delegateWallet.mjs":false,"./action/delegatedActions/revokeWallets.mjs":false,"./action/crossApp/loginWithCrossAppAuth.mjs":false,"./action/crossApp/linkWithCrossAppAuth.mjs":false,"./index-DTAjYY8z.mjs":false,"./action/crossApp/wallet/signMessage.mjs":false,"./action/crossApp/wallet/utils/isCrossAppWalletSmart.mjs":false,"./action/crossApp/wallet/utils/sendCrossAppRequest.mjs":false,"./action/crossApp/wallet/utils/getCrossAppAccountByWalletAddress.mjs":false,"./action/crossApp/wallet/utils/getProviderAccessTokenOrRelink.mjs":false,"./action/crossApp/wallet/utils/throwIfNotLoggedIn.mjs":false,"./action/crossApp/wallet/signTypedData.mjs":false,"./utils/typedData/generateDomainType.mjs":false,"./action/crossApp/wallet/sendTransaction.mjs":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9jRS6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>l);
var _appApiMjs = require("./AppApi.mjs");
var _appApiMjsDefault = parcelHelpers.interopDefault(_appApiMjs);
var _crossAppApiMjs = require("./CrossAppApi.mjs");
var _crossAppApiMjsDefault = parcelHelpers.interopDefault(_crossAppApiMjs);
var _delegatedWalletsApiMjs = require("./DelegatedWalletsApi.mjs");
var _delegatedWalletsApiMjsDefault = parcelHelpers.interopDefault(_delegatedWalletsApiMjs);
var _embeddedWalletApiMjs = require("./EmbeddedWalletApi.mjs");
var _embeddedWalletApiMjsDefault = parcelHelpers.interopDefault(_embeddedWalletApiMjs);
var _mfaPromisesMjs = require("./MfaPromises.mjs");
var _mfaPromisesMjsDefault = parcelHelpers.interopDefault(_mfaPromisesMjs);
var _privyInternalMjs = require("./PrivyInternal.mjs");
var _userApiMjs = require("./UserApi.mjs");
var _userApiMjsDefault = parcelHelpers.interopDefault(_userApiMjs);
var _authApiMjs = require("./auth/AuthApi.mjs");
var _authApiMjsDefault = parcelHelpers.interopDefault(_authApiMjs);
var _fundingApiMjs = require("./funding/FundingApi.mjs");
var _fundingApiMjsDefault = parcelHelpers.interopDefault(_fundingApiMjs);
var _mfaApiMjs = require("./mfa/MfaApi.mjs");
var _mfaApiMjsDefault = parcelHelpers.interopDefault(_mfaApiMjs);
var _recoveryApiMjs = require("./recovery/RecoveryApi.mjs");
var _recoveryApiMjsDefault = parcelHelpers.interopDefault(_recoveryApiMjs);
var _publicApi = require("@privy-io/public-api");
var _tokenMjs = require("../Token.mjs");
var _jose = require("jose");
var _chains = require("@privy-io/chains");
var _errorMjs = require("../Error.mjs");
var _embeddedBitcoinWalletProviderMjs = require("../embedded/EmbeddedBitcoinWalletProvider.mjs");
var _errorsMjs = require("../embedded/errors.mjs");
var _typesMjs = require("../embedded/types.mjs");
var _walletCreateMjs = require("../embedded/stack/walletCreate.mjs");
var _createMjs = require("../wallet-api/create.mjs");
var _indexMjs = require("../embedded/utils/index.mjs");
var _abstractSigner = require("@ethersproject/abstract-signer");
var _providers = require("@ethersproject/providers");
var _arbitrumMjs = require("../embedded/gas/arbitrum.mjs");
var _bignumber = require("@ethersproject/bignumber");
var _ethersMjs = require("../embedded/utils/ethers.mjs");
var _bscMjs = require("../embedded/gas/bsc.mjs");
var _opStackMjs = require("../embedded/gas/op-stack.mjs");
var _contracts = require("@ethersproject/contracts");
var _transactions = require("@ethersproject/transactions");
var _polygonMjs = require("../embedded/gas/polygon.mjs");
var _units = require("@ethersproject/units");
var _fetchRetry = require("fetch-retry");
var _gasMjs = require("../embedded/utils/gas.mjs");
var _unifiedWalletMjs = require("../wallet-api/unified-wallet.mjs");
var _embeddedWalletProxyMjs = require("../embedded/EmbeddedWalletProxy.mjs");
var _sleepMjs = require("../utils/sleep.mjs");
var _eventCallbackQueueMjs = require("../embedded/EventCallbackQueue.mjs");
var _withMfaMjs = require("../embedded/withMfa.mjs");
var _embeddedWalletProviderMjs = require("../embedded/EmbeddedWalletProvider.mjs");
var _eventemitter3 = require("eventemitter3");
var _methodsMjs = require("../embedded/methods.mjs");
var _walletRpcMjs = require("../embedded/stack/walletRpc.mjs");
var _encodingsMjs = require("../utils/encodings.mjs");
var _rpcMjs = require("../wallet-api/rpc.mjs");
var _canonicalize = require("canonicalize");
var _walletApiEthTransactionMjs = require("../embedded/stack/wallet-api-eth-transaction.mjs");
var _walletApiEthTypedDataMjs = require("../embedded/stack/wallet-api-eth-typed-data.mjs");
var _embeddedSolanaWalletProviderMjs = require("../embedded/EmbeddedSolanaWalletProvider.mjs");
var _getWalletPublicKeyFromTransactionMjs = require("../solana/getWalletPublicKeyFromTransaction.mjs");
var _isVersionedTransactionMjs = require("../solana/isVersionedTransaction.mjs");
var _uuid = require("uuid");
var _apiBase = require("@privy-io/api-base");
var _sessionMjs = require("../Session.mjs");
var _jsCookie = require("js-cookie");
var _allSettledMjs = require("../utils/allSettled.mjs");
var _toAbortSignalTimeoutMjs = require("../toAbortSignalTimeout.mjs");
var _toSearchParamsMjs = require("../utils/toSearchParams.mjs");
var _loggerMjs = require("./logger.mjs");
var _noopMjs = require("../utils/noop.mjs");
var _customProviderApiMjs = require("./auth/CustomProviderApi.mjs");
var _maybeCreateWalletOnLoginMjs = require("./auth/maybeCreateWalletOnLogin.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../utils/shouldCreateEmbeddedSolWallet.mjs");
var _emailApiMjs = require("./auth/EmailApi.mjs");
var _farcasterApiMjs = require("./auth/FarcasterApi.mjs");
var _farcasterV2ApiMjs = require("./auth/FarcasterV2Api.mjs");
var _guestApiMjs = require("./auth/GuestApi.mjs");
var _oauthApiMjs = require("./auth/OAuthApi.mjs");
var _pkceMjs = require("../pkce.mjs");
var _passkeyApiMjs = require("./auth/PasskeyApi.mjs");
var _phoneApiMjs = require("./auth/PhoneApi.mjs");
var _siweApiMjs = require("./auth/SiweApi.mjs");
var _siwsApiMjs = require("./auth/SiwsApi.mjs");
var _smartWalletApiMjs = require("./auth/SmartWalletApi.mjs");
var _coinbaseOnRampApiMjs = require("./funding/CoinbaseOnRampApi.mjs");
var _moonpayOnRampApiMjs = require("./funding/MoonpayOnRampApi.mjs");
var _moonpayMjs = require("../funding/moonpay.mjs");
var _mfaPasskeyApiMjs = require("./mfa/MfaPasskeyApi.mjs");
var _mfaSmsApiMjs = require("./mfa/MfaSmsApi.mjs");
var _recoveryICloudApiMjs = require("./recovery/RecoveryICloudApi.mjs");
var _recoveryOAuthApiMjs = require("./recovery/RecoveryOAuthApi.mjs");
class l {
    async initialize() {
        await this._privyInternal._initialize();
    }
    setMessagePoster(e) {
        this.embeddedWallet.setMessagePoster(e);
    }
    addOAuthTokensListener(e) {
        return this._privyInternal.session.on("oauth_tokens_granted", e), {
            unsubscribe: ()=>{
                this._privyInternal.session.removeListener("oauth_tokens_granted", e);
            }
        };
    }
    setCallbacks(e) {
        this._privyInternal.setCallbacks(e);
    }
    getAccessToken() {
        return this._privyInternal.getAccessToken();
    }
    getIdentityToken() {
        return this._privyInternal.getIdentityToken();
    }
    getCompiledPath(e, t) {
        return this._privyInternal.getPath(e, t);
    }
    async fetchPrivyRoute(e, t) {
        return this._privyInternal.fetch(e, t);
    }
    get logger() {
        return this._privyInternal.logger;
    }
    constructor({ clientId: l, ...j }){
        this._privyInternal = new (0, _privyInternalMjs.PrivyInternal)({
            ...j,
            appClientId: l
        }), this.mfa = new (0, _mfaApiMjsDefault.default)(this._privyInternal), this.mfaPromises = new (0, _mfaPromisesMjsDefault.default), this.app = new (0, _appApiMjsDefault.default)(this._privyInternal), this.embeddedWallet = new (0, _embeddedWalletApiMjsDefault.default)(this._privyInternal, j.embeddedWalletMessagePoster, j.supportedChains, this.mfa, this.mfaPromises, this.app), this.user = new (0, _userApiMjsDefault.default)(this._privyInternal), this.auth = new (0, _authApiMjsDefault.default)(this._privyInternal, this.embeddedWallet, j.storage, j.crypto), this.recovery = new (0, _recoveryApiMjsDefault.default)(this._privyInternal, j.storage, j.crypto), this.funding = new (0, _fundingApiMjsDefault.default)(this._privyInternal), this.delegated = new (0, _delegatedWalletsApiMjsDefault.default)(this._privyInternal), this.crossApp = new (0, _crossAppApiMjsDefault.default)(this._privyInternal, j.storage);
    }
}

},{"./AppApi.mjs":"04grB","./CrossAppApi.mjs":"9drw3","./DelegatedWalletsApi.mjs":"ffX00","./EmbeddedWalletApi.mjs":"1f6Fu","./MfaPromises.mjs":"gvOKx","./PrivyInternal.mjs":"7svVu","./UserApi.mjs":"j5bk2","./auth/AuthApi.mjs":"9j69Z","./funding/FundingApi.mjs":"jq5lJ","./mfa/MfaApi.mjs":"9TIdV","./recovery/RecoveryApi.mjs":"lWzxj","@privy-io/public-api":"3ZXNH","../Token.mjs":"kjSV6","jose":"80NDr","@privy-io/chains":"9r5Tr","../Error.mjs":"kMDGn","../embedded/EmbeddedBitcoinWalletProvider.mjs":"6WUGX","../embedded/errors.mjs":"imCDj","../embedded/types.mjs":"47MbA","../embedded/stack/walletCreate.mjs":"9hdqK","../wallet-api/create.mjs":"hBTEu","../embedded/utils/index.mjs":"2aCHs","@ethersproject/abstract-signer":"bq0ju","@ethersproject/providers":"8k75m","../embedded/gas/arbitrum.mjs":"hCPYQ","@ethersproject/bignumber":"gSTRF","../embedded/utils/ethers.mjs":"1PLH5","../embedded/gas/bsc.mjs":"hbFMz","../embedded/gas/op-stack.mjs":"KVI98","@ethersproject/contracts":"26Zqo","@ethersproject/transactions":"lqSCl","../embedded/gas/polygon.mjs":"4wW2T","@ethersproject/units":"4X8jY","fetch-retry":"knqh8","../embedded/utils/gas.mjs":"bzO8p","../wallet-api/unified-wallet.mjs":"5BZHk","../embedded/EmbeddedWalletProxy.mjs":"gocS8","../utils/sleep.mjs":"kvTiu","../embedded/EventCallbackQueue.mjs":"4FEdR","../embedded/withMfa.mjs":"1qfQQ","../embedded/EmbeddedWalletProvider.mjs":"3vejn","eventemitter3":"8mZjp","../embedded/methods.mjs":"28Nn8","../embedded/stack/walletRpc.mjs":"i6bqj","../utils/encodings.mjs":"cllJf","../wallet-api/rpc.mjs":"fTVkX","canonicalize":"jVWhK","../embedded/stack/wallet-api-eth-transaction.mjs":"aQkVZ","../embedded/stack/wallet-api-eth-typed-data.mjs":"8pORF","../embedded/EmbeddedSolanaWalletProvider.mjs":"4XBtJ","../solana/getWalletPublicKeyFromTransaction.mjs":"gDAuD","../solana/isVersionedTransaction.mjs":"4CmTh","uuid":"f1qTK","@privy-io/api-base":"lvLPC","../Session.mjs":"bJKDO","js-cookie":"cEALr","../utils/allSettled.mjs":"kFsnG","../toAbortSignalTimeout.mjs":"8wsRn","../utils/toSearchParams.mjs":"lu4wu","./logger.mjs":"6jIFl","../utils/noop.mjs":"e1jCM","./auth/CustomProviderApi.mjs":"kXaoy","./auth/maybeCreateWalletOnLogin.mjs":"1KXuD","../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","./auth/EmailApi.mjs":"kf0Pi","./auth/FarcasterApi.mjs":"f0sj1","./auth/FarcasterV2Api.mjs":"5IjHq","./auth/GuestApi.mjs":"6IOoX","./auth/OAuthApi.mjs":"crG4F","../pkce.mjs":"hcRGH","./auth/PasskeyApi.mjs":"czhGm","./auth/PhoneApi.mjs":"3aZL2","./auth/SiweApi.mjs":"gs1hS","./auth/SiwsApi.mjs":"ak6Eo","./auth/SmartWalletApi.mjs":"brvJY","./funding/CoinbaseOnRampApi.mjs":"bC60B","./funding/MoonpayOnRampApi.mjs":"jXFhd","../funding/moonpay.mjs":"MCxsh","./mfa/MfaPasskeyApi.mjs":"7bCXO","./mfa/MfaSmsApi.mjs":"l4DbS","./recovery/RecoveryICloudApi.mjs":"cLDet","./recovery/RecoveryOAuthApi.mjs":"5BJea","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"04grB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>a);
var _publicApi = require("@privy-io/public-api");
class a {
    getConfig() {
        return this._privyInternal.config;
    }
    async getSmartWalletConfig() {
        return this._smartWalletConfig || (this._smartWalletConfig = await this._privyInternal.fetch((0, _publicApi.GetSmartWalletConfig), {
            params: {
                app_id: this.appId
            }
        })), this._smartWalletConfig;
    }
    get appId() {
        return this._privyInternal.appId;
    }
    constructor(t){
        this._privyInternal = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3ZXNH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnalyticsEvent", ()=>(0, _analyticsEventsMjs.AnalyticsEvent));
parcelHelpers.export(exports, "AppConfig", ()=>(0, _appsMjs.AppConfig));
parcelHelpers.export(exports, "CoinbaseOnRampInit", ()=>(0, _coinbaseMjs.CoinbaseOnRampInit));
parcelHelpers.export(exports, "CoinbaseOnRampStatus", ()=>(0, _coinbaseMjs.CoinbaseOnRampStatus));
parcelHelpers.export(exports, "GetCrossAppConnections", ()=>(0, _crossAppMjs.GetCrossAppConnections));
parcelHelpers.export(exports, "CustomJWTAuthenticate", ()=>(0, _customJwtAccountMjs.CustomJWTAuthenticate));
parcelHelpers.export(exports, "CustomJWTLink", ()=>(0, _customJwtAccountMjs.CustomJWTLink));
parcelHelpers.export(exports, "FarcasterAuthenticate", ()=>(0, _farcasterMjs.FarcasterAuthenticate));
parcelHelpers.export(exports, "FarcasterInit", ()=>(0, _farcasterMjs.FarcasterInit));
parcelHelpers.export(exports, "FarcasterLink", ()=>(0, _farcasterMjs.FarcasterLink));
parcelHelpers.export(exports, "FarcasterStatus", ()=>(0, _farcasterMjs.FarcasterStatus));
parcelHelpers.export(exports, "FarcasterUnlink", ()=>(0, _farcasterMjs.FarcasterUnlink));
parcelHelpers.export(exports, "FarcasterV2Authenticate", ()=>(0, _farcasterMjs.FarcasterV2Authenticate));
parcelHelpers.export(exports, "FarcasterV2Init", ()=>(0, _farcasterMjs.FarcasterV2Init));
parcelHelpers.export(exports, "FarcasterSignerInit", ()=>(0, _farcasterSignerMjs.FarcasterSignerInit));
parcelHelpers.export(exports, "FarcasterSignerStatus", ()=>(0, _farcasterSignerMjs.FarcasterSignerStatus));
parcelHelpers.export(exports, "GuestAuthenticate", ()=>(0, _guestMjs.GuestAuthenticate));
parcelHelpers.export(exports, "MfaPasskeyEnrollment", ()=>(0, _mfaPasskeyMjs.MfaPasskeyEnrollment));
parcelHelpers.export(exports, "MfaPasskeyInit", ()=>(0, _mfaPasskeyMjs.MfaPasskeyInit));
parcelHelpers.export(exports, "MfaPasskeyVerify", ()=>(0, _mfaPasskeyMjs.MfaPasskeyVerify));
parcelHelpers.export(exports, "MfaPasswordlessSmsEnroll", ()=>(0, _mfaPasswordlessSmsMjs.MfaPasswordlessSmsEnroll));
parcelHelpers.export(exports, "MfaPasswordlessSmsInit", ()=>(0, _mfaPasswordlessSmsMjs.MfaPasswordlessSmsInit));
parcelHelpers.export(exports, "MfaPasswordlessSmsUnenroll", ()=>(0, _mfaPasswordlessSmsMjs.MfaPasswordlessSmsUnenroll));
parcelHelpers.export(exports, "MfaPasswordlessSmsVerify", ()=>(0, _mfaPasswordlessSmsMjs.MfaPasswordlessSmsVerify));
parcelHelpers.export(exports, "MfaTotpEnroll", ()=>(0, _mfaTotpMjs.MfaTotpEnroll));
parcelHelpers.export(exports, "MfaTotpInit", ()=>(0, _mfaTotpMjs.MfaTotpInit));
parcelHelpers.export(exports, "MfaTotpUnenroll", ()=>(0, _mfaTotpMjs.MfaTotpUnenroll));
parcelHelpers.export(exports, "MfaTotpVerify", ()=>(0, _mfaTotpMjs.MfaTotpVerify));
parcelHelpers.export(exports, "OAuthAuthenticate", ()=>(0, _oauthMjs.OAuthAuthenticate));
parcelHelpers.export(exports, "OAuthInit", ()=>(0, _oauthMjs.OAuthInit));
parcelHelpers.export(exports, "OAuthLink", ()=>(0, _oauthMjs.OAuthLink));
parcelHelpers.export(exports, "OAuthUnlink", ()=>(0, _oauthMjs.OAuthUnlink));
parcelHelpers.export(exports, "OAuthProviderAuthorize", ()=>(0, _oauthProviderMjs.OAuthProviderAuthorize));
parcelHelpers.export(exports, "OAuthProviderVerify", ()=>(0, _oauthProviderMjs.OAuthProviderVerify));
parcelHelpers.export(exports, "PasskeyAuthenticate", ()=>(0, _passkeyMjs.PasskeyAuthenticate));
parcelHelpers.export(exports, "PasskeyAuthenticateInit", ()=>(0, _passkeyMjs.PasskeyAuthenticateInit));
parcelHelpers.export(exports, "PasskeyLink", ()=>(0, _passkeyMjs.PasskeyLink));
parcelHelpers.export(exports, "PasskeyLinkInit", ()=>(0, _passkeyMjs.PasskeyLinkInit));
parcelHelpers.export(exports, "PasskeyRegister", ()=>(0, _passkeyMjs.PasskeyRegister));
parcelHelpers.export(exports, "PasskeyRegisterInit", ()=>(0, _passkeyMjs.PasskeyRegisterInit));
parcelHelpers.export(exports, "PasskeyUnlink", ()=>(0, _passkeyMjs.PasskeyUnlink));
parcelHelpers.export(exports, "PasswordlessAuthenticate", ()=>(0, _passwordlessMjs.PasswordlessAuthenticate));
parcelHelpers.export(exports, "PasswordlessInit", ()=>(0, _passwordlessMjs.PasswordlessInit));
parcelHelpers.export(exports, "PasswordlessLink", ()=>(0, _passwordlessMjs.PasswordlessLink));
parcelHelpers.export(exports, "PasswordlessUnlink", ()=>(0, _passwordlessMjs.PasswordlessUnlink));
parcelHelpers.export(exports, "PasswordlessUpdate", ()=>(0, _passwordlessMjs.PasswordlessUpdate));
parcelHelpers.export(exports, "PasswordlessSmsAuthenticate", ()=>(0, _passwordlessSmsMjs.PasswordlessSmsAuthenticate));
parcelHelpers.export(exports, "PasswordlessSmsInit", ()=>(0, _passwordlessSmsMjs.PasswordlessSmsInit));
parcelHelpers.export(exports, "PasswordlessSmsLink", ()=>(0, _passwordlessSmsMjs.PasswordlessSmsLink));
parcelHelpers.export(exports, "PasswordlessSmsUnlink", ()=>(0, _passwordlessSmsMjs.PasswordlessSmsUnlink));
parcelHelpers.export(exports, "PasswordlessSmsUpdate", ()=>(0, _passwordlessSmsMjs.PasswordlessSmsUpdate));
parcelHelpers.export(exports, "RecoveryConfigurationICloud", ()=>(0, _recoveryMjs.RecoveryConfigurationICloud));
parcelHelpers.export(exports, "RecoveryKeyMaterial", ()=>(0, _recoveryMjs.RecoveryKeyMaterial));
parcelHelpers.export(exports, "RecoveryOAuthAuthenticate", ()=>(0, _recoveryMjs.RecoveryOAuthAuthenticate));
parcelHelpers.export(exports, "RecoveryOAuthCallbackICloudExpo", ()=>(0, _recoveryMjs.RecoveryOAuthCallbackICloudExpo));
parcelHelpers.export(exports, "RecoveryOAuthInit", ()=>(0, _recoveryMjs.RecoveryOAuthInit));
parcelHelpers.export(exports, "RecoveryOAuthInitICloud", ()=>(0, _recoveryMjs.RecoveryOAuthInitICloud));
parcelHelpers.export(exports, "getPathWithParams", ()=>(0, _routeMjs.getPathWithParams));
parcelHelpers.export(exports, "Logout", ()=>(0, _sessionsMjs.Logout));
parcelHelpers.export(exports, "RefreshSession", ()=>(0, _sessionsMjs.RefreshSession));
parcelHelpers.export(exports, "GetSmartWalletConfig", ()=>(0, _smartWalletsMjs.GetSmartWalletConfig));
parcelHelpers.export(exports, "PostSmartWalletConfig", ()=>(0, _smartWalletsMjs.PostSmartWalletConfig));
parcelHelpers.export(exports, "SiweAuthenticate", ()=>(0, _siweMjs.SiweAuthenticate));
parcelHelpers.export(exports, "SiweInit", ()=>(0, _siweMjs.SiweInit));
parcelHelpers.export(exports, "SiweLink", ()=>(0, _siweMjs.SiweLink));
parcelHelpers.export(exports, "SiweLinkSmartWallet", ()=>(0, _siweMjs.SiweLinkSmartWallet));
parcelHelpers.export(exports, "SiweUnlink", ()=>(0, _siweMjs.SiweUnlink));
parcelHelpers.export(exports, "SiwsAuthenticate", ()=>(0, _siwsMjs.SiwsAuthenticate));
parcelHelpers.export(exports, "SiwsInit", ()=>(0, _siwsMjs.SiwsInit));
parcelHelpers.export(exports, "SiwsLink", ()=>(0, _siwsMjs.SiwsLink));
parcelHelpers.export(exports, "SiwsUnlink", ()=>(0, _siwsMjs.SiwsUnlink));
parcelHelpers.export(exports, "AcceptTermsOnUser", ()=>(0, _termsMjs.AcceptTermsOnUser));
parcelHelpers.export(exports, "TelegramAuthenticate", ()=>(0, _telegramMjs.TelegramAuthenticate));
parcelHelpers.export(exports, "TelegramLink", ()=>(0, _telegramMjs.TelegramLink));
parcelHelpers.export(exports, "TelegramUnlink", ()=>(0, _telegramMjs.TelegramUnlink));
parcelHelpers.export(exports, "MoonpayOnRampSign", ()=>(0, _moonpayMjs.MoonpayOnRampSign));
parcelHelpers.export(exports, "RefreshUser", ()=>(0, _usersMjs.RefreshUser));
parcelHelpers.export(exports, "WalletCreate", ()=>(0, _walletApiMjs.WalletCreate));
parcelHelpers.export(exports, "WalletDelegate", ()=>(0, _walletApiMjs.WalletDelegate));
parcelHelpers.export(exports, "WalletExport", ()=>(0, _walletApiMjs.WalletExport));
parcelHelpers.export(exports, "WalletGet", ()=>(0, _walletApiMjs.WalletGet));
parcelHelpers.export(exports, "WalletGetBalance", ()=>(0, _walletApiMjs.WalletGetBalance));
parcelHelpers.export(exports, "WalletGetTransactions", ()=>(0, _walletApiMjs.WalletGetTransactions));
parcelHelpers.export(exports, "WalletRawSign", ()=>(0, _walletApiMjs.WalletRawSign));
parcelHelpers.export(exports, "WalletRpc", ()=>(0, _walletApiMjs.WalletRpc));
parcelHelpers.export(exports, "WalletUpdate", ()=>(0, _walletApiMjs.WalletUpdate));
parcelHelpers.export(exports, "WalletsGet", ()=>(0, _walletApiMjs.WalletsGet));
parcelHelpers.export(exports, "WalletsRevoke", ()=>(0, _walletApiMjs.WalletsRevoke));
parcelHelpers.export(exports, "AnalyticsEventInput", ()=>(0, _analyticsEventMjs.AnalyticsEventInput));
parcelHelpers.export(exports, "AccountIdFromPath", ()=>(0, _apiMjs.AccountIdFromPath));
parcelHelpers.export(exports, "AppIdFromPath", ()=>(0, _apiMjs.AppIdFromPath));
parcelHelpers.export(exports, "Pagination", ()=>(0, _apiMjs.Pagination));
parcelHelpers.export(exports, "AppResponseSchema", ()=>(0, _appsMjs1.AppResponseSchema));
parcelHelpers.export(exports, "EmbeddedWalletConfigSchema", ()=>(0, _appConfigMjs.EmbeddedWalletConfigSchema));
parcelHelpers.export(exports, "EmbeddedWalletInputSchema", ()=>(0, _appConfigMjs.EmbeddedWalletInputSchema));
parcelHelpers.export(exports, "FundingConfigResponseSchema", ()=>(0, _appConfigMjs.FundingConfigResponseSchema));
parcelHelpers.export(exports, "FundingMethodArraySchema", ()=>(0, _appConfigMjs.FundingMethodArraySchema));
parcelHelpers.export(exports, "FundingMethodEnum", ()=>(0, _appConfigMjs.FundingMethodEnum));
parcelHelpers.export(exports, "TelegramAuthConfigSchema", ()=>(0, _appConfigMjs.TelegramAuthConfigSchema));
parcelHelpers.export(exports, "CoinbaseOnRampInitInput", ()=>(0, _coinbaseMjs1.CoinbaseOnRampInitInput));
parcelHelpers.export(exports, "CoinbaseOnRampInitResponse", ()=>(0, _coinbaseMjs1.CoinbaseOnRampInitResponse));
parcelHelpers.export(exports, "CoinbaseOnRampStatusResponse", ()=>(0, _coinbaseMjs1.CoinbaseOnRampStatusResponse));
parcelHelpers.export(exports, "AuthenticateMode", ()=>(0, _coreMjs.AuthenticateMode));
parcelHelpers.export(exports, "Email", ()=>(0, _coreMjs.Email));
parcelHelpers.export(exports, "PasswordlessCode", ()=>(0, _coreMjs.PasswordlessCode));
parcelHelpers.export(exports, "PhoneNumber", ()=>(0, _coreMjs.PhoneNumber));
parcelHelpers.export(exports, "SolanaWalletAddress", ()=>(0, _coreMjs.SolanaWalletAddress));
parcelHelpers.export(exports, "UserId", ()=>(0, _coreMjs.UserId));
parcelHelpers.export(exports, "WalletAddress", ()=>(0, _coreMjs.WalletAddress));
parcelHelpers.export(exports, "isValidAddress", ()=>(0, _coreMjs.isValidAddress));
parcelHelpers.export(exports, "normalizeEthereumAddress", ()=>(0, _coreMjs.normalizeEthereumAddress));
parcelHelpers.export(exports, "normalizePhoneNumber", ()=>(0, _coreMjs.normalizePhoneNumber));
parcelHelpers.export(exports, "CrossAppConnectionsResponse", ()=>(0, _crossAppMjs1.CrossAppConnectionsResponse));
parcelHelpers.export(exports, "Currency", ()=>(0, _cryptoAssetMjs.Currency));
parcelHelpers.export(exports, "AuthenticateJwtInput", ()=>(0, _customJwtAccountMjs1.AuthenticateJwtInput));
parcelHelpers.export(exports, "LinkJwtInput", ()=>(0, _customJwtAccountMjs1.LinkJwtInput));
parcelHelpers.export(exports, "AuthenticateEmailInput", ()=>(0, _emailMjs.AuthenticateEmailInput));
parcelHelpers.export(exports, "InitEmailInput", ()=>(0, _emailMjs.InitEmailInput));
parcelHelpers.export(exports, "TransferEmailInput", ()=>(0, _emailMjs.TransferEmailInput));
parcelHelpers.export(exports, "UnlinkEmailInput", ()=>(0, _emailMjs.UnlinkEmailInput));
parcelHelpers.export(exports, "UpdateEmailInput", ()=>(0, _emailMjs.UpdateEmailInput));
parcelHelpers.export(exports, "VerifyEmailInput", ()=>(0, _emailMjs.VerifyEmailInput));
parcelHelpers.export(exports, "JsonWebKey", ()=>(0, _externalAuthMjs.JsonWebKey));
parcelHelpers.export(exports, "JsonWebKeySet", ()=>(0, _externalAuthMjs.JsonWebKeySet));
parcelHelpers.export(exports, "FarcasterAuthenticateInput", ()=>(0, _farcasterMjs1.FarcasterAuthenticateInput));
parcelHelpers.export(exports, "FarcasterConnectInitResponse", ()=>(0, _farcasterMjs1.FarcasterConnectInitResponse));
parcelHelpers.export(exports, "FarcasterConnectStatusCompletedResponse", ()=>(0, _farcasterMjs1.FarcasterConnectStatusCompletedResponse));
parcelHelpers.export(exports, "FarcasterConnectStatusPendingResponse", ()=>(0, _farcasterMjs1.FarcasterConnectStatusPendingResponse));
parcelHelpers.export(exports, "FarcasterInitInput", ()=>(0, _farcasterMjs1.FarcasterInitInput));
parcelHelpers.export(exports, "FarcasterLinkInput", ()=>(0, _farcasterMjs1.FarcasterLinkInput));
parcelHelpers.export(exports, "FarcasterUnlinkInput", ()=>(0, _farcasterMjs1.FarcasterUnlinkInput));
parcelHelpers.export(exports, "FarcasterV2AuthenticateInput", ()=>(0, _farcasterMjs1.FarcasterV2AuthenticateInput));
parcelHelpers.export(exports, "FarcasterV2InitInput", ()=>(0, _farcasterMjs1.FarcasterV2InitInput));
parcelHelpers.export(exports, "FarcasterV2InitResponse", ()=>(0, _farcasterMjs1.FarcasterV2InitResponse));
parcelHelpers.export(exports, "TransferFarcasterInput", ()=>(0, _farcasterMjs1.TransferFarcasterInput));
parcelHelpers.export(exports, "FarcasterSignerInitInput", ()=>(0, _farcasterSignerMjs1.FarcasterSignerInitInput));
parcelHelpers.export(exports, "FarcasterSignerInitResponse", ()=>(0, _farcasterSignerMjs1.FarcasterSignerInitResponse));
parcelHelpers.export(exports, "FarcasterSignerStatusResponse", ()=>(0, _farcasterSignerMjs1.FarcasterSignerStatusResponse));
parcelHelpers.export(exports, "AuthenticateGuestInput", ()=>(0, _guestMjs1.AuthenticateGuestInput));
parcelHelpers.export(exports, "AppleOauthIdTokenEntry", ()=>(0, _identityTokenMjs.AppleOauthIdTokenEntry));
parcelHelpers.export(exports, "CrossAppIdTokenEntry", ()=>(0, _identityTokenMjs.CrossAppIdTokenEntry));
parcelHelpers.export(exports, "CustomJwtIdTokenEntry", ()=>(0, _identityTokenMjs.CustomJwtIdTokenEntry));
parcelHelpers.export(exports, "DiscordOauthIdTokenEntry", ()=>(0, _identityTokenMjs.DiscordOauthIdTokenEntry));
parcelHelpers.export(exports, "EmailIdTokenEntry", ()=>(0, _identityTokenMjs.EmailIdTokenEntry));
parcelHelpers.export(exports, "FarcasterIdTokenEntry", ()=>(0, _identityTokenMjs.FarcasterIdTokenEntry));
parcelHelpers.export(exports, "GithubOauthIdTokenEntry", ()=>(0, _identityTokenMjs.GithubOauthIdTokenEntry));
parcelHelpers.export(exports, "GoogleOauthIdTokenEntry", ()=>(0, _identityTokenMjs.GoogleOauthIdTokenEntry));
parcelHelpers.export(exports, "InstagramOauthIdTokenEntry", ()=>(0, _identityTokenMjs.InstagramOauthIdTokenEntry));
parcelHelpers.export(exports, "LinkedInOauthIdTokenEntry", ()=>(0, _identityTokenMjs.LinkedInOauthIdTokenEntry));
parcelHelpers.export(exports, "PasskeyIdTokenEntry", ()=>(0, _identityTokenMjs.PasskeyIdTokenEntry));
parcelHelpers.export(exports, "PhoneIdTokenEntry", ()=>(0, _identityTokenMjs.PhoneIdTokenEntry));
parcelHelpers.export(exports, "SmartWalletIdTokenEntry", ()=>(0, _identityTokenMjs.SmartWalletIdTokenEntry));
parcelHelpers.export(exports, "SpotifyOauthIdTokenEntry", ()=>(0, _identityTokenMjs.SpotifyOauthIdTokenEntry));
parcelHelpers.export(exports, "TelegramIdTokenEntry", ()=>(0, _identityTokenMjs.TelegramIdTokenEntry));
parcelHelpers.export(exports, "TiktokOauthIdTokenEntry", ()=>(0, _identityTokenMjs.TiktokOauthIdTokenEntry));
parcelHelpers.export(exports, "TwitterOauthIdTokenEntry", ()=>(0, _identityTokenMjs.TwitterOauthIdTokenEntry));
parcelHelpers.export(exports, "WalletIdTokenEntry", ()=>(0, _identityTokenMjs.WalletIdTokenEntry));
parcelHelpers.export(exports, "MfaSmsAuthenticateEnrollInput", ()=>(0, _mfaMjs.MfaSmsAuthenticateEnrollInput));
parcelHelpers.export(exports, "MfaSmsEnrollInput", ()=>(0, _mfaMjs.MfaSmsEnrollInput));
parcelHelpers.export(exports, "MfaSmsInitInput", ()=>(0, _mfaMjs.MfaSmsInitInput));
parcelHelpers.export(exports, "MfaSmsVerifyInput", ()=>(0, _mfaMjs.MfaSmsVerifyInput));
parcelHelpers.export(exports, "MfaTotpInput", ()=>(0, _mfaMjs.MfaTotpInput));
parcelHelpers.export(exports, "MfaVerifyResponse", ()=>(0, _mfaMjs.MfaVerifyResponse));
parcelHelpers.export(exports, "ResponseTotpInitMfa", ()=>(0, _mfaMjs.ResponseTotpInitMfa));
parcelHelpers.export(exports, "MfaEnrollmentPasskeyInput", ()=>(0, _mfaPasskeyMjs1.MfaEnrollmentPasskeyInput));
parcelHelpers.export(exports, "MfaPasskeyInitInput", ()=>(0, _mfaPasskeyMjs1.MfaPasskeyInitInput));
parcelHelpers.export(exports, "MfaPasskeyVerifyInput", ()=>(0, _mfaPasskeyMjs1.MfaPasskeyVerifyInput));
parcelHelpers.export(exports, "ResponsePasskeyInitMfa", ()=>(0, _mfaPasskeyMjs1.ResponsePasskeyInitMfa));
parcelHelpers.export(exports, "MoonpayOnRampSignInput", ()=>(0, _moonpayMjs1.MoonpayOnRampSignInput));
parcelHelpers.export(exports, "MoonpayOnRampSignResponse", ()=>(0, _moonpayMjs1.MoonpayOnRampSignResponse));
parcelHelpers.export(exports, "SUPPORTED_OAUTH_PROVIDERS", ()=>(0, _oauthMjs1.SUPPORTED_OAUTH_PROVIDERS));
parcelHelpers.export(exports, "AuthenticateOauthInput", ()=>(0, _oauthMjs2.AuthenticateOauthInput));
parcelHelpers.export(exports, "ExternalOAuthProvider", ()=>(0, _oauthMjs2.ExternalOAuthProvider));
parcelHelpers.export(exports, "LinkOAuthInput", ()=>(0, _oauthMjs2.LinkOAuthInput));
parcelHelpers.export(exports, "OAuthInitInput", ()=>(0, _oauthMjs2.OAuthInitInput));
parcelHelpers.export(exports, "OAuthInitResponse", ()=>(0, _oauthMjs2.OAuthInitResponse));
parcelHelpers.export(exports, "OAuthLinkResponse", ()=>(0, _oauthMjs2.OAuthLinkResponse));
parcelHelpers.export(exports, "OAuthProvider", ()=>(0, _oauthMjs2.OAuthProvider));
parcelHelpers.export(exports, "OAuthUnlinkInput", ()=>(0, _oauthMjs2.OAuthUnlinkInput));
parcelHelpers.export(exports, "TransferOAuthInput", ()=>(0, _oauthMjs2.TransferOAuthInput));
parcelHelpers.export(exports, "AuthorizationCodeInput", ()=>(0, _oauthProviderMjs1.AuthorizationCodeInput));
parcelHelpers.export(exports, "EmptyObject", ()=>(0, _objectMjs.EmptyObject));
parcelHelpers.export(exports, "SuccessObject", ()=>(0, _objectMjs.SuccessObject));
parcelHelpers.export(exports, "PasskeyAuthenticateInput", ()=>(0, _passkeyMjs1.PasskeyAuthenticateInput));
parcelHelpers.export(exports, "PasskeyAuthenticatorEnrollmentOptions", ()=>(0, _passkeyMjs1.PasskeyAuthenticatorEnrollmentOptions));
parcelHelpers.export(exports, "PasskeyAuthenticatorEnrollmentResponse", ()=>(0, _passkeyMjs1.PasskeyAuthenticatorEnrollmentResponse));
parcelHelpers.export(exports, "PasskeyAuthenticatorVerifyOptions", ()=>(0, _passkeyMjs1.PasskeyAuthenticatorVerifyOptions));
parcelHelpers.export(exports, "PasskeyAuthenticatorVerifyResponse", ()=>(0, _passkeyMjs1.PasskeyAuthenticatorVerifyResponse));
parcelHelpers.export(exports, "PasskeyInitInput", ()=>(0, _passkeyMjs1.PasskeyInitInput));
parcelHelpers.export(exports, "PasskeyLinkInput", ()=>(0, _passkeyMjs1.PasskeyLinkInput));
parcelHelpers.export(exports, "PasskeyRegisterInput", ()=>(0, _passkeyMjs1.PasskeyRegisterInput));
parcelHelpers.export(exports, "ResponsePasskeyInitAuthenticate", ()=>(0, _passkeyMjs1.ResponsePasskeyInitAuthenticate));
parcelHelpers.export(exports, "ResponsePasskeyInitLink", ()=>(0, _passkeyMjs1.ResponsePasskeyInitLink));
parcelHelpers.export(exports, "ResponsePasskeyInitRegister", ()=>(0, _passkeyMjs1.ResponsePasskeyInitRegister));
parcelHelpers.export(exports, "UnlinkPasskeyInput", ()=>(0, _passkeyMjs1.UnlinkPasskeyInput));
parcelHelpers.export(exports, "BaseCondition", ()=>(0, _policyMjs.BaseCondition));
parcelHelpers.export(exports, "Condition", ()=>(0, _policyMjs.Condition));
parcelHelpers.export(exports, "ConditionOperator", ()=>(0, _policyMjs.ConditionOperator));
parcelHelpers.export(exports, "EthereumCalldataCondition", ()=>(0, _policyMjs.EthereumCalldataCondition));
parcelHelpers.export(exports, "EthereumTransactionCondition", ()=>(0, _policyMjs.EthereumTransactionCondition));
parcelHelpers.export(exports, "EthereumTypedDataDomainCondition", ()=>(0, _policyMjs.EthereumTypedDataDomainCondition));
parcelHelpers.export(exports, "EthereumTypedDataMessageCondition", ()=>(0, _policyMjs.EthereumTypedDataMessageCondition));
parcelHelpers.export(exports, "LegacyRule", ()=>(0, _policyMjs.LegacyRule));
parcelHelpers.export(exports, "PolicyAction", ()=>(0, _policyMjs.PolicyAction));
parcelHelpers.export(exports, "PolicyIdFromPath", ()=>(0, _policyMjs.PolicyIdFromPath));
parcelHelpers.export(exports, "PolicyResponse", ()=>(0, _policyMjs.PolicyResponse));
parcelHelpers.export(exports, "PolicyWithoutValidation", ()=>(0, _policyMjs.PolicyWithoutValidation));
parcelHelpers.export(exports, "Rule", ()=>(0, _policyMjs.Rule));
parcelHelpers.export(exports, "SolanaProgramInstruction", ()=>(0, _policyMjs.SolanaProgramInstruction));
parcelHelpers.export(exports, "SolanaSystemProgramInstruction", ()=>(0, _policyMjs.SolanaSystemProgramInstruction));
parcelHelpers.export(exports, "SolanaTokenProgramInstruction", ()=>(0, _policyMjs.SolanaTokenProgramInstruction));
parcelHelpers.export(exports, "UpdatePolicyInput", ()=>(0, _policyMjs.UpdatePolicyInput));
parcelHelpers.export(exports, "OAuthAuthenticateRecoveryResponse", ()=>(0, _recoveryMjs1.OAuthAuthenticateRecoveryResponse));
parcelHelpers.export(exports, "OAuthCallbackICloudExpoInput", ()=>(0, _recoveryMjs1.OAuthCallbackICloudExpoInput));
parcelHelpers.export(exports, "OAuthCallbackICloudExpoResponse", ()=>(0, _recoveryMjs1.OAuthCallbackICloudExpoResponse));
parcelHelpers.export(exports, "OAuthInitICloudRecoveryInput", ()=>(0, _recoveryMjs1.OAuthInitICloudRecoveryInput));
parcelHelpers.export(exports, "OAuthInitRecoveryInput", ()=>(0, _recoveryMjs1.OAuthInitRecoveryInput));
parcelHelpers.export(exports, "RecoveryConfigurationICloudInput", ()=>(0, _recoveryMjs1.RecoveryConfigurationICloudInput));
parcelHelpers.export(exports, "RecoveryConfigurationICloudResponse", ()=>(0, _recoveryMjs1.RecoveryConfigurationICloudResponse));
parcelHelpers.export(exports, "RecoveryKeyMaterialInput", ()=>(0, _recoveryMjs1.RecoveryKeyMaterialInput));
parcelHelpers.export(exports, "RecoveryKeyMaterialResponse", ()=>(0, _recoveryMjs1.RecoveryKeyMaterialResponse));
parcelHelpers.export(exports, "AuthenticateSiweInput", ()=>(0, _siweMjs1.AuthenticateSiweInput));
parcelHelpers.export(exports, "SiweAddressInput", ()=>(0, _siweMjs1.SiweAddressInput));
parcelHelpers.export(exports, "SiweInitInput", ()=>(0, _siweMjs1.SiweInitInput));
parcelHelpers.export(exports, "SiweInput", ()=>(0, _siweMjs1.SiweInput));
parcelHelpers.export(exports, "SiweNonce", ()=>(0, _siweMjs1.SiweNonce));
parcelHelpers.export(exports, "SmartWalletSiweInput", ()=>(0, _siweMjs1.SmartWalletSiweInput));
parcelHelpers.export(exports, "TransferSiweInput", ()=>(0, _siweMjs1.TransferSiweInput));
parcelHelpers.export(exports, "AuthenticateSiwsInput", ()=>(0, _siwsMjs1.AuthenticateSiwsInput));
parcelHelpers.export(exports, "SiwsAddressInput", ()=>(0, _siwsMjs1.SiwsAddressInput));
parcelHelpers.export(exports, "SiwsInitInput", ()=>(0, _siwsMjs1.SiwsInitInput));
parcelHelpers.export(exports, "SiwsInput", ()=>(0, _siwsMjs1.SiwsInput));
parcelHelpers.export(exports, "SiwsNonce", ()=>(0, _siwsMjs1.SiwsNonce));
parcelHelpers.export(exports, "AuthenticatePhoneInput", ()=>(0, _smsMjs.AuthenticatePhoneInput));
parcelHelpers.export(exports, "PasswordlessSmsPhoneInput", ()=>(0, _smsMjs.PasswordlessSmsPhoneInput));
parcelHelpers.export(exports, "TransferPhoneInput", ()=>(0, _smsMjs.TransferPhoneInput));
parcelHelpers.export(exports, "UnlinkPhoneInput", ()=>(0, _smsMjs.UnlinkPhoneInput));
parcelHelpers.export(exports, "UpdatePhoneInput", ()=>(0, _smsMjs.UpdatePhoneInput));
parcelHelpers.export(exports, "VerifyPhoneInput", ()=>(0, _smsMjs.VerifyPhoneInput));
parcelHelpers.export(exports, "BICONOMY", ()=>(0, _smartWalletsMjs1.BICONOMY));
parcelHelpers.export(exports, "COINBASE_SMART_WALLET", ()=>(0, _smartWalletsMjs1.COINBASE_SMART_WALLET));
parcelHelpers.export(exports, "KERNEL", ()=>(0, _smartWalletsMjs1.KERNEL));
parcelHelpers.export(exports, "LIGHT_ACCOUNT", ()=>(0, _smartWalletsMjs1.LIGHT_ACCOUNT));
parcelHelpers.export(exports, "SAFE", ()=>(0, _smartWalletsMjs1.SAFE));
parcelHelpers.export(exports, "SUPPORTED_SMART_WALLET_TYPES", ()=>(0, _smartWalletsMjs1.SUPPORTED_SMART_WALLET_TYPES));
parcelHelpers.export(exports, "THIRDWEB", ()=>(0, _smartWalletsMjs1.THIRDWEB));
parcelHelpers.export(exports, "AlchemyPaymasterContextSchema", ()=>(0, _smartWalletConfigMjs.AlchemyPaymasterContextSchema));
parcelHelpers.export(exports, "SmartWalletConfigurationInputSchema", ()=>(0, _smartWalletConfigMjs.SmartWalletConfigurationInputSchema));
parcelHelpers.export(exports, "SmartWalletConfigurationResponseSchema", ()=>(0, _smartWalletConfigMjs.SmartWalletConfigurationResponseSchema));
parcelHelpers.export(exports, "SmartWalletConfigurationSchema", ()=>(0, _smartWalletConfigMjs.SmartWalletConfigurationSchema));
parcelHelpers.export(exports, "SmartWalletNetworkConfigurationInputSchema", ()=>(0, _smartWalletConfigMjs.SmartWalletNetworkConfigurationInputSchema));
parcelHelpers.export(exports, "SmartWalletProvider", ()=>(0, _smartWalletConfigMjs.SmartWalletProvider));
parcelHelpers.export(exports, "TelegramAuthResult", ()=>(0, _telegramMjs1.TelegramAuthResult));
parcelHelpers.export(exports, "TelegramAuthenticateInput", ()=>(0, _telegramMjs1.TelegramAuthenticateInput));
parcelHelpers.export(exports, "TelegramLinkInput", ()=>(0, _telegramMjs1.TelegramLinkInput));
parcelHelpers.export(exports, "TelegramUnlinkInput", ()=>(0, _telegramMjs1.TelegramUnlinkInput));
parcelHelpers.export(exports, "TelegramWebAppData", ()=>(0, _telegramMjs1.TelegramWebAppData));
parcelHelpers.export(exports, "TransferTelegramInput", ()=>(0, _telegramMjs1.TransferTelegramInput));
parcelHelpers.export(exports, "OptionalRefreshTokenInput", ()=>(0, _tokenMjs.OptionalRefreshTokenInput));
parcelHelpers.export(exports, "RefreshTokenInput", ()=>(0, _tokenMjs.RefreshTokenInput));
parcelHelpers.export(exports, "AppleOauthAccount", ()=>(0, _userMjs.AppleOauthAccount));
parcelHelpers.export(exports, "AuthenticatedUser", ()=>(0, _userMjs.AuthenticatedUser));
parcelHelpers.export(exports, "AuthorizationKeyAccount", ()=>(0, _userMjs.AuthorizationKeyAccount));
parcelHelpers.export(exports, "BaseWalletAccount", ()=>(0, _userMjs.BaseWalletAccount));
parcelHelpers.export(exports, "BitcoinSegwitEmbeddedWalletAccount", ()=>(0, _userMjs.BitcoinSegwitEmbeddedWalletAccount));
parcelHelpers.export(exports, "BitcoinTaprootEmbeddedWalletAccount", ()=>(0, _userMjs.BitcoinTaprootEmbeddedWalletAccount));
parcelHelpers.export(exports, "CrossAppAccount", ()=>(0, _userMjs.CrossAppAccount));
parcelHelpers.export(exports, "CrossAppEmbeddedWallet", ()=>(0, _userMjs.CrossAppEmbeddedWallet));
parcelHelpers.export(exports, "CrossAppSmartWallet", ()=>(0, _userMjs.CrossAppSmartWallet));
parcelHelpers.export(exports, "CustomJwtAccount", ()=>(0, _userMjs.CustomJwtAccount));
parcelHelpers.export(exports, "CustomMetadata", ()=>(0, _userMjs.CustomMetadata));
parcelHelpers.export(exports, "DiscordOauthAccount", ()=>(0, _userMjs.DiscordOauthAccount));
parcelHelpers.export(exports, "EmailAccount", ()=>(0, _userMjs.EmailAccount));
parcelHelpers.export(exports, "EthereumAccount", ()=>(0, _userMjs.EthereumAccount));
parcelHelpers.export(exports, "EthereumEmbeddedWalletAccount", ()=>(0, _userMjs.EthereumEmbeddedWalletAccount));
parcelHelpers.export(exports, "FarcasterAccount", ()=>(0, _userMjs.FarcasterAccount));
parcelHelpers.export(exports, "GithubOauthAccount", ()=>(0, _userMjs.GithubOauthAccount));
parcelHelpers.export(exports, "GoogleOauthAccount", ()=>(0, _userMjs.GoogleOauthAccount));
parcelHelpers.export(exports, "InstagramOauthAccount", ()=>(0, _userMjs.InstagramOauthAccount));
parcelHelpers.export(exports, "LinkedAccount", ()=>(0, _userMjs.LinkedAccount));
parcelHelpers.export(exports, "LinkedInOauthAccount", ()=>(0, _userMjs.LinkedInOauthAccount));
parcelHelpers.export(exports, "LinkedMfaMethod", ()=>(0, _userMjs.LinkedMfaMethod));
parcelHelpers.export(exports, "LoggedOutUser", ()=>(0, _userMjs.LoggedOutUser));
parcelHelpers.export(exports, "MaybeUser", ()=>(0, _userMjs.MaybeUser));
parcelHelpers.export(exports, "OAuthTokens", ()=>(0, _userMjs.OAuthTokens));
parcelHelpers.export(exports, "PasskeyAccount", ()=>(0, _userMjs.PasskeyAccount));
parcelHelpers.export(exports, "PasskeyMfaMethod", ()=>(0, _userMjs.PasskeyMfaMethod));
parcelHelpers.export(exports, "PhoneAccount", ()=>(0, _userMjs.PhoneAccount));
parcelHelpers.export(exports, "SessionUpdateActionEnum", ()=>(0, _userMjs.SessionUpdateActionEnum));
parcelHelpers.export(exports, "SmartWalletAccount", ()=>(0, _userMjs.SmartWalletAccount));
parcelHelpers.export(exports, "SmsMfaMethod", ()=>(0, _userMjs.SmsMfaMethod));
parcelHelpers.export(exports, "SolanaAccount", ()=>(0, _userMjs.SolanaAccount));
parcelHelpers.export(exports, "SolanaEmbeddedWalletAccount", ()=>(0, _userMjs.SolanaEmbeddedWalletAccount));
parcelHelpers.export(exports, "SpotifyOauthAccount", ()=>(0, _userMjs.SpotifyOauthAccount));
parcelHelpers.export(exports, "TelegramAccount", ()=>(0, _userMjs.TelegramAccount));
parcelHelpers.export(exports, "TiktokOauthAccount", ()=>(0, _userMjs.TiktokOauthAccount));
parcelHelpers.export(exports, "TotpMfaMethod", ()=>(0, _userMjs.TotpMfaMethod));
parcelHelpers.export(exports, "TwitterOauthAccount", ()=>(0, _userMjs.TwitterOauthAccount));
parcelHelpers.export(exports, "UnifiedWalletAccount", ()=>(0, _userMjs.UnifiedWalletAccount));
parcelHelpers.export(exports, "User", ()=>(0, _userMjs.User));
parcelHelpers.export(exports, "UserWithIdentityToken", ()=>(0, _userMjs.UserWithIdentityToken));
parcelHelpers.export(exports, "AdditionalSignerInput", ()=>(0, _walletsMjs.AdditionalSignerInput));
parcelHelpers.export(exports, "Asset", ()=>(0, _walletsMjs.Asset));
parcelHelpers.export(exports, "AssetAmountDetails", ()=>(0, _walletsMjs.AssetAmountDetails));
parcelHelpers.export(exports, "AuthorizationKeyDashboardResponse", ()=>(0, _walletsMjs.AuthorizationKeyDashboardResponse));
parcelHelpers.export(exports, "AuthorizationKeyResponse", ()=>(0, _walletsMjs.AuthorizationKeyResponse));
parcelHelpers.export(exports, "AuthorizationKeyRole", ()=>(0, _walletsMjs.AuthorizationKeyRole));
parcelHelpers.export(exports, "BalanceFiatCurrency", ()=>(0, _walletsMjs.BalanceFiatCurrency));
parcelHelpers.export(exports, "BaseWalletApiCreateInput", ()=>(0, _walletsMjs.BaseWalletApiCreateInput));
parcelHelpers.export(exports, "CAIP2", ()=>(0, _walletsMjs.CAIP2));
parcelHelpers.export(exports, "ChainNameInput", ()=>(0, _walletsMjs.ChainNameInput));
parcelHelpers.export(exports, "ChainType", ()=>(0, _walletsMjs.ChainType));
parcelHelpers.export(exports, "Cosmos", ()=>(0, _walletsMjs.Cosmos));
parcelHelpers.export(exports, "CurveSigningChainTypes", ()=>(0, _walletsMjs.CurveSigningChainTypes));
parcelHelpers.export(exports, "CurveType", ()=>(0, _walletsMjs.CurveType));
parcelHelpers.export(exports, "ECDSA", ()=>(0, _walletsMjs.ECDSA));
parcelHelpers.export(exports, "EdDSA", ()=>(0, _walletsMjs.EdDSA));
parcelHelpers.export(exports, "FirstClassChainTypes", ()=>(0, _walletsMjs.FirstClassChainTypes));
parcelHelpers.export(exports, "HDPath", ()=>(0, _walletsMjs.HDPath));
parcelHelpers.export(exports, "Hash", ()=>(0, _walletsMjs.Hash));
parcelHelpers.export(exports, "Hex", ()=>(0, _walletsMjs.Hex));
parcelHelpers.export(exports, "KeyQuorumId", ()=>(0, _walletsMjs.KeyQuorumId));
parcelHelpers.export(exports, "OwnerInput", ()=>(0, _walletsMjs.OwnerInput));
parcelHelpers.export(exports, "OwnerInputFields", ()=>(0, _walletsMjs.OwnerInputFields));
parcelHelpers.export(exports, "P256PublicKey", ()=>(0, _walletsMjs.P256PublicKey));
parcelHelpers.export(exports, "PolicyInput", ()=>(0, _walletsMjs.PolicyInput));
parcelHelpers.export(exports, "PrivyTransactionResponseWithDetails", ()=>(0, _walletsMjs.PrivyTransactionResponseWithDetails));
parcelHelpers.export(exports, "Quantity", ()=>(0, _walletsMjs.Quantity));
parcelHelpers.export(exports, "SigningAlgorithm", ()=>(0, _walletsMjs.SigningAlgorithm));
parcelHelpers.export(exports, "Stellar", ()=>(0, _walletsMjs.Stellar));
parcelHelpers.export(exports, "Sui", ()=>(0, _walletsMjs.Sui));
parcelHelpers.export(exports, "TransactionDetail", ()=>(0, _walletsMjs.TransactionDetail));
parcelHelpers.export(exports, "TransactionResponseWithDetails", ()=>(0, _walletsMjs.TransactionResponseWithDetails));
parcelHelpers.export(exports, "TransferReceivedTransactionDetail", ()=>(0, _walletsMjs.TransferReceivedTransactionDetail));
parcelHelpers.export(exports, "TransferSentTransactionDetail", ()=>(0, _walletsMjs.TransferSentTransactionDetail));
parcelHelpers.export(exports, "TypedDataDomainInputParams", ()=>(0, _walletsMjs.TypedDataDomainInputParams));
parcelHelpers.export(exports, "TypedDataTypesInputParams", ()=>(0, _walletsMjs.TypedDataTypesInputParams));
parcelHelpers.export(exports, "UnsignedEthereumTransaction", ()=>(0, _walletsMjs.UnsignedEthereumTransaction));
parcelHelpers.export(exports, "WalletApiCreateInput", ()=>(0, _walletsMjs.WalletApiCreateInput));
parcelHelpers.export(exports, "WalletApiCreateResponse", ()=>(0, _walletsMjs.WalletApiCreateResponse));
parcelHelpers.export(exports, "WalletApiEthereumPersonalSignRpcInput", ()=>(0, _walletsMjs.WalletApiEthereumPersonalSignRpcInput));
parcelHelpers.export(exports, "WalletApiEthereumPersonalSignRpcInputParams", ()=>(0, _walletsMjs.WalletApiEthereumPersonalSignRpcInputParams));
parcelHelpers.export(exports, "WalletApiEthereumPersonalSignRpcResponse", ()=>(0, _walletsMjs.WalletApiEthereumPersonalSignRpcResponse));
parcelHelpers.export(exports, "WalletApiEthereumRpcInput", ()=>(0, _walletsMjs.WalletApiEthereumRpcInput));
parcelHelpers.export(exports, "WalletApiEthereumSecp256k1SignRpcInput", ()=>(0, _walletsMjs.WalletApiEthereumSecp256k1SignRpcInput));
parcelHelpers.export(exports, "WalletApiEthereumSecp256k1SignRpcResponse", ()=>(0, _walletsMjs.WalletApiEthereumSecp256k1SignRpcResponse));
parcelHelpers.export(exports, "WalletApiEthereumSendTransactionRpcInput", ()=>(0, _walletsMjs.WalletApiEthereumSendTransactionRpcInput));
parcelHelpers.export(exports, "WalletApiEthereumSendTransactionRpcResponse", ()=>(0, _walletsMjs.WalletApiEthereumSendTransactionRpcResponse));
parcelHelpers.export(exports, "WalletApiEthereumSignTransactionRpcInput", ()=>(0, _walletsMjs.WalletApiEthereumSignTransactionRpcInput));
parcelHelpers.export(exports, "WalletApiEthereumSignTransactionRpcResponse", ()=>(0, _walletsMjs.WalletApiEthereumSignTransactionRpcResponse));
parcelHelpers.export(exports, "WalletApiEthereumSignTypedDataRpcInput", ()=>(0, _walletsMjs.WalletApiEthereumSignTypedDataRpcInput));
parcelHelpers.export(exports, "WalletApiEthereumSignTypedDataRpcResponse", ()=>(0, _walletsMjs.WalletApiEthereumSignTypedDataRpcResponse));
parcelHelpers.export(exports, "WalletApiExportPrivateKeyRpcInput", ()=>(0, _walletsMjs.WalletApiExportPrivateKeyRpcInput));
parcelHelpers.export(exports, "WalletApiExportPrivateKeyRpcResponse", ()=>(0, _walletsMjs.WalletApiExportPrivateKeyRpcResponse));
parcelHelpers.export(exports, "WalletApiRawSignInput", ()=>(0, _walletsMjs.WalletApiRawSignInput));
parcelHelpers.export(exports, "WalletApiRawSignResponse", ()=>(0, _walletsMjs.WalletApiRawSignResponse));
parcelHelpers.export(exports, "WalletApiRegisterAuthorizationKeyInput", ()=>(0, _walletsMjs.WalletApiRegisterAuthorizationKeyInput));
parcelHelpers.export(exports, "WalletApiRevokeAuthorizationKeyInput", ()=>(0, _walletsMjs.WalletApiRevokeAuthorizationKeyInput));
parcelHelpers.export(exports, "WalletApiRpcInput", ()=>(0, _walletsMjs.WalletApiRpcInput));
parcelHelpers.export(exports, "WalletApiRpcResponse", ()=>(0, _walletsMjs.WalletApiRpcResponse));
parcelHelpers.export(exports, "WalletApiSolanaRpcInput", ()=>(0, _walletsMjs.WalletApiSolanaRpcInput));
parcelHelpers.export(exports, "WalletApiSolanaSignAndSendTransactionRpcInput", ()=>(0, _walletsMjs.WalletApiSolanaSignAndSendTransactionRpcInput));
parcelHelpers.export(exports, "WalletApiSolanaSignAndSendTransactionRpcResponse", ()=>(0, _walletsMjs.WalletApiSolanaSignAndSendTransactionRpcResponse));
parcelHelpers.export(exports, "WalletApiSolanaSignMessageRpcInput", ()=>(0, _walletsMjs.WalletApiSolanaSignMessageRpcInput));
parcelHelpers.export(exports, "WalletApiSolanaSignMessageRpcResponse", ()=>(0, _walletsMjs.WalletApiSolanaSignMessageRpcResponse));
parcelHelpers.export(exports, "WalletApiSolanaSignTransactionRpcInput", ()=>(0, _walletsMjs.WalletApiSolanaSignTransactionRpcInput));
parcelHelpers.export(exports, "WalletApiSolanaSignTransactionRpcResponse", ()=>(0, _walletsMjs.WalletApiSolanaSignTransactionRpcResponse));
parcelHelpers.export(exports, "WalletGetBalanceInput", ()=>(0, _walletsMjs.WalletGetBalanceInput));
parcelHelpers.export(exports, "WalletGetBalanceResponse", ()=>(0, _walletsMjs.WalletGetBalanceResponse));
parcelHelpers.export(exports, "WalletGetTransactionsInput", ()=>(0, _walletsMjs.WalletGetTransactionsInput));
parcelHelpers.export(exports, "WalletGetTransactionsResponse", ()=>(0, _walletsMjs.WalletGetTransactionsResponse));
parcelHelpers.export(exports, "WalletIdFromPath", ()=>(0, _walletsMjs.WalletIdFromPath));
parcelHelpers.export(exports, "WalletResponse", ()=>(0, _walletsMjs.WalletResponse));
parcelHelpers.export(exports, "WalletUpdateInput", ()=>(0, _walletsMjs.WalletUpdateInput));
parcelHelpers.export(exports, "WalletsSearchInput", ()=>(0, _walletsMjs.WalletsSearchInput));
parcelHelpers.export(exports, "CreateKeyQuorumInput", ()=>(0, _keyQuorumsMjs.CreateKeyQuorumInput));
parcelHelpers.export(exports, "KeyQuorumIdFromPath", ()=>(0, _keyQuorumsMjs.KeyQuorumIdFromPath));
parcelHelpers.export(exports, "UpdateKeyQuorumInput", ()=>(0, _keyQuorumsMjs.UpdateKeyQuorumInput));
parcelHelpers.export(exports, "PrivateKeyExportInput", ()=>(0, _exportMjs.PrivateKeyExportInput));
parcelHelpers.export(exports, "PrivateKeyExportResponse", ()=>(0, _exportMjs.PrivateKeyExportResponse));
parcelHelpers.export(exports, "UserSignersAuthenticateInput", ()=>(0, _userSignersMjs.UserSignersAuthenticateInput));
parcelHelpers.export(exports, "UserSignersAuthenticateResponse", ()=>(0, _userSignersMjs.UserSignersAuthenticateResponse));
parcelHelpers.export(exports, "WalletsWithRecoveryRequest", ()=>(0, _userSignersMjs.WalletsWithRecoveryRequest));
parcelHelpers.export(exports, "WalletsWithRecoveryResponse", ()=>(0, _userSignersMjs.WalletsWithRecoveryResponse));
parcelHelpers.export(exports, "DelegatedActionsConsentInput", ()=>(0, _delegatedActionsMjs.DelegatedActionsConsentInput));
parcelHelpers.export(exports, "WalletApiRevokeResponse", ()=>(0, _delegatedActionsMjs.WalletApiRevokeResponse));
parcelHelpers.export(exports, "TransactionScanningInput", ()=>(0, _transactionScanningMjs.TransactionScanningInput));
parcelHelpers.export(exports, "TransactionScanningResponse", ()=>(0, _transactionScanningMjs.TransactionScanningResponse));
parcelHelpers.export(exports, "TestAccountIdFromPath", ()=>(0, _testAccountMjs.TestAccountIdFromPath));
parcelHelpers.export(exports, "BaseTransactionResponse", ()=>(0, _transactionMjs.BaseTransactionResponse));
parcelHelpers.export(exports, "TransactionIdFromPath", ()=>(0, _transactionMjs.TransactionIdFromPath));
parcelHelpers.export(exports, "TransactionResponse", ()=>(0, _transactionMjs.TransactionResponse));
parcelHelpers.export(exports, "TransactionStatus", ()=>(0, _transactionMjs.TransactionStatus));
parcelHelpers.export(exports, "AuthenticationEvent", ()=>(0, _eventTypeMjs.AuthenticationEvent));
parcelHelpers.export(exports, "EventType", ()=>(0, _eventTypeMjs.EventType));
parcelHelpers.export(exports, "EventTypes", ()=>(0, _eventTypeMjs.EventTypes));
parcelHelpers.export(exports, "FundsTransferEvent", ()=>(0, _eventTypeMjs.FundsTransferEvent));
parcelHelpers.export(exports, "MfaEvent", ()=>(0, _eventTypeMjs.MfaEvent));
parcelHelpers.export(exports, "PrivateKeyExportedEvent", ()=>(0, _eventTypeMjs.PrivateKeyExportedEvent));
parcelHelpers.export(exports, "TransactionEvent", ()=>(0, _eventTypeMjs.TransactionEvent));
parcelHelpers.export(exports, "EMBEDDED_WALLET_RECOVERY_TYPES", ()=>(0, _eventCatalogMjs.EMBEDDED_WALLET_RECOVERY_TYPES));
parcelHelpers.export(exports, "BridgeBusinessAssociatedPerson", ()=>(0, _onrampMjs.BridgeBusinessAssociatedPerson));
parcelHelpers.export(exports, "BridgeKycAddress", ()=>(0, _onrampMjs.BridgeKycAddress));
parcelHelpers.export(exports, "BridgeKycData", ()=>(0, _onrampMjs.BridgeKycData));
parcelHelpers.export(exports, "BridgeKycDocument", ()=>(0, _onrampMjs.BridgeKycDocument));
parcelHelpers.export(exports, "BridgeKycIdentifyingInformation", ()=>(0, _onrampMjs.BridgeKycIdentifyingInformation));
parcelHelpers.export(exports, "BridgeKycInput", ()=>(0, _onrampMjs.BridgeKycInput));
parcelHelpers.export(exports, "BridgeKycLinkResponse", ()=>(0, _onrampMjs.BridgeKycLinkResponse));
parcelHelpers.export(exports, "BridgeRegulatedActivity", ()=>(0, _onrampMjs.BridgeRegulatedActivity));
parcelHelpers.export(exports, "BridgeTradedListings", ()=>(0, _onrampMjs.BridgeTradedListings));
parcelHelpers.export(exports, "FiatAccountAddress", ()=>(0, _onrampMjs.FiatAccountAddress));
parcelHelpers.export(exports, "FiatAccountIbanData", ()=>(0, _onrampMjs.FiatAccountIbanData));
parcelHelpers.export(exports, "FiatAccountSwiftData", ()=>(0, _onrampMjs.FiatAccountSwiftData));
parcelHelpers.export(exports, "FiatAccountUsAccountData", ()=>(0, _onrampMjs.FiatAccountUsAccountData));
parcelHelpers.export(exports, "FiatCurrency", ()=>(0, _onrampMjs.FiatCurrency));
parcelHelpers.export(exports, "FiatPaymentRail", ()=>(0, _onrampMjs.FiatPaymentRail));
parcelHelpers.export(exports, "GetOnrampFiatAccountStatusInput", ()=>(0, _onrampMjs.GetOnrampFiatAccountStatusInput));
parcelHelpers.export(exports, "GetOnrampFiatAccountsResponse", ()=>(0, _onrampMjs.GetOnrampFiatAccountsResponse));
parcelHelpers.export(exports, "GetOnrampKycStatusInput", ()=>(0, _onrampMjs.GetOnrampKycStatusInput));
parcelHelpers.export(exports, "GetOnrampKycStatusResponse", ()=>(0, _onrampMjs.GetOnrampKycStatusResponse));
parcelHelpers.export(exports, "GetOnrampTermsOfServiceStatusInput", ()=>(0, _onrampMjs.GetOnrampTermsOfServiceStatusInput));
parcelHelpers.export(exports, "ListFiatTransactionsInput", ()=>(0, _onrampMjs.ListFiatTransactionsInput));
parcelHelpers.export(exports, "ListFiatTransactionsResponse", ()=>(0, _onrampMjs.ListFiatTransactionsResponse));
parcelHelpers.export(exports, "OfframpInput", ()=>(0, _onrampMjs.OfframpInput));
parcelHelpers.export(exports, "OfframpResponse", ()=>(0, _onrampMjs.OfframpResponse));
parcelHelpers.export(exports, "OnrampAsset", ()=>(0, _onrampMjs.OnrampAsset));
parcelHelpers.export(exports, "OnrampChain", ()=>(0, _onrampMjs.OnrampChain));
parcelHelpers.export(exports, "OnrampFiatAccountInput", ()=>(0, _onrampMjs.OnrampFiatAccountInput));
parcelHelpers.export(exports, "OnrampFiatAccountResponse", ()=>(0, _onrampMjs.OnrampFiatAccountResponse));
parcelHelpers.export(exports, "OnrampInput", ()=>(0, _onrampMjs.OnrampInput));
parcelHelpers.export(exports, "OnrampKycInput", ()=>(0, _onrampMjs.OnrampKycInput));
parcelHelpers.export(exports, "OnrampKycResponse", ()=>(0, _onrampMjs.OnrampKycResponse));
parcelHelpers.export(exports, "OnrampKycStatus", ()=>(0, _onrampMjs.OnrampKycStatus));
parcelHelpers.export(exports, "OnrampProvider", ()=>(0, _onrampMjs.OnrampProvider));
parcelHelpers.export(exports, "OnrampResponse", ()=>(0, _onrampMjs.OnrampResponse));
parcelHelpers.export(exports, "OnrampTermsOfServiceStatusResponse", ()=>(0, _onrampMjs.OnrampTermsOfServiceStatusResponse));
parcelHelpers.export(exports, "OnrampTransferStatus", ()=>(0, _onrampMjs.OnrampTransferStatus));
parcelHelpers.export(exports, "CreateEmbeddedWalletUserImportInput", ()=>(0, _userImportMjs.CreateEmbeddedWalletUserImportInput));
parcelHelpers.export(exports, "CreateWalletInput", ()=>(0, _userImportMjs.CreateWalletInput));
parcelHelpers.export(exports, "EmbeddedWalletCreationInputUnion", ()=>(0, _userImportMjs.EmbeddedWalletCreationInputUnion));
parcelHelpers.export(exports, "ImportAppleAccountInput", ()=>(0, _userImportMjs.ImportAppleAccountInput));
parcelHelpers.export(exports, "ImportCustomJwtAccountInput", ()=>(0, _userImportMjs.ImportCustomJwtAccountInput));
parcelHelpers.export(exports, "ImportDiscordAccountInput", ()=>(0, _userImportMjs.ImportDiscordAccountInput));
parcelHelpers.export(exports, "ImportEmailAccountInput", ()=>(0, _userImportMjs.ImportEmailAccountInput));
parcelHelpers.export(exports, "ImportFarcasterAccountInput", ()=>(0, _userImportMjs.ImportFarcasterAccountInput));
parcelHelpers.export(exports, "ImportGithubAccountInput", ()=>(0, _userImportMjs.ImportGithubAccountInput));
parcelHelpers.export(exports, "ImportGoogleAccountInput", ()=>(0, _userImportMjs.ImportGoogleAccountInput));
parcelHelpers.export(exports, "ImportInstagramAccountInput", ()=>(0, _userImportMjs.ImportInstagramAccountInput));
parcelHelpers.export(exports, "ImportLinkedInAccountInput", ()=>(0, _userImportMjs.ImportLinkedInAccountInput));
parcelHelpers.export(exports, "ImportManyUsersInput", ()=>(0, _userImportMjs.ImportManyUsersInput));
parcelHelpers.export(exports, "ImportPhoneAccountInput", ()=>(0, _userImportMjs.ImportPhoneAccountInput));
parcelHelpers.export(exports, "ImportSpotifyAccountInput", ()=>(0, _userImportMjs.ImportSpotifyAccountInput));
parcelHelpers.export(exports, "ImportTelegramAccountInput", ()=>(0, _userImportMjs.ImportTelegramAccountInput));
parcelHelpers.export(exports, "ImportTiktokAccountInput", ()=>(0, _userImportMjs.ImportTiktokAccountInput));
parcelHelpers.export(exports, "ImportTwitterAccountInput", ()=>(0, _userImportMjs.ImportTwitterAccountInput));
parcelHelpers.export(exports, "ImportUserInput", ()=>(0, _userImportMjs.ImportUserInput));
parcelHelpers.export(exports, "ImportWalletAccountInput", ()=>(0, _userImportMjs.ImportWalletAccountInput));
parcelHelpers.export(exports, "LinkedAccountInput", ()=>(0, _userImportMjs.LinkedAccountInput));
parcelHelpers.export(exports, "WalletCreateUserInput", ()=>(0, _userImportMjs.WalletCreateUserInput));
parcelHelpers.export(exports, "EmbeddedWalletCreationInput", ()=>(0, _embeddedWalletCreationMjs.EmbeddedWalletCreationInput));
parcelHelpers.export(exports, "WalletCreationInput", ()=>(0, _embeddedWalletCreationMjs.WalletCreationInput));
var _analyticsEventsMjs = require("./routes/analytics-events.mjs");
var _appsMjs = require("./routes/apps.mjs");
var _coinbaseMjs = require("./routes/coinbase.mjs");
var _crossAppMjs = require("./routes/cross-app.mjs");
var _customJwtAccountMjs = require("./routes/custom-jwt-account.mjs");
var _farcasterMjs = require("./routes/farcaster.mjs");
var _farcasterSignerMjs = require("./routes/farcaster-signer.mjs");
var _guestMjs = require("./routes/guest.mjs");
var _mfaPasskeyMjs = require("./routes/mfa-passkey.mjs");
var _mfaPasswordlessSmsMjs = require("./routes/mfa-passwordless-sms.mjs");
var _mfaTotpMjs = require("./routes/mfa-totp.mjs");
var _oauthMjs = require("./routes/oauth.mjs");
var _oauthProviderMjs = require("./routes/oauth-provider.mjs");
var _passkeyMjs = require("./routes/passkey.mjs");
var _passwordlessMjs = require("./routes/passwordless.mjs");
var _passwordlessSmsMjs = require("./routes/passwordless-sms.mjs");
var _recoveryMjs = require("./routes/recovery.mjs");
var _routeMjs = require("./routes/Route.mjs");
var _sessionsMjs = require("./routes/sessions.mjs");
var _smartWalletsMjs = require("./routes/smart-wallets.mjs");
var _siweMjs = require("./routes/siwe.mjs");
var _siwsMjs = require("./routes/siws.mjs");
var _termsMjs = require("./routes/terms.mjs");
var _telegramMjs = require("./routes/telegram.mjs");
var _moonpayMjs = require("./routes/moonpay.mjs");
var _usersMjs = require("./routes/users.mjs");
var _walletApiMjs = require("./routes/wallet-api.mjs");
var _analyticsEventMjs = require("./schemas/analytics-event.mjs");
var _apiMjs = require("./schemas/api.mjs");
var _appsMjs1 = require("./schemas/apps.mjs");
var _appConfigMjs = require("./schemas/app-config.mjs");
var _coinbaseMjs1 = require("./schemas/coinbase.mjs");
var _coreMjs = require("./schemas/core.mjs");
var _crossAppMjs1 = require("./schemas/cross-app.mjs");
var _cryptoAssetMjs = require("./schemas/crypto-asset.mjs");
var _customJwtAccountMjs1 = require("./schemas/custom-jwt-account.mjs");
var _emailMjs = require("./schemas/email.mjs");
var _externalAuthMjs = require("./schemas/external-auth.mjs");
var _farcasterMjs1 = require("./schemas/farcaster.mjs");
var _farcasterSignerMjs1 = require("./schemas/farcaster-signer.mjs");
var _guestMjs1 = require("./schemas/guest.mjs");
var _identityTokenMjs = require("./schemas/identity-token.mjs");
var _mfaMjs = require("./schemas/mfa.mjs");
var _mfaPasskeyMjs1 = require("./schemas/mfa-passkey.mjs");
var _moonpayMjs1 = require("./schemas/moonpay.mjs");
var _oauthMjs1 = require("./constants/oauth.mjs");
var _oauthMjs2 = require("./schemas/oauth.mjs");
var _oauthProviderMjs1 = require("./schemas/oauth-provider.mjs");
var _objectMjs = require("./schemas/object.mjs");
var _passkeyMjs1 = require("./schemas/passkey.mjs");
var _policyMjs = require("./schemas/policy.mjs");
var _recoveryMjs1 = require("./schemas/recovery.mjs");
var _siweMjs1 = require("./schemas/siwe.mjs");
var _siwsMjs1 = require("./schemas/siws.mjs");
var _smsMjs = require("./schemas/sms.mjs");
var _smartWalletsMjs1 = require("./constants/smart-wallets.mjs");
var _smartWalletConfigMjs = require("./schemas/smart-wallet-config.mjs");
var _telegramMjs1 = require("./schemas/telegram.mjs");
var _tokenMjs = require("./schemas/token.mjs");
var _userMjs = require("./schemas/user.mjs");
var _walletsMjs = require("./schemas/wallet-api/wallets.mjs");
var _keyQuorumsMjs = require("./schemas/wallet-api/key-quorums.mjs");
var _exportMjs = require("./schemas/wallet-api/export.mjs");
var _userSignersMjs = require("./schemas/wallet-api/user-signers.mjs");
var _delegatedActionsMjs = require("./schemas/wallet-api/delegated-actions.mjs");
var _transactionScanningMjs = require("./schemas/transaction-scanning.mjs");
var _testAccountMjs = require("./schemas/test-account.mjs");
var _transactionMjs = require("./schemas/transaction.mjs");
var _eventTypeMjs = require("./schemas/webhooks/event-type.mjs");
var _eventCatalogMjs = require("./schemas/webhooks/event-catalog.mjs");
var _onrampMjs = require("./schemas/onramp.mjs");
var _userImportMjs = require("./schemas/user-import.mjs");
var _embeddedWalletCreationMjs = require("./schemas/embedded-wallet-creation.mjs");
var _zod = require("zod");
var _apiBase = require("@privy-io/api-base");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
var _accountTransferMjs = require("./schemas/account-transfer.mjs");

},{"./routes/analytics-events.mjs":"ix3a0","./routes/apps.mjs":"lfWQh","./routes/coinbase.mjs":"eJPwz","./routes/cross-app.mjs":"gp1XL","./routes/custom-jwt-account.mjs":"467dE","./routes/farcaster.mjs":"7sS0y","./routes/farcaster-signer.mjs":"dTu2c","./routes/guest.mjs":"jsxpF","./routes/mfa-passkey.mjs":"9jnXO","./routes/mfa-passwordless-sms.mjs":"1Ovmp","./routes/mfa-totp.mjs":"lLU0i","./routes/oauth.mjs":"2CwQr","./routes/oauth-provider.mjs":"du1jA","./routes/passkey.mjs":"iHLs0","./routes/passwordless.mjs":"9M09u","./routes/passwordless-sms.mjs":"jc5pR","./routes/recovery.mjs":"3J6U9","./routes/Route.mjs":"d35BV","./routes/sessions.mjs":"fbPJ3","./routes/smart-wallets.mjs":"1vKMa","./routes/siwe.mjs":"8ooAN","./routes/siws.mjs":"4MLTA","./routes/terms.mjs":"8QFA7","./routes/telegram.mjs":"95J1T","./routes/moonpay.mjs":"bvmzc","./routes/users.mjs":"dloxV","./routes/wallet-api.mjs":"hofXq","./schemas/analytics-event.mjs":"eGcLw","./schemas/api.mjs":"bMsze","./schemas/apps.mjs":"4O6Uu","./schemas/app-config.mjs":"ftEfr","./schemas/coinbase.mjs":"aicc3","./schemas/core.mjs":"9c2nU","./schemas/cross-app.mjs":"dYxg2","./schemas/crypto-asset.mjs":"eDVeC","./schemas/custom-jwt-account.mjs":"13N5i","./schemas/email.mjs":"iYakZ","./schemas/external-auth.mjs":"eiJwy","./schemas/farcaster.mjs":"9mYsv","./schemas/farcaster-signer.mjs":"17BIU","./schemas/guest.mjs":"l2QE3","./schemas/identity-token.mjs":"couzx","./schemas/mfa.mjs":"2vYSX","./schemas/mfa-passkey.mjs":"5Sb9y","./schemas/moonpay.mjs":"hWsxb","./constants/oauth.mjs":"gfeVW","./schemas/oauth.mjs":"jz7dd","./schemas/oauth-provider.mjs":"hawiR","./schemas/object.mjs":"8CKI2","./schemas/passkey.mjs":"leBN7","./schemas/policy.mjs":"aO8b9","./schemas/recovery.mjs":"ApSkO","./schemas/siwe.mjs":"5su1k","./schemas/siws.mjs":"7aeJj","./schemas/sms.mjs":"kBaGG","./constants/smart-wallets.mjs":"hQh54","./schemas/smart-wallet-config.mjs":"eeJcS","./schemas/telegram.mjs":"9hZ0j","./schemas/token.mjs":"jAErm","./schemas/user.mjs":"59vYa","./schemas/wallet-api/wallets.mjs":"eUydR","./schemas/wallet-api/key-quorums.mjs":"lAuQp","./schemas/wallet-api/export.mjs":"3JZvH","./schemas/wallet-api/user-signers.mjs":"f1j5h","./schemas/wallet-api/delegated-actions.mjs":"8mLHk","./schemas/transaction-scanning.mjs":"45AoS","./schemas/test-account.mjs":"5DCvG","./schemas/transaction.mjs":"kzolK","./schemas/webhooks/event-type.mjs":"3STEX","./schemas/webhooks/event-catalog.mjs":"fa6e5","./schemas/onramp.mjs":"a1J95","./schemas/user-import.mjs":"59IXl","./schemas/embedded-wallet-creation.mjs":"gHPYA","zod":"fOFdH","@privy-io/api-base":"lvLPC","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","./schemas/account-transfer.mjs":"f44i0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ix3a0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnalyticsEvent", ()=>t);
const t = {
    path: "/api/v1/analytics_events",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jnFvT":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"lfWQh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AppConfig", ()=>p);
const p = {
    path: "/api/v1/apps/:app_id",
    method: "GET"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eJPwz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CoinbaseOnRampInit", ()=>n);
parcelHelpers.export(exports, "CoinbaseOnRampStatus", ()=>a);
const n = {
    path: "/api/v1/funding/coinbase_on_ramp/init",
    method: "POST"
}, a = {
    path: "/api/v1/funding/coinbase_on_ramp/status",
    method: "GET"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gp1XL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GetCrossAppConnections", ()=>p);
const p = {
    path: "/api/v1/apps/:app_id/cross-app/connections",
    method: "GET"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"467dE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CustomJWTAuthenticate", ()=>t);
parcelHelpers.export(exports, "CustomJWTLink", ()=>a);
const t = {
    path: "/api/v1/custom_jwt_account/authenticate",
    method: "POST"
}, a = {
    path: "/api/v1/custom_jwt_account/link",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7sS0y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FarcasterAuthenticate", ()=>t);
parcelHelpers.export(exports, "FarcasterInit", ()=>a);
parcelHelpers.export(exports, "FarcasterLink", ()=>e);
parcelHelpers.export(exports, "FarcasterStatus", ()=>i);
parcelHelpers.export(exports, "FarcasterUnlink", ()=>h);
parcelHelpers.export(exports, "FarcasterV2Authenticate", ()=>r);
parcelHelpers.export(exports, "FarcasterV2Init", ()=>p);
const a = {
    path: "/api/v1/farcaster/init",
    method: "POST"
}, t = {
    path: "/api/v1/farcaster/authenticate",
    method: "POST"
}, e = {
    path: "/api/v1/farcaster/link",
    method: "POST"
}, h = {
    path: "/api/v1/farcaster/unlink",
    method: "POST"
}, i = {
    path: "/api/v1/farcaster/status",
    method: "GET"
}, p = {
    path: "/api/v2/farcaster/init",
    method: "POST"
}, r = {
    path: "/api/v2/farcaster/authenticate",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dTu2c":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FarcasterSignerInit", ()=>t);
parcelHelpers.export(exports, "FarcasterSignerStatus", ()=>a);
const t = {
    path: "/api/v1/farcaster/signer/init",
    method: "POST"
}, a = {
    path: "/api/v1/farcaster/signer/status",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jsxpF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GuestAuthenticate", ()=>t);
const t = {
    path: "/api/v1/guest/authenticate",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9jnXO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MfaPasskeyEnrollment", ()=>p);
parcelHelpers.export(exports, "MfaPasskeyInit", ()=>a);
parcelHelpers.export(exports, "MfaPasskeyVerify", ()=>e);
const a = {
    path: "/api/v1/mfa/passkeys/init",
    method: "POST"
}, e = {
    path: "/api/v1/mfa/passkeys/verify",
    method: "POST"
}, p = {
    path: "/api/v1/mfa/passkeys/enrollment",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1Ovmp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MfaPasswordlessSmsEnroll", ()=>s);
parcelHelpers.export(exports, "MfaPasswordlessSmsInit", ()=>p);
parcelHelpers.export(exports, "MfaPasswordlessSmsUnenroll", ()=>e);
parcelHelpers.export(exports, "MfaPasswordlessSmsVerify", ()=>a);
const s = {
    path: "/api/v1/mfa/passwordless_sms/enroll",
    method: "POST"
}, a = {
    path: "/api/v1/mfa/passwordless_sms/verify",
    method: "POST"
}, p = {
    path: "/api/v1/mfa/passwordless_sms/init",
    method: "POST"
}, e = {
    path: "/api/v1/mfa/passwordless_sms/unenroll",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lLU0i":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MfaTotpEnroll", ()=>t);
parcelHelpers.export(exports, "MfaTotpInit", ()=>a);
parcelHelpers.export(exports, "MfaTotpUnenroll", ()=>o);
parcelHelpers.export(exports, "MfaTotpVerify", ()=>p);
const t = {
    path: "/api/v1/mfa/totp/enroll",
    method: "POST"
}, p = {
    path: "/api/v1/mfa/totp/verify",
    method: "POST"
}, a = {
    path: "/api/v1/mfa/totp/init",
    method: "POST"
}, o = {
    path: "/api/v1/mfa/totp/unenroll",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2CwQr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OAuthAuthenticate", ()=>t);
parcelHelpers.export(exports, "OAuthInit", ()=>a);
parcelHelpers.export(exports, "OAuthLink", ()=>h);
parcelHelpers.export(exports, "OAuthUnlink", ()=>o);
const t = {
    path: "/api/v1/oauth/authenticate",
    method: "POST"
}, a = {
    path: "/api/v1/oauth/init",
    method: "POST"
}, h = {
    path: "/api/v1/oauth/link",
    method: "POST"
}, o = {
    path: "/api/v1/oauth/unlink",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"du1jA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OAuthProviderAuthorize", ()=>t);
parcelHelpers.export(exports, "OAuthProviderVerify", ()=>o);
const t = {
    path: "/oauth/authorization_code",
    method: "POST"
}, o = {
    path: "/oauth/verify",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iHLs0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PasskeyAuthenticate", ()=>a);
parcelHelpers.export(exports, "PasskeyAuthenticateInit", ()=>e);
parcelHelpers.export(exports, "PasskeyLink", ()=>t);
parcelHelpers.export(exports, "PasskeyLinkInit", ()=>i);
parcelHelpers.export(exports, "PasskeyRegister", ()=>s);
parcelHelpers.export(exports, "PasskeyRegisterInit", ()=>p);
parcelHelpers.export(exports, "PasskeyUnlink", ()=>h);
const t = {
    path: "/api/v1/passkeys/link",
    method: "POST"
}, a = {
    path: "/api/v1/passkeys/authenticate",
    method: "POST"
}, s = {
    path: "/api/v1/passkeys/register",
    method: "POST"
}, e = {
    path: "/api/v1/passkeys/authenticate/init",
    method: "POST"
}, p = {
    path: "/api/v1/passkeys/register/init",
    method: "POST"
}, i = {
    path: "/api/v1/passkeys/link/init",
    method: "POST"
}, h = {
    path: "/api/v1/passkeys/unlink",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9M09u":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PasswordlessAuthenticate", ()=>s);
parcelHelpers.export(exports, "PasswordlessInit", ()=>a);
parcelHelpers.export(exports, "PasswordlessLink", ()=>p);
parcelHelpers.export(exports, "PasswordlessUnlink", ()=>t);
parcelHelpers.export(exports, "PasswordlessUpdate", ()=>e);
const s = {
    path: "/api/v1/passwordless/authenticate",
    method: "POST"
}, a = {
    path: "/api/v1/passwordless/init",
    method: "POST"
}, p = {
    path: "/api/v1/passwordless/link",
    method: "POST"
}, t = {
    path: "/api/v1/passwordless/unlink",
    method: "POST"
}, e = {
    path: "/api/v1/passwordless/update",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jc5pR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PasswordlessSmsAuthenticate", ()=>s);
parcelHelpers.export(exports, "PasswordlessSmsInit", ()=>a);
parcelHelpers.export(exports, "PasswordlessSmsLink", ()=>p);
parcelHelpers.export(exports, "PasswordlessSmsUnlink", ()=>t);
parcelHelpers.export(exports, "PasswordlessSmsUpdate", ()=>e);
const s = {
    path: "/api/v1/passwordless_sms/authenticate",
    method: "POST"
}, a = {
    path: "/api/v1/passwordless_sms/init",
    method: "POST"
}, p = {
    path: "/api/v1/passwordless_sms/link",
    method: "POST"
}, t = {
    path: "/api/v1/passwordless_sms/unlink",
    method: "POST"
}, e = {
    path: "/api/v1/passwordless_sms/update",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3J6U9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RecoveryConfigurationICloud", ()=>h);
parcelHelpers.export(exports, "RecoveryKeyMaterial", ()=>e);
parcelHelpers.export(exports, "RecoveryOAuthAuthenticate", ()=>t);
parcelHelpers.export(exports, "RecoveryOAuthCallbackICloudExpo", ()=>i);
parcelHelpers.export(exports, "RecoveryOAuthInit", ()=>a);
parcelHelpers.export(exports, "RecoveryOAuthInitICloud", ()=>o);
const e = {
    path: "/api/v1/embedded_wallets/:address/recovery/key_material",
    method: "POST"
}, a = {
    path: "/api/v1/recovery/oauth/init",
    method: "POST"
}, t = {
    path: "/api/v1/recovery/oauth/authenticate",
    method: "POST"
}, o = {
    path: "/api/v1/recovery/oauth/init_icloud",
    method: "POST"
}, i = {
    path: "/api/v1/recovery/oauth/callback_icloud/:app_id/expo_ios",
    method: "GET"
}, h = {
    path: "/api/v1/recovery/configuration_icloud",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d35BV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getPathWithParams", ()=>e);
const e = (e, c)=>c ? Object.entries(c).reduce((e, [c, r])=>e.replace(`:${c}`, `${r}`), e) : e;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fbPJ3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Logout", ()=>o);
parcelHelpers.export(exports, "RefreshSession", ()=>s);
const s = {
    path: "/api/v1/sessions",
    method: "POST"
}, o = {
    path: "/api/v1/sessions/logout",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1vKMa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GetSmartWalletConfig", ()=>p);
parcelHelpers.export(exports, "PostSmartWalletConfig", ()=>a);
const p = {
    path: "/api/v1/apps/:app_id/smart_wallets",
    method: "GET"
}, a = {
    path: "/api/v1/apps/:app_id/smart_wallets",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8ooAN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SiweAuthenticate", ()=>i);
parcelHelpers.export(exports, "SiweInit", ()=>t);
parcelHelpers.export(exports, "SiweLink", ()=>a);
parcelHelpers.export(exports, "SiweLinkSmartWallet", ()=>e);
parcelHelpers.export(exports, "SiweUnlink", ()=>h);
const t = {
    path: "/api/v1/siwe/init",
    method: "POST"
}, i = {
    path: "/api/v1/siwe/authenticate",
    method: "POST"
}, a = {
    path: "/api/v1/siwe/link",
    method: "POST"
}, e = {
    path: "/api/v1/siwe/link_smart_wallet",
    method: "POST"
}, h = {
    path: "/api/v1/siwe/unlink",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4MLTA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SiwsAuthenticate", ()=>i);
parcelHelpers.export(exports, "SiwsInit", ()=>t);
parcelHelpers.export(exports, "SiwsLink", ()=>a);
parcelHelpers.export(exports, "SiwsUnlink", ()=>h);
const t = {
    path: "/api/v1/siws/init",
    method: "POST"
}, i = {
    path: "/api/v1/siws/authenticate",
    method: "POST"
}, a = {
    path: "/api/v1/siws/link",
    method: "POST"
}, h = {
    path: "/api/v1/siws/unlink",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8QFA7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AcceptTermsOnUser", ()=>e);
const e = {
    path: "/api/v1/users/me/accept_terms",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"95J1T":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TelegramAuthenticate", ()=>t);
parcelHelpers.export(exports, "TelegramLink", ()=>e);
parcelHelpers.export(exports, "TelegramUnlink", ()=>a);
const t = {
    path: "/api/v1/telegram/authenticate",
    method: "POST"
}, e = {
    path: "/api/v1/telegram/link",
    method: "POST"
}, a = {
    path: "/api/v1/telegram/unlink",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bvmzc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MoonpayOnRampSign", ()=>o);
const o = {
    path: "/api/v1/plugins/moonpay_on_ramp/sign",
    method: "POST"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dloxV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RefreshUser", ()=>e);
const e = {
    path: "/api/v1/users/me",
    method: "GET"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hofXq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WalletCreate", ()=>t);
parcelHelpers.export(exports, "WalletDelegate", ()=>w);
parcelHelpers.export(exports, "WalletExport", ()=>d);
parcelHelpers.export(exports, "WalletGet", ()=>l);
parcelHelpers.export(exports, "WalletGetBalance", ()=>e);
parcelHelpers.export(exports, "WalletGetTransactions", ()=>s);
parcelHelpers.export(exports, "WalletRawSign", ()=>h);
parcelHelpers.export(exports, "WalletRpc", ()=>p);
parcelHelpers.export(exports, "WalletUpdate", ()=>i);
parcelHelpers.export(exports, "WalletsGet", ()=>a);
parcelHelpers.export(exports, "WalletsRevoke", ()=>o);
const a = {
    path: "/api/v1/wallets",
    method: "GET"
}, t = {
    path: "/api/v1/wallets",
    method: "POST"
}, l = {
    path: "/api/v1/wallets/:wallet_id",
    method: "GET"
}, e = {
    path: "/api/v1/wallets/:wallet_id/balance",
    method: "GET"
}, p = {
    path: "/api/v1/wallets/:wallet_id/rpc",
    method: "POST"
}, h = {
    path: "/api/v1/wallets/:wallet_id/raw_sign",
    method: "POST"
}, i = {
    path: "/api/v1/wallets/:wallet_id",
    method: "PATCH"
}, d = {
    path: "/api/v1/wallets/:wallet_id/export",
    method: "POST"
}, w = {
    path: "/api/v1/wallets/delegate",
    method: "POST"
}, o = {
    path: "/api/v1/wallets/revoke",
    method: "POST"
}, s = {
    path: "/api/v1/wallets/:wallet_id/transactions",
    method: "GET"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eGcLw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnalyticsEventInput", ()=>n);
var _zod = require("zod");
const n = (0, _zod.z).object({
    event_name: (0, _zod.z).string().max(255),
    client_id: (0, _zod.z).string().max(255).nullable(),
    payload: (0, _zod.z).record((0, _zod.z).any()).optional()
});

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fOFdH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _indexJs = require("./v3/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
parcelHelpers.exportAll(_indexJs, exports);
exports.default = (0, _indexJsDefault.default);

},{"./v3/index.js":"85MQ2","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"85MQ2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "z", ()=>_externalJs);
var _externalJs = require("./external.js");
parcelHelpers.exportAll(_externalJs, exports);
exports.default = _externalJs;

},{"./external.js":"4GDvM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4GDvM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _errorsJs = require("./errors.js");
parcelHelpers.exportAll(_errorsJs, exports);
var _parseUtilJs = require("./helpers/parseUtil.js");
parcelHelpers.exportAll(_parseUtilJs, exports);
var _typeAliasesJs = require("./helpers/typeAliases.js");
parcelHelpers.exportAll(_typeAliasesJs, exports);
var _utilJs = require("./helpers/util.js");
parcelHelpers.exportAll(_utilJs, exports);
var _typesJs = require("./types.js");
parcelHelpers.exportAll(_typesJs, exports);
var _zodErrorJs = require("./ZodError.js");
parcelHelpers.exportAll(_zodErrorJs, exports);

},{"./errors.js":"a6pdd","./helpers/parseUtil.js":"aROeC","./helpers/typeAliases.js":"b9Sce","./helpers/util.js":"6iaXv","./types.js":"ixywL","./ZodError.js":"gq3rZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a6pdd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultErrorMap", ()=>(0, _enJsDefault.default));
parcelHelpers.export(exports, "setErrorMap", ()=>setErrorMap);
parcelHelpers.export(exports, "getErrorMap", ()=>getErrorMap);
var _enJs = require("./locales/en.js");
var _enJsDefault = parcelHelpers.interopDefault(_enJs);
let overrideErrorMap = (0, _enJsDefault.default);
function setErrorMap(map) {
    overrideErrorMap = map;
}
function getErrorMap() {
    return overrideErrorMap;
}

},{"./locales/en.js":"5HRO6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5HRO6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _zodErrorJs = require("../ZodError.js");
var _utilJs = require("../helpers/util.js");
const errorMap = (issue, _ctx)=>{
    let message;
    switch(issue.code){
        case (0, _zodErrorJs.ZodIssueCode).invalid_type:
            if (issue.received === (0, _utilJs.ZodParsedType).undefined) message = "Required";
            else message = `Expected ${issue.expected}, received ${issue.received}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_literal:
            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, (0, _utilJs.util).jsonStringifyReplacer)}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).unrecognized_keys:
            message = `Unrecognized key(s) in object: ${(0, _utilJs.util).joinValues(issue.keys, ", ")}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_union:
            message = `Invalid input`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_union_discriminator:
            message = `Invalid discriminator value. Expected ${(0, _utilJs.util).joinValues(issue.options)}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_enum_value:
            message = `Invalid enum value. Expected ${(0, _utilJs.util).joinValues(issue.options)}, received '${issue.received}'`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_arguments:
            message = `Invalid function arguments`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_return_type:
            message = `Invalid function return type`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_date:
            message = `Invalid date`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_string:
            if (typeof issue.validation === "object") {
                if ("includes" in issue.validation) {
                    message = `Invalid input: must include "${issue.validation.includes}"`;
                    if (typeof issue.validation.position === "number") message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
                } else if ("startsWith" in issue.validation) message = `Invalid input: must start with "${issue.validation.startsWith}"`;
                else if ("endsWith" in issue.validation) message = `Invalid input: must end with "${issue.validation.endsWith}"`;
                else (0, _utilJs.util).assertNever(issue.validation);
            } else if (issue.validation !== "regex") message = `Invalid ${issue.validation}`;
            else message = "Invalid";
            break;
        case (0, _zodErrorJs.ZodIssueCode).too_small:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
            else message = "Invalid input";
            break;
        case (0, _zodErrorJs.ZodIssueCode).too_big:
            if (issue.type === "array") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
            else if (issue.type === "string") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
            else if (issue.type === "number") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "bigint") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
            else if (issue.type === "date") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
            else message = "Invalid input";
            break;
        case (0, _zodErrorJs.ZodIssueCode).custom:
            message = `Invalid input`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).invalid_intersection_types:
            message = `Intersection results could not be merged`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).not_multiple_of:
            message = `Number must be a multiple of ${issue.multipleOf}`;
            break;
        case (0, _zodErrorJs.ZodIssueCode).not_finite:
            message = "Number must be finite";
            break;
        default:
            message = _ctx.defaultError;
            (0, _utilJs.util).assertNever(issue);
    }
    return {
        message
    };
};
exports.default = errorMap;

},{"../ZodError.js":"gq3rZ","../helpers/util.js":"6iaXv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gq3rZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ZodIssueCode", ()=>ZodIssueCode);
parcelHelpers.export(exports, "quotelessJson", ()=>quotelessJson);
parcelHelpers.export(exports, "ZodError", ()=>ZodError);
var _utilJs = require("./helpers/util.js");
const ZodIssueCode = (0, _utilJs.util).arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
]);
const quotelessJson = (obj)=>{
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues){
        super();
        this.issues = [];
        this.addIssue = (sub)=>{
            this.issues = [
                ...this.issues,
                sub
            ];
        };
        this.addIssues = (subs = [])=>{
            this.issues = [
                ...this.issues,
                ...subs
            ];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) // eslint-disable-next-line ban/ban
        Object.setPrototypeOf(this, actualProto);
        else this.__proto__ = actualProto;
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper || function(issue) {
            return issue.message;
        };
        const fieldErrors = {
            _errors: []
        };
        const processError = (error)=>{
            for (const issue of error.issues){
                if (issue.code === "invalid_union") issue.unionErrors.map(processError);
                else if (issue.code === "invalid_return_type") processError(issue.returnTypeError);
                else if (issue.code === "invalid_arguments") processError(issue.argumentsError);
                else if (issue.path.length === 0) fieldErrors._errors.push(mapper(issue));
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while(i < issue.path.length){
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) curr[el] = curr[el] || {
                            _errors: []
                        };
                        else {
                            curr[el] = curr[el] || {
                                _errors: []
                            };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) throw new Error(`Not a ZodError: ${value}`);
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, (0, _utilJs.util).jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue)=>issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues)if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
        } else formErrors.push(mapper(sub));
        return {
            formErrors,
            fieldErrors
        };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues)=>{
    const error = new ZodError(issues);
    return error;
};

},{"./helpers/util.js":"6iaXv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6iaXv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "util", ()=>util);
parcelHelpers.export(exports, "objectUtil", ()=>objectUtil);
parcelHelpers.export(exports, "ZodParsedType", ()=>ZodParsedType);
parcelHelpers.export(exports, "getParsedType", ()=>getParsedType);
var util;
(function(util) {
    util.assertEqual = (_)=>{};
    function assertIs(_arg) {}
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items)=>{
        const obj = {};
        for (const item of items)obj[item] = item;
        return obj;
    };
    util.getValidEnumValues = (obj)=>{
        const validKeys = util.objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys)filtered[k] = obj[k];
        return util.objectValues(filtered);
    };
    util.objectValues = (obj)=>{
        return util.objectKeys(obj).map(function(e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
     ? (obj)=>Object.keys(obj) // eslint-disable-line ban/ban
     : (object)=>{
        const keys = [];
        for(const key in object)if (Object.prototype.hasOwnProperty.call(object, key)) keys.push(key);
        return keys;
    };
    util.find = (arr, checker)=>{
        for (const item of arr){
            if (checker(item)) return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function" ? (val)=>Number.isInteger(val) // eslint-disable-line ban/ban
     : (val)=>typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array.map((val)=>typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value)=>{
        if (typeof value === "bigint") return value.toString();
        return value;
    };
})(util || (util = {}));
var objectUtil;
(function(objectUtil) {
    objectUtil.mergeShapes = (first, second)=>{
        return {
            ...first,
            ...second
        };
    };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
]);
const getParsedType = (data)=>{
    const t = typeof data;
    switch(t){
        case "undefined":
            return ZodParsedType.undefined;
        case "string":
            return ZodParsedType.string;
        case "number":
            return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
            return ZodParsedType.boolean;
        case "function":
            return ZodParsedType.function;
        case "bigint":
            return ZodParsedType.bigint;
        case "symbol":
            return ZodParsedType.symbol;
        case "object":
            if (Array.isArray(data)) return ZodParsedType.array;
            if (data === null) return ZodParsedType.null;
            if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") return ZodParsedType.promise;
            if (typeof Map !== "undefined" && data instanceof Map) return ZodParsedType.map;
            if (typeof Set !== "undefined" && data instanceof Set) return ZodParsedType.set;
            if (typeof Date !== "undefined" && data instanceof Date) return ZodParsedType.date;
            return ZodParsedType.object;
        default:
            return ZodParsedType.unknown;
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aROeC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "makeIssue", ()=>makeIssue);
parcelHelpers.export(exports, "EMPTY_PATH", ()=>EMPTY_PATH);
parcelHelpers.export(exports, "addIssueToContext", ()=>addIssueToContext);
parcelHelpers.export(exports, "ParseStatus", ()=>ParseStatus);
parcelHelpers.export(exports, "INVALID", ()=>INVALID);
parcelHelpers.export(exports, "DIRTY", ()=>DIRTY);
parcelHelpers.export(exports, "OK", ()=>OK);
parcelHelpers.export(exports, "isAborted", ()=>isAborted);
parcelHelpers.export(exports, "isDirty", ()=>isDirty);
parcelHelpers.export(exports, "isValid", ()=>isValid);
parcelHelpers.export(exports, "isAsync", ()=>isAsync);
var _errorsJs = require("../errors.js");
var _enJs = require("../locales/en.js");
var _enJsDefault = parcelHelpers.interopDefault(_enJs);
const makeIssue = (params)=>{
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [
        ...path,
        ...issueData.path || []
    ];
    const fullIssue = {
        ...issueData,
        path: fullPath
    };
    if (issueData.message !== undefined) return {
        ...issueData,
        path: fullPath,
        message: issueData.message
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m)=>!!m).slice().reverse();
    for (const map of maps)errorMessage = map(fullIssue, {
        data,
        defaultError: errorMessage
    }).message;
    return {
        ...issueData,
        path: fullPath,
        message: errorMessage
    };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
    const overrideMap = (0, _errorsJs.getErrorMap)();
    const issue = makeIssue({
        issueData: issueData,
        data: ctx.data,
        path: ctx.path,
        errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            overrideMap,
            overrideMap === (0, _enJsDefault.default) ? undefined : (0, _enJsDefault.default)
        ].filter((x)=>!!x)
    });
    ctx.common.issues.push(issue);
}
class ParseStatus {
    constructor(){
        this.value = "valid";
    }
    dirty() {
        if (this.value === "valid") this.value = "dirty";
    }
    abort() {
        if (this.value !== "aborted") this.value = "aborted";
    }
    static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results){
            if (s.status === "aborted") return INVALID;
            if (s.status === "dirty") status.dirty();
            arrayValue.push(s.value);
        }
        return {
            status: status.value,
            value: arrayValue
        };
    }
    static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs){
            const key = await pair.key;
            const value = await pair.value;
            syncPairs.push({
                key,
                value
            });
        }
        return ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs){
            const { key, value } = pair;
            if (key.status === "aborted") return INVALID;
            if (value.status === "aborted") return INVALID;
            if (key.status === "dirty") status.dirty();
            if (value.status === "dirty") status.dirty();
            if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) finalObject[key.value] = value.value;
        }
        return {
            status: status.value,
            value: finalObject
        };
    }
}
const INVALID = Object.freeze({
    status: "aborted"
});
const DIRTY = (value)=>({
        status: "dirty",
        value
    });
const OK = (value)=>({
        status: "valid",
        value
    });
const isAborted = (x)=>x.status === "aborted";
const isDirty = (x)=>x.status === "dirty";
const isValid = (x)=>x.status === "valid";
const isAsync = (x)=>typeof Promise !== "undefined" && x instanceof Promise;

},{"../errors.js":"a6pdd","../locales/en.js":"5HRO6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b9Sce":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ixywL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ZodType", ()=>ZodType);
// Adapted from https://stackoverflow.com/a/3143231
parcelHelpers.export(exports, "datetimeRegex", ()=>datetimeRegex);
parcelHelpers.export(exports, "ZodString", ()=>ZodString);
parcelHelpers.export(exports, "ZodNumber", ()=>ZodNumber);
parcelHelpers.export(exports, "ZodBigInt", ()=>ZodBigInt);
parcelHelpers.export(exports, "ZodBoolean", ()=>ZodBoolean);
parcelHelpers.export(exports, "ZodDate", ()=>ZodDate);
parcelHelpers.export(exports, "ZodSymbol", ()=>ZodSymbol);
parcelHelpers.export(exports, "ZodUndefined", ()=>ZodUndefined);
parcelHelpers.export(exports, "ZodNull", ()=>ZodNull);
parcelHelpers.export(exports, "ZodAny", ()=>ZodAny);
parcelHelpers.export(exports, "ZodUnknown", ()=>ZodUnknown);
parcelHelpers.export(exports, "ZodNever", ()=>ZodNever);
parcelHelpers.export(exports, "ZodVoid", ()=>ZodVoid);
parcelHelpers.export(exports, "ZodArray", ()=>ZodArray);
parcelHelpers.export(exports, "ZodObject", ()=>ZodObject);
parcelHelpers.export(exports, "ZodUnion", ()=>ZodUnion);
parcelHelpers.export(exports, "ZodDiscriminatedUnion", ()=>ZodDiscriminatedUnion);
parcelHelpers.export(exports, "ZodIntersection", ()=>ZodIntersection);
// type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
parcelHelpers.export(exports, "ZodTuple", ()=>ZodTuple);
parcelHelpers.export(exports, "ZodRecord", ()=>ZodRecord);
parcelHelpers.export(exports, "ZodMap", ()=>ZodMap);
parcelHelpers.export(exports, "ZodSet", ()=>ZodSet);
parcelHelpers.export(exports, "ZodFunction", ()=>ZodFunction);
parcelHelpers.export(exports, "ZodLazy", ()=>ZodLazy);
parcelHelpers.export(exports, "ZodLiteral", ()=>ZodLiteral);
parcelHelpers.export(exports, "ZodEnum", ()=>ZodEnum);
parcelHelpers.export(exports, "ZodNativeEnum", ()=>ZodNativeEnum);
parcelHelpers.export(exports, "ZodPromise", ()=>ZodPromise);
parcelHelpers.export(exports, "ZodEffects", ()=>ZodEffects);
parcelHelpers.export(exports, "ZodTransformer", ()=>ZodEffects);
parcelHelpers.export(exports, "ZodOptional", ()=>ZodOptional);
parcelHelpers.export(exports, "ZodNullable", ()=>ZodNullable);
parcelHelpers.export(exports, "ZodDefault", ()=>ZodDefault);
parcelHelpers.export(exports, "ZodCatch", ()=>ZodCatch);
parcelHelpers.export(exports, "ZodNaN", ()=>ZodNaN);
parcelHelpers.export(exports, "BRAND", ()=>BRAND);
parcelHelpers.export(exports, "ZodBranded", ()=>ZodBranded);
parcelHelpers.export(exports, "ZodPipeline", ()=>ZodPipeline);
parcelHelpers.export(exports, "ZodReadonly", ()=>ZodReadonly);
parcelHelpers.export(exports, "custom", ()=>custom);
parcelHelpers.export(exports, "Schema", ()=>ZodType);
parcelHelpers.export(exports, "ZodSchema", ()=>ZodType);
parcelHelpers.export(exports, "late", ()=>late);
parcelHelpers.export(exports, "ZodFirstPartyTypeKind", ()=>ZodFirstPartyTypeKind);
parcelHelpers.export(exports, "coerce", ()=>coerce);
parcelHelpers.export(exports, "any", ()=>anyType);
parcelHelpers.export(exports, "array", ()=>arrayType);
parcelHelpers.export(exports, "bigint", ()=>bigIntType);
parcelHelpers.export(exports, "boolean", ()=>booleanType);
parcelHelpers.export(exports, "date", ()=>dateType);
parcelHelpers.export(exports, "discriminatedUnion", ()=>discriminatedUnionType);
parcelHelpers.export(exports, "effect", ()=>effectsType);
parcelHelpers.export(exports, "enum", ()=>enumType);
parcelHelpers.export(exports, "function", ()=>functionType);
parcelHelpers.export(exports, "instanceof", ()=>instanceOfType);
parcelHelpers.export(exports, "intersection", ()=>intersectionType);
parcelHelpers.export(exports, "lazy", ()=>lazyType);
parcelHelpers.export(exports, "literal", ()=>literalType);
parcelHelpers.export(exports, "map", ()=>mapType);
parcelHelpers.export(exports, "nan", ()=>nanType);
parcelHelpers.export(exports, "nativeEnum", ()=>nativeEnumType);
parcelHelpers.export(exports, "never", ()=>neverType);
parcelHelpers.export(exports, "null", ()=>nullType);
parcelHelpers.export(exports, "nullable", ()=>nullableType);
parcelHelpers.export(exports, "number", ()=>numberType);
parcelHelpers.export(exports, "object", ()=>objectType);
parcelHelpers.export(exports, "oboolean", ()=>oboolean);
parcelHelpers.export(exports, "onumber", ()=>onumber);
parcelHelpers.export(exports, "optional", ()=>optionalType);
parcelHelpers.export(exports, "ostring", ()=>ostring);
parcelHelpers.export(exports, "pipeline", ()=>pipelineType);
parcelHelpers.export(exports, "preprocess", ()=>preprocessType);
parcelHelpers.export(exports, "promise", ()=>promiseType);
parcelHelpers.export(exports, "record", ()=>recordType);
parcelHelpers.export(exports, "set", ()=>setType);
parcelHelpers.export(exports, "strictObject", ()=>strictObjectType);
parcelHelpers.export(exports, "string", ()=>stringType);
parcelHelpers.export(exports, "symbol", ()=>symbolType);
parcelHelpers.export(exports, "transformer", ()=>effectsType);
parcelHelpers.export(exports, "tuple", ()=>tupleType);
parcelHelpers.export(exports, "undefined", ()=>undefinedType);
parcelHelpers.export(exports, "union", ()=>unionType);
parcelHelpers.export(exports, "unknown", ()=>unknownType);
parcelHelpers.export(exports, "void", ()=>voidType);
parcelHelpers.export(exports, "NEVER", ()=>NEVER);
var _zodErrorJs = require("./ZodError.js");
var _errorsJs = require("./errors.js");
var _errorUtilJs = require("./helpers/errorUtil.js");
var _parseUtilJs = require("./helpers/parseUtil.js");
var _utilJs = require("./helpers/util.js");
class ParseInputLazyPath {
    constructor(parent, value, path, key){
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
    }
    get path() {
        if (!this._cachedPath.length) {
            if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
            else this._cachedPath.push(...this._path, this._key);
        }
        return this._cachedPath;
    }
}
const handleResult = (ctx, result)=>{
    if ((0, _parseUtilJs.isValid)(result)) return {
        success: true,
        data: result.value
    };
    else {
        if (!ctx.common.issues.length) throw new Error("Validation failed but no issues detected.");
        return {
            success: false,
            get error () {
                if (this._error) return this._error;
                const error = new (0, _zodErrorJs.ZodError)(ctx.common.issues);
                this._error = error;
                return this._error;
            }
        };
    }
};
function processCreateParams(params) {
    if (!params) return {};
    const { errorMap, invalid_type_error, required_error, description } = params;
    if (errorMap && (invalid_type_error || required_error)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    if (errorMap) return {
        errorMap: errorMap,
        description
    };
    const customMap = (iss, ctx)=>{
        const { message } = params;
        if (iss.code === "invalid_enum_value") return {
            message: message ?? ctx.defaultError
        };
        if (typeof ctx.data === "undefined") return {
            message: message ?? required_error ?? ctx.defaultError
        };
        if (iss.code !== "invalid_type") return {
            message: ctx.defaultError
        };
        return {
            message: message ?? invalid_type_error ?? ctx.defaultError
        };
    };
    return {
        errorMap: customMap,
        description
    };
}
class ZodType {
    get description() {
        return this._def.description;
    }
    _getType(input) {
        return (0, _utilJs.getParsedType)(input.data);
    }
    _getOrReturnCtx(input, ctx) {
        return ctx || {
            common: input.parent.common,
            data: input.data,
            parsedType: (0, _utilJs.getParsedType)(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
        };
    }
    _processInputParams(input) {
        return {
            status: new (0, _parseUtilJs.ParseStatus)(),
            ctx: {
                common: input.parent.common,
                data: input.data,
                parsedType: (0, _utilJs.getParsedType)(input.data),
                schemaErrorMap: this._def.errorMap,
                path: input.path,
                parent: input.parent
            }
        };
    }
    _parseSync(input) {
        const result = this._parse(input);
        if ((0, _parseUtilJs.isAsync)(result)) throw new Error("Synchronous parse encountered promise.");
        return result;
    }
    _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
    }
    parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    safeParse(data, params) {
        const ctx = {
            common: {
                issues: [],
                async: params?.async ?? false,
                contextualErrorMap: params?.errorMap
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, _utilJs.getParsedType)(data)
        };
        const result = this._parseSync({
            data,
            path: ctx.path,
            parent: ctx
        });
        return handleResult(ctx, result);
    }
    "~validate"(data) {
        const ctx = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, _utilJs.getParsedType)(data)
        };
        if (!this["~standard"].async) try {
            const result = this._parseSync({
                data,
                path: [],
                parent: ctx
            });
            return (0, _parseUtilJs.isValid)(result) ? {
                value: result.value
            } : {
                issues: ctx.common.issues
            };
        } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) this["~standard"].async = true;
            ctx.common = {
                issues: [],
                async: true
            };
        }
        return this._parseAsync({
            data,
            path: [],
            parent: ctx
        }).then((result)=>(0, _parseUtilJs.isValid)(result) ? {
                value: result.value
            } : {
                issues: ctx.common.issues
            });
    }
    async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success) return result.data;
        throw result.error;
    }
    async safeParseAsync(data, params) {
        const ctx = {
            common: {
                issues: [],
                contextualErrorMap: params?.errorMap,
                async: true
            },
            path: params?.path || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data,
            parsedType: (0, _utilJs.getParsedType)(data)
        };
        const maybeAsyncResult = this._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
        const result = await ((0, _parseUtilJs.isAsync)(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
    }
    refine(check, message) {
        const getIssueProperties = (val)=>{
            if (typeof message === "string" || typeof message === "undefined") return {
                message
            };
            else if (typeof message === "function") return message(val);
            else return message;
        };
        return this._refinement((val, ctx)=>{
            const result = check(val);
            const setError = ()=>ctx.addIssue({
                    code: (0, _zodErrorJs.ZodIssueCode).custom,
                    ...getIssueProperties(val)
                });
            if (typeof Promise !== "undefined" && result instanceof Promise) return result.then((data)=>{
                if (!data) {
                    setError();
                    return false;
                } else return true;
            });
            if (!result) {
                setError();
                return false;
            } else return true;
        });
    }
    refinement(check, refinementData) {
        return this._refinement((val, ctx)=>{
            if (!check(val)) {
                ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
                return false;
            } else return true;
        });
    }
    _refinement(refinement) {
        return new ZodEffects({
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "refinement",
                refinement
            }
        });
    }
    superRefine(refinement) {
        return this._refinement(refinement);
    }
    constructor(def){
        /** Alias of safeParseAsync */ this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: (data)=>this["~validate"](data)
        };
    }
    optional() {
        return ZodOptional.create(this, this._def);
    }
    nullable() {
        return ZodNullable.create(this, this._def);
    }
    nullish() {
        return this.nullable().optional();
    }
    array() {
        return ZodArray.create(this);
    }
    promise() {
        return ZodPromise.create(this, this._def);
    }
    or(option) {
        return ZodUnion.create([
            this,
            option
        ], this._def);
    }
    and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
        return new ZodEffects({
            ...processCreateParams(this._def),
            schema: this,
            typeName: ZodFirstPartyTypeKind.ZodEffects,
            effect: {
                type: "transform",
                transform
            }
        });
    }
    default(def) {
        const defaultValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodDefault({
            ...processCreateParams(this._def),
            innerType: this,
            defaultValue: defaultValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodDefault
        });
    }
    brand() {
        return new ZodBranded({
            typeName: ZodFirstPartyTypeKind.ZodBranded,
            type: this,
            ...processCreateParams(this._def)
        });
    }
    catch(def) {
        const catchValueFunc = typeof def === "function" ? def : ()=>def;
        return new ZodCatch({
            ...processCreateParams(this._def),
            innerType: this,
            catchValue: catchValueFunc,
            typeName: ZodFirstPartyTypeKind.ZodCatch
        });
    }
    describe(description) {
        const This = this.constructor;
        return new This({
            ...this._def,
            description
        });
    }
    pipe(target) {
        return ZodPipeline.create(this, target);
    }
    readonly() {
        return ZodReadonly.create(this);
    }
    isOptional() {
        return this.safeParse(undefined).success;
    }
    isNullable() {
        return this.safeParse(null).success;
    }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
// const uuidRegex =
//   /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
// from https://stackoverflow.com/a/46181/1550155
// old version: too slow, didn't support unicode
// const emailRegex = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
//old email regex
// const emailRegex = /^(([^<>()[\].,;:\s@"]+(\.[^<>()[\].,;:\s@"]+)*)|(".+"))@((?!-)([^<>()[\].,;:\s@"]+\.)+[^<>()[\].,;:\s@"]{1,})[^-<>()[\].,;:\s@"]$/i;
// eslint-disable-next-line
// const emailRegex =
//   /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
// const emailRegex =
//   /^[a-zA-Z0-9\.\!\#\$\%\&\'\*\+\/\=\?\^\_\`\{\|\}\~\-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// const emailRegex =
//   /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
// const emailRegex =
//   /^[a-z0-9.!#$%&*+/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9\-]+)*$/i;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
// faster, simpler, safer
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
// const ipv6Regex =
// /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
// https://base64.guru/standards/base64url
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
// simple
// const dateRegexSource = `\\d{4}-\\d{2}-\\d{2}`;
// no leap year validation
// const dateRegexSource = `\\d{4}-((0[13578]|10|12)-31|(0[13-9]|1[0-2])-30|(0[1-9]|1[0-2])-(0[1-9]|1\\d|2\\d))`;
// with leap year validation
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
    let secondsRegexSource = `[0-5]\\d`;
    if (args.precision) secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
    else if (args.precision == null) secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
    const secondsQuantifier = args.precision ? "+" : "?"; // require seconds if precision is nonzero
    return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
    return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
    const opts = [];
    opts.push(args.local ? `Z?` : `Z`);
    if (args.offset) opts.push(`([+-]\\d{2}:?\\d{2})`);
    regex = `${regex}(${opts.join("|")})`;
    return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) return true;
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) return true;
    return false;
}
function isValidJWT(jwt, alg) {
    if (!jwtRegex.test(jwt)) return false;
    try {
        const [header] = jwt.split(".");
        // Convert base64url to base64
        const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
        const decoded = JSON.parse(atob(base64));
        if (typeof decoded !== "object" || decoded === null) return false;
        if ("typ" in decoded && decoded?.typ !== "JWT") return false;
        if (!decoded.alg) return false;
        if (alg && decoded.alg !== alg) return false;
        return true;
    } catch  {
        return false;
    }
}
function isValidCidr(ip, version) {
    if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) return true;
    if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) return true;
    return false;
}
class ZodString extends ZodType {
    _parse(input) {
        if (this._def.coerce) input.data = String(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).string) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).string,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const status = new (0, _parseUtilJs.ParseStatus)();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.length < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.length > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "length") {
                const tooBig = input.data.length > check.value;
                const tooSmall = input.data.length < check.value;
                if (tooBig || tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    if (tooBig) (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        maximum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: true,
                        message: check.message
                    });
                    else if (tooSmall) (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        minimum: check.value,
                        type: "string",
                        inclusive: true,
                        exact: true,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "email") {
                if (!emailRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "email",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "emoji") {
                if (!emojiRegex) emojiRegex = new RegExp(_emojiRegex, "u");
                if (!emojiRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "emoji",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "uuid") {
                if (!uuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "uuid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "nanoid") {
                if (!nanoidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "nanoid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid") {
                if (!cuidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "cuid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cuid2") {
                if (!cuid2Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "cuid2",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ulid") {
                if (!ulidRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "ulid",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "url") try {
                new URL(input.data);
            } catch  {
                ctx = this._getOrReturnCtx(input, ctx);
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    validation: "url",
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                    message: check.message
                });
                status.dirty();
            }
            else if (check.kind === "regex") {
                check.regex.lastIndex = 0;
                const testResult = check.regex.test(input.data);
                if (!testResult) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "regex",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "trim") input.data = input.data.trim();
            else if (check.kind === "includes") {
                if (!input.data.includes(check.value, check.position)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: {
                            includes: check.value,
                            position: check.position
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "toLowerCase") input.data = input.data.toLowerCase();
            else if (check.kind === "toUpperCase") input.data = input.data.toUpperCase();
            else if (check.kind === "startsWith") {
                if (!input.data.startsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: {
                            startsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "endsWith") {
                if (!input.data.endsWith(check.value)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: {
                            endsWith: check.value
                        },
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "datetime") {
                const regex = datetimeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: "datetime",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "date") {
                const regex = dateRegex;
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: "date",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "time") {
                const regex = timeRegex(check);
                if (!regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        validation: "time",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "duration") {
                if (!durationRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "duration",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "ip") {
                if (!isValidIP(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "ip",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "jwt") {
                if (!isValidJWT(input.data, check.alg)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "jwt",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "cidr") {
                if (!isValidCidr(input.data, check.version)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "cidr",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "base64") {
                if (!base64Regex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "base64",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "base64url") {
                if (!base64urlRegex.test(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        validation: "base64url",
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
                        message: check.message
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    _regex(regex, validation, message) {
        return this.refinement((data)=>regex.test(data), {
            validation,
            code: (0, _zodErrorJs.ZodIssueCode).invalid_string,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    _addCheck(check) {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    email(message) {
        return this._addCheck({
            kind: "email",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    url(message) {
        return this._addCheck({
            kind: "url",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    emoji(message) {
        return this._addCheck({
            kind: "emoji",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    uuid(message) {
        return this._addCheck({
            kind: "uuid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    nanoid(message) {
        return this._addCheck({
            kind: "nanoid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    cuid(message) {
        return this._addCheck({
            kind: "cuid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    cuid2(message) {
        return this._addCheck({
            kind: "cuid2",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    ulid(message) {
        return this._addCheck({
            kind: "ulid",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    base64(message) {
        return this._addCheck({
            kind: "base64",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    base64url(message) {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return this._addCheck({
            kind: "base64url",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    jwt(options) {
        return this._addCheck({
            kind: "jwt",
            ...(0, _errorUtilJs.errorUtil).errToObj(options)
        });
    }
    ip(options) {
        return this._addCheck({
            kind: "ip",
            ...(0, _errorUtilJs.errorUtil).errToObj(options)
        });
    }
    cidr(options) {
        return this._addCheck({
            kind: "cidr",
            ...(0, _errorUtilJs.errorUtil).errToObj(options)
        });
    }
    datetime(options) {
        if (typeof options === "string") return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
        });
        return this._addCheck({
            kind: "datetime",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            offset: options?.offset ?? false,
            local: options?.local ?? false,
            ...(0, _errorUtilJs.errorUtil).errToObj(options?.message)
        });
    }
    date(message) {
        return this._addCheck({
            kind: "date",
            message
        });
    }
    time(options) {
        if (typeof options === "string") return this._addCheck({
            kind: "time",
            precision: null,
            message: options
        });
        return this._addCheck({
            kind: "time",
            precision: typeof options?.precision === "undefined" ? null : options?.precision,
            ...(0, _errorUtilJs.errorUtil).errToObj(options?.message)
        });
    }
    duration(message) {
        return this._addCheck({
            kind: "duration",
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    regex(regex, message) {
        return this._addCheck({
            kind: "regex",
            regex: regex,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    includes(value, options) {
        return this._addCheck({
            kind: "includes",
            value: value,
            position: options?.position,
            ...(0, _errorUtilJs.errorUtil).errToObj(options?.message)
        });
    }
    startsWith(value, message) {
        return this._addCheck({
            kind: "startsWith",
            value: value,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    endsWith(value, message) {
        return this._addCheck({
            kind: "endsWith",
            value: value,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    min(minLength, message) {
        return this._addCheck({
            kind: "min",
            value: minLength,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    max(maxLength, message) {
        return this._addCheck({
            kind: "max",
            value: maxLength,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    length(len, message) {
        return this._addCheck({
            kind: "length",
            value: len,
            ...(0, _errorUtilJs.errorUtil).errToObj(message)
        });
    }
    /**
     * Equivalent to `.min(1)`
     */ nonempty(message) {
        return this.min(1, (0, _errorUtilJs.errorUtil).errToObj(message));
    }
    trim() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "trim"
                }
            ]
        });
    }
    toLowerCase() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toLowerCase"
                }
            ]
        });
    }
    toUpperCase() {
        return new ZodString({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind: "toUpperCase"
                }
            ]
        });
    }
    get isDatetime() {
        return !!this._def.checks.find((ch)=>ch.kind === "datetime");
    }
    get isDate() {
        return !!this._def.checks.find((ch)=>ch.kind === "date");
    }
    get isTime() {
        return !!this._def.checks.find((ch)=>ch.kind === "time");
    }
    get isDuration() {
        return !!this._def.checks.find((ch)=>ch.kind === "duration");
    }
    get isEmail() {
        return !!this._def.checks.find((ch)=>ch.kind === "email");
    }
    get isURL() {
        return !!this._def.checks.find((ch)=>ch.kind === "url");
    }
    get isEmoji() {
        return !!this._def.checks.find((ch)=>ch.kind === "emoji");
    }
    get isUUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "uuid");
    }
    get isNANOID() {
        return !!this._def.checks.find((ch)=>ch.kind === "nanoid");
    }
    get isCUID() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid");
    }
    get isCUID2() {
        return !!this._def.checks.find((ch)=>ch.kind === "cuid2");
    }
    get isULID() {
        return !!this._def.checks.find((ch)=>ch.kind === "ulid");
    }
    get isIP() {
        return !!this._def.checks.find((ch)=>ch.kind === "ip");
    }
    get isCIDR() {
        return !!this._def.checks.find((ch)=>ch.kind === "cidr");
    }
    get isBase64() {
        return !!this._def.checks.find((ch)=>ch.kind === "base64");
    }
    get isBase64url() {
        // base64url encoding is a modification of base64 that can safely be used in URLs and filenames
        return !!this._def.checks.find((ch)=>ch.kind === "base64url");
    }
    get minLength() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxLength() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
}
ZodString.create = (params)=>{
    return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
    });
};
// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / 10 ** decCount;
}
class ZodNumber extends ZodType {
    constructor(){
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
    }
    _parse(input) {
        if (this._def.coerce) input.data = Number(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).number) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).number,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        let ctx = undefined;
        const status = new (0, _parseUtilJs.ParseStatus)();
        for (const check of this._def.checks){
            if (check.kind === "int") {
                if (!(0, _utilJs.util).isInteger(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                        expected: "integer",
                        received: "float",
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        minimum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        maximum: check.value,
                        type: "number",
                        inclusive: check.inclusive,
                        exact: false,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (floatSafeRemainder(input.data, check.value) !== 0) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "finite") {
                if (!Number.isFinite(input.data)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).not_finite,
                        message: check.message
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    gte(value, message) {
        return this.setLimit("min", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: (0, _errorUtilJs.errorUtil).toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodNumber({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    int(message) {
        return this._addCheck({
            kind: "int",
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value: value,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    finite(message) {
        return this._addCheck({
            kind: "finite",
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    safe(message) {
        return this._addCheck({
            kind: "min",
            inclusive: true,
            value: Number.MIN_SAFE_INTEGER,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        })._addCheck({
            kind: "max",
            inclusive: true,
            value: Number.MAX_SAFE_INTEGER,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
    get isInt() {
        return !!this._def.checks.find((ch)=>ch.kind === "int" || ch.kind === "multipleOf" && (0, _utilJs.util).isInteger(ch.value));
    }
    get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") return true;
            else if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            } else if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return Number.isFinite(min) && Number.isFinite(max);
    }
}
ZodNumber.create = (params)=>{
    return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
    });
};
class ZodBigInt extends ZodType {
    constructor(){
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
    }
    _parse(input) {
        if (this._def.coerce) try {
            input.data = BigInt(input.data);
        } catch  {
            return this._getInvalidInput(input);
        }
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).bigint) return this._getInvalidInput(input);
        let ctx = undefined;
        const status = new (0, _parseUtilJs.ParseStatus)();
        for (const check of this._def.checks){
            if (check.kind === "min") {
                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
                if (tooSmall) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        type: "bigint",
                        minimum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
                if (tooBig) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        type: "bigint",
                        maximum: check.value,
                        inclusive: check.inclusive,
                        message: check.message
                    });
                    status.dirty();
                }
            } else if (check.kind === "multipleOf") {
                if (input.data % check.value !== BigInt(0)) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).not_multiple_of,
                        multipleOf: check.value,
                        message: check.message
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: input.data
        };
    }
    _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, _parseUtilJs.addIssueToContext)(ctx, {
            code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
            expected: (0, _utilJs.ZodParsedType).bigint,
            received: ctx.parsedType
        });
        return 0, _parseUtilJs.INVALID;
    }
    gte(value, message) {
        return this.setLimit("min", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    gt(value, message) {
        return this.setLimit("min", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lte(value, message) {
        return this.setLimit("max", value, true, (0, _errorUtilJs.errorUtil).toString(message));
    }
    lt(value, message) {
        return this.setLimit("max", value, false, (0, _errorUtilJs.errorUtil).toString(message));
    }
    setLimit(kind, value, inclusive, message) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                {
                    kind,
                    value,
                    inclusive,
                    message: (0, _errorUtilJs.errorUtil).toString(message)
                }
            ]
        });
    }
    _addCheck(check) {
        return new ZodBigInt({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    positive(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    negative(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: false,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonpositive(message) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    nonnegative(message) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: true,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    multipleOf(value, message) {
        return this._addCheck({
            kind: "multipleOf",
            value,
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    get minValue() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min;
    }
    get maxValue() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max;
    }
}
ZodBigInt.create = (params)=>{
    return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
    });
};
class ZodBoolean extends ZodType {
    _parse(input) {
        if (this._def.coerce) input.data = Boolean(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).boolean) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).boolean,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodBoolean.create = (params)=>{
    return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
    });
};
class ZodDate extends ZodType {
    _parse(input) {
        if (this._def.coerce) input.data = new Date(input.data);
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).date) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).date,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_date
            });
            return 0, _parseUtilJs.INVALID;
        }
        const status = new (0, _parseUtilJs.ParseStatus)();
        let ctx = undefined;
        for (const check of this._def.checks){
            if (check.kind === "min") {
                if (input.data.getTime() < check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_small,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        minimum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else if (check.kind === "max") {
                if (input.data.getTime() > check.value) {
                    ctx = this._getOrReturnCtx(input, ctx);
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).too_big,
                        message: check.message,
                        inclusive: true,
                        exact: false,
                        maximum: check.value,
                        type: "date"
                    });
                    status.dirty();
                }
            } else (0, _utilJs.util).assertNever(check);
        }
        return {
            status: status.value,
            value: new Date(input.data.getTime())
        };
    }
    _addCheck(check) {
        return new ZodDate({
            ...this._def,
            checks: [
                ...this._def.checks,
                check
            ]
        });
    }
    min(minDate, message) {
        return this._addCheck({
            kind: "min",
            value: minDate.getTime(),
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    max(maxDate, message) {
        return this._addCheck({
            kind: "max",
            value: maxDate.getTime(),
            message: (0, _errorUtilJs.errorUtil).toString(message)
        });
    }
    get minDate() {
        let min = null;
        for (const ch of this._def.checks){
            if (ch.kind === "min") {
                if (min === null || ch.value > min) min = ch.value;
            }
        }
        return min != null ? new Date(min) : null;
    }
    get maxDate() {
        let max = null;
        for (const ch of this._def.checks){
            if (ch.kind === "max") {
                if (max === null || ch.value < max) max = ch.value;
            }
        }
        return max != null ? new Date(max) : null;
    }
}
ZodDate.create = (params)=>{
    return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
    });
};
class ZodSymbol extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).symbol) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).symbol,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodSymbol.create = (params)=>{
    return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
    });
};
class ZodUndefined extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).undefined,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodUndefined.create = (params)=>{
    return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
    });
};
class ZodNull extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).null) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).null,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodNull.create = (params)=>{
    return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
    });
};
class ZodAny extends ZodType {
    constructor(){
        super(...arguments);
        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.
        this._any = true;
    }
    _parse(input) {
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodAny.create = (params)=>{
    return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
    });
};
class ZodUnknown extends ZodType {
    constructor(){
        super(...arguments);
        // required
        this._unknown = true;
    }
    _parse(input) {
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodUnknown.create = (params)=>{
    return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
    });
};
class ZodNever extends ZodType {
    _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        (0, _parseUtilJs.addIssueToContext)(ctx, {
            code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
            expected: (0, _utilJs.ZodParsedType).never,
            received: ctx.parsedType
        });
        return 0, _parseUtilJs.INVALID;
    }
}
ZodNever.create = (params)=>{
    return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
    });
};
class ZodVoid extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).undefined) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).void,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
}
ZodVoid.create = (params)=>{
    return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
    });
};
class ZodArray extends ZodType {
    _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).array) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).array,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (def.exactLength !== null) {
            const tooBig = ctx.data.length > def.exactLength.value;
            const tooSmall = ctx.data.length < def.exactLength.value;
            if (tooBig || tooSmall) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: tooBig ? (0, _zodErrorJs.ZodIssueCode).too_big : (0, _zodErrorJs.ZodIssueCode).too_small,
                    minimum: tooSmall ? def.exactLength.value : undefined,
                    maximum: tooBig ? def.exactLength.value : undefined,
                    type: "array",
                    inclusive: true,
                    exact: true,
                    message: def.exactLength.message
                });
                status.dirty();
            }
        }
        if (def.minLength !== null) {
            if (ctx.data.length < def.minLength.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_small,
                    minimum: def.minLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.minLength.message
                });
                status.dirty();
            }
        }
        if (def.maxLength !== null) {
            if (ctx.data.length > def.maxLength.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_big,
                    maximum: def.maxLength.value,
                    type: "array",
                    inclusive: true,
                    exact: false,
                    message: def.maxLength.message
                });
                status.dirty();
            }
        }
        if (ctx.common.async) return Promise.all([
            ...ctx.data
        ].map((item, i)=>{
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result)=>{
            return (0, _parseUtilJs.ParseStatus).mergeArray(status, result);
        });
        const result = [
            ...ctx.data
        ].map((item, i)=>{
            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return (0, _parseUtilJs.ParseStatus).mergeArray(status, result);
    }
    get element() {
        return this._def.type;
    }
    min(minLength, message) {
        return new ZodArray({
            ...this._def,
            minLength: {
                value: minLength,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    max(maxLength, message) {
        return new ZodArray({
            ...this._def,
            maxLength: {
                value: maxLength,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    length(len, message) {
        return new ZodArray({
            ...this._def,
            exactLength: {
                value: len,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodArray.create = (schema, params)=>{
    return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
    });
};
function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
        const newShape = {};
        for(const key in schema.shape){
            const fieldSchema = schema.shape[key];
            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
        }
        return new ZodObject({
            ...schema._def,
            shape: ()=>newShape
        });
    } else if (schema instanceof ZodArray) return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
    });
    else if (schema instanceof ZodOptional) return ZodOptional.create(deepPartialify(schema.unwrap()));
    else if (schema instanceof ZodNullable) return ZodNullable.create(deepPartialify(schema.unwrap()));
    else if (schema instanceof ZodTuple) return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));
    else return schema;
}
class ZodObject extends ZodType {
    constructor(){
        super(...arguments);
        this._cached = null;
        /**
         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
         * If you want to pass through unknown properties, use `.passthrough()` instead.
         */ this.nonstrict = this.passthrough;
        // extend<
        //   Augmentation extends ZodRawShape,
        //   NewOutput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
        //       ? Augmentation[k]["_output"]
        //       : k extends keyof Output
        //       ? Output[k]
        //       : never;
        //   }>,
        //   NewInput extends util.flatten<{
        //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
        //       ? Augmentation[k]["_input"]
        //       : k extends keyof Input
        //       ? Input[k]
        //       : never;
        //   }>
        // >(
        //   augmentation: Augmentation
        // ): ZodObject<
        //   extendShape<T, Augmentation>,
        //   UnknownKeys,
        //   Catchall,
        //   NewOutput,
        //   NewInput
        // > {
        //   return new ZodObject({
        //     ...this._def,
        //     shape: () => ({
        //       ...this._def.shape(),
        //       ...augmentation,
        //     }),
        //   }) as any;
        // }
        /**
         * @deprecated Use `.extend` instead
         *  */ this.augment = this.extend;
    }
    _getCached() {
        if (this._cached !== null) return this._cached;
        const shape = this._def.shape();
        const keys = (0, _utilJs.util).objectKeys(shape);
        this._cached = {
            shape,
            keys
        };
        return this._cached;
    }
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).object) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).object,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
            for(const key in ctx.data)if (!shapeKeys.includes(key)) extraKeys.push(key);
        }
        const pairs = [];
        for (const key of shapeKeys){
            const keyValidator = shape[key];
            const value = ctx.data[key];
            pairs.push({
                key: {
                    status: "valid",
                    value: key
                },
                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
                alwaysSet: key in ctx.data
            });
        }
        if (this._def.catchall instanceof ZodNever) {
            const unknownKeys = this._def.unknownKeys;
            if (unknownKeys === "passthrough") for (const key of extraKeys)pairs.push({
                key: {
                    status: "valid",
                    value: key
                },
                value: {
                    status: "valid",
                    value: ctx.data[key]
                }
            });
            else if (unknownKeys === "strict") {
                if (extraKeys.length > 0) {
                    (0, _parseUtilJs.addIssueToContext)(ctx, {
                        code: (0, _zodErrorJs.ZodIssueCode).unrecognized_keys,
                        keys: extraKeys
                    });
                    status.dirty();
                }
            } else if (unknownKeys === "strip") ;
            else throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        } else {
            // run catchall validation
            const catchall = this._def.catchall;
            for (const key of extraKeys){
                const value = ctx.data[key];
                pairs.push({
                    key: {
                        status: "valid",
                        value: key
                    },
                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)
                    ),
                    alwaysSet: key in ctx.data
                });
            }
        }
        if (ctx.common.async) return Promise.resolve().then(async ()=>{
            const syncPairs = [];
            for (const pair of pairs){
                const key = await pair.key;
                const value = await pair.value;
                syncPairs.push({
                    key,
                    value,
                    alwaysSet: pair.alwaysSet
                });
            }
            return syncPairs;
        }).then((syncPairs)=>{
            return (0, _parseUtilJs.ParseStatus).mergeObjectSync(status, syncPairs);
        });
        else return (0, _parseUtilJs.ParseStatus).mergeObjectSync(status, pairs);
    }
    get shape() {
        return this._def.shape();
    }
    strict(message) {
        (0, _errorUtilJs.errorUtil).errToObj;
        return new ZodObject({
            ...this._def,
            unknownKeys: "strict",
            ...message !== undefined ? {
                errorMap: (issue, ctx)=>{
                    const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
                    if (issue.code === "unrecognized_keys") return {
                        message: (0, _errorUtilJs.errorUtil).errToObj(message).message ?? defaultError
                    };
                    return {
                        message: defaultError
                    };
                }
            } : {}
        });
    }
    strip() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "strip"
        });
    }
    passthrough() {
        return new ZodObject({
            ...this._def,
            unknownKeys: "passthrough"
        });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
        return new ZodObject({
            ...this._def,
            shape: ()=>({
                    ...this._def.shape(),
                    ...augmentation
                })
        });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */ merge(merging) {
        const merged = new ZodObject({
            unknownKeys: merging._def.unknownKeys,
            catchall: merging._def.catchall,
            shape: ()=>({
                    ...this._def.shape(),
                    ...merging._def.shape()
                }),
            typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
        return this.augment({
            [key]: schema
        });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
        return new ZodObject({
            ...this._def,
            catchall: index
        });
    }
    pick(mask) {
        const shape = {};
        for (const key of (0, _utilJs.util).objectKeys(mask))if (mask[key] && this.shape[key]) shape[key] = this.shape[key];
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    omit(mask) {
        const shape = {};
        for (const key of (0, _utilJs.util).objectKeys(this.shape))if (!mask[key]) shape[key] = this.shape[key];
        return new ZodObject({
            ...this._def,
            shape: ()=>shape
        });
    }
    /**
     * @deprecated
     */ deepPartial() {
        return deepPartialify(this);
    }
    partial(mask) {
        const newShape = {};
        for (const key of (0, _utilJs.util).objectKeys(this.shape)){
            const fieldSchema = this.shape[key];
            if (mask && !mask[key]) newShape[key] = fieldSchema;
            else newShape[key] = fieldSchema.optional();
        }
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    required(mask) {
        const newShape = {};
        for (const key of (0, _utilJs.util).objectKeys(this.shape))if (mask && !mask[key]) newShape[key] = this.shape[key];
        else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while(newField instanceof ZodOptional)newField = newField._def.innerType;
            newShape[key] = newField;
        }
        return new ZodObject({
            ...this._def,
            shape: ()=>newShape
        });
    }
    keyof() {
        return createZodEnum((0, _utilJs.util).objectKeys(this.shape));
    }
}
ZodObject.create = (shape, params)=>{
    return new ZodObject({
        shape: ()=>shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
ZodObject.strictCreate = (shape, params)=>{
    return new ZodObject({
        shape: ()=>shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
ZodObject.lazycreate = (shape, params)=>{
    return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
    });
};
class ZodUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
            // return first issue-free validation if it exists
            for (const result of results){
                if (result.result.status === "valid") return result.result;
            }
            for (const result of results)if (result.result.status === "dirty") {
                // add issues from dirty option
                ctx.common.issues.push(...result.ctx.common.issues);
                return result.result;
            }
            // return invalid
            const unionErrors = results.map((result)=>new (0, _zodErrorJs.ZodError)(result.ctx.common.issues));
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_union,
                unionErrors
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (ctx.common.async) return Promise.all(options.map(async (option)=>{
            const childCtx = {
                ...ctx,
                common: {
                    ...ctx.common,
                    issues: []
                },
                parent: null
            };
            return {
                result: await option._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx
                }),
                ctx: childCtx
            };
        })).then(handleResults);
        else {
            let dirty = undefined;
            const issues = [];
            for (const option of options){
                const childCtx = {
                    ...ctx,
                    common: {
                        ...ctx.common,
                        issues: []
                    },
                    parent: null
                };
                const result = option._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: childCtx
                });
                if (result.status === "valid") return result;
                else if (result.status === "dirty" && !dirty) dirty = {
                    result,
                    ctx: childCtx
                };
                if (childCtx.common.issues.length) issues.push(childCtx.common.issues);
            }
            if (dirty) {
                ctx.common.issues.push(...dirty.ctx.common.issues);
                return dirty.result;
            }
            const unionErrors = issues.map((issues)=>new (0, _zodErrorJs.ZodError)(issues));
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_union,
                unionErrors
            });
            return 0, _parseUtilJs.INVALID;
        }
    }
    get options() {
        return this._def.options;
    }
}
ZodUnion.create = (types, params)=>{
    return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
    });
};
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
//////////                                 //////////
//////////      ZodDiscriminatedUnion      //////////
//////////                                 //////////
/////////////////////////////////////////////////////
/////////////////////////////////////////////////////
const getDiscriminator = (type)=>{
    if (type instanceof ZodLazy) return getDiscriminator(type.schema);
    else if (type instanceof ZodEffects) return getDiscriminator(type.innerType());
    else if (type instanceof ZodLiteral) return [
        type.value
    ];
    else if (type instanceof ZodEnum) return type.options;
    else if (type instanceof ZodNativeEnum) // eslint-disable-next-line ban/ban
    return (0, _utilJs.util).objectValues(type.enum);
    else if (type instanceof ZodDefault) return getDiscriminator(type._def.innerType);
    else if (type instanceof ZodUndefined) return [
        undefined
    ];
    else if (type instanceof ZodNull) return [
        null
    ];
    else if (type instanceof ZodOptional) return [
        undefined,
        ...getDiscriminator(type.unwrap())
    ];
    else if (type instanceof ZodNullable) return [
        null,
        ...getDiscriminator(type.unwrap())
    ];
    else if (type instanceof ZodBranded) return getDiscriminator(type.unwrap());
    else if (type instanceof ZodReadonly) return getDiscriminator(type.unwrap());
    else if (type instanceof ZodCatch) return getDiscriminator(type._def.innerType);
    else return [];
};
class ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).object) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).object,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_union_discriminator,
                options: Array.from(this.optionsMap.keys()),
                path: [
                    discriminator
                ]
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (ctx.common.async) return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
        else return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
    }
    get discriminator() {
        return this._def.discriminator;
    }
    get options() {
        return this._def.options;
    }
    get optionsMap() {
        return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */ static create(discriminator, options, params) {
        // Get all the valid discriminator values
        const optionsMap = new Map();
        // try {
        for (const type of options){
            const discriminatorValues = getDiscriminator(type.shape[discriminator]);
            if (!discriminatorValues.length) throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
            for (const value of discriminatorValues){
                if (optionsMap.has(value)) throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
                optionsMap.set(value, type);
            }
        }
        return new ZodDiscriminatedUnion({
            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
            discriminator,
            options,
            optionsMap,
            ...processCreateParams(params)
        });
    }
}
function mergeValues(a, b) {
    const aType = (0, _utilJs.getParsedType)(a);
    const bType = (0, _utilJs.getParsedType)(b);
    if (a === b) return {
        valid: true,
        data: a
    };
    else if (aType === (0, _utilJs.ZodParsedType).object && bType === (0, _utilJs.ZodParsedType).object) {
        const bKeys = (0, _utilJs.util).objectKeys(b);
        const sharedKeys = (0, _utilJs.util).objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);
        const newObj = {
            ...a,
            ...b
        };
        for (const key of sharedKeys){
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) return {
                valid: false
            };
            newObj[key] = sharedValue.data;
        }
        return {
            valid: true,
            data: newObj
        };
    } else if (aType === (0, _utilJs.ZodParsedType).array && bType === (0, _utilJs.ZodParsedType).array) {
        if (a.length !== b.length) return {
            valid: false
        };
        const newArray = [];
        for(let index = 0; index < a.length; index++){
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) return {
                valid: false
            };
            newArray.push(sharedValue.data);
        }
        return {
            valid: true,
            data: newArray
        };
    } else if (aType === (0, _utilJs.ZodParsedType).date && bType === (0, _utilJs.ZodParsedType).date && +a === +b) return {
        valid: true,
        data: a
    };
    else return {
        valid: false
    };
}
class ZodIntersection extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight)=>{
            if ((0, _parseUtilJs.isAborted)(parsedLeft) || (0, _parseUtilJs.isAborted)(parsedRight)) return 0, _parseUtilJs.INVALID;
            const merged = mergeValues(parsedLeft.value, parsedRight.value);
            if (!merged.valid) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_intersection_types
                });
                return 0, _parseUtilJs.INVALID;
            }
            if ((0, _parseUtilJs.isDirty)(parsedLeft) || (0, _parseUtilJs.isDirty)(parsedRight)) status.dirty();
            return {
                status: status.value,
                value: merged.data
            };
        };
        if (ctx.common.async) return Promise.all([
            this._def.left._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }),
            this._def.right._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            })
        ]).then(([left, right])=>handleParsed(left, right));
        else return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        }));
    }
}
ZodIntersection.create = (left, right, params)=>{
    return new ZodIntersection({
        left: left,
        right: right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
    });
};
class ZodTuple extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).array) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).array,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).too_small,
                minimum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            return 0, _parseUtilJs.INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).too_big,
                maximum: this._def.items.length,
                inclusive: true,
                exact: false,
                type: "array"
            });
            status.dirty();
        }
        const items = [
            ...ctx.data
        ].map((item, itemIndex)=>{
            const schema = this._def.items[itemIndex] || this._def.rest;
            if (!schema) return null;
            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x)=>!!x); // filter nulls
        if (ctx.common.async) return Promise.all(items).then((results)=>{
            return (0, _parseUtilJs.ParseStatus).mergeArray(status, results);
        });
        else return (0, _parseUtilJs.ParseStatus).mergeArray(status, items);
    }
    get items() {
        return this._def.items;
    }
    rest(rest) {
        return new ZodTuple({
            ...this._def,
            rest
        });
    }
}
ZodTuple.create = (schemas, params)=>{
    if (!Array.isArray(schemas)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
    });
};
class ZodRecord extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).object) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).object,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for(const key in ctx.data)pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
        });
        if (ctx.common.async) return (0, _parseUtilJs.ParseStatus).mergeObjectAsync(status, pairs);
        else return (0, _parseUtilJs.ParseStatus).mergeObjectSync(status, pairs);
    }
    get element() {
        return this._def.valueType;
    }
    static create(first, second, third) {
        if (second instanceof ZodType) return new ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
        });
        return new ZodRecord({
            keyType: ZodString.create(),
            valueType: first,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(second)
        });
    }
}
class ZodMap extends ZodType {
    get keySchema() {
        return this._def.keyType;
    }
    get valueSchema() {
        return this._def.valueType;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).map) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).map,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [
            ...ctx.data.entries()
        ].map(([key, value], index)=>{
            return {
                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [
                    index,
                    "key"
                ])),
                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [
                    index,
                    "value"
                ]))
            };
        });
        if (ctx.common.async) {
            const finalMap = new Map();
            return Promise.resolve().then(async ()=>{
                for (const pair of pairs){
                    const key = await pair.key;
                    const value = await pair.value;
                    if (key.status === "aborted" || value.status === "aborted") return 0, _parseUtilJs.INVALID;
                    if (key.status === "dirty" || value.status === "dirty") status.dirty();
                    finalMap.set(key.value, value.value);
                }
                return {
                    status: status.value,
                    value: finalMap
                };
            });
        } else {
            const finalMap = new Map();
            for (const pair of pairs){
                const key = pair.key;
                const value = pair.value;
                if (key.status === "aborted" || value.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (key.status === "dirty" || value.status === "dirty") status.dirty();
                finalMap.set(key.value, value.value);
            }
            return {
                status: status.value,
                value: finalMap
            };
        }
    }
}
ZodMap.create = (keyType, valueType, params)=>{
    return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
    });
};
class ZodSet extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).set) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).set,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
            if (ctx.data.size < def.minSize.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_small,
                    minimum: def.minSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.minSize.message
                });
                status.dirty();
            }
        }
        if (def.maxSize !== null) {
            if (ctx.data.size > def.maxSize.value) {
                (0, _parseUtilJs.addIssueToContext)(ctx, {
                    code: (0, _zodErrorJs.ZodIssueCode).too_big,
                    maximum: def.maxSize.value,
                    type: "set",
                    inclusive: true,
                    exact: false,
                    message: def.maxSize.message
                });
                status.dirty();
            }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements) {
            const parsedSet = new Set();
            for (const element of elements){
                if (element.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (element.status === "dirty") status.dirty();
                parsedSet.add(element.value);
            }
            return {
                status: status.value,
                value: parsedSet
            };
        }
        const elements = [
            ...ctx.data.values()
        ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) return Promise.all(elements).then((elements)=>finalizeSet(elements));
        else return finalizeSet(elements);
    }
    min(minSize, message) {
        return new ZodSet({
            ...this._def,
            minSize: {
                value: minSize,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    max(maxSize, message) {
        return new ZodSet({
            ...this._def,
            maxSize: {
                value: maxSize,
                message: (0, _errorUtilJs.errorUtil).toString(message)
            }
        });
    }
    size(size, message) {
        return this.min(size, message).max(size, message);
    }
    nonempty(message) {
        return this.min(1, message);
    }
}
ZodSet.create = (valueType, params)=>{
    return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
    });
};
class ZodFunction extends ZodType {
    constructor(){
        super(...arguments);
        this.validate = this.implement;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).function) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).function,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        function makeArgsIssue(args, error) {
            return (0, _parseUtilJs.makeIssue)({
                data: args,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, _errorsJs.getErrorMap)(),
                    (0, _errorsJs.defaultErrorMap)
                ].filter((x)=>!!x),
                issueData: {
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_arguments,
                    argumentsError: error
                }
            });
        }
        function makeReturnsIssue(returns, error) {
            return (0, _parseUtilJs.makeIssue)({
                data: returns,
                path: ctx.path,
                errorMaps: [
                    ctx.common.contextualErrorMap,
                    ctx.schemaErrorMap,
                    (0, _errorsJs.getErrorMap)(),
                    (0, _errorsJs.defaultErrorMap)
                ].filter((x)=>!!x),
                issueData: {
                    code: (0, _zodErrorJs.ZodIssueCode).invalid_return_type,
                    returnTypeError: error
                }
            });
        }
        const params = {
            errorMap: ctx.common.contextualErrorMap
        };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, _parseUtilJs.OK)(async function(...args) {
                const error = new (0, _zodErrorJs.ZodError)([]);
                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{
                    error.addIssue(makeArgsIssue(args, e));
                    throw error;
                });
                const result = await Reflect.apply(fn, this, parsedArgs);
                const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{
                    error.addIssue(makeReturnsIssue(result, e));
                    throw error;
                });
                return parsedReturns;
            });
        } else {
            // Would love a way to avoid disabling this rule, but we need
            // an alias (using an arrow function was what caused 2651).
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const me = this;
            return (0, _parseUtilJs.OK)(function(...args) {
                const parsedArgs = me._def.args.safeParse(args, params);
                if (!parsedArgs.success) throw new (0, _zodErrorJs.ZodError)([
                    makeArgsIssue(args, parsedArgs.error)
                ]);
                const result = Reflect.apply(fn, this, parsedArgs.data);
                const parsedReturns = me._def.returns.safeParse(result, params);
                if (!parsedReturns.success) throw new (0, _zodErrorJs.ZodError)([
                    makeReturnsIssue(result, parsedReturns.error)
                ]);
                return parsedReturns.data;
            });
        }
    }
    parameters() {
        return this._def.args;
    }
    returnType() {
        return this._def.returns;
    }
    args(...items) {
        return new ZodFunction({
            ...this._def,
            args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
    }
    returns(returnType) {
        return new ZodFunction({
            ...this._def,
            returns: returnType
        });
    }
    implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
    }
    static create(args, returns, params) {
        return new ZodFunction({
            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
            returns: returns || ZodUnknown.create(),
            typeName: ZodFirstPartyTypeKind.ZodFunction,
            ...processCreateParams(params)
        });
    }
}
class ZodLazy extends ZodType {
    get schema() {
        return this._def.getter();
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
        });
    }
}
ZodLazy.create = (getter, params)=>{
    return new ZodLazy({
        getter: getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
    });
};
class ZodLiteral extends ZodType {
    _parse(input) {
        if (input.data !== this._def.value) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                received: ctx.data,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_literal,
                expected: this._def.value
            });
            return 0, _parseUtilJs.INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
    get value() {
        return this._def.value;
    }
}
ZodLiteral.create = (value, params)=>{
    return new ZodLiteral({
        value: value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
    });
};
function createZodEnum(values, params) {
    return new ZodEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodEnum,
        ...processCreateParams(params)
    });
}
class ZodEnum extends ZodType {
    _parse(input) {
        if (typeof input.data !== "string") {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                expected: (0, _utilJs.util).joinValues(expectedValues),
                received: ctx.parsedType,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (!this._cache) this._cache = new Set(this._def.values);
        if (!this._cache.has(input.data)) {
            const ctx = this._getOrReturnCtx(input);
            const expectedValues = this._def.values;
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                received: ctx.data,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_enum_value,
                options: expectedValues
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
    get options() {
        return this._def.values;
    }
    get enum() {
        const enumValues = {};
        for (const val of this._def.values)enumValues[val] = val;
        return enumValues;
    }
    get Values() {
        const enumValues = {};
        for (const val of this._def.values)enumValues[val] = val;
        return enumValues;
    }
    get Enum() {
        const enumValues = {};
        for (const val of this._def.values)enumValues[val] = val;
        return enumValues;
    }
    extract(values, newDef = this._def) {
        return ZodEnum.create(values, {
            ...this._def,
            ...newDef
        });
    }
    exclude(values, newDef = this._def) {
        return ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {
            ...this._def,
            ...newDef
        });
    }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
    _parse(input) {
        const nativeEnumValues = (0, _utilJs.util).getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).string && ctx.parsedType !== (0, _utilJs.ZodParsedType).number) {
            const expectedValues = (0, _utilJs.util).objectValues(nativeEnumValues);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                expected: (0, _utilJs.util).joinValues(expectedValues),
                received: ctx.parsedType,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type
            });
            return 0, _parseUtilJs.INVALID;
        }
        if (!this._cache) this._cache = new Set((0, _utilJs.util).getValidEnumValues(this._def.values));
        if (!this._cache.has(input.data)) {
            const expectedValues = (0, _utilJs.util).objectValues(nativeEnumValues);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                received: ctx.data,
                code: (0, _zodErrorJs.ZodIssueCode).invalid_enum_value,
                options: expectedValues
            });
            return 0, _parseUtilJs.INVALID;
        }
        return (0, _parseUtilJs.OK)(input.data);
    }
    get enum() {
        return this._def.values;
    }
}
ZodNativeEnum.create = (values, params)=>{
    return new ZodNativeEnum({
        values: values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
    });
};
class ZodPromise extends ZodType {
    unwrap() {
        return this._def.type;
    }
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== (0, _utilJs.ZodParsedType).promise && ctx.common.async === false) {
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).promise,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        const promisified = ctx.parsedType === (0, _utilJs.ZodParsedType).promise ? ctx.data : Promise.resolve(ctx.data);
        return (0, _parseUtilJs.OK)(promisified.then((data)=>{
            return this._def.type.parseAsync(data, {
                path: ctx.path,
                errorMap: ctx.common.contextualErrorMap
            });
        }));
    }
}
ZodPromise.create = (schema, params)=>{
    return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
    });
};
class ZodEffects extends ZodType {
    innerType() {
        return this._def.schema;
    }
    sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
            addIssue: (arg)=>{
                (0, _parseUtilJs.addIssueToContext)(ctx, arg);
                if (arg.fatal) status.abort();
                else status.dirty();
            },
            get path () {
                return ctx.path;
            }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
            const processed = effect.transform(ctx.data, checkCtx);
            if (ctx.common.async) return Promise.resolve(processed).then(async (processed)=>{
                if (status.value === "aborted") return 0, _parseUtilJs.INVALID;
                const result = await this._def.schema._parseAsync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx
                });
                if (result.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (result.status === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                if (status.value === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                return result;
            });
            else {
                if (status.value === "aborted") return 0, _parseUtilJs.INVALID;
                const result = this._def.schema._parseSync({
                    data: processed,
                    path: ctx.path,
                    parent: ctx
                });
                if (result.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (result.status === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                if (status.value === "dirty") return (0, _parseUtilJs.DIRTY)(result.value);
                return result;
            }
        }
        if (effect.type === "refinement") {
            const executeRefinement = (acc)=>{
                const result = effect.refinement(acc, checkCtx);
                if (ctx.common.async) return Promise.resolve(result);
                if (result instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return acc;
            };
            if (ctx.common.async === false) {
                const inner = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inner.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (inner.status === "dirty") status.dirty();
                // return value is ignored
                executeRefinement(inner.value);
                return {
                    status: status.value,
                    value: inner.value
                };
            } else return this._def.schema._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }).then((inner)=>{
                if (inner.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (inner.status === "dirty") status.dirty();
                return executeRefinement(inner.value).then(()=>{
                    return {
                        status: status.value,
                        value: inner.value
                    };
                });
            });
        }
        if (effect.type === "transform") {
            if (ctx.common.async === false) {
                const base = this._def.schema._parseSync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (!(0, _parseUtilJs.isValid)(base)) return 0, _parseUtilJs.INVALID;
                const result = effect.transform(base.value, checkCtx);
                if (result instanceof Promise) throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
                return {
                    status: status.value,
                    value: result
                };
            } else return this._def.schema._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            }).then((base)=>{
                if (!(0, _parseUtilJs.isValid)(base)) return 0, _parseUtilJs.INVALID;
                return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({
                        status: status.value,
                        value: result
                    }));
            });
        }
        (0, _utilJs.util).assertNever(effect);
    }
}
ZodEffects.create = (schema, effect, params)=>{
    return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
    });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params)=>{
    return new ZodEffects({
        schema,
        effect: {
            type: "preprocess",
            transform: preprocess
        },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
    });
};
class ZodOptional extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === (0, _utilJs.ZodParsedType).undefined) return (0, _parseUtilJs.OK)(undefined);
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodOptional.create = (type, params)=>{
    return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
    });
};
class ZodNullable extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === (0, _utilJs.ZodParsedType).null) return (0, _parseUtilJs.OK)(null);
        return this._def.innerType._parse(input);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodNullable.create = (type, params)=>{
    return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
    });
};
class ZodDefault extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === (0, _utilJs.ZodParsedType).undefined) data = this._def.defaultValue();
        return this._def.innerType._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    removeDefault() {
        return this._def.innerType;
    }
}
ZodDefault.create = (type, params)=>{
    return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : ()=>params.default,
        ...processCreateParams(params)
    });
};
class ZodCatch extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        // newCtx is used to not collect issues from inner types in ctx
        const newCtx = {
            ...ctx,
            common: {
                ...ctx.common,
                issues: []
            }
        };
        const result = this._def.innerType._parse({
            data: newCtx.data,
            path: newCtx.path,
            parent: {
                ...newCtx
            }
        });
        if ((0, _parseUtilJs.isAsync)(result)) return result.then((result)=>{
            return {
                status: "valid",
                value: result.status === "valid" ? result.value : this._def.catchValue({
                    get error () {
                        return new (0, _zodErrorJs.ZodError)(newCtx.common.issues);
                    },
                    input: newCtx.data
                })
            };
        });
        else return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
                get error () {
                    return new (0, _zodErrorJs.ZodError)(newCtx.common.issues);
                },
                input: newCtx.data
            })
        };
    }
    removeCatch() {
        return this._def.innerType;
    }
}
ZodCatch.create = (type, params)=>{
    return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : ()=>params.catch,
        ...processCreateParams(params)
    });
};
class ZodNaN extends ZodType {
    _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== (0, _utilJs.ZodParsedType).nan) {
            const ctx = this._getOrReturnCtx(input);
            (0, _parseUtilJs.addIssueToContext)(ctx, {
                code: (0, _zodErrorJs.ZodIssueCode).invalid_type,
                expected: (0, _utilJs.ZodParsedType).nan,
                received: ctx.parsedType
            });
            return 0, _parseUtilJs.INVALID;
        }
        return {
            status: "valid",
            value: input.data
        };
    }
}
ZodNaN.create = (params)=>{
    return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
    });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
    _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
            data,
            path: ctx.path,
            parent: ctx
        });
    }
    unwrap() {
        return this._def.type;
    }
}
class ZodPipeline extends ZodType {
    _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
            const handleAsync = async ()=>{
                const inResult = await this._def.in._parseAsync({
                    data: ctx.data,
                    path: ctx.path,
                    parent: ctx
                });
                if (inResult.status === "aborted") return 0, _parseUtilJs.INVALID;
                if (inResult.status === "dirty") {
                    status.dirty();
                    return (0, _parseUtilJs.DIRTY)(inResult.value);
                } else return this._def.out._parseAsync({
                    data: inResult.value,
                    path: ctx.path,
                    parent: ctx
                });
            };
            return handleAsync();
        } else {
            const inResult = this._def.in._parseSync({
                data: ctx.data,
                path: ctx.path,
                parent: ctx
            });
            if (inResult.status === "aborted") return 0, _parseUtilJs.INVALID;
            if (inResult.status === "dirty") {
                status.dirty();
                return {
                    status: "dirty",
                    value: inResult.value
                };
            } else return this._def.out._parseSync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
            });
        }
    }
    static create(a, b) {
        return new ZodPipeline({
            in: a,
            out: b,
            typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
    }
}
class ZodReadonly extends ZodType {
    _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data)=>{
            if ((0, _parseUtilJs.isValid)(data)) data.value = Object.freeze(data.value);
            return data;
        };
        return (0, _parseUtilJs.isAsync)(result) ? result.then((data)=>freeze(data)) : freeze(result);
    }
    unwrap() {
        return this._def.innerType;
    }
}
ZodReadonly.create = (type, params)=>{
    return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
    });
};
////////////////////////////////////////
////////////////////////////////////////
//////////                    //////////
//////////      z.custom      //////////
//////////                    //////////
////////////////////////////////////////
////////////////////////////////////////
function cleanParams(params, data) {
    const p = typeof params === "function" ? params(data) : typeof params === "string" ? {
        message: params
    } : params;
    const p2 = typeof p === "string" ? {
        message: p
    } : p;
    return p2;
}
function custom(check, _params = {}, /**
 * @deprecated
 *
 * Pass `fatal` into the params object instead:
 *
 * ```ts
 * z.string().custom((val) => val.length > 5, { fatal: false })
 * ```
 *
 */ fatal) {
    if (check) return ZodAny.create().superRefine((data, ctx)=>{
        const r = check(data);
        if (r instanceof Promise) return r.then((r)=>{
            if (!r) {
                const params = cleanParams(_params, data);
                const _fatal = params.fatal ?? fatal ?? true;
                ctx.addIssue({
                    code: "custom",
                    ...params,
                    fatal: _fatal
                });
            }
        });
        if (!r) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({
                code: "custom",
                ...params,
                fatal: _fatal
            });
        }
        return;
    });
    return ZodAny.create();
}
const late = {
    object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// requires TS 4.4+
class Class {
    constructor(..._){}
}
const instanceOfType = (// const instanceOfType = <T extends new (...args: any[]) => any>(
cls, params = {
    message: `Input not instance of ${cls.name}`
})=>custom((data)=>data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = ()=>stringType().optional();
const onumber = ()=>numberType().optional();
const oboolean = ()=>booleanType().optional();
const coerce = {
    string: (arg)=>ZodString.create({
            ...arg,
            coerce: true
        }),
    number: (arg)=>ZodNumber.create({
            ...arg,
            coerce: true
        }),
    boolean: (arg)=>ZodBoolean.create({
            ...arg,
            coerce: true
        }),
    bigint: (arg)=>ZodBigInt.create({
            ...arg,
            coerce: true
        }),
    date: (arg)=>ZodDate.create({
            ...arg,
            coerce: true
        })
};
const NEVER = (0, _parseUtilJs.INVALID);

},{"./ZodError.js":"gq3rZ","./errors.js":"a6pdd","./helpers/errorUtil.js":"a23WZ","./helpers/parseUtil.js":"aROeC","./helpers/util.js":"6iaXv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a23WZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "errorUtil", ()=>errorUtil);
var errorUtil;
(function(errorUtil) {
    errorUtil.errToObj = (message)=>typeof message === "string" ? {
            message
        } : message || {};
    // biome-ignore lint:
    errorUtil.toString = (message)=>typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bMsze":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AccountIdFromPath", ()=>t);
parcelHelpers.export(exports, "AppIdFromPath", ()=>p);
parcelHelpers.export(exports, "Pagination", ()=>m);
var _zod = require("zod");
var _apiBase = require("@privy-io/api-base");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
const t = (0, _zod.z).object({
    account_id: (0, _zod.z).string({
        required_error: "Account ID must be provided",
        invalid_type_error: "Account ID is not a valid string"
    }).min(1)
}), p = (0, _zod.z).object({
    app_id: (0, _zod.z).string({
        required_error: "App ID must be provided",
        invalid_type_error: "App ID is not a valid string"
    }).min(1)
}).transform(({ app_id: r })=>({
        app_id: r,
        appId: r
    })).catch(({ error: r })=>{
    throw new (0, _apiBase.InvalidInputError)(r.message, (0, _apiBase.PrivyErrorCode).MISSING_OR_INVALID_PRIVY_APP_ID);
}), m = (0, _zod.z).object({
    cursor: (0, _coreMjs.UserId).optional(),
    limit: (0, _zod.z).coerce.number().max(100, {
        message: "Query limit can be at maximum 100 records."
    }).optional()
});

},{"zod":"fOFdH","@privy-io/api-base":"lvLPC","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lvLPC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AccountTransferRequiredError", ()=>(0, _apiErrorMjs.AccountTransferRequiredError));
parcelHelpers.export(exports, "AllowlistRejectedError", ()=>(0, _apiErrorMjs.AllowlistRejectedError));
parcelHelpers.export(exports, "ForbiddenError", ()=>(0, _apiErrorMjs.ForbiddenError));
parcelHelpers.export(exports, "HttpError", ()=>(0, _apiErrorMjs.HttpError));
parcelHelpers.export(exports, "InternalServerError", ()=>(0, _apiErrorMjs.InternalServerError));
parcelHelpers.export(exports, "InvalidInputError", ()=>(0, _apiErrorMjs.InvalidInputError));
parcelHelpers.export(exports, "LegacyInvalidInputError", ()=>(0, _apiErrorMjs.LegacyInvalidInputError));
parcelHelpers.export(exports, "NotFoundError", ()=>(0, _apiErrorMjs.NotFoundError));
parcelHelpers.export(exports, "RequestTimeoutError", ()=>(0, _apiErrorMjs.RequestTimeoutError));
parcelHelpers.export(exports, "TooManyRequestsError", ()=>(0, _apiErrorMjs.TooManyRequestsError));
parcelHelpers.export(exports, "UnauthorizedError", ()=>(0, _apiErrorMjs.UnauthorizedError));
parcelHelpers.export(exports, "UnsupportedMediaType", ()=>(0, _apiErrorMjs.UnsupportedMediaType));
parcelHelpers.export(exports, "PrivyErrorCode", ()=>(0, _errorCodesMjs.PrivyErrorCode));
parcelHelpers.export(exports, "APIError", ()=>(0, _errorMjs.APIError));
var _apiErrorMjs = require("./classes/api-error.mjs");
var _errorCodesMjs = require("./constants/error-codes.mjs");
var _errorMjs = require("./schemas/error.mjs");
var _zod = require("zod");

},{"./classes/api-error.mjs":"5lnRR","./constants/error-codes.mjs":"aDOBh","./schemas/error.mjs":"9SBID","zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5lnRR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AccountTransferRequiredError", ()=>p);
parcelHelpers.export(exports, "AllowlistRejectedError", ()=>c);
parcelHelpers.export(exports, "ForbiddenError", ()=>o);
parcelHelpers.export(exports, "HttpError", ()=>t);
parcelHelpers.export(exports, "InternalServerError", ()=>d);
parcelHelpers.export(exports, "InvalidInputError", ()=>e);
parcelHelpers.export(exports, "LegacyInvalidInputError", ()=>i);
parcelHelpers.export(exports, "NotFoundError", ()=>n);
parcelHelpers.export(exports, "RequestTimeoutError", ()=>a);
parcelHelpers.export(exports, "TooManyRequestsError", ()=>l);
parcelHelpers.export(exports, "UnauthorizedError", ()=>r);
parcelHelpers.export(exports, "UnsupportedMediaType", ()=>u);
var _errorCodesMjs = require("../constants/error-codes.mjs");
class t extends Error {
    toString() {
        return `${this.constructor.name}: ${this.message}${this.cause ? ` [cause: ${this.cause}]` : ""}`;
    }
    constructor(s, t, e, r){
        super(t), this.code = e, this.status = s, this.responseData = r;
    }
}
class e extends t {
    constructor(t, e){
        super(400, t, e || (0, _errorCodesMjs.PrivyErrorCode).INVALID_DATA);
    }
}
class r extends t {
    constructor(s, t){
        super(401, s, t);
    }
}
class c extends r {
    constructor(t){
        super(t || "User is not allowed to login to this app.", (0, _errorCodesMjs.PrivyErrorCode).ALLOWLIST_REJECTED);
    }
}
class o extends t {
    constructor(s, t){
        super(403, s, t);
    }
}
class n extends t {
    constructor(s){
        super(404, s);
    }
}
class a extends t {
    constructor(s, t){
        super(408, s, t);
    }
}
class u extends t {
    constructor(s){
        super(415, s);
    }
}
class i extends t {
    constructor(s, t){
        super(422, s, t);
    }
}
class l extends t {
    constructor(t){
        super(429, t || "Too many requests. Please wait to try again.", (0, _errorCodesMjs.PrivyErrorCode).TOO_MANY_REQUESTS);
    }
}
class d extends t {
    constructor(s){
        super(500, s || "Service unavailable.");
    }
}
class p extends t {
    constructor(t){
        super(400, "Account transfer required", (0, _errorCodesMjs.PrivyErrorCode).ACCOUNT_TRANSFER_REQUIRED, t), this.data = t;
    }
}

},{"../constants/error-codes.mjs":"aDOBh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aDOBh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PrivyErrorCode", ()=>e);
var _, e = ((_ = {}).OAUTH_ACCOUNT_SUSPENDED = "oauth_account_suspended", _.MISSING_OR_INVALID_PRIVY_APP_ID = "missing_or_invalid_privy_app_id", _.MISSING_OR_INVALID_PRIVY_CLIENT_ID = "missing_or_invalid_privy_client_id", _.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID = "missing_or_invalid_privy_account_id", _.MISSING_OR_INVALID_TOKEN = "missing_or_invalid_token", _.MISSING_OR_INVALID_MFA = "missing_or_invalid_mfa", _.EXPIRED_OR_INVALID_MFA_TOKEN = "expired_or_invalid_mfa_token", _.INVALID_DATA = "invalid_data", _.INVALID_CREDENTIALS = "invalid_credentials", _.INVALID_CAPTCHA = "invalid_captcha", _.LINKED_TO_ANOTHER_USER = "linked_to_another_user", _.ALLOWLIST_REJECTED = "allowlist_rejected", _.CANNOT_UNLINK_EMBEDDED_WALLET = "cannot_unlink_embedded_wallet", _.CANNOT_UNLINK_SOLE_ACCOUNT = "cannot_unlink_sole_account", _.CANNOT_LINK_MORE_OF_TYPE = "cannot_link_more_of_type", _.LINKED_ACCOUNT_NOT_FOUND = "linked_account_not_found", _.TOO_MANY_REQUESTS = "too_many_requests", _.INVALID_ORIGIN = "invalid_origin", _.MISSING_ORIGIN = "missing_origin", _.INVALID_NATIVE_APP_ID = "invalid_native_app_id", _.TOKEN_ALREADY_USED = "token_already_used", _.ALREADY_LOGGED_OUT = "already_logged_out", _.NOT_SUPPORTED = "not_supported", _.USER_UNSUBSCRIBED = "user_unsubscribed", _.MAX_APPS_REACHED = "max_apps_reached", _.USER_LIMIT_REACHED = "max_accounts_reached", _.DEVICE_REVOKED = "device_revoked", _.WALLET_PASSWORD_EXISTS = "wallet_password_exists", _.OAUTH_STATE_MISMATCH = "oauth_state_mismatch", _.MAX_DENYLIST_ENTRIES_REACHED = "max_denylist_entries_reached", _.MAX_TEST_ACCOUNTS_REACHED = "max_test_accounts_reached", _.DISALLOWED_LOGIN_METHOD = "disallowed_login_method", _.DISALLOWED_PLUS_EMAIL = "disallowed_plus_email", _.DISALLOWED_RECOVERY_METHOD = "disallowed_recovery_method", _.LEGACY_DASHBOARD_LOGIN_CONFIGURATION = "legacy_dashboard_login_configuration", _.CANNOT_SET_PASSWORD = "cannot_set_password", _.INVALID_PKCE_PARAMETERS = "invalid_pkce_parameters", _.INVALID_APP_URL_SCHEME_CONFIGURATION = "invalid_app_url_scheme_configuration", _.CROSS_APP_CONNECTION_NOT_ALLOWED = "cross_app_connection_not_allowed", _.USER_DOES_NOT_EXIST = "user_does_not_exist", _.ALREADY_EXISTS = "resource_already_exists", _.ACCOUNT_TRANSFER_REQUIRED = "account_transfer_required", _.USER_HAS_NOT_DELEGATED_WALLET = "user_has_not_delegated_wallet", _.FEATURE_NOT_ENABLED = "feature_not_enabled", _.INSUFFICIENT_FUNDS = "insufficient_funds", _.TRANSACTION_BROADCAST_FAILURE = "transaction_broadcast_failure", _.INVALID_POLICY_FORMAT = "invalid_policy_format", _.POLICY_VIOLATION = "policy_violation", _.AUTHORIZATION_KEY_HAS_ASSOCIATED_WALLETS = "authorization_key_has_associated_wallets", _.INVALID_REQUEST = "invalid_request", _);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9SBID":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "APIError", ()=>t);
var _zod = require("zod");
var _errorCodesMjs = require("../constants/error-codes.mjs");
const t = (0, _zod.z).object({
    error: (0, _zod.z).string(),
    cause: (0, _zod.z).string().optional(),
    code: (0, _zod.z).nativeEnum((0, _errorCodesMjs.PrivyErrorCode)).optional()
});

},{"zod":"fOFdH","../constants/error-codes.mjs":"aDOBh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9c2nU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthenticateMode", ()=>c);
parcelHelpers.export(exports, "Email", ()=>d);
parcelHelpers.export(exports, "PasswordlessCode", ()=>n);
parcelHelpers.export(exports, "PhoneNumber", ()=>m);
parcelHelpers.export(exports, "SolanaWalletAddress", ()=>a);
parcelHelpers.export(exports, "UserId", ()=>t);
parcelHelpers.export(exports, "WalletAddress", ()=>s);
parcelHelpers.export(exports, "isValidAddress", ()=>l);
parcelHelpers.export(exports, "normalizeEthereumAddress", ()=>v);
parcelHelpers.export(exports, "normalizePhoneNumber", ()=>u);
var _bs58 = require("bs58");
var _bs58Default = parcelHelpers.interopDefault(_bs58);
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
var _zod = require("zod");
const t = (0, _zod.z).string({
    required_error: "Privy DID must be included",
    invalid_type_error: "Privy DID is not a valid string"
}).min(1).transform((r)=>r.replace("did:privy:", "")), d = (0, _zod.z).string({
    required_error: "Email address must be provided",
    invalid_type_error: "Email address must be a valid string"
}).email("Invalid email address").transform((r)=>r.toLowerCase()), n = (0, _zod.z).string({
    required_error: "Verification code must be provided",
    invalid_type_error: "Invalid verification code"
}).length(6, "Verification code must have 6 digits."), s = (0, _zod.z).string({
    required_error: "Ethereum address must be provided",
    invalid_type_error: "Invalid Ethereum address"
}).transform((r, e)=>v(r) || (e.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "Invalid Ethereum address"
    }), (0, _zod.z).NEVER)), a = (0, _zod.z).string({
    required_error: "Solana address must be provided",
    invalid_type_error: "Invalid Solana address"
}).trim().transform((e, i)=>{
    try {
        (0, _bs58Default.default).decode(e);
    } catch (r) {
        return i.addIssue({
            code: (0, _zod.z).ZodIssueCode.custom,
            message: "Invalid Solana address"
        }), (0, _zod.z).NEVER;
    }
    return e;
}), m = (0, _zod.z).string({
    required_error: "Phone number must be included",
    invalid_type_error: "Phone number is not a valid string"
}).refine((r)=>{
    try {
        return void 0 !== u(r);
    } catch (r) {
        return !1;
    }
}, {
    message: "Phone number is not valid"
}).transform((r)=>u(r) || "");
function u(r) {
    let i = (0, _max.parsePhoneNumber)(r, "US");
    if (i?.isPossible()) return i.formatInternational();
}
function l(r) {
    return !!v(r);
}
function v(r) {
    if ("string" == typeof r) try {
        return (0, _viem.getAddress)(r.trim());
    } catch (r) {}
}
const c = (0, _zod.z).object({
    mode: (0, _zod.z).enum([
        "no-signup",
        "login-or-sign-up"
    ]).optional()
});

},{"bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7AN9k":[function(require,module,exports,__globalThis) {
const basex = require("819c30266ae09475");
const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
module.exports = basex(ALPHABET);

},{"819c30266ae09475":"ayfR0"}],"ayfR0":[function(require,module,exports,__globalThis) {
'use strict';
// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base(ALPHABET) {
    if (ALPHABET.length >= 255) throw new TypeError('Alphabet too long');
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++)BASE_MAP[j] = 255;
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) throw new TypeError(x + ' is ambiguous');
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
    ;
    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
    ;
    function encode(source) {
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        else if (Array.isArray(source)) source = Uint8Array.from(source);
        if (!(source instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');
        if (source.length === 0) return '';
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while(pbegin !== pend){
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) throw new Error('Non-zero carry');
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0)it2++;
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2)str += ALPHABET.charAt(b58[it2]);
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== 'string') throw new TypeError('Expected String');
        if (source.length === 0) return new Uint8Array();
        var psz = 0;
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.
        ;
        var b256 = new Uint8Array(size);
        // Process the characters.
        while(source[psz]){
            // Find code of next character
            var charCode = source.charCodeAt(psz);
            // Base map can not be indexed using char code
            if (charCode > 255) return;
            // Decode character
            var carry = BASE_MAP[charCode];
            // Invalid character
            if (carry === 255) return;
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) throw new Error('Non-zero carry');
            length = i;
            psz++;
        }
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0)it4++;
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while(it4 !== size)vch[j++] = b256[it4++];
        return vch;
    }
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) return buffer;
        throw new Error('Non-base' + BASE + ' character');
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
module.exports = base;

},{}],"3PQfh":[function(require,module,exports,__globalThis) {
// `parsePhoneNumber()` named export has been renamed to `parsePhoneNumberWithError()`.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parsePhoneNumberWithError", ()=>(0, _parsePhoneNumberWithErrorJs.parsePhoneNumberWithError));
parcelHelpers.export(exports, "parsePhoneNumber", ()=>(0, _parsePhoneNumberWithErrorJs.parsePhoneNumberWithError));
// `parsePhoneNumberFromString()` named export is now considered legacy:
// it has been promoted to a default export due to being too verbose.
parcelHelpers.export(exports, "parsePhoneNumberFromString", ()=>(0, _parsePhoneNumberJs.parsePhoneNumber));
parcelHelpers.export(exports, "default", ()=>(0, _parsePhoneNumberJs.parsePhoneNumber));
parcelHelpers.export(exports, "isValidPhoneNumber", ()=>(0, _isValidPhoneNumberJs.isValidPhoneNumber));
parcelHelpers.export(exports, "isPossiblePhoneNumber", ()=>(0, _isPossiblePhoneNumberJs.isPossiblePhoneNumber));
parcelHelpers.export(exports, "validatePhoneNumberLength", ()=>(0, _validatePhoneNumberLengthJs.validatePhoneNumberLength));
// Deprecated.
parcelHelpers.export(exports, "findNumbers", ()=>(0, _findNumbersJs.findNumbers));
parcelHelpers.export(exports, "searchNumbers", ()=>(0, _searchNumbersJs.searchNumbers));
parcelHelpers.export(exports, "findPhoneNumbersInText", ()=>(0, _findPhoneNumbersInTextJs.findPhoneNumbersInText));
parcelHelpers.export(exports, "searchPhoneNumbersInText", ()=>(0, _searchPhoneNumbersInTextJs.searchPhoneNumbersInText));
parcelHelpers.export(exports, "PhoneNumberMatcher", ()=>(0, _phoneNumberMatcherJs.PhoneNumberMatcher));
parcelHelpers.export(exports, "AsYouType", ()=>(0, _asYouTypeJs.AsYouType));
parcelHelpers.export(exports, "isSupportedCountry", ()=>(0, _isSupportedCountryJs.isSupportedCountry));
parcelHelpers.export(exports, "getCountries", ()=>(0, _getCountriesJs.getCountries));
parcelHelpers.export(exports, "getCountryCallingCode", ()=>(0, _getCountryCallingCodeJs.getCountryCallingCode));
parcelHelpers.export(exports, "getExtPrefix", ()=>(0, _getExtPrefixJs.getExtPrefix));
parcelHelpers.export(exports, "Metadata", ()=>(0, _metadataJs.Metadata));
parcelHelpers.export(exports, "getExampleNumber", ()=>(0, _getExampleNumberJs.getExampleNumber));
parcelHelpers.export(exports, "formatIncompletePhoneNumber", ()=>(0, _formatIncompletePhoneNumberJs.formatIncompletePhoneNumber));
parcelHelpers.export(exports, "PhoneNumber", ()=>(0, _phoneNumberJs.PhoneNumber));
parcelHelpers.export(exports, "ParseError", ()=>(0, _indexJs.ParseError));
parcelHelpers.export(exports, "parseIncompletePhoneNumber", ()=>(0, _indexJs.parseIncompletePhoneNumber));
parcelHelpers.export(exports, "parsePhoneNumberCharacter", ()=>(0, _indexJs.parsePhoneNumberCharacter));
parcelHelpers.export(exports, "parseDigits", ()=>(0, _indexJs.parseDigits));
parcelHelpers.export(exports, "parseRFC3966", ()=>(0, _indexJs.parseRFC3966));
parcelHelpers.export(exports, "formatRFC3966", ()=>(0, _indexJs.formatRFC3966));
parcelHelpers.export(exports, "DIGIT_PLACEHOLDER", ()=>(0, _indexJs.DIGIT_PLACEHOLDER));
var _parsePhoneNumberWithErrorJs = require("./exports/parsePhoneNumberWithError.js");
var _parsePhoneNumberJs = require("./exports/parsePhoneNumber.js");
var _isValidPhoneNumberJs = require("./exports/isValidPhoneNumber.js");
var _isPossiblePhoneNumberJs = require("./exports/isPossiblePhoneNumber.js");
var _validatePhoneNumberLengthJs = require("./exports/validatePhoneNumberLength.js");
var _findNumbersJs = require("./exports/findNumbers.js");
var _searchNumbersJs = require("./exports/searchNumbers.js");
var _findPhoneNumbersInTextJs = require("./exports/findPhoneNumbersInText.js");
var _searchPhoneNumbersInTextJs = require("./exports/searchPhoneNumbersInText.js");
var _phoneNumberMatcherJs = require("./exports/PhoneNumberMatcher.js");
var _asYouTypeJs = require("./exports/AsYouType.js");
var _isSupportedCountryJs = require("./exports/isSupportedCountry.js");
var _getCountriesJs = require("./exports/getCountries.js");
var _getCountryCallingCodeJs = require("./exports/getCountryCallingCode.js");
var _getExtPrefixJs = require("./exports/getExtPrefix.js");
var _metadataJs = require("./exports/Metadata.js");
var _getExampleNumberJs = require("./exports/getExampleNumber.js");
var _formatIncompletePhoneNumberJs = require("./exports/formatIncompletePhoneNumber.js");
var _phoneNumberJs = require("./exports/PhoneNumber.js");
var _indexJs = require("../core/index.js");

},{"./exports/parsePhoneNumberWithError.js":"kIckV","./exports/parsePhoneNumber.js":"fonYF","./exports/isValidPhoneNumber.js":"7YQVd","./exports/isPossiblePhoneNumber.js":"4Y8Oi","./exports/validatePhoneNumberLength.js":"eTnz1","./exports/findNumbers.js":"f5n8d","./exports/searchNumbers.js":"gGhau","./exports/findPhoneNumbersInText.js":"6omsZ","./exports/searchPhoneNumbersInText.js":"5I1Qk","./exports/PhoneNumberMatcher.js":"iRdV7","./exports/AsYouType.js":"fWNGu","./exports/isSupportedCountry.js":"iiy4r","./exports/getCountries.js":"bGKH3","./exports/getCountryCallingCode.js":"hMqun","./exports/getExtPrefix.js":"9fanj","./exports/Metadata.js":"cdZaE","./exports/getExampleNumber.js":"deLuu","./exports/formatIncompletePhoneNumber.js":"kzSCU","./exports/PhoneNumber.js":"2Z2vR","../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kIckV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parsePhoneNumberWithError", ()=>parsePhoneNumberWithError);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function parsePhoneNumberWithError() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.parsePhoneNumberWithError), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7y4e6":[function(require,module,exports,__globalThis) {
// Importing from a ".js" file is a workaround for Node.js "ES Modules"
// importing system which is even uncapable of importing "*.json" files.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>withMetadataArgument);
var _metadataMaxJsonJs = require("../../metadata.max.json.js");
var _metadataMaxJsonJsDefault = parcelHelpers.interopDefault(_metadataMaxJsonJs);
function withMetadataArgument(func, _arguments) {
    var args = Array.prototype.slice.call(_arguments);
    args.push((0, _metadataMaxJsonJsDefault.default));
    return func.apply(this, args);
}

},{"../../metadata.max.json.js":"8d2g5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8d2g5":[function(require,module,exports,__globalThis) {
// This file is a workaround for a bug in web browsers' "native"
// ES6 importing system which is uncapable of importing "*.json" files.
// https://github.com/catamphetamine/libphonenumber-js/issues/239
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = {
    "version": 4,
    "country_calling_codes": {
        "1": [
            "US",
            "AG",
            "AI",
            "AS",
            "BB",
            "BM",
            "BS",
            "CA",
            "DM",
            "DO",
            "GD",
            "GU",
            "JM",
            "KN",
            "KY",
            "LC",
            "MP",
            "MS",
            "PR",
            "SX",
            "TC",
            "TT",
            "VC",
            "VG",
            "VI"
        ],
        "7": [
            "RU",
            "KZ"
        ],
        "20": [
            "EG"
        ],
        "27": [
            "ZA"
        ],
        "30": [
            "GR"
        ],
        "31": [
            "NL"
        ],
        "32": [
            "BE"
        ],
        "33": [
            "FR"
        ],
        "34": [
            "ES"
        ],
        "36": [
            "HU"
        ],
        "39": [
            "IT",
            "VA"
        ],
        "40": [
            "RO"
        ],
        "41": [
            "CH"
        ],
        "43": [
            "AT"
        ],
        "44": [
            "GB",
            "GG",
            "IM",
            "JE"
        ],
        "45": [
            "DK"
        ],
        "46": [
            "SE"
        ],
        "47": [
            "NO",
            "SJ"
        ],
        "48": [
            "PL"
        ],
        "49": [
            "DE"
        ],
        "51": [
            "PE"
        ],
        "52": [
            "MX"
        ],
        "53": [
            "CU"
        ],
        "54": [
            "AR"
        ],
        "55": [
            "BR"
        ],
        "56": [
            "CL"
        ],
        "57": [
            "CO"
        ],
        "58": [
            "VE"
        ],
        "60": [
            "MY"
        ],
        "61": [
            "AU",
            "CC",
            "CX"
        ],
        "62": [
            "ID"
        ],
        "63": [
            "PH"
        ],
        "64": [
            "NZ"
        ],
        "65": [
            "SG"
        ],
        "66": [
            "TH"
        ],
        "81": [
            "JP"
        ],
        "82": [
            "KR"
        ],
        "84": [
            "VN"
        ],
        "86": [
            "CN"
        ],
        "90": [
            "TR"
        ],
        "91": [
            "IN"
        ],
        "92": [
            "PK"
        ],
        "93": [
            "AF"
        ],
        "94": [
            "LK"
        ],
        "95": [
            "MM"
        ],
        "98": [
            "IR"
        ],
        "211": [
            "SS"
        ],
        "212": [
            "MA",
            "EH"
        ],
        "213": [
            "DZ"
        ],
        "216": [
            "TN"
        ],
        "218": [
            "LY"
        ],
        "220": [
            "GM"
        ],
        "221": [
            "SN"
        ],
        "222": [
            "MR"
        ],
        "223": [
            "ML"
        ],
        "224": [
            "GN"
        ],
        "225": [
            "CI"
        ],
        "226": [
            "BF"
        ],
        "227": [
            "NE"
        ],
        "228": [
            "TG"
        ],
        "229": [
            "BJ"
        ],
        "230": [
            "MU"
        ],
        "231": [
            "LR"
        ],
        "232": [
            "SL"
        ],
        "233": [
            "GH"
        ],
        "234": [
            "NG"
        ],
        "235": [
            "TD"
        ],
        "236": [
            "CF"
        ],
        "237": [
            "CM"
        ],
        "238": [
            "CV"
        ],
        "239": [
            "ST"
        ],
        "240": [
            "GQ"
        ],
        "241": [
            "GA"
        ],
        "242": [
            "CG"
        ],
        "243": [
            "CD"
        ],
        "244": [
            "AO"
        ],
        "245": [
            "GW"
        ],
        "246": [
            "IO"
        ],
        "247": [
            "AC"
        ],
        "248": [
            "SC"
        ],
        "249": [
            "SD"
        ],
        "250": [
            "RW"
        ],
        "251": [
            "ET"
        ],
        "252": [
            "SO"
        ],
        "253": [
            "DJ"
        ],
        "254": [
            "KE"
        ],
        "255": [
            "TZ"
        ],
        "256": [
            "UG"
        ],
        "257": [
            "BI"
        ],
        "258": [
            "MZ"
        ],
        "260": [
            "ZM"
        ],
        "261": [
            "MG"
        ],
        "262": [
            "RE",
            "YT"
        ],
        "263": [
            "ZW"
        ],
        "264": [
            "NA"
        ],
        "265": [
            "MW"
        ],
        "266": [
            "LS"
        ],
        "267": [
            "BW"
        ],
        "268": [
            "SZ"
        ],
        "269": [
            "KM"
        ],
        "290": [
            "SH",
            "TA"
        ],
        "291": [
            "ER"
        ],
        "297": [
            "AW"
        ],
        "298": [
            "FO"
        ],
        "299": [
            "GL"
        ],
        "350": [
            "GI"
        ],
        "351": [
            "PT"
        ],
        "352": [
            "LU"
        ],
        "353": [
            "IE"
        ],
        "354": [
            "IS"
        ],
        "355": [
            "AL"
        ],
        "356": [
            "MT"
        ],
        "357": [
            "CY"
        ],
        "358": [
            "FI",
            "AX"
        ],
        "359": [
            "BG"
        ],
        "370": [
            "LT"
        ],
        "371": [
            "LV"
        ],
        "372": [
            "EE"
        ],
        "373": [
            "MD"
        ],
        "374": [
            "AM"
        ],
        "375": [
            "BY"
        ],
        "376": [
            "AD"
        ],
        "377": [
            "MC"
        ],
        "378": [
            "SM"
        ],
        "380": [
            "UA"
        ],
        "381": [
            "RS"
        ],
        "382": [
            "ME"
        ],
        "383": [
            "XK"
        ],
        "385": [
            "HR"
        ],
        "386": [
            "SI"
        ],
        "387": [
            "BA"
        ],
        "389": [
            "MK"
        ],
        "420": [
            "CZ"
        ],
        "421": [
            "SK"
        ],
        "423": [
            "LI"
        ],
        "500": [
            "FK"
        ],
        "501": [
            "BZ"
        ],
        "502": [
            "GT"
        ],
        "503": [
            "SV"
        ],
        "504": [
            "HN"
        ],
        "505": [
            "NI"
        ],
        "506": [
            "CR"
        ],
        "507": [
            "PA"
        ],
        "508": [
            "PM"
        ],
        "509": [
            "HT"
        ],
        "590": [
            "GP",
            "BL",
            "MF"
        ],
        "591": [
            "BO"
        ],
        "592": [
            "GY"
        ],
        "593": [
            "EC"
        ],
        "594": [
            "GF"
        ],
        "595": [
            "PY"
        ],
        "596": [
            "MQ"
        ],
        "597": [
            "SR"
        ],
        "598": [
            "UY"
        ],
        "599": [
            "CW",
            "BQ"
        ],
        "670": [
            "TL"
        ],
        "672": [
            "NF"
        ],
        "673": [
            "BN"
        ],
        "674": [
            "NR"
        ],
        "675": [
            "PG"
        ],
        "676": [
            "TO"
        ],
        "677": [
            "SB"
        ],
        "678": [
            "VU"
        ],
        "679": [
            "FJ"
        ],
        "680": [
            "PW"
        ],
        "681": [
            "WF"
        ],
        "682": [
            "CK"
        ],
        "683": [
            "NU"
        ],
        "685": [
            "WS"
        ],
        "686": [
            "KI"
        ],
        "687": [
            "NC"
        ],
        "688": [
            "TV"
        ],
        "689": [
            "PF"
        ],
        "690": [
            "TK"
        ],
        "691": [
            "FM"
        ],
        "692": [
            "MH"
        ],
        "850": [
            "KP"
        ],
        "852": [
            "HK"
        ],
        "853": [
            "MO"
        ],
        "855": [
            "KH"
        ],
        "856": [
            "LA"
        ],
        "880": [
            "BD"
        ],
        "886": [
            "TW"
        ],
        "960": [
            "MV"
        ],
        "961": [
            "LB"
        ],
        "962": [
            "JO"
        ],
        "963": [
            "SY"
        ],
        "964": [
            "IQ"
        ],
        "965": [
            "KW"
        ],
        "966": [
            "SA"
        ],
        "967": [
            "YE"
        ],
        "968": [
            "OM"
        ],
        "970": [
            "PS"
        ],
        "971": [
            "AE"
        ],
        "972": [
            "IL"
        ],
        "973": [
            "BH"
        ],
        "974": [
            "QA"
        ],
        "975": [
            "BT"
        ],
        "976": [
            "MN"
        ],
        "977": [
            "NP"
        ],
        "992": [
            "TJ"
        ],
        "993": [
            "TM"
        ],
        "994": [
            "AZ"
        ],
        "995": [
            "GE"
        ],
        "996": [
            "KG"
        ],
        "998": [
            "UZ"
        ]
    },
    "countries": {
        "AC": [
            "247",
            "00",
            "(?:[01589]\\d|[46])\\d{4}",
            [
                5,
                6
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "6[2-467]\\d{3}",
                    [
                        5
                    ]
                ],
                [
                    "4\\d{4}",
                    [
                        5
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "(?:0[1-9]|[1589]\\d)\\d{4}",
                    [
                        6
                    ]
                ]
            ]
        ],
        "AD": [
            "376",
            "00",
            "(?:1|6\\d)\\d{7}|[135-9]\\d{5}",
            [
                6,
                8,
                9
            ],
            [
                [
                    "(\\d{3})(\\d{3})",
                    "$1 $2",
                    [
                        "[135-9]"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "1"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "6"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "[78]\\d{5}",
                    [
                        6
                    ]
                ],
                [
                    "690\\d{6}|[356]\\d{5}",
                    [
                        6,
                        9
                    ]
                ],
                [
                    "180[02]\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "[19]\\d{5}",
                    [
                        6
                    ]
                ]
            ]
        ],
        "AE": [
            "971",
            "00",
            "(?:[4-7]\\d|9[0-689])\\d{7}|800\\d{2,9}|[2-4679]\\d{7}",
            [
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{3})(\\d{2,9})",
                    "$1 $2",
                    [
                        "60|8"
                    ]
                ],
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[236]|[479][2-8]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d)(\\d{5})",
                    "$1 $2 $3",
                    [
                        "[479]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "5"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "[2-4679][2-8]\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "5[024-68]\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "400\\d{6}|800\\d{2,9}"
                ],
                [
                    "900[02]\\d{5}",
                    [
                        9
                    ]
                ],
                0,
                0,
                [
                    "600[25]\\d{5}",
                    [
                        9
                    ]
                ],
                0,
                0,
                [
                    "700[05]\\d{5}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "AF": [
            "93",
            "00",
            "[2-7]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[2-7]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:[25][0-8]|[34][0-4]|6[0-5])[2-9]\\d{6}"
                ],
                [
                    "7\\d{8}"
                ]
            ]
        ],
        "AG": [
            "1",
            "011",
            "(?:268|[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([457]\\d{6})$|1",
            "268$1",
            0,
            "268",
            [
                [
                    "268(?:4(?:6[0-38]|84)|56[0-2])\\d{4}"
                ],
                [
                    "268(?:464|7(?:1[3-9]|[28]\\d|3[0246]|64|7[0-689]))\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ],
                0,
                0,
                [
                    "26840[69]\\d{4}"
                ],
                [
                    "26848[01]\\d{4}"
                ]
            ]
        ],
        "AI": [
            "1",
            "011",
            "(?:264|[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2457]\\d{6})$|1",
            "264$1",
            0,
            "264",
            [
                [
                    "264(?:292|4(?:6[12]|9[78]))\\d{4}"
                ],
                [
                    "264(?:235|4(?:69|76)|5(?:3[6-9]|8[1-4])|7(?:29|72))\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ],
                0,
                0,
                [
                    "264724\\d{4}"
                ]
            ]
        ],
        "AL": [
            "355",
            "00",
            "(?:700\\d\\d|900)\\d{3}|8\\d{5,7}|(?:[2-5]|6\\d)\\d{7}",
            [
                6,
                7,
                8,
                9
            ],
            [
                [
                    "(\\d{3})(\\d{3,4})",
                    "$1 $2",
                    [
                        "80|9"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "4[2-6]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[2358][2-5]|4"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{5})",
                    "$1 $2",
                    [
                        "[23578]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "6"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "4505[0-2]\\d{3}|(?:[2358][16-9]\\d[2-9]|4410)\\d{4}|(?:[2358][2-5][2-9]|4(?:[2-57-9][2-9]|6\\d))\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "6(?:[78][2-9]|9\\d)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "900[1-9]\\d\\d",
                    [
                        6
                    ]
                ],
                [
                    "700[2-9]\\d{4}",
                    [
                        8
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "808[1-9]\\d\\d",
                    [
                        6
                    ]
                ]
            ]
        ],
        "AM": [
            "374",
            "00",
            "(?:[1-489]\\d|55|60|77)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[89]0"
                    ],
                    "0 $1"
                ],
                [
                    "(\\d{3})(\\d{5})",
                    "$1 $2",
                    [
                        "2|3[12]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d{6})",
                    "$1 $2",
                    [
                        "1|47"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d{6})",
                    "$1 $2",
                    [
                        "[3-9]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:(?:1[0-25]|47)\\d|2(?:2[2-46]|3[1-8]|4[2-69]|5[2-7]|6[1-9]|8[1-7])|3[12]2)\\d{5}"
                ],
                [
                    "(?:33|4[1349]|55|77|88|9[13-9])\\d{6}"
                ],
                [
                    "800\\d{5}"
                ],
                [
                    "90[016]\\d{5}"
                ],
                0,
                0,
                0,
                0,
                [
                    "60(?:2[78]|3[5-9]|4[02-9]|5[0-46-9]|[6-8]\\d|9[0-2])\\d{4}"
                ],
                [
                    "80[1-4]\\d{5}"
                ]
            ]
        ],
        "AO": [
            "244",
            "00",
            "[29]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[29]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2\\d(?:[0134][25-9]|[25-9]\\d)\\d{5}"
                ],
                [
                    "9[1-79]\\d{7}"
                ]
            ]
        ],
        "AR": [
            "54",
            "00",
            "(?:11|[89]\\d\\d)\\d{8}|[2368]\\d{9}",
            [
                10,
                11
            ],
            [
                [
                    "(\\d{4})(\\d{2})(\\d{4})",
                    "$1 $2-$3",
                    [
                        "2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9])",
                        "2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8]))|2(?:2[24-9]|3[1-59]|47)",
                        "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5[56][46]|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]",
                        "2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|58|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|54(?:4|5[13-7]|6[89])|86[3-6]))|2(?:2[24-9]|3[1-59]|47)|38(?:[58][78]|7[378])|3(?:454|85[56])[46]|3(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1 $2-$3",
                    [
                        "1"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "[68]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2-$3",
                    [
                        "[23]"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d)(\\d{4})(\\d{2})(\\d{4})",
                    "$2 15-$3-$4",
                    [
                        "9(?:2[2-469]|3[3-578])",
                        "9(?:2(?:2[024-9]|3[0-59]|47|6[245]|9[02-8])|3(?:3[28]|4[03-9]|5[2-46-8]|7[1-578]|8[2-9]))",
                        "9(?:2(?:[23]02|6(?:[25]|4[6-8])|9(?:[02356]|4[02568]|72|8[23]))|3(?:3[28]|4(?:[04679]|3[5-8]|5[4-68]|8[2379])|5(?:[2467]|3[237]|8[2-5])|7[1-578]|8(?:[2469]|3[2578]|5[4-8]|7[36-8]|8[5-8])))|92(?:2[24-9]|3[1-59]|47)",
                        "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3[78]|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8[23])|7[1-578]|8(?:[2469]|3[278]|5(?:[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4[35][56]|58[45]|8(?:[38]5|54|76))[4-6]",
                        "9(?:2(?:[23]02|6(?:[25]|4(?:64|[78]))|9(?:[02356]|4(?:[0268]|5[2-6])|72|8[23]))|3(?:3[28]|4(?:[04679]|3(?:5(?:4[0-25689]|[56])|[78])|5(?:4[46]|8)|8[2379])|5(?:[2467]|3[237]|8(?:[23]|4(?:[45]|60)|5(?:4[0-39]|5|64)))|7[1-578]|8(?:[2469]|3[278]|5(?:4(?:4|5[13-7]|6[89])|[56][46]|[78])|7[378]|8(?:6[3-6]|[78]))))|92(?:2[24-9]|3[1-59]|47)|93(?:4(?:36|5[56])|8(?:[38]5|76))[4-6]"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3-$4"
                ],
                [
                    "(\\d)(\\d{2})(\\d{4})(\\d{4})",
                    "$2 15-$3-$4",
                    [
                        "91"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3-$4"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{5})",
                    "$1-$2-$3",
                    [
                        "8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{3})(\\d{4})",
                    "$2 15-$3-$4",
                    [
                        "9"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3-$4"
                ]
            ],
            "0",
            0,
            "0?(?:(11|2(?:2(?:02?|[13]|2[13-79]|4[1-6]|5[2457]|6[124-8]|7[1-4]|8[13-6]|9[1267])|3(?:02?|1[467]|2[03-6]|3[13-8]|[49][2-6]|5[2-8]|[67])|4(?:7[3-578]|9)|6(?:[0136]|2[24-6]|4[6-8]?|5[15-8])|80|9(?:0[1-3]|[19]|2\\d|3[1-6]|4[02568]?|5[2-4]|6[2-46]|72?|8[23]?))|3(?:3(?:2[79]|6|8[2578])|4(?:0[0-24-9]|[12]|3[5-8]?|4[24-7]|5[4-68]?|6[02-9]|7[126]|8[2379]?|9[1-36-8])|5(?:1|2[1245]|3[237]?|4[1-46-9]|6[2-4]|7[1-6]|8[2-5]?)|6[24]|7(?:[069]|1[1568]|2[15]|3[145]|4[13]|5[14-8]|7[2-57]|8[126])|8(?:[01]|2[15-7]|3[2578]?|4[13-6]|5[4-8]?|6[1-357-9]|7[36-8]?|8[5-8]?|9[124])))15)?",
            "9$1",
            0,
            0,
            [
                [
                    "3(?:7(?:1[15]|81)|8(?:21|4[16]|69|9[12]))[46]\\d{5}|(?:2(?:2(?:2[59]|44|52)|3(?:26|44)|47[35]|9(?:[07]2|2[26]|34|46))|3327)[45]\\d{5}|(?:2(?:657|9(?:54|66))|3(?:48[27]|7(?:55|77)|8(?:65|78)))[2-8]\\d{5}|(?:2(?:284|3(?:02|23)|477|622|920)|3(?:4(?:46|89|92)|541))[2-7]\\d{5}|(?:(?:11[1-8]|670)\\d|2(?:2(?:0[45]|1[2-6]|3[3-6])|3(?:[06]4|7[45])|494|6(?:04|1[2-8]|[36][45]|4[3-6])|80[45]|9(?:[17][4-6]|[48][45]|9[3-6]))|3(?:364|4(?:1[2-8]|[25][4-6]|3[3-6]|84)|5(?:1[2-9]|[38][4-6])|6(?:2[45]|44)|7[069][45]|8(?:0[45]|1[2-7]|3[4-6]|5[3-6]|7[2-6]|8[3-68])))\\d{6}|(?:2(?:2(?:62|81)|320|9(?:42|83))|3(?:329|4(?:62|7[16])|5(?:43|64)|7(?:18|5[17])))[2-6]\\d{5}|2(?:2(?:21|4[23]|6[145]|7[1-4]|8[356]|9[267])|3(?:16|3[13-8]|43|5[346-8]|9[3-5])|6(?:2[46]|4[78]|5[1568])|9(?:03|2[1457-9]|3[1356]|4[08]|[56][23]|82))4\\d{5}|(?:2(?:257|3(?:24|46|92)|9(?:01|23|64))|3(?:4(?:42|64)|5(?:25|37|4[47]|71)|7(?:35|72)|825))[3-6]\\d{5}|(?:2(?:2(?:02|2[3467]|4[156]|5[45]|6[6-8]|91)|3(?:1[47]|25|[45][25]|96)|47[48]|625|932)|3(?:38[2578]|4(?:0[0-24-9]|3[78]|4[457]|58|6[035-9]|72|83|9[136-8])|5(?:2[124]|[368][23]|4[2689]|7[2-6])|7(?:16|2[15]|3[14]|4[13]|5[468]|7[3-5]|8[26])|8(?:2[67]|3[278]|4[3-5]|5[78]|6[1-378]|[78]7|94)))[4-6]\\d{5}",
                    [
                        10
                    ]
                ],
                [
                    "93(?:7(?:1[15]|81)|8(?:21|4[16]|69|9[12]))[46]\\d{5}|9(?:2(?:2(?:2[59]|44|52)|3(?:26|44)|47[35]|9(?:[07]2|2[26]|34|46))|3327)[45]\\d{5}|9(?:2(?:657|9(?:54|66))|3(?:48[27]|7(?:55|77)|8(?:65|78)))[2-8]\\d{5}|9(?:2(?:284|3(?:02|23)|477|622|920)|3(?:4(?:46|89|92)|541))[2-7]\\d{5}|(?:675\\d|9(?:11[1-8]\\d|2(?:2(?:0[45]|1[2-6]|3[3-6])|3(?:[06]4|7[45])|494|6(?:04|1[2-8]|[36][45]|4[3-6])|80[45]|9(?:[17][4-6]|[48][45]|9[3-6]))|3(?:364|4(?:1[2-8]|[25][4-6]|3[3-6]|84)|5(?:1[2-9]|[38][4-6])|6(?:2[45]|44)|7[069][45]|8(?:0[45]|1[2-7]|3[4-6]|5[3-6]|7[2-6]|8[3-68]))))\\d{6}|9(?:2(?:2(?:62|81)|320|9(?:42|83))|3(?:329|4(?:62|7[16])|5(?:43|64)|7(?:18|5[17])))[2-6]\\d{5}|92(?:2(?:21|4[23]|6[145]|7[1-4]|8[356]|9[267])|3(?:16|3[13-8]|43|5[346-8]|9[3-5])|6(?:2[46]|4[78]|5[1568])|9(?:03|2[1457-9]|3[1356]|4[08]|[56][23]|82))4\\d{5}|9(?:2(?:257|3(?:24|46|92)|9(?:01|23|64))|3(?:4(?:42|64)|5(?:25|37|4[47]|71)|7(?:35|72)|825))[3-6]\\d{5}|9(?:2(?:2(?:02|2[3467]|4[156]|5[45]|6[6-8]|91)|3(?:1[47]|25|[45][25]|96)|47[48]|625|932)|3(?:38[2578]|4(?:0[0-24-9]|3[78]|4[457]|58|6[035-9]|72|83|9[136-8])|5(?:2[124]|[368][23]|4[2689]|7[2-6])|7(?:16|2[15]|3[14]|4[13]|5[468]|7[3-5]|8[26])|8(?:2[67]|3[278]|4[3-5]|5[78]|6[1-378]|[78]7|94)))[4-6]\\d{5}"
                ],
                [
                    "800\\d{7,8}"
                ],
                [
                    "60[04579]\\d{7}",
                    [
                        10
                    ]
                ],
                0,
                0,
                [
                    "810\\d{7}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "AS": [
            "1",
            "011",
            "(?:[58]\\d\\d|684|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([267]\\d{6})$|1",
            "684$1",
            0,
            "684",
            [
                [
                    "6846(?:22|33|44|55|77|88|9[19])\\d{4}"
                ],
                [
                    "684(?:2(?:48|5[2468]|7[26])|7(?:3[13]|70|82))\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "AT": [
            "43",
            "00",
            "1\\d{3,12}|2\\d{6,12}|43(?:(?:0\\d|5[02-9])\\d{3,9}|2\\d{4,5}|[3467]\\d{4}|8\\d{4,6}|9\\d{4,7})|5\\d{4,12}|8\\d{7,12}|9\\d{8,12}|(?:[367]\\d|4[0-24-9])\\d{4,11}",
            [
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            [
                [
                    "(\\d)(\\d{3,12})",
                    "$1 $2",
                    [
                        "1(?:11|[2-9])"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})",
                    "$1 $2",
                    [
                        "517"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3,5})",
                    "$1 $2",
                    [
                        "5[079]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3,10})",
                    "$1 $2",
                    [
                        "(?:31|4)6|51|6(?:48|5[0-3579]|[6-9])|7(?:20|32|8)|[89]",
                        "(?:31|4)6|51|6(?:485|5[0-3579]|[6-9])|7(?:20|32|8)|[89]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{3,9})",
                    "$1 $2",
                    [
                        "[2-467]|5[2-6]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "5"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4,7})",
                    "$1 $2 $3",
                    [
                        "5"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "1(?:11\\d|[2-9]\\d{3,11})|(?:316|463)\\d{3,10}|648[34]\\d{3,9}|(?:51|66|73)2\\d{3,10}|(?:2(?:1[467]|2[13-8]|5[2357]|6[1-46-8]|7[1-8]|8[124-7]|9[1458])|3(?:1[1-578]|3[23568]|4[5-7]|5[1378]|6[1-38]|8[3-68])|4(?:2[1-8]|35|7[1368]|8[2457])|5(?:2[1-8]|3[357]|4[147]|5[12578]|6[37])|6(?:13|2[1-47]|4[135-7]|5[468])|7(?:2[1-8]|35|4[13478]|5[68]|6[16-8]|7[1-6]|9[45]))\\d{4,10}"
                ],
                [
                    "6(?:485|(?:5[0-3579]|6[013-9]|[7-9]\\d)\\d)\\d{3,9}",
                    [
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ]
                ],
                [
                    "800\\d{6,10}",
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ]
                ],
                [
                    "(?:8[69][2-68]|9(?:0[01]|3[019]))\\d{6,10}",
                    [
                        9,
                        10,
                        11,
                        12,
                        13
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "5(?:0[1-9]|17|[79]\\d)\\d{2,10}|7[28]0\\d{6,10}",
                    [
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ]
                ],
                [
                    "8(?:10|2[018])\\d{6,10}|828\\d{5}",
                    [
                        8,
                        9,
                        10,
                        11,
                        12,
                        13
                    ]
                ]
            ]
        ],
        "AU": [
            "61",
            "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011",
            "1(?:[0-79]\\d{7}(?:\\d(?:\\d{2})?)?|8[0-24-9]\\d{7})|[2-478]\\d{8}|1\\d{4,7}",
            [
                5,
                6,
                7,
                8,
                9,
                10,
                12
            ],
            [
                [
                    "(\\d{2})(\\d{3,4})",
                    "$1 $2",
                    [
                        "16"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2,4})",
                    "$1 $2 $3",
                    [
                        "16"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "14|4"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[2378]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "1(?:30|[89])"
                    ]
                ]
            ],
            "0",
            0,
            "(183[12])|0",
            0,
            0,
            0,
            [
                [
                    "(?:(?:(?:2(?:[0-26-9]\\d|3[0-8]|4[02-9]|5[0135-9])|7(?:[013-57-9]\\d|2[0-8]))\\d|3(?:(?:[0-3589]\\d|6[1-9]|7[0-35-9])\\d|4(?:[0-578]\\d|90)))\\d\\d|8(?:51(?:0(?:0[03-9]|[12479]\\d|3[2-9]|5[0-8]|6[1-9]|8[0-7])|1(?:[0235689]\\d|1[0-69]|4[0-589]|7[0-47-9])|2(?:0[0-79]|[18][13579]|2[14-9]|3[0-46-9]|[4-6]\\d|7[89]|9[0-4])|3\\d\\d)|(?:6[0-8]|[78]\\d)\\d{3}|9(?:[02-9]\\d{3}|1(?:(?:[0-58]\\d|6[0135-9])\\d|7(?:0[0-24-9]|[1-9]\\d)|9(?:[0-46-9]\\d|5[0-79])))))\\d{3}",
                    [
                        9
                    ]
                ],
                [
                    "4(?:79[01]|83[0-389]|94[0-4])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "180(?:0\\d{3}|2)\\d{3}",
                    [
                        7,
                        10
                    ]
                ],
                [
                    "190[0-26]\\d{6}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                [
                    "163\\d{2,6}",
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}",
                    [
                        9
                    ]
                ],
                [
                    "13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}",
                    [
                        6,
                        8,
                        10,
                        12
                    ]
                ]
            ],
            "0011"
        ],
        "AW": [
            "297",
            "00",
            "(?:[25-79]\\d\\d|800)\\d{4}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[25-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "5(?:2\\d|8[1-9])\\d{4}"
                ],
                [
                    "(?:290|5[69]\\d|6(?:[03]0|22|4[0-2]|[69]\\d)|7(?:[34]\\d|7[07])|9(?:6[45]|9[4-8]))\\d{4}"
                ],
                [
                    "800\\d{4}"
                ],
                [
                    "900\\d{4}"
                ],
                0,
                0,
                0,
                0,
                [
                    "(?:28\\d|501)\\d{4}"
                ]
            ]
        ],
        "AX": [
            "358",
            "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))",
            "2\\d{4,9}|35\\d{4,5}|(?:60\\d\\d|800)\\d{4,6}|7\\d{5,11}|(?:[14]\\d|3[0-46-9]|50)\\d{4,8}",
            [
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            0,
            "0",
            0,
            0,
            0,
            0,
            "18",
            [
                [
                    "18[1-8]\\d{3,6}",
                    [
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "4946\\d{2,6}|(?:4[0-8]|50)\\d{4,8}",
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "800\\d{4,6}",
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "[67]00\\d{5,6}",
                    [
                        8,
                        9
                    ]
                ],
                0,
                0,
                [
                    "20\\d{4,8}|60[12]\\d{5,6}|7(?:099\\d{4,5}|5[03-9]\\d{3,7})|20[2-59]\\d\\d|(?:606|7(?:0[78]|1|3\\d))\\d{7}|(?:10|29|3[09]|70[1-5]\\d)\\d{4,8}"
                ]
            ],
            "00"
        ],
        "AZ": [
            "994",
            "00",
            "365\\d{6}|(?:[124579]\\d|60|88)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "90"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "1[28]|2|365|46",
                        "1[28]|2|365[45]|46",
                        "1[28]|2|365(?:4|5[02])|46"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[13-9]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2[12]428|3655[02])\\d{4}|(?:2(?:22[0-79]|63[0-28])|3654)\\d{5}|(?:(?:1[28]|46)\\d|2(?:[014-6]2|[23]3))\\d{6}"
                ],
                [
                    "36554\\d{4}|(?:[16]0|4[04]|5[015]|7[07]|99)\\d{7}"
                ],
                [
                    "88\\d{7}"
                ],
                [
                    "900200\\d{3}"
                ]
            ]
        ],
        "BA": [
            "387",
            "00",
            "6\\d{8}|(?:[35689]\\d|49|70)\\d{6}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "6[1-3]|[7-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2-$3",
                    [
                        "[3-5]|6[56]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "6"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:3(?:[05-79][2-9]|1[4579]|[23][24-9]|4[2-4689]|8[2457-9])|49[2-579]|5(?:0[2-49]|[13][2-9]|[268][2-4679]|4[4689]|5[2-79]|7[2-69]|9[2-4689]))\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "6040\\d{5}|6(?:03|[1-356]|44|7\\d)\\d{6}"
                ],
                [
                    "8[08]\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "9[0246]\\d{6}",
                    [
                        8
                    ]
                ],
                0,
                0,
                [
                    "703[235]0\\d{3}|70(?:2[0-5]|3[0146]|[56]0)\\d{4}",
                    [
                        8
                    ]
                ],
                0,
                0,
                [
                    "8[12]\\d{6}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "BB": [
            "1",
            "011",
            "(?:246|[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-9]\\d{6})$|1",
            "246$1",
            0,
            "246",
            [
                [
                    "246521[0369]\\d{3}|246(?:2(?:2[78]|7[0-4])|4(?:1[024-6]|2\\d|3[2-9])|5(?:20|[34]\\d|54|7[1-3])|6(?:2\\d|38)|7[35]7|9(?:1[89]|63))\\d{4}"
                ],
                [
                    "246(?:(?:2(?:[3568]\\d|4[0-57-9])|3(?:5[2-9]|6[0-6])|4(?:46|5\\d)|69[5-7]|8(?:[2-5]\\d|83))\\d|52(?:1[147]|20))\\d{3}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "(?:246976|900[2-9]\\d\\d)\\d{4}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ],
                0,
                [
                    "246(?:292|367|4(?:1[7-9]|3[01]|4[47-9]|67)|7(?:1[2-9]|2\\d|3[016]|53))\\d{4}"
                ],
                0,
                [
                    "24631\\d{5}"
                ]
            ]
        ],
        "BD": [
            "880",
            "00",
            "[1-469]\\d{9}|8[0-79]\\d{7,8}|[2-79]\\d{8}|[2-9]\\d{7}|[3-9]\\d{6}|[57-9]\\d{5}",
            [
                6,
                7,
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{4,6})",
                    "$1-$2",
                    [
                        "31[5-8]|[459]1"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3,7})",
                    "$1-$2",
                    [
                        "3(?:[67]|8[013-9])|4(?:6[168]|7|[89][18])|5(?:6[128]|9)|6(?:[15]|28|4[14])|7[2-589]|8(?:0[014-9]|[12])|9[358]|(?:3[2-5]|4[235]|5[2-578]|6[0389]|76|8[3-7]|9[24])1|(?:44|66)[01346-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{3,6})",
                    "$1-$2",
                    [
                        "[13-9]|2[23]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{7,8})",
                    "$1-$2",
                    [
                        "2"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:4(?:31\\d\\d|423)|5222)\\d{3}(?:\\d{2})?|8332[6-9]\\d\\d|(?:3(?:03[56]|224)|4(?:22[25]|653))\\d{3,4}|(?:3(?:42[47]|529|823)|4(?:027|525|65(?:28|8))|562|6257|7(?:1(?:5[3-5]|6[12]|7[156]|89)|22[589]56|32|42675|52(?:[25689](?:56|8)|[347]8)|71(?:6[1267]|75|89)|92374)|82(?:2[59]|32)56|9(?:03[23]56|23(?:256|373)|31|5(?:1|2[4589]56)))\\d{3}|(?:3(?:02[348]|22[35]|324|422)|4(?:22[67]|32[236-9]|6(?:2[46]|5[57])|953)|5526|6(?:024|6655)|81)\\d{4,5}|(?:2(?:7(?:1[0-267]|2[0-289]|3[0-29]|4[01]|5[1-3]|6[013]|7[0178]|91)|8(?:0[125]|1[1-6]|2[0157-9]|3[1-69]|41|6[1-35]|7[1-5]|8[1-8]|9[0-6])|9(?:0[0-2]|1[0-4]|2[568]|3[3-6]|5[5-7]|6[0136-9]|7[0-7]|8[014-9]))|3(?:0(?:2[025-79]|3[2-4])|181|22[12]|32[2356]|824)|4(?:02[09]|22[348]|32[045]|523|6(?:27|54))|666(?:22|53)|7(?:22[57-9]|42[56]|82[35])8|8(?:0[124-9]|2(?:181|2[02-4679]8)|4[12]|[5-7]2)|9(?:[04]2|2(?:2|328)|81))\\d{4}|(?:2(?:[23]\\d|[45])\\d\\d|3(?:1(?:2[5-7]|[5-7])|425|822)|4(?:033|1\\d|[257]1|332|4(?:2[246]|5[25])|6(?:2[35]|56|62)|8(?:23|54)|92[2-5])|5(?:02[03489]|22[457]|32[35-79]|42[46]|6(?:[18]|53)|724|826)|6(?:023|2(?:2[2-5]|5[3-5]|8)|32[3478]|42[34]|52[47]|6(?:[18]|6(?:2[34]|5[24]))|[78]2[2-5]|92[2-6])|7(?:02|21\\d|[3-589]1|6[12]|72[24])|8(?:217|3[12]|[5-7]1)|9[24]1)\\d{5}|(?:(?:3[2-8]|5[2-57-9]|6[03-589])1|4[4689][18])\\d{5}|[59]1\\d{5}"
                ],
                [
                    "(?:1[13-9]\\d|644)\\d{7}|(?:3[78]|44|66)[02-9]\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "80[03]\\d{7}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "96(?:0[469]|1[0-47]|3[389]|43|6[69]|7[78])\\d{6}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "BE": [
            "32",
            "00",
            "4\\d{8}|[1-9]\\d{7}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "(?:80|9)0"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[239]|4[23]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[15-8]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "4"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "80[2-8]\\d{5}|(?:1[0-69]|[23][2-8]|4[23]|5\\d|6[013-57-9]|71|8[1-79]|9[2-4])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "4[5-9]\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "800[1-9]\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "(?:70(?:2[0-57]|3[04-7]|44|6[04-69]|7[0579])|90\\d\\d)\\d{4}",
                    [
                        8
                    ]
                ],
                0,
                0,
                [
                    "78(?:0[578]|1[014-8]|2[25]|3[15-8]|48|5[05]|60|7[06-8]|9\\d)\\d{4}",
                    [
                        8
                    ]
                ],
                0,
                0,
                [
                    "7879\\d{4}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "BF": [
            "226",
            "00",
            "[025-7]\\d{7}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[025-7]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:0(?:49|5[23]|6[5-7]|9[016-9])|4(?:4[569]|5[4-6]|6[5-7]|7[0179])|5(?:[34]\\d|50|6[5-7]))\\d{4}"
                ],
                [
                    "(?:0[1-7]|5[0-8]|[67]\\d)\\d{6}"
                ]
            ]
        ],
        "BG": [
            "359",
            "00",
            "00800\\d{7}|[2-7]\\d{6,7}|[89]\\d{6,8}|2\\d{5}",
            [
                6,
                7,
                8,
                9,
                12
            ],
            [
                [
                    "(\\d)(\\d)(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "2"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "43[1-6]|70[1-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "2"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2,3})",
                    "$1 $2 $3",
                    [
                        "[356]|4[124-7]|7[1-9]|8[1-6]|9[1-7]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "(?:70|8)0"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{2})",
                    "$1 $2 $3",
                    [
                        "43[1-7]|7"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[48]|9[08]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "9"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2\\d{5,7}|(?:43[1-6]|70[1-9])\\d{4,5}|(?:[36]\\d|4[124-7]|[57][1-9]|8[1-6]|9[1-7])\\d{5,6}",
                    [
                        6,
                        7,
                        8
                    ]
                ],
                [
                    "(?:43[07-9]|99[69]\\d)\\d{5}|(?:8[7-9]|98)\\d{7}",
                    [
                        8,
                        9
                    ]
                ],
                [
                    "(?:00800\\d\\d|800)\\d{5}",
                    [
                        8,
                        12
                    ]
                ],
                [
                    "90\\d{6}",
                    [
                        8
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "700\\d{5}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "BH": [
            "973",
            "00",
            "[136-9]\\d{7}",
            [
                8
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[13679]|8[02-4679]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1(?:3[1356]|6[0156]|7\\d)\\d|6(?:1[16]\\d|500|6(?:0\\d|3[12]|44|55|7[7-9]|88)|9[69][69])|7(?:[07]\\d\\d|1(?:11|78)))\\d{4}"
                ],
                [
                    "(?:3(?:[0-79]\\d|8[0-57-9])\\d|6(?:3(?:00|33|6[16])|441|6(?:3[03-9]|[69]\\d|7[0-689])))\\d{4}"
                ],
                [
                    "8[02369]\\d{6}"
                ],
                [
                    "(?:87|9[0-8])\\d{6}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "84\\d{6}"
                ]
            ]
        ],
        "BI": [
            "257",
            "00",
            "(?:[267]\\d|31)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[2367]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:22|31)\\d{6}"
                ],
                [
                    "64[0-2]\\d{5}|(?:29|[67][125-9])\\d{6}"
                ]
            ]
        ],
        "BJ": [
            "229",
            "00",
            "(?:01\\d|[24-689])\\d{7}",
            [
                8,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[24-689]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4 $5",
                    [
                        "0"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2090\\d{4}|(?:012\\d\\d|2(?:02|1[037]|2[45]|3[68]|4\\d))\\d{5}"
                ],
                [
                    "(?:01(?:2[5-9]|[4-69]\\d)|4[0-8]|[56]\\d|9[013-9])\\d{6}"
                ],
                0,
                0,
                0,
                0,
                [
                    "81\\d{6}",
                    [
                        8
                    ]
                ],
                0,
                [
                    "857[58]\\d{4}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "BL": [
            "590",
            "00",
            "(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}",
            [
                9
            ],
            0,
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "590(?:2[7-9]|3[3-7]|5[12]|87)\\d{4}"
                ],
                [
                    "(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"
                ],
                [
                    "80[0-5]\\d{6}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"
                ]
            ]
        ],
        "BM": [
            "1",
            "011",
            "(?:441|[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-9]\\d{6})$|1",
            "441$1",
            0,
            "441",
            [
                [
                    "441(?:[46]\\d\\d|5(?:4\\d|60|89))\\d{4}"
                ],
                [
                    "441(?:[2378]\\d|5[0-39]|9[02])\\d{5}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "BN": [
            "673",
            "00",
            "[2-578]\\d{6}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[2-578]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "22[0-7]\\d{4}|(?:2[013-9]|[34]\\d|5[0-25-9])\\d{5}"
                ],
                [
                    "(?:22[89]|[78]\\d\\d)\\d{4}"
                ],
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "5[34]\\d{5}"
                ]
            ]
        ],
        "BO": [
            "591",
            "00(?:1\\d)?",
            "8001\\d{5}|(?:[2-467]\\d|50)\\d{6}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d)(\\d{7})",
                    "$1 $2",
                    [
                        "[235]|4[46]"
                    ]
                ],
                [
                    "(\\d{8})",
                    "$1",
                    [
                        "[67]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ]
            ],
            "0",
            0,
            "0(1\\d)?",
            0,
            0,
            0,
            [
                [
                    "(?:2(?:2\\d\\d|5(?:11|[258]\\d|9[67])|6(?:12|2\\d|9[34])|8(?:2[34]|39|62))|3(?:3\\d\\d|4(?:6\\d|8[24])|8(?:25|42|5[257]|86|9[25])|9(?:[27]\\d|3[2-4]|4[248]|5[24]|6[2-6]))|4(?:4\\d\\d|6(?:11|[24689]\\d|72)))\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "[67]\\d{7}",
                    [
                        8
                    ]
                ],
                [
                    "8001[07]\\d{4}",
                    [
                        9
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "50\\d{6}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "BQ": [
            "599",
            "00",
            "(?:[34]1|7\\d)\\d{5}",
            [
                7
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            "[347]",
            [
                [
                    "(?:318[023]|41(?:6[023]|70)|7(?:1[578]|2[05]|50)\\d)\\d{3}"
                ],
                [
                    "(?:31(?:8[14-8]|9[14578])|416[14-9]|7(?:0[01]|7[07]|8\\d|9[056])\\d)\\d{3}"
                ]
            ]
        ],
        "BR": [
            "55",
            "00(?:1[245]|2[1-35]|31|4[13]|[56]5|99)",
            "[1-467]\\d{9,10}|55[0-46-9]\\d{8}|[34]\\d{7}|55\\d{7,8}|(?:5[0-46-9]|[89]\\d)\\d{7,9}",
            [
                8,
                9,
                10,
                11
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1-$2",
                    [
                        "300|4(?:0[02]|37|86)",
                        "300|4(?:0(?:0|20)|370|864)"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2,3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "(?:[358]|90)0"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1 $2-$3",
                    [
                        "(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-57]"
                    ],
                    "($1)"
                ],
                [
                    "(\\d{2})(\\d{5})(\\d{4})",
                    "$1 $2-$3",
                    [
                        "[16][1-9]|[2-57-9]"
                    ],
                    "($1)"
                ]
            ],
            "0",
            0,
            "(?:0|90)(?:(1[245]|2[1-35]|31|4[13]|[56]5|99)(\\d{10,11}))?",
            "$2",
            0,
            0,
            [
                [
                    "(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])[2-5]\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "(?:[14689][1-9]|2[12478]|3[1-578]|5[13-5]|7[13-579])(?:7|9\\d)\\d{7}",
                    [
                        10,
                        11
                    ]
                ],
                [
                    "800\\d{6,7}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "[59]00\\d{6,7}",
                    [
                        9,
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "(?:30[03]\\d{3}|4(?:0(?:0\\d|20)|370|864))\\d{4}|300\\d{5}",
                    [
                        8,
                        10
                    ]
                ]
            ]
        ],
        "BS": [
            "1",
            "011",
            "(?:242|[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([3-8]\\d{6})$|1",
            "242$1",
            0,
            "242",
            [
                [
                    "242(?:3(?:02|[236][1-9]|4[0-24-9]|5[0-68]|7[347]|8[0-4]|9[2-467])|461|502|6(?:0[1-5]|12|2[013]|[45]0|7[67]|8[78]|9[89])|7(?:02|88))\\d{4}"
                ],
                [
                    "242(?:3(?:5[79]|7[56]|95)|4(?:[23][1-9]|4[1-35-9]|5[1-8]|6[2-8]|7\\d|81)|5(?:2[45]|3[35]|44|5[1-46-9]|65|77)|6[34]6|7(?:27|38)|8(?:0[1-9]|1[02-9]|2\\d|3[0-4]|[89]9))\\d{4}"
                ],
                [
                    "242300\\d{4}|8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ],
                0,
                [
                    "242225\\d{4}"
                ]
            ]
        ],
        "BT": [
            "975",
            "00",
            "[17]\\d{7}|[2-8]\\d{6}",
            [
                7,
                8
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[2-68]|7[246]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "1[67]|7"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2[3-6]|[34][5-7]|5[236]|6[2-46]|7[246]|8[2-4])\\d{5}",
                    [
                        7
                    ]
                ],
                [
                    "(?:1[67]|77)\\d{6}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "BW": [
            "267",
            "00",
            "(?:0800|(?:[37]|800)\\d)\\d{6}|(?:[2-6]\\d|90)\\d{5}",
            [
                7,
                8,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{5})",
                    "$1 $2",
                    [
                        "90"
                    ]
                ],
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[24-6]|3[15-9]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[37]"
                    ]
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "0"
                    ]
                ],
                [
                    "(\\d{3})(\\d{4})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:4[0-48]|6[0-24]|9[0578])|3(?:1[0-35-9]|55|[69]\\d|7[013]|81)|4(?:6[03]|7[1267]|9[0-5])|5(?:3[03489]|4[0489]|7[1-47]|88|9[0-49])|6(?:2[1-35]|5[149]|8[013467]))\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "(?:321|7[1-8]\\d)\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "(?:0800|800\\d)\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "90\\d{5}",
                    [
                        7
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "79(?:1(?:[0-2]\\d|3[0-3])|2[0-7]\\d)\\d{3}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "BY": [
            "375",
            "810",
            "(?:[12]\\d|33|44|902)\\d{7}|8(?:0[0-79]\\d{5,7}|[1-7]\\d{9})|8(?:1[0-489]|[5-79]\\d)\\d{7}|8[1-79]\\d{6,7}|8[0-79]\\d{5}|8\\d{5}",
            [
                6,
                7,
                8,
                9,
                10,
                11
            ],
            [
                [
                    "(\\d{3})(\\d{3})",
                    "$1 $2",
                    [
                        "800"
                    ],
                    "8 $1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2,4})",
                    "$1 $2 $3",
                    [
                        "800"
                    ],
                    "8 $1"
                ],
                [
                    "(\\d{4})(\\d{2})(\\d{3})",
                    "$1 $2-$3",
                    [
                        "1(?:5[169]|6[3-5]|7[179])|2(?:1[35]|2[34]|3[3-5])",
                        "1(?:5[169]|6(?:3[1-3]|4|5[125])|7(?:1[3-9]|7[0-24-6]|9[2-7]))|2(?:1[35]|2[34]|3[3-5])"
                    ],
                    "8 0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2-$3-$4",
                    [
                        "1(?:[56]|7[467])|2[1-3]"
                    ],
                    "8 0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2-$3-$4",
                    [
                        "[1-4]"
                    ],
                    "8 0$1"
                ],
                [
                    "(\\d{3})(\\d{3,4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[89]"
                    ],
                    "8 $1"
                ]
            ],
            "8",
            0,
            "0|80?",
            0,
            0,
            0,
            [
                [
                    "(?:1(?:5(?:1[1-5]|[24]\\d|6[2-4]|9[1-7])|6(?:[235]\\d|4[1-7])|7\\d\\d)|2(?:1(?:[246]\\d|3[0-35-9]|5[1-9])|2(?:[235]\\d|4[0-8])|3(?:[26]\\d|3[02-79]|4[024-7]|5[03-7])))\\d{5}",
                    [
                        9
                    ]
                ],
                [
                    "(?:2(?:5[5-79]|9[1-9])|(?:33|44)\\d)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{3,7}|8(?:0[13]|20\\d)\\d{7}"
                ],
                [
                    "(?:810|902)\\d{7}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "249\\d{6}",
                    [
                        9
                    ]
                ]
            ],
            "8~10"
        ],
        "BZ": [
            "501",
            "00",
            "(?:0800\\d|[2-8])\\d{6}",
            [
                7,
                11
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1-$2",
                    [
                        "[2-8]"
                    ]
                ],
                [
                    "(\\d)(\\d{3})(\\d{4})(\\d{3})",
                    "$1-$2-$3-$4",
                    [
                        "0"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:[02]\\d|36|[68]0)|[3-58](?:[02]\\d|[68]0)|7(?:[02]\\d|32|[68]0))\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "6[0-35-7]\\d{5}",
                    [
                        7
                    ]
                ],
                [
                    "0800\\d{7}",
                    [
                        11
                    ]
                ]
            ]
        ],
        "CA": [
            "1",
            "011",
            "[2-9]\\d{9}|3\\d{6}",
            [
                7,
                10
            ],
            0,
            "1",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:04|[23]6|[48]9|50|63)|3(?:06|43|54|6[578]|82)|4(?:03|1[68]|[26]8|3[178]|50|74)|5(?:06|1[49]|48|79|8[147])|6(?:04|[18]3|39|47|72)|7(?:0[59]|42|53|78|8[02])|8(?:[06]7|19|25|7[39])|9(?:0[25]|42))[2-9]\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "",
                    [
                        10
                    ]
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "900[2-9]\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|(?:5(?:2[125-9]|33|44|66|77|88)|6(?:22|33))[2-9]\\d{6}",
                    [
                        10
                    ]
                ],
                0,
                [
                    "310\\d{4}",
                    [
                        7
                    ]
                ],
                0,
                [
                    "600[2-9]\\d{6}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "CC": [
            "61",
            "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011",
            "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}",
            [
                6,
                7,
                8,
                9,
                10,
                12
            ],
            0,
            "0",
            0,
            "([59]\\d{7})$|0",
            "8$1",
            0,
            0,
            [
                [
                    "8(?:51(?:0(?:02|31|60|89)|1(?:18|76)|223)|91(?:0(?:1[0-2]|29)|1(?:[28]2|50|79)|2(?:10|64)|3(?:[06]8|22)|4[29]8|62\\d|70[23]|959))\\d{3}",
                    [
                        9
                    ]
                ],
                [
                    "4(?:79[01]|83[0-389]|94[0-4])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "180(?:0\\d{3}|2)\\d{3}",
                    [
                        7,
                        10
                    ]
                ],
                [
                    "190[0-26]\\d{6}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}",
                    [
                        9
                    ]
                ],
                [
                    "13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}",
                    [
                        6,
                        8,
                        10,
                        12
                    ]
                ]
            ],
            "0011"
        ],
        "CD": [
            "243",
            "00",
            "(?:(?:[189]|5\\d)\\d|2)\\d{7}|[1-68]\\d{6}",
            [
                7,
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "88"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{5})",
                    "$1 $2",
                    [
                        "[1-6]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "2"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[89]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "5"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:(?:12|573)\\d\\d|276)\\d{5}|[1-6]\\d{6}"
                ],
                [
                    "88\\d{5}|(?:8[0-69]|9[017-9])\\d{7}",
                    [
                        7,
                        9
                    ]
                ]
            ]
        ],
        "CF": [
            "236",
            "00",
            "(?:[27]\\d{3}|8776)\\d{4}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[278]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2[12]\\d{6}"
                ],
                [
                    "7[024-7]\\d{6}"
                ],
                0,
                [
                    "8776\\d{4}"
                ]
            ]
        ],
        "CG": [
            "242",
            "00",
            "222\\d{6}|(?:0\\d|80)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d)(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[02]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "222[1-589]\\d{5}"
                ],
                [
                    "026(?:1[0-5]|6[6-9])\\d{4}|0(?:[14-6]\\d\\d|2(?:40|5[5-8]|6[07-9]))\\d{5}"
                ],
                0,
                [
                    "80[0-2]\\d{6}"
                ]
            ]
        ],
        "CH": [
            "41",
            "00",
            "8\\d{11}|[2-9]\\d{8}",
            [
                9,
                12
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "8[047]|90"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[2-79]|81"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4 $5",
                    [
                        "8"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2[12467]|3[1-4]|4[134]|5[256]|6[12]|[7-9]1)\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "(?:6[89]|7[235-9])\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "90[016]\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "878\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "860\\d{9}",
                    [
                        12
                    ]
                ],
                [
                    "5[18]\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "74[0248]\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "84[0248]\\d{6}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "CI": [
            "225",
            "00",
            "[02]\\d{9}",
            [
                10
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d)(\\d{5})",
                    "$1 $2 $3 $4",
                    [
                        "2"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{4})",
                    "$1 $2 $3 $4",
                    [
                        "0"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:[15]\\d{3}|7(?:2(?:0[23]|1[2357]|2[245]|3[45]|4[3-5])|3(?:06|1[69]|[2-6]7)))\\d{5}"
                ],
                [
                    "0[157]\\d{8}"
                ]
            ]
        ],
        "CK": [
            "682",
            "00",
            "[2-578]\\d{4}",
            [
                5
            ],
            [
                [
                    "(\\d{2})(\\d{3})",
                    "$1 $2",
                    [
                        "[2-578]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2\\d|3[13-7]|4[1-5])\\d{3}"
                ],
                [
                    "[578]\\d{4}"
                ]
            ]
        ],
        "CL": [
            "56",
            "(?:0|1(?:1[0-69]|2[02-5]|5[13-58]|69|7[0167]|8[018]))0",
            "12300\\d{6}|6\\d{9,10}|[2-9]\\d{8}",
            [
                9,
                10,
                11
            ],
            [
                [
                    "(\\d{5})(\\d{4})",
                    "$1 $2",
                    [
                        "219",
                        "2196"
                    ],
                    "($1)"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "44"
                    ]
                ],
                [
                    "(\\d)(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "2[1-36]"
                    ],
                    "($1)"
                ],
                [
                    "(\\d)(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "9[2-9]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "3[2-5]|[47]|5[1-3578]|6[13-57]|8(?:0[1-9]|[1-9])"
                    ],
                    "($1)"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "60|8"
                    ]
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{2})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "60"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:1982[0-6]|3314[05-9])\\d{3}|(?:2(?:1(?:160|962)|3(?:2\\d\\d|3(?:[03467]\\d|1[0-35-9]|2[1-9]|5[0-24-9]|8[0-3])|600)|646[59])|80[1-9]\\d\\d|9(?:3(?:[0-57-9]\\d\\d|6(?:0[02-9]|[1-9]\\d))|6(?:[0-8]\\d\\d|9(?:[02-79]\\d|1[05-9]))|7[1-9]\\d\\d|9(?:[03-9]\\d\\d|1(?:[0235-9]\\d|4[0-24-9])|2(?:[0-79]\\d|8[0-46-9]))))\\d{4}|(?:22|3[2-5]|[47][1-35]|5[1-3578]|6[13-57]|8[1-9]|9[2458])\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "",
                    [
                        9
                    ]
                ],
                [
                    "(?:123|8)00\\d{6}",
                    [
                        9,
                        11
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "44\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "600\\d{7,8}",
                    [
                        10,
                        11
                    ]
                ]
            ]
        ],
        "CM": [
            "237",
            "00",
            "[26]\\d{8}|88\\d{6,7}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "88"
                    ]
                ],
                [
                    "(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4 $5",
                    [
                        "[26]|88"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:22|33)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "(?:24[23]|6(?:[25-9]\\d|40))\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "88\\d{6,7}"
                ]
            ]
        ],
        "CN": [
            "86",
            "00|1(?:[12]\\d|79)\\d\\d00",
            "(?:(?:1[03-689]|2\\d)\\d\\d|6)\\d{8}|1\\d{10}|[126]\\d{6}(?:\\d(?:\\d{2})?)?|86\\d{5,6}|(?:[3-579]\\d|8[0-57-9])\\d{5,9}",
            [
                7,
                8,
                9,
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{2})(\\d{5,6})",
                    "$1 $2",
                    [
                        "(?:10|2[0-57-9])[19]|3(?:[157]|35|49|9[1-68])|4(?:1[124-9]|2[179]|6[47-9]|7|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:07|1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3|4[13]|5[1-5]|7[0-79]|9[0-35-9])|(?:4[35]|59|85)[1-9]",
                        "(?:10|2[0-57-9])(?:1[02]|9[56])|8078|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))1",
                        "10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|80781|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))12",
                        "10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|807812|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))123",
                        "10(?:1(?:0|23)|9[56])|2[0-57-9](?:1(?:00|23)|9[56])|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:1[124-9]|2[179]|[35][1-9]|6[47-9]|7\\d|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:078|1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))123"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{5,6})",
                    "$1 $2",
                    [
                        "3(?:[157]|35|49|9[1-68])|4(?:[17]|2[179]|6[47-9]|8[23])|5(?:[1357]|2[37]|4[36]|6[1-46]|80)|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]|4[13]|5[1-5])|(?:4[35]|59|85)[1-9]",
                        "(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[1-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))[19]",
                        "85[23](?:10|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:10|9[56])",
                        "85[23](?:100|95)|(?:3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))(?:100|9[56])"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "(?:4|80)0"
                    ]
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "10|2(?:[02-57-9]|1[1-9])",
                        "10|2(?:[02-57-9]|1[1-9])",
                        "10[0-79]|2(?:[02-57-9]|1[1-79])|(?:10|21)8(?:0[1-9]|[1-9])"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "3(?:[3-59]|7[02-68])|4(?:[26-8]|3[3-9]|5[2-9])|5(?:3[03-9]|[468]|7[028]|9[2-46-9])|6|7(?:[0-247]|3[04-9]|5[0-4689]|6[2368])|8(?:[1-358]|9[1-7])|9(?:[013479]|5[1-5])|(?:[34]1|55|79|87)[02-9]"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{3})(\\d{7,8})",
                    "$1 $2",
                    [
                        "9"
                    ]
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "80"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{3})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[3-578]"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{3})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1[3-9]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3 $4",
                    [
                        "[12]"
                    ],
                    "0$1",
                    1
                ]
            ],
            "0",
            0,
            "(1(?:[12]\\d|79)\\d\\d)|0",
            0,
            0,
            0,
            [
                [
                    "(?:10(?:[02-79]\\d\\d|[18](?:0[1-9]|[1-9]\\d))|2(?:[02-57-9]\\d{3}|1(?:[18](?:0[1-9]|[1-9]\\d)|[2-79]\\d\\d))|(?:41[03]|8078|9(?:78|94))\\d\\d)\\d{5}|(?:10|2[0-57-9])(?:1(?:00|23)\\d\\d|95\\d{3,4})|(?:41[03]|9(?:78|94))(?:100\\d\\d|95\\d{3,4})|8078123|(?:43[35]|754|851)\\d{7,8}|(?:43[35]|754|851)(?:1(?:00\\d|23)\\d|95\\d{3,4})|(?:3(?:11|7[179])|4(?:[15]1|3[12])|5(?:1\\d|2[37]|3[12]|51|7[13-79]|9[15])|7(?:[39]1|5[57]|6[09])|8(?:71|98))(?:[02-8]\\d{7}|1(?:0(?:0\\d\\d(?:\\d{3})?|[1-9]\\d{5})|[13-9]\\d{6}|2(?:[0-24-9]\\d{5}|3\\d(?:\\d{4})?))|9(?:[0-46-9]\\d{6}|5\\d{3}(?:\\d(?:\\d{2})?)?))|(?:3(?:1[02-9]|35|49|5\\d|7[02-68]|9[1-68])|4(?:1[24-9]|2[179]|3[46-9]|5[2-9]|6[47-9]|7\\d|8[23])|5(?:3[03-9]|4[36]|5[02-9]|6[1-46]|7[028]|80|9[2-46-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[17]\\d|2[248]|3[04-9]|4[3-6]|5[0-3689]|6[2368]|9[02-9])|8(?:1[236-8]|2[5-7]|3\\d|5[2-9]|7[02-9]|8[36-8]|9[1-7])|9(?:0[1-3689]|1[1-79]|3\\d|4[13]|5[1-5]|7[0-79]|9[0-35-9]))(?:[02-8]\\d{6}|1(?:0(?:0\\d\\d(?:\\d{2})?|[1-9]\\d{4})|[13-9]\\d{5}|2(?:[0-24-9]\\d{4}|3\\d(?:\\d{3})?))|9(?:[0-46-9]\\d{5}|5\\d{3,5}))",
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    "1740[0-5]\\d{6}|1(?:[38]\\d|4[57]|[59][0-35-9]|6[25-7]|7[0-35-8])\\d{8}",
                    [
                        11
                    ]
                ],
                [
                    "(?:(?:10|21)8|8)00\\d{7}",
                    [
                        10,
                        12
                    ]
                ],
                [
                    "16[08]\\d{5}",
                    [
                        8
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "10(?:10\\d{4}|96\\d{3,4})|400\\d{7}|950\\d{7,8}|(?:2[0-57-9]|3(?:[157]\\d|35|49|9[1-68])|4(?:[17]\\d|2[179]|[35][1-9]|6[47-9]|8[23])|5(?:[1357]\\d|2[37]|4[36]|6[1-46]|80|9[1-9])|6(?:3[1-5]|6[0238]|9[12])|7(?:01|[1579]\\d|2[248]|3[014-9]|4[3-6]|6[023689])|8(?:1[236-8]|2[5-7]|[37]\\d|5[14-9]|8[36-8]|9[1-8])|9(?:0[1-3689]|1[1-79]|[379]\\d|4[13]|5[1-5]))96\\d{3,4}",
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ]
            ],
            "00"
        ],
        "CO": [
            "57",
            "00(?:4(?:[14]4|56)|[579])",
            "(?:46|60\\d\\d)\\d{6}|(?:1\\d|[39])\\d{9}",
            [
                8,
                10,
                11
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "46"
                    ]
                ],
                [
                    "(\\d{3})(\\d{7})",
                    "$1 $2",
                    [
                        "6|90"
                    ],
                    "($1)"
                ],
                [
                    "(\\d{3})(\\d{7})",
                    "$1 $2",
                    [
                        "3[0-357]|91"
                    ]
                ],
                [
                    "(\\d)(\\d{3})(\\d{7})",
                    "$1-$2-$3",
                    [
                        "1"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3"
                ]
            ],
            "0",
            0,
            "0([3579]|4(?:[14]4|56))?",
            0,
            0,
            0,
            [
                [
                    "601055(?:[0-4]\\d|50)\\d\\d|6010(?:[0-4]\\d|5[0-4])\\d{4}|(?:46|60(?:[124-7][2-9]|8[1-9]))\\d{6}",
                    [
                        8,
                        10
                    ]
                ],
                [
                    "333301[0-5]\\d{3}|3333(?:00|2[5-9]|[3-9]\\d)\\d{4}|(?:3(?:24[1-9]|3(?:00|3[0-24-9]))|9101)\\d{6}|3(?:0[0-5]|1\\d|2[0-3]|5[01]|70)\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "1800\\d{7}",
                    [
                        11
                    ]
                ],
                [
                    "(?:19(?:0[01]|4[78])|901)\\d{7}",
                    [
                        10,
                        11
                    ]
                ]
            ]
        ],
        "CR": [
            "506",
            "00",
            "(?:8\\d|90)\\d{8}|(?:[24-8]\\d{3}|3005)\\d{4}",
            [
                8,
                10
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[2-7]|8[3-9]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "[89]"
                    ]
                ]
            ],
            0,
            0,
            "(19(?:0[0-2468]|1[09]|20|66|77|99))",
            0,
            0,
            0,
            [
                [
                    "210[7-9]\\d{4}|2(?:[024-7]\\d|1[1-9])\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "(?:3005\\d|6500[01])\\d{3}|(?:5[07]|6[0-4]|7[0-3]|8[3-9])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "800\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "90[059]\\d{7}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "(?:210[0-6]|4\\d{3}|5100)\\d{4}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "CU": [
            "53",
            "119",
            "(?:[2-7]|8\\d\\d)\\d{7}|[2-47]\\d{6}|[34]\\d{5}",
            [
                6,
                7,
                8,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{4,6})",
                    "$1 $2",
                    [
                        "2[1-4]|[34]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d)(\\d{6,7})",
                    "$1 $2",
                    [
                        "7"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d)(\\d{7})",
                    "$1 $2",
                    [
                        "[56]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{7})",
                    "$1 $2",
                    [
                        "8"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:3[23]|4[89])\\d{4,6}|(?:31|4[36]|8(?:0[25]|78)\\d)\\d{6}|(?:2[1-4]|4[1257]|7\\d)\\d{5,6}"
                ],
                [
                    "(?:5\\d|6[2-4])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "800\\d{7}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "807\\d{7}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "CV": [
            "238",
            "0",
            "(?:[2-59]\\d\\d|800)\\d{4}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3",
                    [
                        "[2-589]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:2[1-7]|3[0-8]|4[12]|5[1256]|6\\d|7[1-3]|8[1-5])\\d{4}"
                ],
                [
                    "(?:36|5[1-389]|9\\d)\\d{5}"
                ],
                [
                    "800\\d{4}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "(?:3[3-5]|4[356])\\d{5}"
                ]
            ]
        ],
        "CW": [
            "599",
            "00",
            "(?:[34]1|60|(?:7|9\\d)\\d)\\d{5}",
            [
                7,
                8
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[3467]"
                    ]
                ],
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "9[4-8]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            "[69]",
            [
                [
                    "9(?:4(?:3[0-5]|4[14]|6\\d)|50\\d|7(?:2[014]|3[02-9]|4[4-9]|6[357]|77|8[7-9])|8(?:3[39]|[46]\\d|7[01]|8[57-9]))\\d{4}"
                ],
                [
                    "953[01]\\d{4}|9(?:5[12467]|6[5-9])\\d{5}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "955\\d{5}",
                    [
                        8
                    ]
                ],
                0,
                [
                    "60[0-2]\\d{4}",
                    [
                        7
                    ]
                ]
            ]
        ],
        "CX": [
            "61",
            "001[14-689]|14(?:1[14]|34|4[17]|[56]6|7[47]|88)0011",
            "1(?:[0-79]\\d{8}(?:\\d{2})?|8[0-24-9]\\d{7})|[148]\\d{8}|1\\d{5,7}",
            [
                6,
                7,
                8,
                9,
                10,
                12
            ],
            0,
            "0",
            0,
            "([59]\\d{7})$|0",
            "8$1",
            0,
            0,
            [
                [
                    "8(?:51(?:0(?:01|30|59|88)|1(?:17|46|75)|2(?:22|35))|91(?:00[6-9]|1(?:[28]1|49|78)|2(?:09|63)|3(?:12|26|75)|4(?:56|97)|64\\d|7(?:0[01]|1[0-2])|958))\\d{3}",
                    [
                        9
                    ]
                ],
                [
                    "4(?:79[01]|83[0-389]|94[0-4])\\d{5}|4(?:[0-36]\\d|4[047-9]|5[0-25-9]|7[02-8]|8[0-24-9]|9[0-37-9])\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "180(?:0\\d{3}|2)\\d{3}",
                    [
                        7,
                        10
                    ]
                ],
                [
                    "190[0-26]\\d{6}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "14(?:5(?:1[0458]|[23][458])|71\\d)\\d{4}",
                    [
                        9
                    ]
                ],
                [
                    "13(?:00\\d{6}(?:\\d{2})?|45[0-4]\\d{3})|13\\d{4}",
                    [
                        6,
                        8,
                        10,
                        12
                    ]
                ]
            ],
            "0011"
        ],
        "CY": [
            "357",
            "00",
            "(?:[279]\\d|[58]0)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{6})",
                    "$1 $2",
                    [
                        "[257-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2[2-6]\\d{6}"
                ],
                [
                    "9(?:10|[4-79]\\d)\\d{5}"
                ],
                [
                    "800\\d{5}"
                ],
                [
                    "90[09]\\d{5}"
                ],
                [
                    "700\\d{5}"
                ],
                0,
                [
                    "(?:50|77)\\d{6}"
                ],
                0,
                0,
                [
                    "80[1-9]\\d{5}"
                ]
            ]
        ],
        "CZ": [
            "420",
            "00",
            "(?:[2-578]\\d|60)\\d{7}|9\\d{8,11}",
            [
                9,
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[2-8]|9[015-7]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "96"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "9"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "9"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2\\d|3[1257-9]|4[16-9]|5[13-9])\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "(?:60[1-8]\\d|7(?:0(?:[2-5]\\d|60)|19[0-2]|[2379]\\d\\d))\\d{5}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "9(?:0[05689]|76)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "70[01]\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "9(?:3\\d{9}|6\\d{7,10})"
                ],
                [
                    "9(?:5\\d|7[2-4])\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "9[17]0\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "8[134]\\d{7}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "DE": [
            "49",
            "00",
            "[2579]\\d{5,14}|49(?:[34]0|69|8\\d)\\d\\d?|49(?:37|49|60|7[089]|9\\d)\\d{1,3}|49(?:2[024-9]|3[2-689]|7[1-7])\\d{1,8}|(?:1|[368]\\d|4[0-8])\\d{3,13}|49(?:[015]\\d|2[13]|31|[46][1-8])\\d{1,9}",
            [
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15
            ],
            [
                [
                    "(\\d{2})(\\d{3,13})",
                    "$1 $2",
                    [
                        "3[02]|40|[68]9"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3,12})",
                    "$1 $2",
                    [
                        "2(?:0[1-389]|1[124]|2[18]|3[14])|3(?:[35-9][15]|4[015])|906|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1",
                        "2(?:0[1-389]|12[0-8])|3(?:[35-9][15]|4[015])|906|2(?:[13][14]|2[18])|(?:2[4-9]|4[2-9]|[579][1-9]|[68][1-8])1"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{2,11})",
                    "$1 $2",
                    [
                        "[24-6]|3(?:[3569][02-46-9]|4[2-4679]|7[2-467]|8[2-46-8])|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]",
                        "[24-6]|3(?:3(?:0[1-467]|2[127-9]|3[124578]|7[1257-9]|8[1256]|9[145])|4(?:2[135]|4[13578]|9[1346])|5(?:0[14]|2[1-3589]|6[1-4]|7[13468]|8[13568])|6(?:2[1-489]|3[124-6]|6[13]|7[12579]|8[1-356]|9[135])|7(?:2[1-7]|4[145]|6[1-5]|7[1-4])|8(?:21|3[1468]|6|7[1467]|8[136])|9(?:0[12479]|2[1358]|4[134679]|6[1-9]|7[136]|8[147]|9[1468]))|70[2-8]|8(?:0[2-9]|[1-8])|90[7-9]|[79][1-9]|3[68]4[1347]|3(?:47|60)[1356]|3(?:3[46]|46|5[49])[1246]|3[4579]3[1357]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "138"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{5})(\\d{2,10})",
                    "$1 $2",
                    [
                        "3"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{5,11})",
                    "$1 $2",
                    [
                        "181"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d)(\\d{4,10})",
                    "$1 $2 $3",
                    [
                        "1(?:3|80)|9"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{7,8})",
                    "$1 $2",
                    [
                        "1[67]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{7,12})",
                    "$1 $2",
                    [
                        "8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{5})(\\d{6})",
                    "$1 $2",
                    [
                        "185",
                        "1850",
                        "18500"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "7"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{7})",
                    "$1 $2",
                    [
                        "18[68]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{7})",
                    "$1 $2",
                    [
                        "15[1279]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{5})(\\d{6})",
                    "$1 $2",
                    [
                        "15[03568]",
                        "15(?:[0568]|31)"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{8})",
                    "$1 $2",
                    [
                        "18"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{7,8})",
                    "$1 $2 $3",
                    [
                        "1(?:6[023]|7)"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{2})(\\d{7})",
                    "$1 $2 $3",
                    [
                        "15[279]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{8})",
                    "$1 $2 $3",
                    [
                        "15"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "32\\d{9,11}|49[1-6]\\d{10}|322\\d{6}|49[0-7]\\d{3,9}|(?:[34]0|[68]9)\\d{3,13}|(?:2(?:0[1-689]|[1-3569]\\d|4[0-8]|7[1-7]|8[0-7])|3(?:[3569]\\d|4[0-79]|7[1-7]|8[1-8])|4(?:1[02-9]|[2-48]\\d|5[0-6]|6[0-8]|7[0-79])|5(?:0[2-8]|[124-6]\\d|[38][0-8]|[79][0-7])|6(?:0[02-9]|[1-358]\\d|[47][0-8]|6[1-9])|7(?:0[2-8]|1[1-9]|[27][0-7]|3\\d|[4-6][0-8]|8[0-5]|9[013-7])|8(?:0[2-9]|1[0-79]|2\\d|3[0-46-9]|4[0-6]|5[013-9]|6[1-8]|7[0-8]|8[0-24-6])|9(?:0[6-9]|[1-4]\\d|[589][0-7]|6[0-8]|7[0-467]))\\d{3,12}",
                    [
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    "1(?:(?:5(?:[0-25-9]\\d\\d|310)|76\\d\\d)\\d{6}|6[023]\\d{7,8})|17\\d{8}",
                    [
                        10,
                        11
                    ]
                ],
                [
                    "800\\d{7,12}",
                    [
                        10,
                        11,
                        12,
                        13,
                        14,
                        15
                    ]
                ],
                [
                    "(?:137[7-9]|900(?:[135]|9\\d))\\d{6}",
                    [
                        10,
                        11
                    ]
                ],
                [
                    "700\\d{8}",
                    [
                        11
                    ]
                ],
                [
                    "1(?:6(?:013|255|399)|7(?:(?:[015]1|[69]3)3|[2-4]55|[78]99))\\d{7,8}|15(?:(?:[03-68]00|113)\\d|2\\d55|7\\d99|9\\d33)\\d{7}",
                    [
                        12,
                        13
                    ]
                ],
                [
                    "18(?:1\\d{5,11}|[2-9]\\d{8})",
                    [
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ]
                ],
                [
                    "16(?:4\\d{1,10}|[89]\\d{1,11})",
                    [
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ]
                ],
                0,
                [
                    "180\\d{5,11}|13(?:7[1-6]\\d\\d|8)\\d{4}",
                    [
                        7,
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14
                    ]
                ]
            ]
        ],
        "DJ": [
            "253",
            "00",
            "(?:2\\d|77)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[27]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:1[2-5]|7[45])\\d{5}"
                ],
                [
                    "77\\d{6}"
                ]
            ]
        ],
        "DK": [
            "45",
            "00",
            "[2-9]\\d{7}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[2-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:[0-59][1-9]|[6-8]\\d)|3(?:[0-3][1-9]|4[13]|5[1-58]|6[1347-9]|7\\d|8[1-8]|9[1-79])|4(?:[0-25][1-9]|[34][2-9]|6[13-579]|7[13579]|8[1-47]|9[127])|5(?:[0-36][1-9]|4[146-9]|5[3-57-9]|7[568]|8[1-358]|9[1-69])|6(?:[0135][1-9]|2[1-68]|4[2-8]|6[1689]|[78]\\d|9[15689])|7(?:[0-69][1-9]|7[3-9]|8[147])|8(?:[16-9][1-9]|2[1-58])|9(?:[1-47-9][1-9]|6\\d))\\d{5}"
                ],
                [
                    "(?:2[6-8]|37|6[78]|96)\\d{6}|(?:2[0-59]|3[0-689]|[457]\\d|6[0-69]|8[126-9]|9[1-47-9])[1-9]\\d{5}"
                ],
                [
                    "80\\d{6}"
                ],
                [
                    "90\\d{6}"
                ]
            ]
        ],
        "DM": [
            "1",
            "011",
            "(?:[58]\\d\\d|767|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-7]\\d{6})$|1",
            "767$1",
            0,
            "767",
            [
                [
                    "767(?:2(?:55|66)|4(?:2[01]|4[0-25-9])|50[0-4])\\d{4}"
                ],
                [
                    "767(?:2(?:[2-4689]5|7[5-7])|31[5-7]|61[1-8]|70[1-6])\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "DO": [
            "1",
            "011",
            "(?:[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            0,
            0,
            0,
            "8001|8[024]9",
            [
                [
                    "8(?:[04]9[2-9]\\d\\d|29(?:2(?:[0-59]\\d|6[04-9]|7[0-27]|8[0237-9])|3(?:[0-35-9]\\d|4[7-9])|[45]\\d\\d|6(?:[0-27-9]\\d|[3-5][1-9]|6[0135-8])|7(?:0[013-9]|[1-37]\\d|4[1-35689]|5[1-4689]|6[1-57-9]|8[1-79]|9[1-8])|8(?:0[146-9]|1[0-48]|[248]\\d|3[1-79]|5[01589]|6[013-68]|7[124-8]|9[0-8])|9(?:[0-24]\\d|3[02-46-9]|5[0-79]|60|7[0169]|8[57-9]|9[02-9])))\\d{4}"
                ],
                [
                    "8[024]9[2-9]\\d{6}"
                ],
                [
                    "8(?:00(?:14|[2-9]\\d)|(?:33|44|55|66|77|88)[2-9]\\d)\\d{5}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "DZ": [
            "213",
            "00",
            "(?:[1-4]|[5-79]\\d|80)\\d{7}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[1-4]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "9"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[5-8]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "9619\\d{5}|(?:1\\d|2[013-79]|3[0-8]|4[013-689])\\d{6}"
                ],
                [
                    "(?:5(?:4[0-29]|5\\d|6[0-3])|6(?:[569]\\d|7[0-6])|7[7-9]\\d)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "80[3-689]1\\d{5}",
                    [
                        9
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "98[23]\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "80[12]1\\d{5}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "EC": [
            "593",
            "00",
            "1\\d{9,10}|(?:[2-7]|9\\d)\\d{7}",
            [
                8,
                9,
                10,
                11
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2-$3",
                    [
                        "[2-7]"
                    ],
                    "(0$1)",
                    0,
                    "$1-$2-$3"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "9"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "1"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "[2-7][2-7]\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "964[0-2]\\d{5}|9(?:39|[57][89]|6[0-36-9]|[89]\\d)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "1800\\d{7}|1[78]00\\d{6}",
                    [
                        10,
                        11
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "[2-7]890\\d{4}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "EE": [
            "372",
            "00",
            "8\\d{9}|[4578]\\d{7}|(?:[3-8]\\d|90)\\d{5}",
            [
                7,
                8,
                10
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[369]|4[3-8]|5(?:[0-2]|5[0-478]|6[45])|7[1-9]|88",
                        "[369]|4[3-8]|5(?:[02]|1(?:[0-8]|95)|5[0-478]|6(?:4[0-4]|5[1-589]))|7[1-9]|88"
                    ]
                ],
                [
                    "(\\d{4})(\\d{3,4})",
                    "$1 $2",
                    [
                        "[45]|8(?:00|[1-49])",
                        "[45]|8(?:00[1-9]|[1-49])"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "7"
                    ]
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:3[23589]|4[3-8]|6\\d|7[1-9]|88)\\d{5}",
                    [
                        7
                    ]
                ],
                [
                    "(?:5\\d{5}|8(?:1(?:0(?:0(?:00|[178]\\d)|[3-9]\\d\\d)|(?:1(?:0[2-6]|1\\d)|(?:2[0-59]|[3-79]\\d)\\d)\\d)|2(?:0(?:0(?:00|4\\d)|(?:19|[2-7]\\d)\\d)|(?:(?:[124-69]\\d|3[5-9])\\d|7(?:[0-79]\\d|8[13-9])|8(?:[2-6]\\d|7[01]))\\d)|[349]\\d{4}))\\d\\d|5(?:(?:[02]\\d|5[0-478])\\d|1(?:[0-8]\\d|95)|6(?:4[0-4]|5[1-589]))\\d{3}",
                    [
                        7,
                        8
                    ]
                ],
                [
                    "800(?:(?:0\\d\\d|1)\\d|[2-9])\\d{3}"
                ],
                [
                    "(?:40\\d\\d|900)\\d{4}",
                    [
                        7,
                        8
                    ]
                ],
                [
                    "70[0-2]\\d{5}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "EG": [
            "20",
            "00",
            "[189]\\d{8,9}|[24-6]\\d{8}|[135]\\d{7}",
            [
                8,
                9,
                10
            ],
            [
                [
                    "(\\d)(\\d{7,8})",
                    "$1 $2",
                    [
                        "[23]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{6,7})",
                    "$1 $2",
                    [
                        "1[35]|[4-6]|8[2468]|9[235-7]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[89]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{8})",
                    "$1 $2",
                    [
                        "1"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "13[23]\\d{6}|(?:15|57)\\d{6,7}|(?:2\\d|3|4[05-8]|5[05]|6[24-689]|8[2468]|9[235-7])\\d{7}",
                    [
                        8,
                        9
                    ]
                ],
                [
                    "1[0-25]\\d{8}",
                    [
                        10
                    ]
                ],
                [
                    "800\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "900\\d{7}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "EH": [
            "212",
            "00",
            "[5-8]\\d{8}",
            [
                9
            ],
            0,
            "0",
            0,
            0,
            0,
            0,
            "528[89]",
            [
                [
                    "528[89]\\d{5}"
                ],
                [
                    "(?:6(?:[0-79]\\d|8[0-247-9])|7(?:[0167]\\d|2[0-467]|5[0-3]|8[0-7]))\\d{6}"
                ],
                [
                    "80[0-7]\\d{6}"
                ],
                [
                    "89\\d{7}"
                ],
                0,
                0,
                0,
                0,
                [
                    "(?:592(?:4[0-2]|93)|80[89]\\d\\d)\\d{4}"
                ]
            ]
        ],
        "ER": [
            "291",
            "00",
            "[178]\\d{6}",
            [
                7
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[178]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1(?:1[12568]|[24]0|55|6[146])|8\\d\\d)\\d{4}"
                ],
                [
                    "(?:17[1-3]|7\\d\\d)\\d{4}"
                ]
            ]
        ],
        "ES": [
            "34",
            "00",
            "[5-9]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[89]00"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[5-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "96906(?:0[0-8]|1[1-9]|[2-9]\\d)\\d\\d|9(?:69(?:0[0-57-9]|[1-9]\\d)|73(?:[0-8]\\d|9[1-9]))\\d{4}|(?:8(?:[1356]\\d|[28][0-8]|[47][1-9])|9(?:[135]\\d|[268][0-8]|4[1-9]|7[124-9]))\\d{6}"
                ],
                [
                    "(?:590[16]00\\d|9(?:6906(?:09|10)|7390\\d\\d))\\d\\d|(?:6\\d|7[1-48])\\d{7}"
                ],
                [
                    "[89]00\\d{6}"
                ],
                [
                    "80[367]\\d{6}"
                ],
                [
                    "70\\d{7}"
                ],
                0,
                [
                    "51\\d{7}"
                ],
                0,
                0,
                [
                    "90[12]\\d{6}"
                ]
            ]
        ],
        "ET": [
            "251",
            "00",
            "(?:11|[2-579]\\d)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[1-579]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "11667[01]\\d{3}|(?:11(?:1(?:1[124]|2[2-7]|3[1-5]|5[5-8]|8[6-8])|2(?:13|3[6-8]|5[89]|7[05-9]|8[2-6])|3(?:2[01]|3[0-289]|4[1289]|7[1-4]|87)|4(?:1[69]|3[2-49]|4[0-3]|6[5-8]|7\\d)|5(?:1[578]|44|5[0-4])|6(?:1[578]|2[69]|39|4[5-7]|5[0-5]|6[0-59]|8[015-8]))|2(?:2(?:11[1-9]|22[0-7]|33\\d|44[1467]|66[1-68])|5(?:11[124-6]|33[2-8]|44[1467]|55[14]|66[1-3679]|77[124-79]|880))|3(?:3(?:11[0-46-8]|(?:22|55)[0-6]|33[0134689]|44[04]|66[01467])|4(?:44[0-8]|55[0-69]|66[0-3]|77[1-5]))|4(?:6(?:119|22[0-24-7]|33[1-5]|44[13-69]|55[14-689]|660|88[1-4])|7(?:(?:11|22)[1-9]|33[13-7]|44[13-6]|55[1-689]))|5(?:7(?:227|55[05]|(?:66|77)[14-8])|8(?:11[149]|22[013-79]|33[0-68]|44[013-8]|550|66[1-5]|77\\d)))\\d{4}"
                ],
                [
                    "700[1-9]\\d{5}|(?:7(?:0[1-9]|1[0-8]|22|77|86|99)|9\\d\\d)\\d{6}"
                ]
            ]
        ],
        "FI": [
            "358",
            "00|99(?:[01469]|5(?:[14]1|3[23]|5[59]|77|88|9[09]))",
            "[1-35689]\\d{4}|7\\d{10,11}|(?:[124-7]\\d|3[0-46-9])\\d{8}|[1-9]\\d{5,8}",
            [
                5,
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{5})",
                    "$1",
                    [
                        "20[2-59]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3,7})",
                    "$1 $2",
                    [
                        "(?:[1-3]0|[68])0|70[07-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{4,8})",
                    "$1 $2",
                    [
                        "[14]|2[09]|50|7[135]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{6,10})",
                    "$1 $2",
                    [
                        "7"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{4,9})",
                    "$1 $2",
                    [
                        "(?:19|[2568])[1-8]|3(?:0[1-9]|[1-9])|9"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            "1[03-79]|[2-9]",
            [
                [
                    "1[3-7][1-8]\\d{3,6}|(?:19[1-8]|[23568][1-8]\\d|9(?:00|[1-8]\\d))\\d{2,6}",
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "4946\\d{2,6}|(?:4[0-8]|50)\\d{4,8}",
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "800\\d{4,6}",
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "[67]00\\d{5,6}",
                    [
                        8,
                        9
                    ]
                ],
                0,
                0,
                [
                    "20\\d{4,8}|60[12]\\d{5,6}|7(?:099\\d{4,5}|5[03-9]\\d{3,7})|20[2-59]\\d\\d|(?:606|7(?:0[78]|1|3\\d))\\d{7}|(?:10|29|3[09]|70[1-5]\\d)\\d{4,8}"
                ]
            ],
            "00"
        ],
        "FJ": [
            "679",
            "0(?:0|52)",
            "45\\d{5}|(?:0800\\d|[235-9])\\d{6}",
            [
                7,
                11
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[235-9]|45"
                    ]
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "0"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "603\\d{4}|(?:3[0-5]|6[25-7]|8[58])\\d{5}",
                    [
                        7
                    ]
                ],
                [
                    "(?:[279]\\d|45|5[01568]|8[034679])\\d{5}",
                    [
                        7
                    ]
                ],
                [
                    "0800\\d{7}",
                    [
                        11
                    ]
                ]
            ],
            "00"
        ],
        "FK": [
            "500",
            "00",
            "[2-7]\\d{4}",
            [
                5
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "[2-47]\\d{4}"
                ],
                [
                    "[56]\\d{4}"
                ]
            ]
        ],
        "FM": [
            "691",
            "00",
            "(?:[39]\\d\\d|820)\\d{4}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[389]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "31(?:00[67]|208|309)\\d\\d|(?:3(?:[2357]0[1-9]|602|804|905)|(?:820|9[2-6]\\d)\\d)\\d{3}"
                ],
                [
                    "31(?:00[67]|208|309)\\d\\d|(?:3(?:[2357]0[1-9]|602|804|905)|(?:820|9[2-7]\\d)\\d)\\d{3}"
                ]
            ]
        ],
        "FO": [
            "298",
            "00",
            "[2-9]\\d{5}",
            [
                6
            ],
            [
                [
                    "(\\d{6})",
                    "$1",
                    [
                        "[2-9]"
                    ]
                ]
            ],
            0,
            0,
            "(10(?:01|[12]0|88))",
            0,
            0,
            0,
            [
                [
                    "(?:20|[34]\\d|8[19])\\d{4}"
                ],
                [
                    "(?:[27][1-9]|5\\d|9[16])\\d{4}"
                ],
                [
                    "80[257-9]\\d{3}"
                ],
                [
                    "90(?:[13-5][15-7]|2[125-7]|9\\d)\\d\\d"
                ],
                0,
                0,
                0,
                0,
                [
                    "(?:6[0-36]|88)\\d{4}"
                ]
            ]
        ],
        "FR": [
            "33",
            "00",
            "[1-9]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "8"
                    ],
                    "0 $1"
                ],
                [
                    "(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4 $5",
                    [
                        "[1-79]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:26[013-9]|59[1-35-9])\\d{6}|(?:[13]\\d|2[0-57-9]|4[1-9]|5[0-8])\\d{7}"
                ],
                [
                    "(?:6(?:[0-24-8]\\d|3[0-8]|9[589])|7[3-9]\\d)\\d{6}"
                ],
                [
                    "80[0-5]\\d{6}"
                ],
                [
                    "836(?:0[0-36-9]|[1-9]\\d)\\d{4}|8(?:1[2-9]|2[2-47-9]|3[0-57-9]|[569]\\d|8[0-35-9])\\d{6}"
                ],
                0,
                0,
                [
                    "80[6-9]\\d{6}"
                ],
                0,
                [
                    "9\\d{8}"
                ],
                [
                    "8(?:1[01]|2[0156]|4[024]|84)\\d{6}"
                ]
            ]
        ],
        "GA": [
            "241",
            "00",
            "(?:[067]\\d|11)\\d{6}|[2-7]\\d{6}",
            [
                7,
                8
            ],
            [
                [
                    "(\\d)(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[2-7]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "0"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "11|[67]"
                    ],
                    "0$1"
                ]
            ],
            0,
            0,
            "0(11\\d{6}|60\\d{6}|61\\d{6}|6[256]\\d{6}|7[467]\\d{6})",
            "$1",
            0,
            0,
            [
                [
                    "[01]1\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "(?:(?:0[2-7]|7[467])\\d|6(?:0[0-4]|10|[256]\\d))\\d{5}|[2-7]\\d{6}"
                ]
            ]
        ],
        "GB": [
            "44",
            "00",
            "[1-357-9]\\d{9}|[18]\\d{8}|8\\d{6}",
            [
                7,
                9,
                10
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "800",
                        "8001",
                        "80011",
                        "800111",
                        "8001111"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3",
                    [
                        "845",
                        "8454",
                        "84546",
                        "845464"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{6})",
                    "$1 $2",
                    [
                        "800"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{5})(\\d{4,5})",
                    "$1 $2",
                    [
                        "1(?:38|5[23]|69|76|94)",
                        "1(?:(?:38|69)7|5(?:24|39)|768|946)",
                        "1(?:3873|5(?:242|39[4-6])|(?:697|768)[347]|9467)"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{5,6})",
                    "$1 $2",
                    [
                        "1(?:[2-69][02-9]|[78])"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[25]|7(?:0|6[02-9])",
                        "[25]|7(?:0|6(?:[03-9]|2[356]))"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{6})",
                    "$1 $2",
                    [
                        "7"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[1389]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1(?:1(?:3(?:[0-58]\\d\\d|73[0-35])|4(?:(?:[0-5]\\d|70)\\d|69[7-9])|(?:(?:5[0-26-9]|[78][0-49])\\d|6(?:[0-4]\\d|50))\\d)|(?:2(?:(?:0[024-9]|2[3-9]|3[3-79]|4[1-689]|[58][02-9]|6[0-47-9]|7[013-9]|9\\d)\\d|1(?:[0-7]\\d|8[0-3]))|(?:3(?:0\\d|1[0-8]|[25][02-9]|3[02-579]|[468][0-46-9]|7[1-35-79]|9[2-578])|4(?:0[03-9]|[137]\\d|[28][02-57-9]|4[02-69]|5[0-8]|[69][0-79])|5(?:0[1-35-9]|[16]\\d|2[024-9]|3[015689]|4[02-9]|5[03-9]|7[0-35-9]|8[0-468]|9[0-57-9])|6(?:0[034689]|1\\d|2[0-35689]|[38][013-9]|4[1-467]|5[0-69]|6[13-9]|7[0-8]|9[0-24578])|7(?:0[0246-9]|2\\d|3[0236-8]|4[03-9]|5[0-46-9]|6[013-9]|7[0-35-9]|8[024-9]|9[02-9])|8(?:0[35-9]|2[1-57-9]|3[02-578]|4[0-578]|5[124-9]|6[2-69]|7\\d|8[02-9]|9[02569])|9(?:0[02-589]|[18]\\d|2[02-689]|3[1-57-9]|4[2-9]|5[0-579]|6[2-47-9]|7[0-24578]|9[2-57]))\\d)\\d)|2(?:0[013478]|3[0189]|4[017]|8[0-46-9]|9[0-2])\\d{3})\\d{4}|1(?:2(?:0(?:46[1-4]|87[2-9])|545[1-79]|76(?:2\\d|3[1-8]|6[1-6])|9(?:7(?:2[0-4]|3[2-5])|8(?:2[2-8]|7[0-47-9]|8[3-5])))|3(?:6(?:38[2-5]|47[23])|8(?:47[04-9]|64[0157-9]))|4(?:044[1-7]|20(?:2[23]|8\\d)|6(?:0(?:30|5[2-57]|6[1-8]|7[2-8])|140)|8(?:052|87[1-3]))|5(?:2(?:4(?:3[2-79]|6\\d)|76\\d)|6(?:26[06-9]|686))|6(?:06(?:4\\d|7[4-79])|295[5-7]|35[34]\\d|47(?:24|61)|59(?:5[08]|6[67]|74)|9(?:55[0-4]|77[23]))|7(?:26(?:6[13-9]|7[0-7])|(?:442|688)\\d|50(?:2[0-3]|[3-68]2|76))|8(?:27[56]\\d|37(?:5[2-5]|8[239])|843[2-58])|9(?:0(?:0(?:6[1-8]|85)|52\\d)|3583|4(?:66[1-8]|9(?:2[01]|81))|63(?:23|3[1-4])|9561))\\d{3}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "7(?:457[0-57-9]|700[01]|911[028])\\d{5}|7(?:[1-3]\\d\\d|4(?:[0-46-9]\\d|5[0-689])|5(?:0[0-8]|[13-9]\\d|2[0-35-9])|7(?:0[1-9]|[1-7]\\d|8[02-9]|9[0-689])|8(?:[014-9]\\d|[23][0-8])|9(?:[024-9]\\d|1[02-9]|3[0-689]))\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "80[08]\\d{7}|800\\d{6}|8001111"
                ],
                [
                    "(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[2-49]))\\d{7}|845464\\d",
                    [
                        7,
                        10
                    ]
                ],
                [
                    "70\\d{8}",
                    [
                        10
                    ]
                ],
                0,
                [
                    "(?:3[0347]|55)\\d{8}",
                    [
                        10
                    ]
                ],
                [
                    "76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "56\\d{8}",
                    [
                        10
                    ]
                ]
            ],
            0,
            " x"
        ],
        "GD": [
            "1",
            "011",
            "(?:473|[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-9]\\d{6})$|1",
            "473$1",
            0,
            "473",
            [
                [
                    "473(?:2(?:3[0-2]|69)|3(?:2[89]|86)|4(?:[06]8|3[5-9]|4[0-4]|5[59]|73|90)|63[68]|7(?:58|84)|800|938)\\d{4}"
                ],
                [
                    "473(?:4(?:0[2-79]|1[04-9]|2[0-5]|49|5[6-8])|5(?:2[01]|3[3-8])|901)\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "GE": [
            "995",
            "00",
            "(?:[3-57]\\d\\d|800)\\d{6}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "70"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "32"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[57]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[348]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:3(?:[256]\\d|4[124-9]|7[0-4])|4(?:1\\d|2[2-7]|3[1-79]|4[2-8]|7[239]|9[1-7]))\\d{6}"
                ],
                [
                    "5(?:(?:(?:0555|1(?:[17]77|555))[5-9]|757(?:7[7-9]|8[01]))\\d|22252[0-4])\\d\\d|5(?:0(?:0[17]0|505)|1(?:0[01]0|1(?:07|33|51))|2(?:0[02]0|2[25]2)|3(?:0[03]0|3[35]3)|(?:40[04]|900)0|5222)[0-4]\\d{3}|(?:5(?:0(?:0(?:0\\d|11|22|3[0-6]|44|5[05]|77|88|9[09])|(?:[14]\\d|77)\\d|22[02])|1(?:1(?:[03][01]|[124]\\d|5[2-6]|7[0-4])|4\\d\\d)|[23]555|4(?:4\\d\\d|555)|5(?:[0157-9]\\d\\d|200|333|444)|6[89]\\d\\d|7(?:[0147-9]\\d\\d|5(?:00|[57]5))|8(?:0(?:[018]\\d|2[0-4])|5(?:55|8[89])|8(?:55|88))|9(?:090|[1-35-9]\\d\\d))|790\\d\\d)\\d{4}"
                ],
                [
                    "800\\d{6}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "70[67]\\d{6}"
                ]
            ]
        ],
        "GF": [
            "594",
            "00",
            "(?:[56]94\\d|7093)\\d{5}|(?:80|9\\d)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[5-7]|9[47]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[89]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "594(?:[02-49]\\d|1[0-5]|5[6-9]|6[0-3]|80)\\d{4}"
                ],
                [
                    "(?:694(?:[0-249]\\d|3[0-8])|7093[0-3])\\d{4}"
                ],
                [
                    "80[0-5]\\d{6}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "9(?:(?:396|76\\d)\\d|476[0-6])\\d{4}"
                ]
            ]
        ],
        "GG": [
            "44",
            "00",
            "(?:1481|[357-9]\\d{3})\\d{6}|8\\d{6}(?:\\d{2})?",
            [
                7,
                9,
                10
            ],
            0,
            "0",
            0,
            "([25-9]\\d{5})$|0",
            "1481$1",
            0,
            0,
            [
                [
                    "1481[25-9]\\d{5}",
                    [
                        10
                    ]
                ],
                [
                    "7(?:(?:781|839)\\d|911[17])\\d{5}",
                    [
                        10
                    ]
                ],
                [
                    "80[08]\\d{7}|800\\d{6}|8001111"
                ],
                [
                    "(?:8(?:4[2-5]|7[0-3])|9(?:[01]\\d|8[0-3]))\\d{7}|845464\\d",
                    [
                        7,
                        10
                    ]
                ],
                [
                    "70\\d{8}",
                    [
                        10
                    ]
                ],
                0,
                [
                    "(?:3[0347]|55)\\d{8}",
                    [
                        10
                    ]
                ],
                [
                    "76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "56\\d{8}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "GH": [
            "233",
            "00",
            "(?:[235]\\d{3}|800)\\d{5}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{3})(\\d{5})",
                    "$1 $2",
                    [
                        "8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[235]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "3082[0-5]\\d{4}|3(?:0(?:[237]\\d|8[01])|[167](?:2[0-6]|7\\d|80)|2(?:2[0-5]|7\\d|80)|3(?:2[0-3]|7\\d|80)|4(?:2[013-9]|3[01]|7\\d|80)|5(?:2[0-7]|7\\d|80)|8(?:2[0-2]|7\\d|80)|9(?:[28]0|7\\d))\\d{5}",
                    [
                        9
                    ]
                ],
                [
                    "(?:2(?:[0346-9]\\d|5[67])|5(?:[03-7]\\d|9[1-9]))\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{5}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "GI": [
            "350",
            "00",
            "(?:[25]\\d|60)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{3})(\\d{5})",
                    "$1 $2",
                    [
                        "2"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2190[0-2]\\d{3}|2(?:0(?:[02]\\d|3[01])|16[24-9]|2[2-5]\\d)\\d{4}"
                ],
                [
                    "5251[0-4]\\d{3}|(?:5(?:[146-8]\\d\\d|250)|60(?:1[01]|6\\d))\\d{4}"
                ]
            ]
        ],
        "GL": [
            "299",
            "00",
            "(?:19|[2-689]\\d|70)\\d{4}",
            [
                6
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3",
                    [
                        "19|[2-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:19|3[1-7]|[68][1-9]|70|9\\d)\\d{4}"
                ],
                [
                    "[245]\\d{5}"
                ],
                [
                    "80\\d{4}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "3[89]\\d{4}"
                ]
            ]
        ],
        "GM": [
            "220",
            "00",
            "[2-9]\\d{6}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[2-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:4(?:[23]\\d\\d|4(?:1[024679]|[6-9]\\d))|5(?:5(?:3\\d|4[0-7])|6[67]\\d|7(?:1[04]|2[035]|3[58]|48))|8\\d{3})\\d{3}"
                ],
                [
                    "(?:[23679]\\d|4[015]|5[0-489])\\d{5}"
                ]
            ]
        ],
        "GN": [
            "224",
            "00",
            "722\\d{6}|(?:3|6\\d)\\d{7}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "3"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[67]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "3(?:0(?:24|3[12]|4[1-35-7]|5[13]|6[189]|[78]1|9[1478])|1\\d\\d)\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "6[0-356]\\d{7}",
                    [
                        9
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "722\\d{6}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "GP": [
            "590",
            "00",
            "(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[5-79]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "8"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "590(?:0[1-68]|[14][0-24-9]|2[0-68]|3[1-9]|5[3-579]|[68][0-689]|7[08]|9\\d)\\d{4}"
                ],
                [
                    "(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"
                ],
                [
                    "80[0-5]\\d{6}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"
                ]
            ]
        ],
        "GQ": [
            "240",
            "00",
            "222\\d{6}|(?:3\\d|55|[89]0)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[235]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{6})",
                    "$1 $2",
                    [
                        "[89]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "33[0-24-9]\\d[46]\\d{4}|3(?:33|5\\d)\\d[7-9]\\d{4}"
                ],
                [
                    "(?:222|55\\d)\\d{6}"
                ],
                [
                    "80\\d[1-9]\\d{5}"
                ],
                [
                    "90\\d[1-9]\\d{5}"
                ]
            ]
        ],
        "GR": [
            "30",
            "00",
            "5005000\\d{3}|8\\d{9,11}|(?:[269]\\d|70)\\d{8}",
            [
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "21|7"
                    ]
                ],
                [
                    "(\\d{4})(\\d{6})",
                    "$1 $2",
                    [
                        "2(?:2|3[2-57-9]|4[2-469]|5[2-59]|6[2-9]|7[2-69]|8[2-49])|5"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[2689]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3,4})(\\d{5})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:1\\d\\d|2(?:2[1-46-9]|[36][1-8]|4[1-7]|5[1-4]|7[1-5]|[89][1-9])|3(?:1\\d|2[1-57]|[35][1-3]|4[13]|7[1-7]|8[124-6]|9[1-79])|4(?:1\\d|2[1-8]|3[1-4]|4[13-5]|6[1-578]|9[1-5])|5(?:1\\d|[29][1-4]|3[1-5]|4[124]|5[1-6])|6(?:1\\d|[269][1-6]|3[1245]|4[1-7]|5[13-9]|7[14]|8[1-5])|7(?:1\\d|2[1-5]|3[1-6]|4[1-7]|5[1-57]|6[135]|9[125-7])|8(?:1\\d|2[1-5]|[34][1-4]|9[1-57]))\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "68[57-9]\\d{7}|(?:69|94)\\d{8}",
                    [
                        10
                    ]
                ],
                [
                    "800\\d{7,9}"
                ],
                [
                    "90[19]\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "70\\d{8}",
                    [
                        10
                    ]
                ],
                0,
                [
                    "5005000\\d{3}",
                    [
                        10
                    ]
                ],
                0,
                0,
                [
                    "8(?:0[16]|12|[27]5|50)\\d{7}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "GT": [
            "502",
            "00",
            "80\\d{6}|(?:1\\d{3}|[2-7])\\d{7}",
            [
                8,
                11
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[2-8]"
                    ]
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "[267][2-9]\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "(?:[3-5]\\d\\d|80[0-4])\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "18[01]\\d{8}",
                    [
                        11
                    ]
                ],
                [
                    "19\\d{9}",
                    [
                        11
                    ]
                ]
            ]
        ],
        "GU": [
            "1",
            "011",
            "(?:[58]\\d\\d|671|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-9]\\d{6})$|1",
            "671$1",
            0,
            "671",
            [
                [
                    "671(?:2\\d\\d|3(?:00|3[39]|4[349]|55|6[26])|4(?:00|56|7[1-9]|8[02-9])|5(?:55|6[2-5]|88)|6(?:3[2-578]|4[24-9]|5[34]|78|8[235-9])|7(?:[0479]7|2[0167]|3[45]|8[7-9])|8(?:[2-57-9]8|6[478])|9(?:2[29]|6[79]|7[1279]|8[7-9]|9[78]))\\d{4}"
                ],
                [
                    ""
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "GW": [
            "245",
            "00",
            "[49]\\d{8}|4\\d{6}",
            [
                7,
                9
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "40"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[49]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "443\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "9(?:5\\d|6[569]|77)\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "40\\d{5}",
                    [
                        7
                    ]
                ]
            ]
        ],
        "GY": [
            "592",
            "001",
            "(?:[2-8]\\d{3}|9008)\\d{3}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[2-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:1[6-9]|2[0-35-9]|3[1-4]|5[3-9]|6\\d|7[0-79])|3(?:2[25-9]|3\\d)|4(?:4[0-24]|5[56])|50[0-6]|77[1-57])\\d{4}"
                ],
                [
                    "(?:510|6\\d\\d|7(?:[0-5]\\d|6[01]))\\d{4}"
                ],
                [
                    "(?:289|8(?:00|6[28]|88|99))\\d{4}"
                ],
                [
                    "9008\\d{3}"
                ],
                0,
                0,
                0,
                0,
                [
                    "515\\d{4}"
                ]
            ]
        ],
        "HK": [
            "852",
            "00(?:30|5[09]|[126-9]?)",
            "8[0-46-9]\\d{6,7}|9\\d{4,7}|(?:[2-7]|9\\d{3})\\d{7}",
            [
                5,
                6,
                7,
                8,
                9,
                11
            ],
            [
                [
                    "(\\d{3})(\\d{2,5})",
                    "$1 $2",
                    [
                        "900",
                        "9003"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[2-7]|8[1-4]|9(?:0[1-9]|[1-8])"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "9"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:[13-9]\\d|2[013-9])\\d|3(?:(?:[1569][0-24-9]|4[0-246-9]|7[0-24-69])\\d|8(?:4[0-8]|[579]\\d|6[0-2]))|58(?:0[1-9]|1[2-9]))\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "(?:4(?:44[0-35-9]|6(?:1[0-79]|4[0-57-9]|6[0-4])|7(?:[26][0-5]|4[0-28]))|5(?:73[0-6]|95[0-8])|6(?:26[013-8]|66[0-3]|78[0-5])|70(?:7[1-8]|8[0-4])|84(?:4[0-2]|8[0-35-9])|9(?:29[013-9]|39[014-9]|59[0-4]|899))\\d{4}|(?:4(?:4[0-35-9]|6[02357-9]|7[015])|5(?:[1-59][0-46-9]|6[0-4689]|7[0-246-9])|6(?:0[1-9]|[13-59]\\d|[268][0-57-9]|7[0-79])|70[1-59]|84[0-39]|9(?:0[1-9]|1[02-9]|[2358][0-8]|[467]\\d))\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "800\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "900(?:[0-24-9]\\d{7}|3\\d{1,4})",
                    [
                        5,
                        6,
                        7,
                        8,
                        11
                    ]
                ],
                [
                    "8(?:1[0-4679]\\d|2(?:[0-36]\\d|7[0-4])|3(?:[034]\\d|2[09]|70))\\d{4}",
                    [
                        8
                    ]
                ],
                0,
                [
                    "30(?:0[1-9]|[15-7]\\d|2[047]|89)\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "7(?:1(?:0[0-38]|1[0-3679]|3[013]|69|9[0136])|2(?:[02389]\\d|1[18]|7[27-9])|3(?:[0-38]\\d|7[0-369]|9[2357-9])|47\\d|5(?:[178]\\d|5[0-5])|6(?:0[0-7]|2[236-9]|[35]\\d)|7(?:[27]\\d|8[7-9])|8(?:[23689]\\d|7[1-9])|9(?:[025]\\d|6[0-246-8]|7[0-36-9]|8[238]))\\d{4}",
                    [
                        8
                    ]
                ]
            ],
            "00"
        ],
        "HN": [
            "504",
            "00",
            "8\\d{10}|[237-9]\\d{7}",
            [
                8,
                11
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1-$2",
                    [
                        "[237-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:2(?:0[0-59]|1[1-9]|[23]\\d|4[02-7]|5[57]|6[245]|7[0135689]|8[01346-9]|9[0-2])|4(?:0[578]|2[3-59]|3[13-9]|4[0-68]|5[1-3589])|5(?:0[2357-9]|1[1-356]|4[03-5]|5\\d|6[014-69]|7[04]|80)|6(?:[056]\\d|17|2[067]|3[047]|4[0-378]|[78][0-8]|9[01])|7(?:0[5-79]|6[46-9]|7[02-9]|8[034]|91)|8(?:79|8[0-357-9]|9[1-57-9]))\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "[37-9]\\d{7}",
                    [
                        8
                    ]
                ],
                [
                    "8002\\d{7}",
                    [
                        11
                    ]
                ]
            ]
        ],
        "HR": [
            "385",
            "00",
            "[2-69]\\d{8}|80\\d{5,7}|[1-79]\\d{7}|6\\d{6}",
            [
                7,
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "6[01]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2,3})",
                    "$1 $2 $3",
                    [
                        "8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{4})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "1"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "6|7[245]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "9"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[2-57]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "8"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "1\\d{7}|(?:2[0-3]|3[1-5]|4[02-47-9]|5[1-3])\\d{6,7}",
                    [
                        8,
                        9
                    ]
                ],
                [
                    "9(?:(?:0[1-9]|[12589]\\d)\\d\\d|7(?:[0679]\\d\\d|5(?:[01]\\d|44|55|77|9[5-79])))\\d{4}|98\\d{6}",
                    [
                        8,
                        9
                    ]
                ],
                [
                    "80\\d{5,7}"
                ],
                [
                    "6[01459]\\d{6}|6[01]\\d{5}",
                    [
                        7,
                        8
                    ]
                ],
                [
                    "7[45]\\d{6}",
                    [
                        8
                    ]
                ],
                0,
                [
                    "62\\d{6,7}|72\\d{6}",
                    [
                        8,
                        9
                    ]
                ]
            ]
        ],
        "HT": [
            "509",
            "00",
            "(?:[2-489]\\d|55)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[2-589]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:2\\d|5[1-5]|81|9[149])\\d{5}"
                ],
                [
                    "(?:[34]\\d|55)\\d{6}"
                ],
                [
                    "8\\d{7}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "9(?:[67][0-4]|8[0-3589]|9\\d)\\d{5}"
                ]
            ]
        ],
        "HU": [
            "36",
            "00",
            "[235-7]\\d{8}|[1-9]\\d{7}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1"
                    ],
                    "(06 $1)"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6|8[2-57-9]|9[2-69]"
                    ],
                    "(06 $1)"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[2-9]"
                    ],
                    "06 $1"
                ]
            ],
            "06",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1\\d|[27][2-9]|3[2-7]|4[24-9]|5[2-79]|6[23689]|8[2-57-9]|9[2-69])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "(?:[257]0|3[01])\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "(?:[48]0\\d|680[29])\\d{5}"
                ],
                [
                    "9[01]\\d{6}",
                    [
                        8
                    ]
                ],
                0,
                0,
                [
                    "38\\d{7}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "21\\d{7}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "ID": [
            "62",
            "00[89]",
            "00[1-9]\\d{9,14}|(?:[1-36]|8\\d{5})\\d{6}|00\\d{9}|[1-9]\\d{8,10}|[2-9]\\d{7}",
            [
                7,
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "15"
                    ]
                ],
                [
                    "(\\d{2})(\\d{5,9})",
                    "$1 $2",
                    [
                        "2[124]|[36]1"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{3})(\\d{5,7})",
                    "$1 $2",
                    [
                        "800"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{5,8})",
                    "$1 $2",
                    [
                        "[2-79]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{3})(\\d{3,4})(\\d{3})",
                    "$1-$2-$3",
                    [
                        "8[1-35-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{6,8})",
                    "$1 $2",
                    [
                        "1"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "804"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d)(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "80"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{4})(\\d{4,5})",
                    "$1-$2-$3",
                    [
                        "8"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2[124]\\d{7,8}|619\\d{8}|2(?:1(?:14|500)|2\\d{3})\\d{3}|61\\d{5,8}|(?:2(?:[35][1-4]|6[0-8]|7[1-6]|8\\d|9[1-8])|3(?:1|[25][1-8]|3[1-68]|4[1-3]|6[1-3568]|7[0-469]|8\\d)|4(?:0[1-589]|1[01347-9]|2[0-36-8]|3[0-24-68]|43|5[1-378]|6[1-5]|7[134]|8[1245])|5(?:1[1-35-9]|2[25-8]|3[124-9]|4[1-3589]|5[1-46]|6[1-8])|6(?:[25]\\d|3[1-69]|4[1-6])|7(?:02|[125][1-9]|[36]\\d|4[1-8]|7[0-36-9])|9(?:0[12]|1[013-8]|2[0-479]|5[125-8]|6[23679]|7[159]|8[01346]))\\d{5,8}",
                    [
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    "8[1-35-9]\\d{7,10}",
                    [
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    "00(?:1803\\d{5,11}|7803\\d{7})|(?:177\\d|800)\\d{5,7}",
                    [
                        8,
                        9,
                        10,
                        11,
                        12,
                        13,
                        14,
                        15,
                        16,
                        17
                    ]
                ],
                [
                    "809\\d{7}",
                    [
                        10
                    ]
                ],
                0,
                0,
                [
                    "(?:1500|8071\\d{3})\\d{3}",
                    [
                        7,
                        10
                    ]
                ],
                0,
                0,
                [
                    "804\\d{7}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "IE": [
            "353",
            "00",
            "(?:1\\d|[2569])\\d{6,8}|4\\d{6,9}|7\\d{8}|8\\d{8,9}",
            [
                7,
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{5})",
                    "$1 $2",
                    [
                        "2[24-9]|47|58|6[237-9]|9[35-9]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{3})(\\d{5})",
                    "$1 $2",
                    [
                        "[45]0"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d)(\\d{3,4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[2569]|4[1-69]|7[14]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "70"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "81"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[78]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "1"
                    ]
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "4"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3 $4",
                    [
                        "8"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1\\d|21)\\d{6,7}|(?:2[24-9]|4(?:0[24]|5\\d|7)|5(?:0[45]|1\\d|8)|6(?:1\\d|[237-9])|9(?:1\\d|[35-9]))\\d{5}|(?:23|4(?:[1-469]|8\\d)|5[23679]|6[4-6]|7[14]|9[04])\\d{7}"
                ],
                [
                    "8(?:22|[35-9]\\d)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "1800\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "15(?:1[2-8]|[2-8]0|9[089])\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "700\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "88210[1-9]\\d{4}|8(?:[35-79]5\\d\\d|8(?:[013-9]\\d\\d|2(?:[01][1-9]|[2-9]\\d)))\\d{5}",
                    [
                        10
                    ]
                ],
                [
                    "818\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "76\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "18[59]0\\d{6}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "IL": [
            "972",
            "0(?:0|1[2-9])",
            "1\\d{6}(?:\\d{3,5})?|[57]\\d{8}|[1-489]\\d{7}",
            [
                7,
                8,
                9,
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{4})(\\d{3})",
                    "$1-$2",
                    [
                        "125"
                    ]
                ],
                [
                    "(\\d{4})(\\d{2})(\\d{2})",
                    "$1-$2-$3",
                    [
                        "121"
                    ]
                ],
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "[2-489]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "[57]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{3})",
                    "$1-$2-$3",
                    [
                        "12"
                    ]
                ],
                [
                    "(\\d{4})(\\d{6})",
                    "$1-$2",
                    [
                        "159"
                    ]
                ],
                [
                    "(\\d)(\\d{3})(\\d{3})(\\d{3})",
                    "$1-$2-$3-$4",
                    [
                        "1[7-9]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{1,2})(\\d{3})(\\d{4})",
                    "$1-$2 $3-$4",
                    [
                        "15"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "153\\d{8,9}|29[1-9]\\d{5}|(?:2[0-8]|[3489]\\d)\\d{6}",
                    [
                        8,
                        11,
                        12
                    ]
                ],
                [
                    "55(?:4(?:[01]0|5[0-2])|57[0-289])\\d{4}|5(?:(?:[0-2][02-9]|[36]\\d|[49][2-9]|8[3-7])\\d|5(?:01|2\\d|3[0-3]|4[34]|5[0-25689]|6[6-8]|7[0-267]|8[7-9]|9[1-9]))\\d{5}",
                    [
                        9
                    ]
                ],
                [
                    "1(?:255|80[019]\\d{3})\\d{3}",
                    [
                        7,
                        10
                    ]
                ],
                [
                    "1212\\d{4}|1(?:200|9(?:0[0-2]|19))\\d{6}",
                    [
                        8,
                        10
                    ]
                ],
                0,
                [
                    "151\\d{8,9}",
                    [
                        11,
                        12
                    ]
                ],
                [
                    "1599\\d{6}",
                    [
                        10
                    ]
                ],
                0,
                [
                    "7(?:38(?:[05]\\d|8[08])|8(?:33|55|77|81)\\d)\\d{4}|7(?:18|2[23]|3[237]|47|6[258]|7\\d|82|9[2-9])\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "1700\\d{6}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "IM": [
            "44",
            "00",
            "1624\\d{6}|(?:[3578]\\d|90)\\d{8}",
            [
                10
            ],
            0,
            "0",
            0,
            "([25-8]\\d{5})$|0",
            "1624$1",
            0,
            "74576|(?:16|7[56])24",
            [
                [
                    "1624(?:230|[5-8]\\d\\d)\\d{3}"
                ],
                [
                    "76245[06]\\d{4}|7(?:4576|[59]24\\d|624[0-4689])\\d{5}"
                ],
                [
                    "808162\\d{4}"
                ],
                [
                    "8(?:440[49]06|72299\\d)\\d{3}|(?:8(?:45|70)|90[0167])624\\d{4}"
                ],
                [
                    "70\\d{8}"
                ],
                0,
                [
                    "3440[49]06\\d{3}|(?:3(?:08162|3\\d{4}|45624|7(?:0624|2299))|55\\d{4})\\d{4}"
                ],
                0,
                [
                    "56\\d{8}"
                ]
            ]
        ],
        "IN": [
            "91",
            "00",
            "(?:000800|[2-9]\\d\\d)\\d{7}|1\\d{7,12}",
            [
                8,
                9,
                10,
                11,
                12,
                13
            ],
            [
                [
                    "(\\d{8})",
                    "$1",
                    [
                        "5(?:0|2[23]|3[03]|[67]1|88)",
                        "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|888)",
                        "5(?:0|2(?:21|3)|3(?:0|3[23])|616|717|8888)"
                    ],
                    0,
                    1
                ],
                [
                    "(\\d{4})(\\d{4,5})",
                    "$1 $2",
                    [
                        "180",
                        "1800"
                    ],
                    0,
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "140"
                    ],
                    0,
                    1
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "11|2[02]|33|4[04]|79[1-7]|80[2-46]",
                        "11|2[02]|33|4[04]|79(?:[1-6]|7[19])|80(?:[2-4]|6[0-589])",
                        "11|2[02]|33|4[04]|79(?:[124-6]|3(?:[02-9]|1[0-24-9])|7(?:1|9[1-6]))|80(?:[2-4]|6[0-589])"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1(?:2[0-249]|3[0-25]|4[145]|[68]|7[1257])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|5[12]|[78]1)|6(?:12|[2-4]1|5[17]|6[13]|80)|7(?:12|3[134]|4[47]|61|88)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91)|(?:43|59|75)[15]|(?:1[59]|29|67|72)[14]",
                        "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|674|7(?:(?:2[14]|3[34]|5[15])[2-6]|61[346]|88[0-8])|8(?:70[2-6]|84[235-7]|91[3-7])|(?:1(?:29|60|8[06])|261|552|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))[2-7]",
                        "1(?:2[0-24]|3[0-25]|4[145]|[59][14]|6[1-9]|7[1257]|8[1-57-9])|2(?:1[257]|3[013]|4[01]|5[0137]|6[058]|78|8[1568]|9[14])|3(?:26|4[1-3]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[0-24-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12(?:[2-6]|7[0-8])|74[2-7])|7(?:(?:2[14]|5[15])[2-6]|3171|61[346]|88(?:[2-7]|82))|8(?:70[2-6]|84(?:[2356]|7[19])|91(?:[3-6]|7[19]))|73[134][2-6]|(?:74[47]|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[2-6]|7[19])|(?:1(?:29|60|8[06])|261|552|6(?:[2-4]1|5[17]|6[13]|7(?:1|4[0189])|80)|7(?:12|88[01]))[2-7]"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2[2457-9]|3[2-5]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1[013-9]|28|3[129]|4[1-35689]|5[29]|6[02-5]|70)|807",
                        "1(?:[2-479]|5[0235-9])|[2-5]|6(?:1[1358]|2(?:[2457]|84|95)|3(?:[2-4]|55)|4[235-7]|5[2-689]|6[24578]|7[235689]|8[1-6])|7(?:1(?:[013-8]|9[6-9])|28[6-8]|3(?:17|2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4|5[0-367])|70[13-7])|807[19]",
                        "1(?:[2-479]|5(?:[0236-9]|5[013-9]))|[2-5]|6(?:2(?:84|95)|355|83)|73179|807(?:1|9[1-3])|(?:1552|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])\\d|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-57])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]))[2-7]"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{5})(\\d{5})",
                    "$1 $2",
                    [
                        "[6-9]"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{4})(\\d{2,4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1(?:6|8[06])",
                        "1(?:6|8[06]0)"
                    ],
                    0,
                    1
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "18"
                    ],
                    0,
                    1
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2717(?:[2-7]\\d|95)\\d{4}|(?:271[0-689]|782[0-6])[2-7]\\d{5}|(?:170[24]|2(?:(?:[02][2-79]|90)\\d|80[13468])|(?:3(?:23|80)|683|79[1-7])\\d|4(?:20[24]|72[2-8])|552[1-7])\\d{6}|(?:11|33|4[04]|80)[2-7]\\d{7}|(?:342|674|788)(?:[0189][2-7]|[2-7]\\d)\\d{5}|(?:1(?:2[0-249]|3[0-25]|4[145]|[59][14]|6[014]|7[1257]|8[01346])|2(?:1[257]|3[013]|4[01]|5[0137]|6[0158]|78|8[1568]|9[14])|3(?:26|4[13]|5[34]|6[01489]|7[02-46]|8[159])|4(?:1[36]|2[1-47]|3[15]|5[12]|6[0-26-9]|7[014-9]|8[013-57]|9[014-7])|5(?:1[025]|22|[36][25]|4[28]|[578]1|9[15])|6(?:12|[2-47]1|5[17]|6[13]|80)|7(?:12|2[14]|3[134]|4[47]|5[15]|[67]1)|8(?:16|2[014]|3[126]|6[136]|7[078]|8[34]|91))[2-7]\\d{6}|(?:1(?:2[35-8]|3[346-9]|4[236-9]|[59][0235-9]|6[235-9]|7[34689]|8[257-9])|2(?:1[134689]|3[24-8]|4[2-8]|5[25689]|6[2-4679]|7[3-79]|8[2-479]|9[235-9])|3(?:01|1[79]|2[1245]|4[5-8]|5[125689]|6[235-7]|7[157-9]|8[2-46-8])|4(?:1[14578]|2[5689]|3[2-467]|5[4-7]|6[35]|73|8[2689]|9[2389])|5(?:[16][146-9]|2[14-8]|3[1346]|4[14-69]|5[46]|7[2-4]|8[2-8]|9[246])|6(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|7[235689]|8[124-6])|7(?:1[013-9]|2[0235-9]|3[2679]|4[1-35689]|5[2-46-9]|[67][02-9]|8[013-7]|9[089])|8(?:1[1357-9]|2[235-8]|3[03-57-9]|4[0-24-9]|5\\d|6[2457-9]|7[1-6]|8[1256]|9[2-4]))\\d[2-7]\\d{5}",
                    [
                        10
                    ]
                ],
                [
                    "(?:61279|7(?:887[02-9]|9(?:313|79[07-9]))|8(?:079[04-9]|(?:84|91)7[02-8]))\\d{5}|(?:6(?:12|[2-47]1|5[17]|6[13]|80)[0189]|7(?:1(?:2[0189]|9[0-5])|2(?:[14][017-9]|8[0-59])|3(?:2[5-8]|[34][017-9]|9[016-9])|4(?:1[015-9]|[29][89]|39|8[389])|5(?:[15][017-9]|2[04-9]|9[7-9])|6(?:0[0-47]|1[0-257-9]|2[0-4]|3[19]|5[4589])|70[0289]|88[089]|97[02-8])|8(?:0(?:6[67]|7[02-8])|70[017-9]|84[01489]|91[0-289]))\\d{6}|(?:7(?:31|4[47])|8(?:16|2[014]|3[126]|6[136]|7[78]|83))(?:[0189]\\d|7[02-8])\\d{5}|(?:6(?:[09]\\d|1[04679]|2[03689]|3[05-9]|4[0489]|50|6[069]|7[07]|8[7-9])|7(?:0\\d|2[0235-79]|3[05-8]|40|5[0346-8]|6[6-9]|7[1-9]|8[0-79]|9[089])|8(?:0[01589]|1[0-57-9]|2[235-9]|3[03-57-9]|[45]\\d|6[02457-9]|7[1-69]|8[0-25-9]|9[02-9])|9\\d\\d)\\d{7}|(?:6(?:(?:1[1358]|2[2457]|3[2-4]|4[235-7]|5[2-689]|6[24578]|8[124-6])\\d|7(?:[235689]\\d|4[0189]))|7(?:1(?:[013-8]\\d|9[6-9])|28[6-8]|3(?:2[0-49]|9[2-5])|4(?:1[2-4]|[29][0-7]|3[0-8]|[56]\\d|8[0-24-7])|5(?:2[1-3]|9[0-6])|6(?:0[5689]|2[5-9]|3[02-8]|4\\d|5[0-367])|70[13-7]|881))[0189]\\d{5}",
                    [
                        10
                    ]
                ],
                [
                    "000800\\d{7}|1(?:600\\d{6}|80(?:0\\d{4,9}|3\\d{9}))"
                ],
                [
                    "186[12]\\d{9}",
                    [
                        13
                    ]
                ],
                0,
                0,
                [
                    "140\\d{7}",
                    [
                        10
                    ]
                ],
                0,
                0,
                [
                    "1860\\d{7}",
                    [
                        11
                    ]
                ]
            ]
        ],
        "IO": [
            "246",
            "00",
            "3\\d{6}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "3"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "37\\d{5}"
                ],
                [
                    "38\\d{5}"
                ]
            ]
        ],
        "IQ": [
            "964",
            "00",
            "(?:1|7\\d\\d)\\d{7}|[2-6]\\d{7,8}",
            [
                8,
                9,
                10
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[2-6]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "7"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "1\\d{7}|(?:2[13-5]|3[02367]|4[023]|5[03]|6[026])\\d{6,7}",
                    [
                        8,
                        9
                    ]
                ],
                [
                    "7[3-9]\\d{8}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "IR": [
            "98",
            "00",
            "[1-9]\\d{9}|(?:[1-8]\\d\\d|9)\\d{3,4}",
            [
                4,
                5,
                6,
                7,
                10
            ],
            [
                [
                    "(\\d{4,5})",
                    "$1",
                    [
                        "96"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{4,5})",
                    "$1 $2",
                    [
                        "(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])[12689]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "9"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[1-8]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1[137]|2[13-68]|3[1458]|4[145]|5[1468]|6[16]|7[1467]|8[13467])(?:[03-57]\\d{7}|[16]\\d{3}(?:\\d{4})?|[289]\\d{3}(?:\\d(?:\\d{3})?)?)|94(?:000[09]|(?:12\\d|30[0-2])\\d|2(?:121|[2689]0\\d)|4(?:111|40\\d))\\d{4}",
                    [
                        6,
                        7,
                        10
                    ]
                ],
                [
                    "9(?:(?:0(?:[0-35]\\d|4[4-6])|(?:[13]\\d|2[0-3])\\d)\\d|9(?:[0-46]\\d\\d|5[15]0|8(?:[12]\\d|88)|9(?:0[0-3]|[19]\\d|21|69|77|8[7-9])))\\d{5}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "96(?:0[12]|2[16-8]|3(?:08|[14]5|[23]|66)|4(?:0|80)|5[01]|6[89]|86|9[19])",
                    [
                        4,
                        5
                    ]
                ]
            ]
        ],
        "IS": [
            "354",
            "00|1(?:0(?:01|[12]0)|100)",
            "(?:38\\d|[4-9])\\d{6}",
            [
                7,
                9
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[4-9]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "3"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:4(?:1[0-24-69]|2[0-7]|[37][0-8]|4[0-24589]|5[0-68]|6\\d|8[0-36-8])|5(?:05|[156]\\d|2[02578]|3[0-579]|4[03-7]|7[0-2578]|8[0-35-9]|9[013-689])|872)\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "(?:38[589]\\d\\d|6(?:1[1-8]|2[0-6]|3[026-9]|4[014679]|5[0159]|6[0-69]|70|8[06-8]|9\\d)|7(?:5[057]|[6-9]\\d)|8(?:2[0-59]|[3-69]\\d|8[238]))\\d{4}"
                ],
                [
                    "80[0-8]\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "90(?:0\\d|1[5-79]|2[015-79]|3[135-79]|4[125-7]|5[25-79]|7[1-37]|8[0-35-7])\\d{3}",
                    [
                        7
                    ]
                ],
                0,
                [
                    "(?:689|8(?:7[18]|80)|95[48])\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "809\\d{4}",
                    [
                        7
                    ]
                ],
                0,
                [
                    "49[0-24-79]\\d{4}",
                    [
                        7
                    ]
                ]
            ],
            "00"
        ],
        "IT": [
            "39",
            "00",
            "0\\d{5,10}|1\\d{8,10}|3(?:[0-8]\\d{7,10}|9\\d{7,8})|(?:43|55|70)\\d{8}|8\\d{5}(?:\\d{2,4})?",
            [
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{2})(\\d{4,6})",
                    "$1 $2",
                    [
                        "0[26]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3,6})",
                    "$1 $2",
                    [
                        "0[13-57-9][0159]|8(?:03|4[17]|9[2-5])",
                        "0[13-57-9][0159]|8(?:03|4[17]|9(?:2|3[04]|[45][0-4]))"
                    ]
                ],
                [
                    "(\\d{4})(\\d{2,6})",
                    "$1 $2",
                    [
                        "0(?:[13-579][2-46-8]|8[236-8])"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "894"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3,4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "0[26]|5"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "1(?:44|[679])|[378]|43"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3,4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "0[13-57-9][0159]|14"
                    ]
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{5})",
                    "$1 $2 $3",
                    [
                        "0[26]"
                    ]
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "0"
                    ]
                ],
                [
                    "(\\d{3})(\\d{4})(\\d{4,5})",
                    "$1 $2 $3",
                    [
                        "3"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "0669[0-79]\\d{1,6}|0(?:1(?:[0159]\\d|[27][1-5]|31|4[1-4]|6[1356]|8[2-57])|2\\d\\d|3(?:[0159]\\d|2[1-4]|3[12]|[48][1-6]|6[2-59]|7[1-7])|4(?:[0159]\\d|[23][1-9]|4[245]|6[1-5]|7[1-4]|81)|5(?:[0159]\\d|2[1-5]|3[2-6]|4[1-79]|6[4-6]|7[1-578]|8[3-8])|6(?:[0-57-9]\\d|6[0-8])|7(?:[0159]\\d|2[12]|3[1-7]|4[2-46]|6[13569]|7[13-6]|8[1-59])|8(?:[0159]\\d|2[3-578]|3[1-356]|[6-8][1-5])|9(?:[0159]\\d|[238][1-5]|4[12]|6[1-8]|7[1-6]))\\d{2,7}",
                    [
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    "3[2-9]\\d{7,8}|(?:31|43)\\d{8}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "80(?:0\\d{3}|3)\\d{3}",
                    [
                        6,
                        9
                    ]
                ],
                [
                    "(?:0878\\d{3}|89(?:2\\d|3[04]|4(?:[0-4]|[5-9]\\d\\d)|5[0-4]))\\d\\d|(?:1(?:44|6[346])|89(?:38|5[5-9]|9))\\d{6}",
                    [
                        6,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "1(?:78\\d|99)\\d{6}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "3[2-8]\\d{9,10}",
                    [
                        11,
                        12
                    ]
                ],
                0,
                0,
                [
                    "55\\d{8}",
                    [
                        10
                    ]
                ],
                [
                    "84(?:[08]\\d{3}|[17])\\d{3}",
                    [
                        6,
                        9
                    ]
                ]
            ]
        ],
        "JE": [
            "44",
            "00",
            "1534\\d{6}|(?:[3578]\\d|90)\\d{8}",
            [
                10
            ],
            0,
            "0",
            0,
            "([0-24-8]\\d{5})$|0",
            "1534$1",
            0,
            0,
            [
                [
                    "1534[0-24-8]\\d{5}"
                ],
                [
                    "7(?:(?:(?:50|82)9|937)\\d|7(?:00[378]|97\\d))\\d{5}"
                ],
                [
                    "80(?:07(?:35|81)|8901)\\d{4}"
                ],
                [
                    "(?:8(?:4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|90(?:066[59]|1810|71(?:07|55)))\\d{4}"
                ],
                [
                    "701511\\d{4}"
                ],
                0,
                [
                    "(?:3(?:0(?:07(?:35|81)|8901)|3\\d{4}|4(?:4(?:4(?:05|42|69)|703)|5(?:041|800))|7(?:0002|1206))|55\\d{4})\\d{4}"
                ],
                [
                    "76(?:464|652)\\d{5}|76(?:0[0-28]|2[356]|34|4[01347]|5[49]|6[0-369]|77|8[14]|9[139])\\d{6}"
                ],
                [
                    "56\\d{8}"
                ]
            ]
        ],
        "JM": [
            "1",
            "011",
            "(?:[58]\\d\\d|658|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            0,
            0,
            0,
            "658|876",
            [
                [
                    "8766060\\d{3}|(?:658(?:2(?:[0-8]\\d|9[0-46-9])|[3-9]\\d\\d)|876(?:52[35]|6(?:0[1-3579]|1[0235-9]|[23]\\d|40|5[06]|6[2-589]|7[0-25-9]|8[04]|9[4-9])|7(?:0[2-689]|[1-6]\\d|8[056]|9[45])|9(?:0[1-8]|1[02378]|[2-8]\\d|9[2-468])))\\d{4}"
                ],
                [
                    "(?:658295|876(?:2(?:0[1-9]|[13-9]\\d|2[013-9])|[348]\\d\\d|5(?:0[1-9]|[1-9]\\d)|6(?:4[89]|6[67])|7(?:0[07]|7\\d|8[1-47-9]|9[0-36-9])|9(?:[01]9|9[0579])))\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "JO": [
            "962",
            "00",
            "(?:(?:[2689]|7\\d)\\d|32|53)\\d{6}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[2356]|87"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{3})(\\d{5,6})",
                    "$1 $2",
                    [
                        "[89]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{7})",
                    "$1 $2",
                    [
                        "70"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "7"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "87(?:000|90[01])\\d{3}|(?:2(?:6(?:2[0-35-9]|3[0-578]|4[24-7]|5[0-24-8]|[6-8][023]|9[0-3])|7(?:0[1-79]|10|2[014-7]|3[0-689]|4[019]|5[0-3578]))|32(?:0[1-69]|1[1-35-7]|2[024-7]|3\\d|4[0-3]|[5-7][023])|53(?:0[0-3]|[13][023]|2[0-59]|49|5[0-35-9]|6[15]|7[45]|8[1-6]|9[0-36-9])|6(?:2(?:[05]0|22)|3(?:00|33)|4(?:0[0-25]|1[2-7]|2[0569]|[38][07-9]|4[025689]|6[0-589]|7\\d|9[0-2])|5(?:[01][056]|2[034]|3[0-57-9]|4[178]|5[0-69]|6[0-35-9]|7[1-379]|8[0-68]|9[0239]))|87(?:20|7[078]|99))\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "7(?:[78][0-25-9]|9\\d)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "80\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "9\\d{7}",
                    [
                        8
                    ]
                ],
                [
                    "70\\d{7}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "8(?:10|8\\d)\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "74(?:66|77)\\d{5}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "85\\d{6}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "JP": [
            "81",
            "010",
            "00[1-9]\\d{6,14}|[257-9]\\d{9}|(?:00|[1-9]\\d\\d)\\d{6}",
            [
                8,
                9,
                10,
                11,
                12,
                13,
                14,
                15,
                16,
                17
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1-$2-$3",
                    [
                        "(?:12|57|99)0"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d)(\\d{4})",
                    "$1-$2-$3",
                    [
                        "1(?:26|3[79]|4[56]|5[4-68]|6[3-5])|499|5(?:76|97)|746|8(?:3[89]|47|51)|9(?:80|9[16])",
                        "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:76|97)9|7468|8(?:3(?:8[7-9]|96)|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]",
                        "1(?:267|3(?:7[247]|9[278])|466|5(?:47|58|64)|6(?:3[245]|48|5[4-68]))|499[2468]|5(?:769|979[2-69])|7468|8(?:3(?:8[7-9]|96[2457-9])|477|51[2-9])|9(?:802|9(?:1[23]|69))|1(?:45|58)[67]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "60"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{4})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "[36]|4(?:2[09]|7[01])",
                        "[36]|4(?:2(?:0|9[02-69])|7(?:0[019]|1))"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "1(?:1|5[45]|77|88|9[69])|2(?:2[1-37]|3[0-269]|4[59]|5|6[24]|7[1-358]|8[1369]|9[0-38])|4(?:[28][1-9]|3[0-57]|[45]|6[248]|7[2-579]|9[29])|5(?:2|3[0459]|4[0-369]|5[29]|8[02389]|9[0-389])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9[2-6])|8(?:2[124589]|3[26-9]|49|51|6|7[0-468]|8[68]|9[019])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9[1-489])",
                        "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2(?:[127]|3[014-9])|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9[19])|62|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|8[1-9]|9[29])|5(?:2|3(?:[045]|9[0-8])|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0-2469])|3(?:[29]|60)|49|51|6(?:[0-24]|36|5[0-3589]|7[23]|9[01459])|7[0-468]|8[68])|9(?:[23][1-9]|4[15]|5[138]|6[1-3]|7[156]|8[189]|9(?:[1289]|3[34]|4[0178]))|(?:264|837)[016-9]|2(?:57|93)[015-9]|(?:25[0468]|422|838)[01]|(?:47[59]|59[89]|8(?:6[68]|9))[019]",
                        "1(?:1|5(?:4[018]|5[017])|77|88|9[69])|2(?:2[127]|3[0-269]|4[59]|5(?:[1-3]|5[0-69]|9(?:17|99))|6(?:2|4[016-9])|7(?:[1-35]|8[0189])|8(?:[16]|3[0134]|9[0-5])|9(?:[028]|17))|4(?:2(?:[13-79]|8[014-6])|3[0-57]|[45]|6[248]|7[2-47]|9[29])|5(?:2|3(?:[045]|9(?:[0-58]|6[4-9]|7[0-35689]))|4[0-369]|5[29]|8[02389]|9[0-3])|7(?:2[02-46-9]|34|[58]|6[0249]|7[57]|9(?:[23]|4[0-59]|5[01569]|6[0167]))|8(?:2(?:[1258]|4[0-39]|9[0169])|3(?:[29]|60|7(?:[017-9]|6[6-8]))|49|51|6(?:[0-24]|36[2-57-9]|5(?:[0-389]|5[23])|6(?:[01]|9[178])|7(?:2[2-468]|3[78])|9[0145])|7[0-468]|8[68])|9(?:4[15]|5[138]|7[156]|8[189]|9(?:[1289]|3(?:31|4[357])|4[0178]))|(?:8294|96)[1-3]|2(?:57|93)[015-9]|(?:223|8699)[014-9]|(?:25[0468]|422|838)[01]|(?:48|8292|9[23])[1-9]|(?:47[59]|59[89]|8(?:68|9))[019]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "[14]|[289][2-9]|5[3-9]|7[2-4679]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "800"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "[257-9]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            "(000[259]\\d{6})$|(?:(?:003768)0?)|0",
            "$1",
            0,
            0,
            [
                [
                    "(?:1(?:1[235-8]|2[3-6]|3[3-9]|4[2-6]|[58][2-8]|6[2-7]|7[2-9]|9[1-9])|(?:2[2-9]|[36][1-9])\\d|4(?:[2-578]\\d|6[02-8]|9[2-59])|5(?:[2-589]\\d|6[1-9]|7[2-8])|7(?:[25-9]\\d|3[4-9]|4[02-9])|8(?:[2679]\\d|3[2-9]|4[5-9]|5[1-9]|8[03-9])|9(?:[2-58]\\d|[679][1-9]))\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "[7-9]0[1-9]\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "00777(?:[01]|5\\d)\\d\\d|(?:00(?:7778|882[1245])|(?:120|800\\d)\\d\\d)\\d{4}|00(?:37|66|78)\\d{6,13}"
                ],
                [
                    "990\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "60\\d{7}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "570\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "20\\d{8}",
                    [
                        10
                    ]
                ],
                [
                    "50[1-9]\\d{7}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "KE": [
            "254",
            "000",
            "(?:[17]\\d\\d|900)\\d{6}|(?:2|80)0\\d{6,7}|[4-6]\\d{6,8}",
            [
                7,
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{5,7})",
                    "$1 $2",
                    [
                        "[24-6]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{6})",
                    "$1 $2",
                    [
                        "[17]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[89]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:4[245]|5[1-79]|6[01457-9])\\d{5,7}|(?:4[136]|5[08]|62)\\d{7}|(?:[24]0|66)\\d{6,7}",
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "(?:1(?:0[0-8]|1[0-7]|2[014]|30)|7\\d\\d)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "800[02-8]\\d{5,6}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "900[02-9]\\d{5}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "KG": [
            "996",
            "00",
            "8\\d{9}|[235-9]\\d{8}",
            [
                9,
                10
            ],
            [
                [
                    "(\\d{4})(\\d{5})",
                    "$1 $2",
                    [
                        "3(?:1[346]|[24-79])"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[235-79]|88"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d)(\\d{2,3})",
                    "$1 $2 $3 $4",
                    [
                        "8"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "312(?:5[0-79]\\d|9(?:[0-689]\\d|7[0-24-9]))\\d{3}|(?:3(?:1(?:2[0-46-8]|3[1-9]|47|[56]\\d)|2(?:22|3[0-479]|6[0-7])|4(?:22|5[6-9]|6\\d)|5(?:22|3[4-7]|59|6\\d)|6(?:22|5[35-7]|6\\d)|7(?:22|3[468]|4[1-9]|59|[67]\\d)|9(?:22|4[1-8]|6\\d))|6(?:09|12|2[2-4])\\d)\\d{5}",
                    [
                        9
                    ]
                ],
                [
                    "312(?:58\\d|973)\\d{3}|(?:2(?:0[0-35]|2\\d)|5[0-24-7]\\d|600|7(?:[07]\\d|55)|88[08]|9(?:12|9[05-9]))\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{6,7}"
                ]
            ]
        ],
        "KH": [
            "855",
            "00[14-9]",
            "1\\d{9}|[1-9]\\d{7,8}",
            [
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[1-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "1"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "23(?:4(?:[2-4]|[56]\\d)|[568]\\d\\d)\\d{4}|23[236-9]\\d{5}|(?:2[4-6]|3[2-6]|4[2-4]|[5-7][2-5])(?:(?:[237-9]|4[56]|5\\d)\\d{5}|6\\d{5,6})",
                    [
                        8,
                        9
                    ]
                ],
                [
                    "(?:(?:1[28]|3[18]|9[67])\\d|6[016-9]|7(?:[07-9]|[16]\\d)|8(?:[013-79]|8\\d))\\d{6}|(?:1\\d|9[0-57-9])\\d{6}|(?:2[3-6]|3[2-6]|4[2-4]|[5-7][2-5])48\\d{5}",
                    [
                        8,
                        9
                    ]
                ],
                [
                    "1800(?:1\\d|2[019])\\d{4}",
                    [
                        10
                    ]
                ],
                [
                    "1900(?:1\\d|2[09])\\d{4}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "KI": [
            "686",
            "00",
            "(?:[37]\\d|6[0-79])\\d{6}|(?:[2-48]\\d|50)\\d{3}",
            [
                5,
                8
            ],
            0,
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:[24]\\d|3[1-9]|50|65(?:02[12]|12[56]|22[89]|[3-5]00)|7(?:27\\d\\d|3100|5(?:02[12]|12[56]|22[89]|[34](?:00|81)|500))|8[0-5])\\d{3}"
                ],
                [
                    "(?:6200[01]|7(?:310[1-9]|5(?:02[03-9]|12[0-47-9]|22[0-7]|[34](?:0[1-9]|8[02-9])|50[1-9])))\\d{3}|(?:63\\d\\d|7(?:(?:[0146-9]\\d|2[0-689])\\d|3(?:[02-9]\\d|1[1-9])|5(?:[0-2][013-9]|[34][1-79]|5[1-9]|[6-9]\\d)))\\d{4}",
                    [
                        8
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "30(?:0[01]\\d\\d|12(?:11|20))\\d\\d",
                    [
                        8
                    ]
                ]
            ]
        ],
        "KM": [
            "269",
            "00",
            "[3478]\\d{6}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3",
                    [
                        "[3478]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "7[4-7]\\d{5}"
                ],
                [
                    "[34]\\d{6}"
                ],
                0,
                [
                    "8\\d{6}"
                ]
            ]
        ],
        "KN": [
            "1",
            "011",
            "(?:[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-7]\\d{6})$|1",
            "869$1",
            0,
            "869",
            [
                [
                    "869(?:2(?:29|36)|302|4(?:6[015-9]|70)|56[5-7])\\d{4}"
                ],
                [
                    "869(?:48[89]|55[6-8]|66\\d|76[02-7])\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "KP": [
            "850",
            "00|99",
            "85\\d{6}|(?:19\\d|[2-7])\\d{7}",
            [
                8,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[2-7]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:(?:195|2)\\d|3[19]|4[159]|5[37]|6[17]|7[39]|85)\\d{6}"
                ],
                [
                    "19[1-3]\\d{7}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "KR": [
            "82",
            "00(?:[125689]|3(?:[46]5|91)|7(?:00|27|3|55|6[126]))",
            "00[1-9]\\d{8,11}|(?:[12]|5\\d{3})\\d{7}|[13-6]\\d{9}|(?:[1-6]\\d|80)\\d{7}|[3-6]\\d{4,5}|(?:00|7)0\\d{8}",
            [
                5,
                6,
                8,
                9,
                10,
                11,
                12,
                13,
                14
            ],
            [
                [
                    "(\\d{2})(\\d{3,4})",
                    "$1-$2",
                    [
                        "(?:3[1-3]|[46][1-4]|5[1-5])1"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1-$2",
                    [
                        "1"
                    ]
                ],
                [
                    "(\\d)(\\d{3,4})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "2"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "[36]0|8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3,4})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "[1346]|5[1-5]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "[57]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{5})(\\d{4})",
                    "$1-$2-$3",
                    [
                        "5"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            "0(8(?:[1-46-8]|5\\d\\d))?",
            0,
            0,
            0,
            [
                [
                    "(?:2|3[1-3]|[46][1-4]|5[1-5])[1-9]\\d{6,7}|(?:3[1-3]|[46][1-4]|5[1-5])1\\d{2,3}",
                    [
                        5,
                        6,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "1(?:05(?:[0-8]\\d|9[0-6])|22[13]\\d)\\d{4,5}|1(?:0[0-46-9]|[16-9]\\d|2[013-9])\\d{6,7}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "00(?:308\\d{6,7}|798\\d{7,9})|(?:00368|[38]0)\\d{7}",
                    [
                        9,
                        11,
                        12,
                        13,
                        14
                    ]
                ],
                [
                    "60[2-9]\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "50\\d{8,9}",
                    [
                        10,
                        11
                    ]
                ],
                0,
                [
                    "1(?:5(?:22|33|44|66|77|88|99)|6(?:[07]0|44|6[0168]|88)|8(?:00|33|55|77|99))\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "15\\d{7,8}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "70\\d{8}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "KW": [
            "965",
            "00",
            "18\\d{5}|(?:[2569]\\d|41)\\d{6}",
            [
                7,
                8
            ],
            [
                [
                    "(\\d{4})(\\d{3,4})",
                    "$1 $2",
                    [
                        "[169]|2(?:[235]|4[1-35-9])|52"
                    ]
                ],
                [
                    "(\\d{3})(\\d{5})",
                    "$1 $2",
                    [
                        "[245]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:[23]\\d\\d|4(?:[1-35-9]\\d|44)|5(?:0[034]|[2-46]\\d|5[1-3]|7[1-7]))\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "(?:41\\d\\d|5(?:(?:[05]\\d|1[0-7]|6[56])\\d|2(?:22|5[25])|7(?:55|77)|88[58])|6(?:(?:0[034679]|5[015-9]|6\\d)\\d|1(?:00|11|6[16])|2[26]2|3[36]3|4[46]4|7(?:0[013-9]|[67]\\d)|8[68]8|9(?:[069]\\d|3[039]))|9(?:(?:[04679]\\d|8[057-9])\\d|1(?:1[01]|99)|2(?:00|2\\d)|3(?:00|3[03])|5(?:00|5\\d)))\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "18\\d{5}",
                    [
                        7
                    ]
                ]
            ]
        ],
        "KY": [
            "1",
            "011",
            "(?:345|[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-9]\\d{6})$|1",
            "345$1",
            0,
            "345",
            [
                [
                    "345(?:2(?:22|3[23]|44|66)|333|444|6(?:23|38|40)|7(?:30|4[35-79]|6[6-9]|77)|8(?:00|1[45]|4[89]|88)|9(?:14|4[035-9]))\\d{4}"
                ],
                [
                    "345(?:32[1-9]|42[0-4]|5(?:1[67]|2[5-79]|4[6-9]|50|76)|649|82[56]|9(?:1[679]|2[2-9]|3[06-9]|90))\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "(?:345976|900[2-9]\\d\\d)\\d{4}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "KZ": [
            "7",
            "810",
            "(?:33622|8\\d{8})\\d{5}|[78]\\d{9}",
            [
                10,
                14
            ],
            0,
            "8",
            0,
            0,
            0,
            0,
            "33|7",
            [
                [
                    "(?:33622|7(?:1(?:0(?:[23]\\d|4[0-3]|59|63)|1(?:[23]\\d|4[0-79]|59)|2(?:[23]\\d|59)|3(?:2\\d|3[0-79]|4[0-35-9]|59)|4(?:[24]\\d|3[013-9]|5[1-9]|97)|5(?:2\\d|3[1-9]|4[0-7]|59)|6(?:[2-4]\\d|5[19]|61)|72\\d|8(?:[27]\\d|3[1-46-9]|4[0-5]|59))|2(?:1(?:[23]\\d|4[46-9]|5[3469])|2(?:2\\d|3[0679]|46|5[12679])|3(?:[2-4]\\d|5[139])|4(?:2\\d|3[1-35-9]|59)|5(?:[23]\\d|4[0-8]|59|61)|6(?:2\\d|3[1-9]|4[0-4]|59)|7(?:[2379]\\d|40|5[279])|8(?:[23]\\d|4[0-3]|59)|9(?:2\\d|3[124578]|59))))\\d{5}",
                    [
                        10
                    ]
                ],
                [
                    "7(?:0[0-25-8]|47|6[0-4]|7[15-8]|85)\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "8(?:00|108\\d{3})\\d{7}"
                ],
                [
                    "809\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "808\\d{7}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                [
                    "751\\d{7}",
                    [
                        10
                    ]
                ]
            ],
            "8~10"
        ],
        "LA": [
            "856",
            "00",
            "[23]\\d{9}|3\\d{8}|(?:[235-8]\\d|41)\\d{6}",
            [
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "2[13]|3[14]|[4-8]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "3"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "[23]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2[13]|[35-7][14]|41|8[1468])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "(?:20(?:[23579]\\d|8[78])|30[24]\\d)\\d{6}|30\\d{7}",
                    [
                        9,
                        10
                    ]
                ]
            ]
        ],
        "LB": [
            "961",
            "00",
            "[27-9]\\d{7}|[13-9]\\d{6}",
            [
                7,
                8
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[13-69]|7(?:[2-57]|62|8[0-7]|9[04-9])|8[02-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[27-9]"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "7(?:62|8[0-6]|9[04-9])\\d{4}|(?:[14-69]\\d|2(?:[14-69]\\d|[78][1-9])|7[2-57]|8[02-9])\\d{5}"
                ],
                [
                    "787\\d{4}|(?:(?:3|81)\\d|7(?:[01]\\d|6[013-9]|8[89]|9[1-3]))\\d{5}"
                ],
                0,
                [
                    "9[01]\\d{6}",
                    [
                        8
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "80\\d{6}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "LC": [
            "1",
            "011",
            "(?:[58]\\d\\d|758|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-8]\\d{6})$|1",
            "758$1",
            0,
            "758",
            [
                [
                    "758(?:234|4(?:30|5\\d|6[2-9]|8[0-2])|57[0-2]|(?:63|75)8)\\d{4}"
                ],
                [
                    "758(?:28[4-7]|384|4(?:6[01]|8[4-9])|5(?:1[89]|20|84)|7(?:1[2-9]|2\\d|3[0-3])|812)\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "LI": [
            "423",
            "00",
            "[68]\\d{8}|(?:[2378]\\d|90)\\d{5}",
            [
                7,
                9
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3",
                    [
                        "[2379]|8(?:0[09]|7)",
                        "[2379]|8(?:0(?:02|9)|7)"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "69"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "6"
                    ]
                ]
            ],
            "0",
            0,
            "(1001)|0",
            0,
            0,
            0,
            [
                [
                    "(?:2(?:01|1[27]|2[02]|3\\d|6[02-578]|96)|3(?:[24]0|33|7[0135-7]|8[048]|9[0269]))\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "(?:6(?:(?:4[5-9]|5[0-469])\\d|6(?:[024-6]\\d|[17]0|3[7-9]))\\d|7(?:[37-9]\\d|42|56))\\d{4}"
                ],
                [
                    "8002[28]\\d\\d|80(?:05\\d|9)\\d{4}"
                ],
                [
                    "90(?:02[258]|1(?:23|3[14])|66[136])\\d\\d",
                    [
                        7
                    ]
                ],
                0,
                [
                    "697(?:42|56|[78]\\d)\\d{4}",
                    [
                        9
                    ]
                ],
                [
                    "870(?:28|87)\\d\\d",
                    [
                        7
                    ]
                ]
            ]
        ],
        "LK": [
            "94",
            "00",
            "[1-9]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "7"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[1-689]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:12[2-9]|602|8[12]\\d|9(?:1\\d|22|9[245]))\\d{6}|(?:11|2[13-7]|3[1-8]|4[157]|5[12457]|6[35-7])[2-57]\\d{6}"
                ],
                [
                    "7(?:[0-25-8]\\d|4[0-4])\\d{6}"
                ],
                0,
                0,
                0,
                0,
                [
                    "1973\\d{5}"
                ]
            ]
        ],
        "LR": [
            "231",
            "00",
            "(?:[245]\\d|33|77|88)\\d{7}|(?:2\\d|[4-6])\\d{6}",
            [
                7,
                8,
                9
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "4[67]|[56]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "2"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[2-578]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2\\d{7}",
                    [
                        8
                    ]
                ],
                [
                    "(?:(?:(?:22|33)0|555|(?:77|88)\\d)\\d|4(?:240|[67]))\\d{5}|[56]\\d{6}",
                    [
                        7,
                        9
                    ]
                ],
                0,
                [
                    "332(?:02|[34]\\d)\\d{4}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "LS": [
            "266",
            "00",
            "(?:[256]\\d\\d|800)\\d{5}",
            [
                8
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[2568]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2\\d{7}"
                ],
                [
                    "[56]\\d{7}"
                ],
                [
                    "800[1256]\\d{4}"
                ]
            ]
        ],
        "LT": [
            "370",
            "00",
            "(?:[3469]\\d|52|[78]0)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "52[0-7]"
                    ],
                    "(0-$1)",
                    1
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[7-9]"
                    ],
                    "0 $1",
                    1
                ],
                [
                    "(\\d{2})(\\d{6})",
                    "$1 $2",
                    [
                        "37|4(?:[15]|6[1-8])"
                    ],
                    "(0-$1)",
                    1
                ],
                [
                    "(\\d{3})(\\d{5})",
                    "$1 $2",
                    [
                        "[3-6]"
                    ],
                    "(0-$1)",
                    1
                ]
            ],
            "0",
            0,
            "[08]",
            0,
            0,
            0,
            [
                [
                    "(?:3[1478]|4[124-6]|52)\\d{6}"
                ],
                [
                    "6\\d{7}"
                ],
                [
                    "80[02]\\d{5}"
                ],
                [
                    "9(?:0[0239]|10)\\d{5}"
                ],
                [
                    "70[05]\\d{5}"
                ],
                0,
                [
                    "70[67]\\d{5}"
                ],
                0,
                [
                    "[89]01\\d{5}"
                ],
                [
                    "808\\d{5}"
                ]
            ]
        ],
        "LU": [
            "352",
            "00",
            "35[013-9]\\d{4,8}|6\\d{8}|35\\d{2,4}|(?:[2457-9]\\d|3[0-46-9])\\d{2,9}",
            [
                4,
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            [
                [
                    "(\\d{2})(\\d{3})",
                    "$1 $2",
                    [
                        "2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3",
                    [
                        "2(?:0[2-689]|[2-9])|[3-57]|8(?:0[2-9]|[13-9])|9(?:0[89]|[2-579])"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "20[2-689]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})",
                    "$1 $2 $3 $4",
                    [
                        "2(?:[0367]|4[3-8])"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "80[01]|90[015]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "20"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "6"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})(\\d{1,2})",
                    "$1 $2 $3 $4 $5",
                    [
                        "2(?:[0367]|4[3-8])"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{1,5})",
                    "$1 $2 $3 $4",
                    [
                        "[3-57]|8[13-9]|9(?:0[89]|[2-579])|(?:2|80)[2-9]"
                    ]
                ]
            ],
            0,
            0,
            "(15(?:0[06]|1[12]|[35]5|4[04]|6[26]|77|88|99)\\d)",
            0,
            0,
            0,
            [
                [
                    "(?:35[013-9]|80[2-9]|90[89])\\d{1,8}|(?:2[2-9]|3[0-46-9]|[457]\\d|8[13-9]|9[2-579])\\d{2,9}"
                ],
                [
                    "6(?:[269][18]|5[1568]|7[189]|81)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "90[015]\\d{5}",
                    [
                        8
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "20(?:1\\d{5}|[2-689]\\d{1,7})",
                    [
                        4,
                        5,
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "801\\d{5}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "LV": [
            "371",
            "00",
            "(?:[268]\\d|90)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[269]|8[01]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "6\\d{7}"
                ],
                [
                    "2333[0-8]\\d{3}|2(?:[0-24-9]\\d\\d|3(?:0[07]|[14-9]\\d|2[02-9]|3[0-24-9]))\\d{4}"
                ],
                [
                    "80\\d{6}"
                ],
                [
                    "90\\d{6}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "81\\d{6}"
                ]
            ]
        ],
        "LY": [
            "218",
            "00",
            "[2-9]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d{2})(\\d{7})",
                    "$1-$2",
                    [
                        "[2-9]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:0[56]|[1-6]\\d|7[124579]|8[124])|3(?:1\\d|2[2356])|4(?:[17]\\d|2[1-357]|5[2-4]|8[124])|5(?:[1347]\\d|2[1-469]|5[13-5]|8[1-4])|6(?:[1-479]\\d|5[2-57]|8[1-5])|7(?:[13]\\d|2[13-79])|8(?:[124]\\d|5[124]|84))\\d{6}"
                ],
                [
                    "9[1-6]\\d{7}"
                ]
            ]
        ],
        "MA": [
            "212",
            "00",
            "[5-8]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "5[45]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{5})",
                    "$1-$2",
                    [
                        "5(?:2[2-46-9]|3[3-9]|9)|8(?:0[89]|92)"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{7})",
                    "$1-$2",
                    [
                        "8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{6})",
                    "$1-$2",
                    [
                        "[5-7]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "5(?:2(?:[0-25-79]\\d|3[1-578]|4[02-46-8]|8[0235-7])|3(?:[0-47]\\d|5[02-9]|6[02-8]|8[014-9]|9[3-9])|(?:4[067]|5[03])\\d)\\d{5}"
                ],
                [
                    "(?:6(?:[0-79]\\d|8[0-247-9])|7(?:[0167]\\d|2[0-467]|5[0-3]|8[0-7]))\\d{6}"
                ],
                [
                    "80[0-7]\\d{6}"
                ],
                [
                    "89\\d{7}"
                ],
                0,
                0,
                0,
                0,
                [
                    "(?:592(?:4[0-2]|93)|80[89]\\d\\d)\\d{4}"
                ]
            ]
        ],
        "MC": [
            "377",
            "00",
            "(?:[3489]|6\\d)\\d{7}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "4"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[389]"
                    ]
                ],
                [
                    "(\\d)(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4 $5",
                    [
                        "6"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:870|9[2-47-9]\\d)\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "4(?:[469]\\d|5[1-9])\\d{5}|(?:3|6\\d)\\d{7}"
                ],
                [
                    "(?:800|90\\d)\\d{5}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "MD": [
            "373",
            "00",
            "(?:[235-7]\\d|[89]0)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{3})(\\d{5})",
                    "$1 $2",
                    [
                        "[89]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "22|3"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[25-7]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:(?:2[1-9]|3[1-79])\\d|5(?:33|5[257]))\\d{5}"
                ],
                [
                    "562\\d{5}|(?:6\\d|7[16-9])\\d{6}"
                ],
                [
                    "800\\d{5}"
                ],
                [
                    "90[056]\\d{5}"
                ],
                0,
                0,
                [
                    "803\\d{5}"
                ],
                0,
                [
                    "3[08]\\d{6}"
                ],
                [
                    "808\\d{5}"
                ]
            ]
        ],
        "ME": [
            "382",
            "00",
            "(?:20|[3-79]\\d)\\d{6}|80\\d{6,7}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[2-9]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:20[2-8]|3(?:[0-2][2-7]|3[24-7])|4(?:0[2-467]|1[2467])|5(?:0[2467]|1[24-7]|2[2-467]))\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "6(?:[07-9]\\d|3[024]|6[0-25])\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "80(?:[0-2578]|9\\d)\\d{5}"
                ],
                [
                    "9(?:4[1568]|5[178])\\d{5}",
                    [
                        8
                    ]
                ],
                0,
                0,
                [
                    "77[1-9]\\d{5}",
                    [
                        8
                    ]
                ],
                0,
                [
                    "78[1-49]\\d{5}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "MF": [
            "590",
            "00",
            "(?:590\\d|7090)\\d{5}|(?:69|80|9\\d)\\d{7}",
            [
                9
            ],
            0,
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "590(?:0[079]|[14]3|[27][79]|3[03-7]|5[0-268]|87)\\d{4}"
                ],
                [
                    "(?:69(?:0\\d\\d|1(?:2[2-9]|3[0-5])|4(?:0[89]|1[2-6]|9\\d)|6(?:1[016-9]|5[0-4]|[67]\\d))|7090[0-4])\\d{4}"
                ],
                [
                    "80[0-5]\\d{6}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "9(?:(?:39[5-7]|76[018])\\d|475[0-6])\\d{4}"
                ]
            ]
        ],
        "MG": [
            "261",
            "00",
            "[23]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{3})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[23]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            "([24-9]\\d{6})$|0",
            "20$1",
            0,
            0,
            [
                [
                    "2072[29]\\d{4}|20(?:2\\d|4[47]|5[3467]|6[279]|7[356]|8[268]|9[2457])\\d{5}"
                ],
                [
                    "3[2-47-9]\\d{7}"
                ],
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "22\\d{7}"
                ]
            ]
        ],
        "MH": [
            "692",
            "011",
            "329\\d{4}|(?:[256]\\d|45)\\d{5}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1-$2",
                    [
                        "[2-6]"
                    ]
                ]
            ],
            "1",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:247|528|625)\\d{4}"
                ],
                [
                    "(?:(?:23|54)5|329|45[35-8])\\d{4}"
                ],
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "635\\d{4}"
                ]
            ]
        ],
        "MK": [
            "389",
            "00",
            "[2-578]\\d{7}",
            [
                8
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "2|34[47]|4(?:[37]7|5[47]|64)"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[347]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d)(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[58]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:(?:2(?:62|77)0|3444)\\d|4[56]440)\\d{3}|(?:34|4[357])700\\d{3}|(?:2(?:[0-3]\\d|5[0-578]|6[01]|82)|3(?:1[3-68]|[23][2-68]|4[23568])|4(?:[23][2-68]|4[3-68]|5[2568]|6[25-8]|7[24-68]|8[4-68]))\\d{5}"
                ],
                [
                    "7(?:3555|(?:474|9[019]7)7)\\d{3}|7(?:[0-25-8]\\d\\d|3(?:[1-478]\\d|6[01])|4(?:2\\d|60|7[01578])|9(?:[2-4]\\d|5[01]|7[015]))\\d{4}"
                ],
                [
                    "800\\d{5}"
                ],
                [
                    "5\\d{7}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "8(?:0[1-9]|[1-9]\\d)\\d{5}"
                ]
            ]
        ],
        "ML": [
            "223",
            "00",
            "[24-9]\\d{7}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[24-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:07[0-8]|12[67])\\d{4}|(?:2(?:02|1[4-689])|4(?:0[0-4]|4[1-59]))\\d{5}"
                ],
                [
                    "2(?:0(?:01|79)|17\\d)\\d{4}|(?:5[0-3]|[679]\\d|8[2-59])\\d{6}"
                ],
                [
                    "80\\d{6}"
                ]
            ]
        ],
        "MM": [
            "95",
            "00",
            "1\\d{5,7}|95\\d{6}|(?:[4-7]|9[0-46-9])\\d{6,8}|(?:2|8\\d)\\d{5,8}",
            [
                6,
                7,
                8,
                9,
                10
            ],
            [
                [
                    "(\\d)(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "16|2"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "4(?:[2-46]|5[3-5])|5|6(?:[1-689]|7[235-7])|7(?:[0-4]|5[2-7])|8[1-5]|(?:60|86)[23]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[12]|452|678|86",
                        "[12]|452|6788|86"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[4-7]|8[1-35]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{4,6})",
                    "$1 $2 $3",
                    [
                        "9(?:2[0-4]|[35-9]|4[137-9])"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "2"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "92"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{5})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "9"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1(?:(?:12|[28]\\d|3[56]|7[3-6]|9[0-6])\\d|4(?:2[29]|7[0-2]|83)|6)|2(?:2(?:00|8[34])|4(?:0\\d|22|7[0-2]|83)|51\\d\\d)|4(?:2(?:2\\d\\d|48[013])|3(?:20\\d|4(?:70|83)|56)|420\\d|5(?:2\\d|470))|6(?:0(?:[23]|88\\d)|(?:124|[56]2\\d)\\d|2472|3(?:20\\d|470)|4(?:2[04]\\d|472)|7(?:3\\d\\d|4[67]0|8(?:[01459]\\d|8))))\\d{4}|5(?:2(?:2\\d{5,6}|47[02]\\d{4})|(?:3472|4(?:2(?:1|86)|470)|522\\d|6(?:20\\d|483)|7(?:20\\d|48[01])|8(?:20\\d|47[02])|9(?:20\\d|470))\\d{4})|7(?:(?:0470|4(?:25\\d|470)|5(?:202|470|96\\d))\\d{4}|1(?:20\\d{4,5}|4(?:70|83)\\d{4}))|8(?:1(?:2\\d{5,6}|4(?:10|7[01]\\d)\\d{3})|2(?:2\\d{5,6}|(?:320|490\\d)\\d{3})|(?:3(?:2\\d\\d|470)|4[24-7]|5(?:(?:2\\d|51)\\d|4(?:[1-35-9]\\d|4[0-57-9]))|6[23])\\d{4})|(?:1[2-6]\\d|4(?:2[24-8]|3[2-7]|[46][2-6]|5[3-5])|5(?:[27][2-8]|3[2-68]|4[24-8]|5[23]|6[2-4]|8[24-7]|9[2-7])|6(?:[19]20|42[03-6]|(?:52|7[45])\\d)|7(?:[04][24-8]|[15][2-7]|22|3[2-4])|8(?:1[2-689]|2[2-8]|(?:[35]2|64)\\d))\\d{4}|25\\d{5,6}|(?:2[2-9]|6(?:1[2356]|[24][2-6]|3[24-6]|5[2-4]|6[2-8]|7[235-7]|8[245]|9[24])|8(?:3[24]|5[245]))\\d{4}",
                    [
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "(?:17[01]|9(?:2(?:[0-4]|[56]\\d\\d)|(?:3(?:[0-36]|4\\d)|(?:6\\d|8[89]|9[4-8])\\d|7(?:3|40|[5-9]\\d))\\d|4(?:(?:[0245]\\d|[1379])\\d|88)|5[0-6])\\d)\\d{4}|9[69]1\\d{6}|9(?:[68]\\d|9[089])\\d{5}",
                    [
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "80080(?:0[1-9]|2\\d)\\d{3}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "1333\\d{4}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "MN": [
            "976",
            "001",
            "[12]\\d{7,9}|[5-9]\\d{7}",
            [
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[12]1"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[5-9]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{5,6})",
                    "$1 $2",
                    [
                        "[12]2[1-3]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{5,6})",
                    "$1 $2",
                    [
                        "[12](?:27|3[2-8]|4[2-68]|5[1-4689])",
                        "[12](?:27|3[2-8]|4[2-68]|5[1-4689])[0-3]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{5})(\\d{4,5})",
                    "$1 $2",
                    [
                        "[12]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "[12]2[1-3]\\d{5,6}|(?:(?:[12](?:1|27)|5[368])\\d\\d|7(?:0(?:[0-5]\\d|7[078]|80)|128))\\d{4}|[12](?:3[2-8]|4[2-68]|5[1-4689])\\d{6,7}"
                ],
                [
                    "(?:83[01]|92[039])\\d{5}|(?:5[05]|6[069]|72|8[015689]|9[013-9])\\d{6}",
                    [
                        8
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "712[0-79]\\d{4}|7(?:1[013-9]|[5-9]\\d)\\d{5}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "MO": [
            "853",
            "00",
            "0800\\d{3}|(?:28|[68]\\d)\\d{6}",
            [
                7,
                8
            ],
            [
                [
                    "(\\d{4})(\\d{3})",
                    "$1 $2",
                    [
                        "0"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[268]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:28[2-9]|8(?:11|[2-57-9]\\d))\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "6800[0-79]\\d{3}|6(?:[235]\\d\\d|6(?:0[0-5]|[1-9]\\d)|8(?:0[1-9]|[14-8]\\d|2[5-9]|[39][0-4]))\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "0800\\d{3}",
                    [
                        7
                    ]
                ]
            ]
        ],
        "MP": [
            "1",
            "011",
            "[58]\\d{9}|(?:67|90)0\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-9]\\d{6})$|1",
            "670$1",
            0,
            "670",
            [
                [
                    "670(?:2(?:3[3-7]|56|8[4-8])|32[1-38]|4(?:33|8[348])|5(?:32|55|88)|6(?:64|70|82)|78[3589]|8[3-9]8|989)\\d{4}"
                ],
                [
                    ""
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "MQ": [
            "596",
            "00",
            "(?:596\\d|7091)\\d{5}|(?:69|[89]\\d)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[5-79]|8(?:0[6-9]|[36])"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "8"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:596(?:[03-7]\\d|1[05]|2[7-9]|8[0-39]|9[04-9])|80[6-9]\\d\\d|9(?:477[6-9]|767[4589]))\\d{4}"
                ],
                [
                    "(?:69[67]\\d\\d|7091[0-3])\\d{4}"
                ],
                [
                    "80[0-5]\\d{6}"
                ],
                [
                    "8[129]\\d{7}"
                ],
                0,
                0,
                0,
                0,
                [
                    "9(?:397[0-3]|477[0-5]|76(?:6\\d|7[0-367]))\\d{4}"
                ]
            ]
        ],
        "MR": [
            "222",
            "00",
            "(?:[2-4]\\d\\d|800)\\d{5}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[2-48]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:25[08]|35\\d|45[1-7])\\d{5}"
                ],
                [
                    "[2-4][0-46-9]\\d{6}"
                ],
                [
                    "800\\d{5}"
                ]
            ]
        ],
        "MS": [
            "1",
            "011",
            "(?:[58]\\d\\d|664|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([34]\\d{6})$|1",
            "664$1",
            0,
            "664",
            [
                [
                    "6644(?:1[0-3]|91)\\d{4}"
                ],
                [
                    "664(?:3(?:49|9[1-6])|49[2-6])\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "MT": [
            "356",
            "00",
            "3550\\d{4}|(?:[2579]\\d\\d|800)\\d{5}",
            [
                8
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[2357-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "20(?:3[1-4]|6[059])\\d{4}|2(?:0[19]|[1-357]\\d|60)\\d{5}"
                ],
                [
                    "(?:7(?:210|[79]\\d\\d)|9(?:[29]\\d\\d|69[67]|8(?:1[1-3]|89|97)))\\d{4}"
                ],
                [
                    "800(?:02|[3467]\\d)\\d{3}"
                ],
                [
                    "5(?:0(?:0(?:37|43)|(?:6\\d|70|9[0168])\\d)|[12]\\d0[1-5])\\d{3}"
                ],
                0,
                0,
                [
                    "501\\d{5}"
                ],
                [
                    "7117\\d{4}"
                ],
                [
                    "3550\\d{4}"
                ]
            ]
        ],
        "MU": [
            "230",
            "0(?:0|[24-7]0|3[03])",
            "(?:[57]|8\\d\\d)\\d{7}|[2-468]\\d{6}",
            [
                7,
                8,
                10
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[2-46]|8[013]"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[57]"
                    ]
                ],
                [
                    "(\\d{5})(\\d{5})",
                    "$1 $2",
                    [
                        "8"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:[0346-8]\\d|1[0-8])|4(?:[013568]\\d|2[4-8]|71|90)|54(?:[3-5]\\d|71)|6\\d\\d|8(?:14|3[129]))\\d{4}",
                    [
                        7,
                        8
                    ]
                ],
                [
                    "5(?:4(?:2[1-389]|7[1-9])|87[15-8])\\d{4}|(?:5(?:2[5-9]|4[3-689]|[57]\\d|8[0-689]|9[0-8])|7(?:0[0-6]|3[013]))\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "802\\d{7}|80[0-2]\\d{4}",
                    [
                        7,
                        10
                    ]
                ],
                [
                    "30\\d{5}",
                    [
                        7
                    ]
                ],
                0,
                0,
                0,
                [
                    "219\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "3(?:20|9\\d)\\d{4}",
                    [
                        7
                    ]
                ]
            ],
            "020"
        ],
        "MV": [
            "960",
            "0(?:0|19)",
            "(?:800|9[0-57-9]\\d)\\d{7}|[34679]\\d{6}",
            [
                7,
                10
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1-$2",
                    [
                        "[34679]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[89]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:3(?:0[0-4]|3[0-59])|6(?:[58][024689]|6[024-68]|7[02468]))\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "(?:46[46]|[79]\\d\\d)\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "800\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "900\\d{7}",
                    [
                        10
                    ]
                ],
                0,
                0,
                [
                    "4(?:0[01]|50)\\d{4}",
                    [
                        7
                    ]
                ]
            ],
            "00"
        ],
        "MW": [
            "265",
            "00",
            "(?:[1289]\\d|31|77)\\d{7}|1\\d{6}",
            [
                7,
                9
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "1[2-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "2"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[137-9]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1[2-9]|2[12]\\d\\d)\\d{5}"
                ],
                [
                    "111\\d{6}|(?:31|77|[89][89])\\d{7}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "MX": [
            "52",
            "0[09]",
            "[2-9]\\d{9}",
            [
                10
            ],
            [
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "33|5[56]|81"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[2-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:0[01]|2\\d|3[1-35-8]|4[13-9]|7[1-689]|8[1-578]|9[467])|3(?:1[1-79]|[2458][1-9]|3\\d|7[1-8]|9[1-5])|4(?:1[1-57-9]|[267][1-9]|3[1-8]|[45]\\d|8[1-35-9]|9[2-689])|5(?:[56]\\d|88|9[1-79])|6(?:1[2-68]|[2-4][1-9]|5[1-36-9]|6[0-57-9]|7[1-7]|8[67]|9[4-8])|7(?:[1346][1-9]|[27]\\d|5[13-9]|8[1-69]|9[17])|8(?:1\\d|2[13-689]|3[1-6]|4[124-6]|6[1246-9]|7[0-378]|9[12479])|9(?:1[346-9]|2[1-4]|3[2-46-8]|5[1348]|[69]\\d|7[12]|8[1-8]))\\d{7}"
                ],
                [
                    "(?:2(?:2\\d|3[1-35-8]|4[13-9]|7[1-689]|8[1-578]|9[467])|3(?:1[1-79]|[2458][1-9]|3\\d|7[1-8]|9[1-5])|4(?:1[1-57-9]|[267][1-9]|3[1-8]|[45]\\d|8[1-35-9]|9[2-689])|5(?:[56]\\d|88|9[1-79])|6(?:1[2-68]|[2-4][1-9]|5[1-36-9]|6[0-57-9]|7[1-7]|8[67]|9[4-8])|7(?:[1346][1-9]|[27]\\d|5[13-9]|8[1-69]|9[17])|8(?:1\\d|2[13-689]|3[1-6]|4[124-6]|6[1246-9]|7[0-378]|9[12479])|9(?:1[346-9]|2[1-4]|3[2-46-8]|5[1348]|[69]\\d|7[12]|8[1-8]))\\d{7}"
                ],
                [
                    "8(?:00|88)\\d{7}"
                ],
                [
                    "900\\d{7}"
                ],
                [
                    "500\\d{7}"
                ],
                0,
                0,
                0,
                0,
                [
                    "300\\d{7}"
                ]
            ],
            "00"
        ],
        "MY": [
            "60",
            "00",
            "1\\d{8,9}|(?:3\\d|[4-9])\\d{7}",
            [
                8,
                9,
                10
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1-$2 $3",
                    [
                        "[4-79]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1-$2 $3",
                    [
                        "1(?:[02469]|[378][1-9]|53)|8",
                        "1(?:[02469]|[37][1-9]|53|8(?:[1-46-9]|5[7-9]))|8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{4})(\\d{4})",
                    "$1-$2 $3",
                    [
                        "3"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{2})(\\d{4})",
                    "$1-$2-$3-$4",
                    [
                        "1(?:[367]|80)"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1-$2 $3",
                    [
                        "15"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1-$2 $3",
                    [
                        "1"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "4270\\d{4}|(?:3(?:2[0-36-9]|3[0-368]|4[0-278]|5[0-24-8]|6[0-467]|7[1246-9]|8\\d|9[0-57])\\d|4(?:2[0-689]|[3-79]\\d|8[1-35689])|5(?:2[0-589]|[3468]\\d|5[0-489]|7[1-9]|9[23])|6(?:2[2-9]|3[1357-9]|[46]\\d|5[0-6]|7[0-35-9]|85|9[015-8])|7(?:[2579]\\d|3[03-68]|4[0-8]|6[5-9]|8[0-35-9])|8(?:[24][2-8]|3[2-5]|5[2-7]|6[2-589]|7[2-578]|[89][2-9])|9(?:0[57]|13|[25-7]\\d|[3489][0-8]))\\d{5}",
                    [
                        8,
                        9
                    ]
                ],
                [
                    "1(?:1888[689]|4400|8(?:47|8[27])[0-4])\\d{4}|1(?:0(?:[23568]\\d|4[0-6]|7[016-9]|9[0-8])|1(?:[1-5]\\d\\d|6(?:0[5-9]|[1-9]\\d)|7(?:[0-4]\\d|5[0-7]))|(?:[269]\\d|[37][1-9]|4[235-9])\\d|5(?:31|9\\d\\d)|8(?:1[23]|[236]\\d|4[06]|5(?:46|[7-9])|7[016-9]|8[01]|9[0-8]))\\d{5}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "1[378]00\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "1600\\d{6}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "15(?:4(?:6[0-4]\\d|8(?:0[125]|[17]\\d|21|3[01]|4[01589]|5[014]|6[02]))|6(?:32[0-6]|78\\d))\\d{4}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "MZ": [
            "258",
            "00",
            "(?:2|8\\d)\\d{7}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "2|8[2-79]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:[1346]\\d|5[0-2]|[78][12]|93)\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "8[2-79]\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{6}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "NA": [
            "264",
            "00",
            "[68]\\d{7,8}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "88"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "6"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "87"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "8"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "64426\\d{3}|6(?:1(?:2[2-7]|3[01378]|4[0-4])|254|32[0237]|4(?:27|41|5[25])|52[236-8]|626|7(?:2[2-4]|30))\\d{4,5}|6(?:1(?:(?:0\\d|2[0189]|3[24-69]|4[5-9])\\d|17|69|7[014])|2(?:17|5[0-36-8]|69|70)|3(?:17|2[14-689]|34|6[289]|7[01]|81)|4(?:17|2[0-2]|4[06]|5[0137]|69|7[01])|5(?:17|2[0459]|69|7[01])|6(?:17|25|38|42|69|7[01])|7(?:17|2[569]|3[13]|6[89]|7[01]))\\d{4}"
                ],
                [
                    "(?:60|8[1245])\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "80\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "8701\\d{5}",
                    [
                        9
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "8(?:3\\d\\d|86)\\d{5}"
                ]
            ]
        ],
        "NC": [
            "687",
            "00",
            "(?:050|[2-57-9]\\d\\d)\\d{3}",
            [
                6
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})",
                    "$1.$2.$3",
                    [
                        "[02-57-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2[03-9]|3[0-5]|4[1-7]|88)\\d{4}"
                ],
                [
                    "(?:[579]\\d|8[0-79])\\d{4}"
                ],
                [
                    "050\\d{3}"
                ],
                [
                    "36\\d{4}"
                ]
            ]
        ],
        "NE": [
            "227",
            "00",
            "[027-9]\\d{7}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "08"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[089]|2[013]|7[0467]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:0(?:20|3[1-8]|4[13-5]|5[14]|6[14578]|7[1-578])|1(?:4[145]|5[14]|6[14-68]|7[169]|88))\\d{4}"
                ],
                [
                    "(?:23|7[0467]|[89]\\d)\\d{6}"
                ],
                [
                    "08\\d{6}"
                ],
                [
                    "09\\d{6}"
                ]
            ]
        ],
        "NF": [
            "672",
            "00",
            "[13]\\d{5}",
            [
                6
            ],
            [
                [
                    "(\\d{2})(\\d{4})",
                    "$1 $2",
                    [
                        "1[0-3]"
                    ]
                ],
                [
                    "(\\d)(\\d{5})",
                    "$1 $2",
                    [
                        "[13]"
                    ]
                ]
            ],
            0,
            0,
            "([0-258]\\d{4})$",
            "3$1",
            0,
            0,
            [
                [
                    "(?:1(?:06|17|28|39)|3[0-2]\\d)\\d{3}"
                ],
                [
                    "(?:14|3[58])\\d{4}"
                ]
            ]
        ],
        "NG": [
            "234",
            "009",
            "(?:20|9\\d)\\d{8}|[78]\\d{9,13}",
            [
                10,
                11,
                12,
                13,
                14
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[7-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "20[129]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{2})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "2"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{4})(\\d{4,5})",
                    "$1 $2 $3",
                    [
                        "[78]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{5})(\\d{5,6})",
                    "$1 $2 $3",
                    [
                        "[78]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "20(?:[1259]\\d|3[013-9]|4[1-8]|6[024-689]|7[1-79]|8[2-9])\\d{6}",
                    [
                        10
                    ]
                ],
                [
                    "(?:702[0-24-9]|819[01])\\d{6}|(?:7(?:0[13-9]|[12]\\d)|8(?:0[1-9]|1[0-8])|9(?:0[1-9]|1[1-6]))\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "800\\d{7,11}"
                ],
                0,
                0,
                0,
                [
                    "700\\d{7,11}"
                ]
            ]
        ],
        "NI": [
            "505",
            "00",
            "(?:1800|[25-8]\\d{3})\\d{4}",
            [
                8
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[125-8]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2\\d{7}"
                ],
                [
                    "(?:5(?:5[0-7]|[78]\\d)|6(?:20|3[035]|4[045]|5[05]|77|8[1-9]|9[059])|(?:7[5-8]|8\\d)\\d)\\d{5}"
                ],
                [
                    "1800\\d{4}"
                ]
            ]
        ],
        "NL": [
            "31",
            "00",
            "(?:[124-7]\\d\\d|3(?:[02-9]\\d|1[0-8]))\\d{6}|8\\d{6,9}|9\\d{6,10}|1\\d{4,5}",
            [
                5,
                6,
                7,
                8,
                9,
                10,
                11
            ],
            [
                [
                    "(\\d{3})(\\d{4,7})",
                    "$1 $2",
                    [
                        "[89]0"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{7})",
                    "$1 $2",
                    [
                        "66"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{8})",
                    "$1 $2",
                    [
                        "6"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "1[16-8]|2[259]|3[124]|4[17-9]|5[124679]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[1-578]|91"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{5})",
                    "$1 $2 $3",
                    [
                        "9"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1(?:[035]\\d|1[13-578]|6[124-8]|7[24]|8[0-467])|2(?:[0346]\\d|2[2-46-9]|5[125]|9[479])|3(?:[03568]\\d|1[3-8]|2[01]|4[1-8])|4(?:[0356]\\d|1[1-368]|7[58]|8[15-8]|9[23579])|5(?:[0358]\\d|[19][1-9]|2[1-57-9]|4[13-8]|6[126]|7[0-3578])|7\\d\\d)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "(?:6[1-58]|970\\d)\\d{7}",
                    [
                        9,
                        11
                    ]
                ],
                [
                    "800\\d{4,7}",
                    [
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "90[069]\\d{4,7}",
                    [
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                0,
                0,
                [
                    "140(?:1[035]|2[0346]|3[03568]|4[0356]|5[0358]|8[458])|(?:140(?:1[16-8]|2[259]|3[124]|4[17-9]|5[124679]|7)|8[478]\\d{6})\\d",
                    [
                        5,
                        6,
                        9
                    ]
                ],
                [
                    "66\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "(?:85|91)\\d{7}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "NO": [
            "47",
            "00",
            "(?:0|[2-9]\\d{3})\\d{4}",
            [
                5,
                8
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[2-79]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            "[02-689]|7[0-8]",
            [
                [
                    "(?:2[1-4]|3[1-3578]|5[1-35-7]|6[1-4679]|7[0-8])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "(?:4[015-8]|9\\d)\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "80[01]\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "82[09]\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "880\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "81[23]\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "(?:0[235-9]|81(?:0(?:0[7-9]|1\\d)|5\\d\\d))\\d{3}"
                ],
                0,
                [
                    "85[0-5]\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "810(?:0[0-6]|[2-8]\\d)\\d{3}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "NP": [
            "977",
            "00",
            "(?:1\\d|9)\\d{9}|[1-9]\\d{7}",
            [
                8,
                10,
                11
            ],
            [
                [
                    "(\\d)(\\d{7})",
                    "$1-$2",
                    [
                        "1[2-6]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{6})",
                    "$1-$2",
                    [
                        "1[01]|[2-8]|9(?:[1-59]|[67][2-6])"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{7})",
                    "$1-$2",
                    [
                        "9"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1[0-6]\\d|99[02-6])\\d{5}|(?:2[13-79]|3[135-8]|4[146-9]|5[135-7]|6[13-9]|7[15-9]|8[1-46-9]|9[1-7])[2-6]\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "9(?:00|6[0-3]|7[024-6]|8[0-24-68])\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "1(?:66001|800\\d\\d)\\d{5}",
                    [
                        11
                    ]
                ]
            ]
        ],
        "NR": [
            "674",
            "00",
            "(?:222|444|(?:55|8\\d)\\d|666|777|999)\\d{4}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[24-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "444\\d{4}"
                ],
                [
                    "(?:222|55[3-9]|666|777|8\\d\\d|999)\\d{4}"
                ]
            ]
        ],
        "NU": [
            "683",
            "00",
            "(?:[4-7]|888\\d)\\d{3}",
            [
                4,
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "8"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "[47]\\d{3}",
                    [
                        4
                    ]
                ],
                [
                    "(?:[56]|888[1-9])\\d{3}"
                ]
            ]
        ],
        "NZ": [
            "64",
            "0(?:0|161)",
            "[1289]\\d{9}|50\\d{5}(?:\\d{2,3})?|[27-9]\\d{7,8}|(?:[34]\\d|6[0-35-9])\\d{6}|8\\d{4,6}",
            [
                5,
                6,
                7,
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{3,8})",
                    "$1 $2",
                    [
                        "8[1-79]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2,3})",
                    "$1 $2 $3",
                    [
                        "50[036-8]|8|90",
                        "50(?:[0367]|88)|8|90"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "24|[346]|7[2-57-9]|9[2-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "2(?:10|74)|[589]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3,4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1|2[028]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,5})",
                    "$1 $2 $3",
                    [
                        "2(?:[169]|7[0-35-9])|7"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "240\\d{5}|(?:3[2-79]|[49][2-9]|6[235-9]|7[2-57-9])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "2(?:[0-27-9]\\d|6)\\d{6,7}|2(?:1\\d|75)\\d{5}",
                    [
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "508\\d{6,7}|80\\d{6,8}",
                    [
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "(?:1[13-57-9]\\d{5}|50(?:0[08]|30|66|77|88))\\d{3}|90\\d{6,8}",
                    [
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "70\\d{7}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "8(?:1[16-9]|22|3\\d|4[045]|5[459]|6[235-9]|7[0-3579]|90)\\d{2,7}"
                ]
            ],
            "00"
        ],
        "OM": [
            "968",
            "00",
            "(?:1505|[279]\\d{3}|500)\\d{4}|800\\d{5,6}",
            [
                7,
                8,
                9
            ],
            [
                [
                    "(\\d{3})(\\d{4,6})",
                    "$1 $2",
                    [
                        "[58]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{6})",
                    "$1 $2",
                    [
                        "2"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[179]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2[1-6]\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "(?:1505|90[1-9]\\d)\\d{4}|(?:7[126-9]|9[1-9])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "8007\\d{4,5}|(?:500|800[05])\\d{4}"
                ],
                [
                    "900\\d{5}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "PA": [
            "507",
            "00",
            "(?:00800|8\\d{3})\\d{6}|[68]\\d{7}|[1-57-9]\\d{6}",
            [
                7,
                8,
                10,
                11
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1-$2",
                    [
                        "[1-57-9]"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1-$2",
                    [
                        "[68]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1(?:0\\d|1[479]|2[37]|3[0137]|4[17]|5[05]|6[058]|7[0167]|8[2358]|9[1389])|2(?:[0235-79]\\d|1[0-7]|4[013-9]|8[02-9])|3(?:[07-9]\\d|1[0-7]|2[0-5]|33|4[0-79]|5[0-35]|6[068])|4(?:00|3[0-579]|4\\d|7[0-57-9])|5(?:[01]\\d|2[0-7]|[56]0|79)|7(?:0[09]|2[0-26-8]|3[03]|4[04]|5[05-9]|6[0156]|7[0-24-9]|8[5-9]|90)|8(?:09|2[89]|3\\d|4[0-24-689]|5[014]|8[02])|9(?:0[5-9]|1[0135-8]|2[036-9]|3[35-79]|40|5[0457-9]|6[05-9]|7[04-9]|8[35-8]|9\\d))\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "(?:1[16]1|21[89]|6\\d{3}|8(?:1[01]|7[23]))\\d{4}",
                    [
                        7,
                        8
                    ]
                ],
                [
                    "800\\d{4,5}|(?:00800|800\\d)\\d{6}"
                ],
                [
                    "(?:8(?:22|55|60|7[78]|86)|9(?:00|81))\\d{4}",
                    [
                        7
                    ]
                ]
            ]
        ],
        "PE": [
            "51",
            "00|19(?:1[124]|77|90)00",
            "(?:[14-8]|9\\d)\\d{7}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{3})(\\d{5})",
                    "$1 $2",
                    [
                        "80"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d)(\\d{7})",
                    "$1 $2",
                    [
                        "1"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d{6})",
                    "$1 $2",
                    [
                        "[4-8]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "9"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:(?:(?:4[34]|5[14])[0-8]|687)\\d|7(?:173|(?:3[0-8]|55)\\d)|8(?:10[05689]|6(?:0[06-9]|1[6-9]|29)|7(?:0[0569]|[56]0)))\\d{4}|(?:1[0-8]|4[12]|5[236]|6[1-7]|7[246]|8[2-4])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "9\\d{8}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "805\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "80[24]\\d{5}",
                    [
                        8
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "801\\d{5}",
                    [
                        8
                    ]
                ]
            ],
            "00",
            " Anexo "
        ],
        "PF": [
            "689",
            "00",
            "4\\d{5}(?:\\d{2})?|8\\d{7,8}",
            [
                6,
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3",
                    [
                        "44"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "4|8[7-9]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "8"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "4(?:0[4-689]|9[4-68])\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "8[7-9]\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "80[0-5]\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                0,
                0,
                [
                    "44\\d{4}",
                    [
                        6
                    ]
                ],
                0,
                [
                    "499\\d{5}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "PG": [
            "675",
            "00|140[1-3]",
            "(?:180|[78]\\d{3})\\d{4}|(?:[2-589]\\d|64)\\d{5}",
            [
                7,
                8
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "18|[2-69]|85"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[78]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:(?:3[0-2]|4[257]|5[34]|9[78])\\d|64[1-9]|85[02-46-9])\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "(?:7\\d|8[1-38])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "180\\d{4}",
                    [
                        7
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "27[01]\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "2(?:0[0-57]|7[568])\\d{4}",
                    [
                        7
                    ]
                ]
            ],
            "00"
        ],
        "PH": [
            "63",
            "00",
            "(?:[2-7]|9\\d)\\d{8}|2\\d{5}|(?:1800|8)\\d{7,9}",
            [
                6,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            [
                [
                    "(\\d)(\\d{5})",
                    "$1 $2",
                    [
                        "2"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{4})(\\d{4,6})",
                    "$1 $2",
                    [
                        "3(?:23|39|46)|4(?:2[3-6]|[35]9|4[26]|76)|544|88[245]|(?:52|64|86)2",
                        "3(?:230|397|461)|4(?:2(?:35|[46]4|51)|396|4(?:22|63)|59[347]|76[15])|5(?:221|446)|642[23]|8(?:622|8(?:[24]2|5[13]))"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{5})(\\d{4})",
                    "$1 $2",
                    [
                        "346|4(?:27|9[35])|883",
                        "3469|4(?:279|9(?:30|56))|8834"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d)(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "2"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[3-7]|8[2-8]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[89]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1"
                    ]
                ],
                [
                    "(\\d{4})(\\d{1,2})(\\d{3})(\\d{4})",
                    "$1 $2 $3 $4",
                    [
                        "1"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:(?:2[3-8]|3[2-68]|4[2-9]|5[2-6]|6[2-58]|7[24578])\\d{3}|88(?:22\\d\\d|42))\\d{4}|(?:2|8[2-8]\\d\\d)\\d{5}",
                    [
                        6,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "(?:8(?:1[37]|9[5-8])|9(?:0[5-9]|1[0-24-9]|[235-7]\\d|4[2-9]|8[135-9]|9[1-9]))\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "1800\\d{7,9}",
                    [
                        11,
                        12,
                        13
                    ]
                ]
            ]
        ],
        "PK": [
            "92",
            "00",
            "122\\d{6}|[24-8]\\d{10,11}|9(?:[013-9]\\d{8,10}|2(?:[01]\\d\\d|2(?:[06-8]\\d|1[01]))\\d{7})|(?:[2-8]\\d{3}|92(?:[0-7]\\d|8[1-9]))\\d{6}|[24-9]\\d{8}|[89]\\d{7}",
            [
                8,
                9,
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{2,7})",
                    "$1 $2 $3",
                    [
                        "[89]0"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{5})",
                    "$1 $2",
                    [
                        "1"
                    ]
                ],
                [
                    "(\\d{3})(\\d{6,7})",
                    "$1 $2",
                    [
                        "2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8])",
                        "9(?:2[3-8]|98)|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:22|3[27-9]|4[2-6]|6[3569]|9[25-7]))[2-9]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d{7,8})",
                    "$1 $2",
                    [
                        "(?:2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{5})(\\d{5})",
                    "$1 $2",
                    [
                        "58"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{3})(\\d{7})",
                    "$1 $2",
                    [
                        "3"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "2[125]|4[0-246-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "[24-9]"
                    ],
                    "(0$1)"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:(?:21|42)[2-9]|58[126])\\d{7}|(?:2[25]|4[0146-9]|5[1-35-7]|6[1-8]|7[14]|8[16]|91)[2-9]\\d{6,7}|(?:2(?:3[2358]|4[2-4]|9[2-8])|45[3479]|54[2-467]|60[468]|72[236]|8(?:2[2-689]|3[23578]|4[3478]|5[2356])|9(?:2[2-8]|3[27-9]|4[2-6]|6[3569]|9[25-8]))[2-9]\\d{5,6}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "3(?:[0-247]\\d|3[0-79]|55|64)\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "800\\d{5}(?:\\d{3})?",
                    [
                        8,
                        11
                    ]
                ],
                [
                    "900\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "122\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "(?:2(?:[125]|3[2358]|4[2-4]|9[2-8])|4(?:[0-246-9]|5[3479])|5(?:[1-35-7]|4[2-467])|6(?:0[468]|[1-8])|7(?:[14]|2[236])|8(?:[16]|2[2-689]|3[23578]|4[3478]|5[2356])|9(?:1|22|3[27-9]|4[2-6]|6[3569]|9[2-7]))111\\d{6}",
                    [
                        11,
                        12
                    ]
                ]
            ]
        ],
        "PL": [
            "48",
            "00",
            "(?:6|8\\d\\d)\\d{7}|[1-9]\\d{6}(?:\\d{2})?|[26]\\d{5}",
            [
                6,
                7,
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{5})",
                    "$1",
                    [
                        "19"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})",
                    "$1 $2",
                    [
                        "11|20|64"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])1",
                        "(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])19"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2,3})",
                    "$1 $2 $3",
                    [
                        "64"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "21|39|45|5[0137]|6[0469]|7[02389]|8(?:0[14]|8)"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "1[2-8]|[2-7]|8[1-79]|9[145]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "47\\d{7}|(?:1[2-8]|2[2-69]|3[2-4]|4[1-468]|5[24-689]|6[1-3578]|7[14-7]|8[1-79]|9[145])(?:[02-9]\\d{6}|1(?:[0-8]\\d{5}|9\\d{3}(?:\\d{2})?))",
                    [
                        7,
                        9
                    ]
                ],
                [
                    "2131[89]\\d{4}|21(?:1[013-5]|2\\d|3[2-9])\\d{5}|(?:45|5[0137]|6[069]|7[2389]|88)\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{6,7}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "70[01346-8]\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                0,
                [
                    "804\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "64\\d{4,7}",
                    [
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "39\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "801\\d{6}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "PM": [
            "508",
            "00",
            "[45]\\d{5}|(?:708|8\\d\\d)\\d{6}",
            [
                6,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3",
                    [
                        "[45]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "7"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "8"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:4[1-35-9]|5[0-47-9]|80[6-9]\\d\\d)\\d{4}"
                ],
                [
                    "(?:4[02-489]|5[02-9]|708(?:4[0-5]|5[0-6]))\\d{4}"
                ],
                [
                    "80[0-5]\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "8[129]\\d{7}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "PR": [
            "1",
            "011",
            "(?:[589]\\d\\d|787)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            0,
            0,
            0,
            "787|939",
            [
                [
                    "(?:787|939)[2-9]\\d{6}"
                ],
                [
                    ""
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "PS": [
            "970",
            "00",
            "[2489]2\\d{6}|(?:1\\d|5)\\d{8}",
            [
                8,
                9,
                10
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[2489]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "5"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "1"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:22[2-47-9]|42[45]|82[014-68]|92[3569])\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "5[69]\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "1800\\d{6}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "1700\\d{6}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "PT": [
            "351",
            "00",
            "1693\\d{5}|(?:[26-9]\\d|30)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "2[12]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "16|[236-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:[12]\\d|3[1-689]|4[1-59]|[57][1-9]|6[1-35689]|8[1-69]|9[1256])\\d{6}"
                ],
                [
                    "6(?:[06]92(?:30|9\\d)|[35]92(?:[049]\\d|3[034]))\\d{3}|(?:(?:16|6[0356])93|9(?:[1-36]\\d\\d|480))\\d{5}"
                ],
                [
                    "80[02]\\d{6}"
                ],
                [
                    "(?:6(?:0[178]|4[68])\\d|76(?:0[1-57]|1[2-47]|2[237]))\\d{5}"
                ],
                [
                    "884[0-4689]\\d{5}"
                ],
                [
                    "600\\d{6}|6[06]92(?:0\\d|3[349]|49)\\d{3}"
                ],
                [
                    "70(?:38[01]|596|(?:7\\d|8[17])\\d)\\d{4}"
                ],
                [
                    "6(?:222\\d|8988)\\d{4}"
                ],
                [
                    "30\\d{7}"
                ],
                [
                    "80(?:8\\d|9[1579])\\d{5}"
                ]
            ]
        ],
        "PW": [
            "680",
            "01[12]",
            "(?:[24-8]\\d\\d|345|900)\\d{4}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[2-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:55|77)|345|488|5(?:35|44|87)|6(?:22|54|79)|7(?:33|47)|8(?:24|55|76)|900)\\d{4}"
                ],
                [
                    "(?:(?:46|83)[0-5]|(?:6[2-4689]|78)0)\\d{4}|(?:45|77|88)\\d{5}"
                ]
            ]
        ],
        "PY": [
            "595",
            "00",
            "59\\d{4,6}|9\\d{5,10}|(?:[2-46-8]\\d|5[0-8])\\d{4,7}",
            [
                6,
                7,
                8,
                9,
                10,
                11
            ],
            [
                [
                    "(\\d{3})(\\d{3,6})",
                    "$1 $2",
                    [
                        "[2-9]0"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{5})",
                    "$1 $2",
                    [
                        "[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{3})(\\d{4,5})",
                    "$1 $2",
                    [
                        "2[279]|3[13-5]|4[359]|5|6(?:[34]|7[1-46-8])|7[46-8]|85"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "2[14-68]|3[26-9]|4[1246-8]|6(?:1|75)|7[1-35]|8[1-36]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "87"
                    ]
                ],
                [
                    "(\\d{3})(\\d{6})",
                    "$1 $2",
                    [
                        "9(?:[5-79]|8[1-7])"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[2-8]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "9"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:[26]1|3[289]|4[1246-8]|7[1-3]|8[1-36])\\d{5,7}|(?:2(?:2[4-68]|[4-68]\\d|7[15]|9[1-5])|3(?:18|3[167]|4[2357]|51|[67]\\d)|4(?:3[12]|5[13]|9[1-47])|5(?:[1-4]\\d|5[02-4])|6(?:3[1-3]|44|7[1-8])|7(?:4[0-4]|5\\d|6[1-578]|75|8[0-8])|858)\\d{5,6}",
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "9(?:51|6[129]|7[1-6]|8[1-7]|9[1-5])\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "9800\\d{5,7}",
                    [
                        9,
                        10,
                        11
                    ]
                ],
                0,
                0,
                0,
                [
                    "[2-9]0\\d{4,7}",
                    [
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                0,
                [
                    "8700[0-4]\\d{4}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "QA": [
            "974",
            "00",
            "800\\d{4}|(?:2|800)\\d{6}|(?:0080|[3-7])\\d{7}",
            [
                7,
                8,
                9,
                11
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "2[136]|8"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[3-7]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "4(?:1111|2022)\\d{3}|4(?:[04]\\d\\d|14[0-6]|999)\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "[35-7]\\d{7}",
                    [
                        8
                    ]
                ],
                [
                    "800\\d{4}|(?:0080[01]|800)\\d{6}",
                    [
                        7,
                        9,
                        11
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "2[136]\\d{5}",
                    [
                        7
                    ]
                ]
            ]
        ],
        "RE": [
            "262",
            "00",
            "709\\d{6}|(?:26|[689]\\d)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[26-9]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "26(?:2\\d\\d|3(?:0\\d|1[0-6]))\\d{4}"
                ],
                [
                    "(?:69(?:2\\d\\d|3(?:[06][0-6]|1[0-3]|2[0-2]|3[0-39]|4\\d|5[0-5]|7[0-37]|8[0-8]|9[0-479]))|7092[0-3])\\d{4}"
                ],
                [
                    "80\\d{7}"
                ],
                [
                    "89[1-37-9]\\d{6}"
                ],
                0,
                0,
                0,
                0,
                [
                    "9(?:399[0-3]|479[0-6]|76(?:2[278]|3[0-37]))\\d{4}"
                ],
                [
                    "8(?:1[019]|2[0156]|84|90)\\d{6}"
                ]
            ]
        ],
        "RO": [
            "40",
            "00",
            "(?:[236-8]\\d|90)\\d{7}|[23]\\d{5}",
            [
                6,
                9
            ],
            [
                [
                    "(\\d{3})(\\d{3})",
                    "$1 $2",
                    [
                        "2[3-6]",
                        "2[3-6]\\d9"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{4})",
                    "$1 $2",
                    [
                        "219|31"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[23]1"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[236-9]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "[23][13-6]\\d{7}|(?:2(?:19\\d|[3-6]\\d9)|31\\d\\d)\\d\\d"
                ],
                [
                    "(?:630|702)0\\d{5}|(?:6(?:00|2\\d)|7(?:0[013-9]|1[0-3]|[2-7]\\d|8[03-8]|9[0-39]))\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "90[0136]\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                0,
                [
                    "(?:37\\d|80[578])\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                0,
                [
                    "801\\d{6}",
                    [
                        9
                    ]
                ]
            ],
            0,
            " int "
        ],
        "RS": [
            "381",
            "00",
            "38[02-9]\\d{6,9}|6\\d{7,9}|90\\d{4,8}|38\\d{5,6}|(?:7\\d\\d|800)\\d{3,9}|(?:[12]\\d|3[0-79])\\d{5,10}",
            [
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{3})(\\d{3,9})",
                    "$1 $2",
                    [
                        "(?:2[389]|39)0|[7-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{5,10})",
                    "$1 $2",
                    [
                        "[1-36]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:11[1-9]\\d|(?:2[389]|39)(?:0[2-9]|[2-9]\\d))\\d{3,8}|(?:1[02-9]|2[0-24-7]|3[0-8])[2-9]\\d{4,9}",
                    [
                        7,
                        8,
                        9,
                        10,
                        11,
                        12
                    ]
                ],
                [
                    "6(?:[0-689]|7\\d)\\d{6,7}",
                    [
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "800\\d{3,9}"
                ],
                [
                    "(?:78\\d|90[0169])\\d{3,7}",
                    [
                        6,
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                0,
                0,
                [
                    "7[06]\\d{4,10}"
                ]
            ]
        ],
        "RU": [
            "7",
            "810",
            "8\\d{13}|[347-9]\\d{9}",
            [
                10,
                14
            ],
            [
                [
                    "(\\d{4})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "7(?:1[0-8]|2[1-9])",
                        "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:1[23]|[2-9]2))",
                        "7(?:1(?:[0-356]2|4[29]|7|8[27])|2(?:13[03-69]|62[013-9]))|72[1-57-9]2"
                    ],
                    "8 ($1)",
                    1
                ],
                [
                    "(\\d{5})(\\d)(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "7(?:1[0-68]|2[1-9])",
                        "7(?:1(?:[06][3-6]|[18]|2[35]|[3-5][3-5])|2(?:[13][3-5]|[24-689]|7[457]))",
                        "7(?:1(?:0(?:[356]|4[023])|[18]|2(?:3[013-9]|5)|3[45]|43[013-79]|5(?:3[1-8]|4[1-7]|5)|6(?:3[0-35-9]|[4-6]))|2(?:1(?:3[178]|[45])|[24-689]|3[35]|7[457]))|7(?:14|23)4[0-8]|71(?:33|45)[1-79]"
                    ],
                    "8 ($1)",
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "7"
                    ],
                    "8 ($1)",
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2-$3-$4",
                    [
                        "[349]|8(?:[02-7]|1[1-8])"
                    ],
                    "8 ($1)",
                    1
                ],
                [
                    "(\\d{4})(\\d{4})(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "8"
                    ],
                    "8 ($1)"
                ]
            ],
            "8",
            0,
            0,
            0,
            0,
            "3[04-689]|[489]",
            [
                [
                    "(?:3(?:0[12]|4[1-35-79]|5[1-3]|65|8[1-58]|9[0145])|4(?:01|1[1356]|2[13467]|7[1-5]|8[1-7]|9[1-689])|8(?:1[1-8]|2[01]|3[13-6]|4[0-8]|5[15]|6[1-35-79]|7[1-37-9]))\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "9\\d{9}",
                    [
                        10
                    ]
                ],
                [
                    "8(?:0[04]|108\\d{3})\\d{7}"
                ],
                [
                    "80[39]\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "808\\d{7}",
                    [
                        10
                    ]
                ]
            ],
            "8~10"
        ],
        "RW": [
            "250",
            "00",
            "(?:06|[27]\\d\\d|[89]00)\\d{6}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "0"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "2"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[7-9]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:06|2[23568]\\d)\\d{6}"
                ],
                [
                    "7[237-9]\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "900\\d{6}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "SA": [
            "966",
            "00",
            "92\\d{7}|(?:[15]|8\\d)\\d{8}",
            [
                9,
                10
            ],
            [
                [
                    "(\\d{4})(\\d{5})",
                    "$1 $2",
                    [
                        "9"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "5"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "81"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "1(?:1\\d|2[24-8]|3[35-8]|4[3-68]|6[2-5]|7[235-7])\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "579[01]\\d{5}|5(?:[013-689]\\d|7[0-8])\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "925\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                0,
                [
                    "811\\d{7}",
                    [
                        10
                    ]
                ],
                0,
                0,
                [
                    "920\\d{6}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "SB": [
            "677",
            "0[01]",
            "[6-9]\\d{6}|[1-6]\\d{4}",
            [
                5,
                7
            ],
            [
                [
                    "(\\d{2})(\\d{5})",
                    "$1 $2",
                    [
                        "6[89]|7|8[4-9]|9(?:[1-8]|9[0-8])"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1[4-79]|[23]\\d|4[0-2]|5[03]|6[0-37])\\d{3}",
                    [
                        5
                    ]
                ],
                [
                    "48\\d{3}|(?:(?:6[89]|7[1-9]|8[4-9])\\d|9(?:1[2-9]|2[013-9]|3[0-2]|[46]\\d|5[0-46-9]|7[0-689]|8[0-79]|9[0-8]))\\d{4}"
                ],
                [
                    "1[38]\\d{3}",
                    [
                        5
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "5[12]\\d{3}",
                    [
                        5
                    ]
                ]
            ]
        ],
        "SC": [
            "248",
            "010|0[0-2]",
            "(?:[2489]\\d|64)\\d{5}",
            [
                7
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[246]|9[57]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "4[2-46]\\d{5}"
                ],
                [
                    "2[125-8]\\d{5}"
                ],
                [
                    "800[08]\\d{3}"
                ],
                [
                    "85\\d{5}"
                ],
                0,
                0,
                0,
                0,
                [
                    "971\\d{4}|(?:64|95)\\d{5}"
                ]
            ],
            "00"
        ],
        "SD": [
            "249",
            "00",
            "[19]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[19]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "1(?:5\\d|8[35-7])\\d{6}"
                ],
                [
                    "(?:1[0-2]|9[0-3569])\\d{7}"
                ]
            ]
        ],
        "SE": [
            "46",
            "00",
            "(?:[26]\\d\\d|9)\\d{9}|[1-9]\\d{8}|[1-689]\\d{7}|[1-4689]\\d{6}|2\\d{5}",
            [
                6,
                7,
                8,
                9,
                10,
                12
            ],
            [
                [
                    "(\\d{2})(\\d{2,3})(\\d{2})",
                    "$1-$2 $3",
                    [
                        "20"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3"
                ],
                [
                    "(\\d{3})(\\d{4})",
                    "$1-$2",
                    [
                        "9(?:00|39|44|9)"
                    ],
                    "0$1",
                    0,
                    "$1 $2"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})",
                    "$1-$2 $3",
                    [
                        "[12][136]|3[356]|4[0246]|6[03]|90[1-9]"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3"
                ],
                [
                    "(\\d)(\\d{2,3})(\\d{2})(\\d{2})",
                    "$1-$2 $3 $4",
                    [
                        "8"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3 $4"
                ],
                [
                    "(\\d{3})(\\d{2,3})(\\d{2})",
                    "$1-$2 $3",
                    [
                        "1[2457]|2(?:[247-9]|5[0138])|3[0247-9]|4[1357-9]|5[0-35-9]|6(?:[125689]|4[02-57]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3"
                ],
                [
                    "(\\d{3})(\\d{2,3})(\\d{3})",
                    "$1-$2 $3",
                    [
                        "9(?:00|39|44)"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3"
                ],
                [
                    "(\\d{2})(\\d{2,3})(\\d{2})(\\d{2})",
                    "$1-$2 $3 $4",
                    [
                        "1[13689]|2[0136]|3[1356]|4[0246]|54|6[03]|90[1-9]"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3 $4"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1-$2 $3 $4",
                    [
                        "10|7"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3 $4"
                ],
                [
                    "(\\d)(\\d{3})(\\d{3})(\\d{2})",
                    "$1-$2 $3 $4",
                    [
                        "8"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3 $4"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1-$2 $3 $4",
                    [
                        "[13-5]|2(?:[247-9]|5[0138])|6(?:[124-689]|7[0-2])|9(?:[125-8]|3[02-5]|4[0-3])"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3 $4"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{3})",
                    "$1-$2 $3 $4",
                    [
                        "9"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3 $4"
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1-$2 $3 $4 $5",
                    [
                        "[26]"
                    ],
                    "0$1",
                    0,
                    "$1 $2 $3 $4 $5"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:(?:[12][136]|3[356]|4[0246]|6[03]|8\\d)\\d|90[1-9])\\d{4,6}|(?:1(?:2[0-35]|4[0-4]|5[0-25-9]|7[13-6]|[89]\\d)|2(?:2[0-7]|4[0136-8]|5[0138]|7[018]|8[01]|9[0-57])|3(?:0[0-4]|1\\d|2[0-25]|4[056]|7[0-2]|8[0-3]|9[023])|4(?:1[013-8]|3[0135]|5[14-79]|7[0-246-9]|8[0156]|9[0-689])|5(?:0[0-6]|[15][0-5]|2[0-68]|3[0-4]|4\\d|6[03-5]|7[013]|8[0-79]|9[01])|6(?:1[1-3]|2[0-4]|4[02-57]|5[0-37]|6[0-3]|7[0-2]|8[0247]|9[0-356])|9(?:1[0-68]|2\\d|3[02-5]|4[0-3]|5[0-4]|[68][01]|7[0135-8]))\\d{5,6}",
                    [
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "7[02369]\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "20\\d{4,7}",
                    [
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "649\\d{6}|99[1-59]\\d{4}(?:\\d{3})?|9(?:00|39|44)[1-8]\\d{3,6}",
                    [
                        7,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "75[1-8]\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "(?:25[245]|67[3-68])\\d{9}",
                    [
                        12
                    ]
                ],
                [
                    "10[1-8]\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "74[02-9]\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "77[0-7]\\d{6}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "SG": [
            "65",
            "0[0-3]\\d",
            "(?:(?:1\\d|8)\\d\\d|7000)\\d{7}|[3689]\\d{7}",
            [
                8,
                10,
                11
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[369]|8(?:0[1-9]|[1-9])"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "8"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "7"
                    ]
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "662[0-24-9]\\d{4}|6(?:[0-578]\\d|6[013-57-9]|9[0-35-9])\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "897[01]\\d{4}|(?:8(?:0[1-9]|[1-8]\\d|9[0-6])|9[0-8]\\d)\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "(?:18|8)00\\d{7}",
                    [
                        10,
                        11
                    ]
                ],
                [
                    "1900\\d{7}",
                    [
                        11
                    ]
                ],
                0,
                0,
                [
                    "7000\\d{7}",
                    [
                        11
                    ]
                ],
                0,
                [
                    "(?:3[12]\\d|666)\\d{5}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "SH": [
            "290",
            "00",
            "(?:[256]\\d|8)\\d{3}",
            [
                4,
                5
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            "[256]",
            [
                [
                    "2(?:[0-57-9]\\d|6[4-9])\\d\\d"
                ],
                [
                    "[56]\\d{4}",
                    [
                        5
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "262\\d\\d",
                    [
                        5
                    ]
                ]
            ]
        ],
        "SI": [
            "386",
            "00|10(?:22|66|88|99)",
            "[1-7]\\d{7}|8\\d{4,7}|90\\d{4,6}",
            [
                5,
                6,
                7,
                8
            ],
            [
                [
                    "(\\d{2})(\\d{3,6})",
                    "$1 $2",
                    [
                        "8[09]|9"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{5})",
                    "$1 $2",
                    [
                        "59|8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[37][01]|4[0139]|51|6"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[1-57]"
                    ],
                    "(0$1)"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:[1-357][2-8]|4[24-8])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "65(?:[178]\\d|5[56]|6[01])\\d{4}|(?:[37][01]|4[0139]|51|6[489])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "80\\d{4,6}",
                    [
                        6,
                        7,
                        8
                    ]
                ],
                [
                    "89[1-3]\\d{2,5}|90\\d{4,6}"
                ],
                0,
                0,
                0,
                0,
                [
                    "(?:59\\d\\d|8(?:1(?:[67]\\d|8[0-589])|2(?:0\\d|2[0-37-9]|8[0-2489])|3[389]\\d))\\d{4}",
                    [
                        8
                    ]
                ]
            ],
            "00"
        ],
        "SJ": [
            "47",
            "00",
            "0\\d{4}|(?:[489]\\d|79)\\d{6}",
            [
                5,
                8
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            "79",
            [
                [
                    "79\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "(?:4[015-8]|9\\d)\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "80[01]\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "82[09]\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "880\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "81[23]\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "(?:0[235-9]|81(?:0(?:0[7-9]|1\\d)|5\\d\\d))\\d{3}"
                ],
                0,
                [
                    "85[0-5]\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "810(?:0[0-6]|[2-8]\\d)\\d{3}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "SK": [
            "421",
            "00",
            "[2-689]\\d{8}|[2-59]\\d{6}|[2-5]\\d{5}",
            [
                6,
                7,
                9
            ],
            [
                [
                    "(\\d)(\\d{2})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "21"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{2,3})",
                    "$1 $2 $3",
                    [
                        "[3-5][1-8]1",
                        "[3-5][1-8]1[67]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{3})(\\d{2})",
                    "$1/$2 $3 $4",
                    [
                        "2"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[689]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1/$2 $3 $4",
                    [
                        "[3-5]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:16|[2-9]\\d{3})|(?:(?:[3-5][1-8]\\d|819)\\d|601[1-5])\\d)\\d{4}|(?:2|[3-5][1-8])1[67]\\d{3}|[3-5][1-8]16\\d\\d"
                ],
                [
                    "909[1-9]\\d{5}|9(?:0[1-8]|1[0-24-9]|4[03-57-9]|5\\d)\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "800\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "9(?:00|[78]\\d)\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                0,
                [
                    "96\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "9090\\d{3}",
                    [
                        7
                    ]
                ],
                [
                    "6(?:02|5[0-4]|9[0-6])\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "8[5-9]\\d{7}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "SL": [
            "232",
            "00",
            "(?:[237-9]\\d|66)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{6})",
                    "$1 $2",
                    [
                        "[236-9]"
                    ],
                    "(0$1)"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "22[2-4][2-9]\\d{4}"
                ],
                [
                    "(?:25|3[0-5]|66|7[1-9]|8[08]|9[09])\\d{6}"
                ]
            ]
        ],
        "SM": [
            "378",
            "00",
            "(?:0549|[5-7]\\d)\\d{6}",
            [
                8,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[5-7]"
                    ]
                ],
                [
                    "(\\d{4})(\\d{6})",
                    "$1 $2",
                    [
                        "0"
                    ]
                ]
            ],
            0,
            0,
            "([89]\\d{5})$",
            "0549$1",
            0,
            0,
            [
                [
                    "0549(?:8[0157-9]|9\\d)\\d{4}",
                    [
                        10
                    ]
                ],
                [
                    "6[16]\\d{6}",
                    [
                        8
                    ]
                ],
                0,
                [
                    "7[178]\\d{6}",
                    [
                        8
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "5[158]\\d{6}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "SN": [
            "221",
            "00",
            "(?:[378]\\d|93)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "8"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[379]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "3(?:0(?:1[0-2]|80)|282|3(?:8[1-9]|9[3-9])|611)\\d{5}"
                ],
                [
                    "7(?:(?:[06-8]\\d|[19]0|21)\\d|5(?:0[01]|[19]0|2[25]|3[356]|[4-7]\\d|8[35]))\\d{5}"
                ],
                [
                    "800\\d{6}"
                ],
                [
                    "88[4689]\\d{6}"
                ],
                0,
                0,
                0,
                0,
                [
                    "(?:3(?:392|9[01]\\d)\\d|93(?:3[13]0|929))\\d{4}"
                ],
                [
                    "81[02468]\\d{6}"
                ]
            ]
        ],
        "SO": [
            "252",
            "00",
            "[346-9]\\d{8}|[12679]\\d{7}|[1-5]\\d{6}|[1348]\\d{5}",
            [
                6,
                7,
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{4})",
                    "$1 $2",
                    [
                        "8[125]"
                    ]
                ],
                [
                    "(\\d{6})",
                    "$1",
                    [
                        "[134]"
                    ]
                ],
                [
                    "(\\d)(\\d{6})",
                    "$1 $2",
                    [
                        "[15]|2[0-79]|3[0-46-8]|4[0-7]"
                    ]
                ],
                [
                    "(\\d)(\\d{7})",
                    "$1 $2",
                    [
                        "(?:2|90)4|[67]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[348]|64|79|90"
                    ]
                ],
                [
                    "(\\d{2})(\\d{5,7})",
                    "$1 $2",
                    [
                        "1|28|6[0-35-9]|7[67]|9[2-9]"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1\\d|2[0-79]|3[0-46-8]|4[0-7]|5[57-9])\\d{5}|(?:[134]\\d|8[125])\\d{4}",
                    [
                        6,
                        7
                    ]
                ],
                [
                    "(?:(?:15|(?:3[59]|4[89]|6\\d|7[679]|8[08])\\d|9(?:0\\d|[2-9]))\\d|2(?:4\\d|8))\\d{5}|(?:[67]\\d\\d|904)\\d{5}",
                    [
                        7,
                        8,
                        9
                    ]
                ]
            ]
        ],
        "SR": [
            "597",
            "00",
            "(?:[2-5]|68|[78]\\d|90)\\d{5}",
            [
                6,
                7
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})",
                    "$1-$2-$3",
                    [
                        "56"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})",
                    "$1-$2",
                    [
                        "[2-5]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{4})",
                    "$1-$2",
                    [
                        "[6-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2[1-3]|3[0-7]|(?:4|68)\\d|5[2-58])\\d{4}"
                ],
                [
                    "(?:7[124-7]|8[1-9])\\d{5}",
                    [
                        7
                    ]
                ],
                [
                    "80\\d{5}",
                    [
                        7
                    ]
                ],
                [
                    "90\\d{5}",
                    [
                        7
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "56\\d{4}",
                    [
                        6
                    ]
                ]
            ]
        ],
        "SS": [
            "211",
            "00",
            "[19]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[19]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "1[89]\\d{7}"
                ],
                [
                    "(?:12|9[1257-9])\\d{7}"
                ]
            ]
        ],
        "ST": [
            "239",
            "00",
            "(?:22|9\\d)\\d{5}",
            [
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[29]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "22\\d{5}"
                ],
                [
                    "900[5-9]\\d{3}|9(?:0[1-9]|[89]\\d)\\d{4}"
                ]
            ]
        ],
        "SV": [
            "503",
            "00",
            "[267]\\d{7}|(?:80\\d|900)\\d{4}(?:\\d{4})?",
            [
                7,
                8,
                11
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[89]"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[267]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[89]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:79(?:0[0347-9]|[1-9]\\d)|89(?:0[024589]|[1-9]\\d))\\d{3}|2(?:[1-69]\\d|[78][0-8])\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "[67]\\d{7}",
                    [
                        8
                    ]
                ],
                [
                    "800\\d{8}|80[01]\\d{4}",
                    [
                        7,
                        11
                    ]
                ],
                [
                    "900\\d{4}(?:\\d{4})?",
                    [
                        7,
                        11
                    ]
                ]
            ]
        ],
        "SX": [
            "1",
            "011",
            "7215\\d{6}|(?:[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "(5\\d{6})$|1",
            "721$1",
            0,
            "721",
            [
                [
                    "7215(?:4[2-8]|8[239]|9[056])\\d{4}"
                ],
                [
                    "7215(?:1[02]|2\\d|5[034679]|8[014-8])\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "SY": [
            "963",
            "00",
            "[1-39]\\d{8}|[1-5]\\d{7}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[1-5]"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "9"
                    ],
                    "0$1",
                    1
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "21\\d{6,7}|(?:1(?:[14]\\d|[2356])|2[235]|3(?:[13]\\d|4)|4[134]|5[1-3])\\d{6}"
                ],
                [
                    "9[1-9]\\d{7}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "SZ": [
            "268",
            "00",
            "0800\\d{4}|(?:[237]\\d|900)\\d{6}",
            [
                8,
                9
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[0237]"
                    ]
                ],
                [
                    "(\\d{5})(\\d{4})",
                    "$1 $2",
                    [
                        "9"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "[23][2-5]\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "7[6-9]\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "0800\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "900\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "70\\d{6}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "TA": [
            "290",
            "00",
            "8\\d{3}",
            [
                4
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            "8",
            [
                [
                    "8\\d{3}"
                ]
            ]
        ],
        "TC": [
            "1",
            "011",
            "(?:[58]\\d\\d|649|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-479]\\d{6})$|1",
            "649$1",
            0,
            "649",
            [
                [
                    "649(?:266|712|9(?:4\\d|50))\\d{4}"
                ],
                [
                    "649(?:2(?:3[129]|4[1-79])|3\\d\\d|4[34][1-3])\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ],
                0,
                0,
                0,
                [
                    "649(?:71[01]|966)\\d{4}"
                ]
            ]
        ],
        "TD": [
            "235",
            "00|16",
            "(?:22|[689]\\d|77)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[26-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "22(?:[37-9]0|5[0-5]|6[89])\\d{4}"
                ],
                [
                    "(?:[69]\\d|77|8[56])\\d{6}"
                ]
            ],
            "00"
        ],
        "TG": [
            "228",
            "00",
            "[279]\\d{7}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[279]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:2[2-7]|3[23]|4[45]|55|6[67]|77)\\d{5}"
                ],
                [
                    "(?:7[0-29]|9[0-36-9])\\d{6}"
                ]
            ]
        ],
        "TH": [
            "66",
            "00[1-9]",
            "(?:001800|[2-57]|[689]\\d)\\d{7}|1\\d{7,9}",
            [
                8,
                9,
                10,
                13
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "2"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[13-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "1"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1[0689]|2\\d|3[2-9]|4[2-5]|5[2-6]|7[3-7])\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "67(?:1[0-8]|2[4-7])\\d{5}|(?:14|6[1-6]|[89]\\d)\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "(?:001800\\d|1800)\\d{6}",
                    [
                        10,
                        13
                    ]
                ],
                [
                    "1900\\d{6}",
                    [
                        10
                    ]
                ],
                0,
                0,
                0,
                0,
                [
                    "6[08]\\d{7}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "TJ": [
            "992",
            "810",
            "[0-57-9]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d{6})(\\d)(\\d{2})",
                    "$1 $2 $3",
                    [
                        "331",
                        "3317"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "44[02-479]|[34]7"
                    ]
                ],
                [
                    "(\\d{4})(\\d)(\\d{4})",
                    "$1 $2 $3",
                    [
                        "3(?:[1245]|3[12])"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[0-57-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:3(?:1[3-5]|2[245]|3[12]|4[24-7]|5[25]|72)|4(?:46|74|87))\\d{6}"
                ],
                [
                    "(?:33[03-9]|4(?:1[18]|4[02-479])|81[1-9])\\d{6}|(?:[09]\\d|1[0-27-9]|2[0-27]|[34]0|5[05]|7[01578]|8[078])\\d{7}"
                ]
            ],
            "8~10"
        ],
        "TK": [
            "690",
            "00",
            "[2-47]\\d{3,6}",
            [
                4,
                5,
                6,
                7
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2[2-4]|[34]\\d)\\d{2,5}"
                ],
                [
                    "7[2-4]\\d{2,5}"
                ]
            ]
        ],
        "TL": [
            "670",
            "00",
            "7\\d{7}|(?:[2-47]\\d|[89]0)\\d{5}",
            [
                7,
                8
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[2-489]|70"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "7"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2[1-5]|3[1-9]|4[1-4])\\d{5}",
                    [
                        7
                    ]
                ],
                [
                    "7[2-8]\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "80\\d{5}",
                    [
                        7
                    ]
                ],
                [
                    "90\\d{5}",
                    [
                        7
                    ]
                ],
                [
                    "70\\d{5}",
                    [
                        7
                    ]
                ]
            ]
        ],
        "TM": [
            "993",
            "810",
            "(?:[1-6]\\d|71)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2-$3-$4",
                    [
                        "12"
                    ],
                    "(8 $1)"
                ],
                [
                    "(\\d{3})(\\d)(\\d{2})(\\d{2})",
                    "$1 $2-$3-$4",
                    [
                        "[1-5]"
                    ],
                    "(8 $1)"
                ],
                [
                    "(\\d{2})(\\d{6})",
                    "$1 $2",
                    [
                        "[67]"
                    ],
                    "8 $1"
                ]
            ],
            "8",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1(?:2\\d|3[1-9])|2(?:22|4[0-35-8])|3(?:22|4[03-9])|4(?:22|3[128]|4\\d|6[15])|5(?:22|5[7-9]|6[014-689]))\\d{5}"
                ],
                [
                    "(?:6\\d|71)\\d{6}"
                ]
            ],
            "8~10"
        ],
        "TN": [
            "216",
            "00",
            "[2-57-9]\\d{7}",
            [
                8
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[2-57-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "81200\\d{3}|(?:3[0-2]|7\\d)\\d{6}"
                ],
                [
                    "3(?:001|[12]40)\\d{4}|(?:(?:[259]\\d|4[0-8])\\d|3(?:1[1-35]|6[0-4]|91))\\d{5}"
                ],
                [
                    "8010\\d{4}"
                ],
                [
                    "88\\d{6}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "8[12]10\\d{4}"
                ]
            ]
        ],
        "TO": [
            "676",
            "00",
            "(?:0800|(?:[5-8]\\d\\d|999)\\d)\\d{3}|[2-8]\\d{4}",
            [
                5,
                7
            ],
            [
                [
                    "(\\d{2})(\\d{3})",
                    "$1-$2",
                    [
                        "[2-4]|50|6[09]|7[0-24-69]|8[05]"
                    ]
                ],
                [
                    "(\\d{4})(\\d{3})",
                    "$1 $2",
                    [
                        "0"
                    ]
                ],
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[5-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2\\d|3[0-8]|4[0-4]|50|6[09]|7[0-24-69]|8[05])\\d{3}",
                    [
                        5
                    ]
                ],
                [
                    "(?:5(?:4[0-5]|5[4-6])|6(?:[09]\\d|3[02]|8[15-9])|(?:7\\d|8[46-9])\\d|999)\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "0800\\d{3}",
                    [
                        7
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "55[0-37-9]\\d{4}",
                    [
                        7
                    ]
                ]
            ]
        ],
        "TR": [
            "90",
            "00",
            "4\\d{6}|8\\d{11,12}|(?:[2-58]\\d\\d|900)\\d{7}",
            [
                7,
                10,
                12,
                13
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "512|8[01589]|90"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "5(?:[0-59]|61)",
                        "5(?:[0-59]|61[06])",
                        "5(?:[0-59]|61[06]1)"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[24][1-8]|3[1-9]"
                    ],
                    "(0$1)",
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{6,7})",
                    "$1 $2 $3",
                    [
                        "80"
                    ],
                    "0$1",
                    1
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:[13][26]|[28][2468]|[45][268]|[67][246])|3(?:[13][28]|[24-6][2468]|[78][02468]|92)|4(?:[16][246]|[23578][2468]|4[26]))\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "561(?:011|61\\d)\\d{4}|5(?:0[15-7]|1[06]|24|[34]\\d|5[1-59]|9[46])\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "8(?:00\\d{7}(?:\\d{2,3})?|11\\d{7})",
                    [
                        10,
                        12,
                        13
                    ]
                ],
                [
                    "(?:8[89]8|900)\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "592(?:21[12]|461)\\d{4}",
                    [
                        10
                    ]
                ],
                0,
                [
                    "444\\d{4}",
                    [
                        7
                    ]
                ],
                [
                    "512\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "850\\d{7}",
                    [
                        10
                    ]
                ]
            ]
        ],
        "TT": [
            "1",
            "011",
            "(?:[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-46-8]\\d{6})$|1",
            "868$1",
            0,
            "868",
            [
                [
                    "868(?:2(?:01|1[5-9]|[23]\\d|4[0-2])|6(?:0[7-9]|1[02-8]|2[1-9]|[3-69]\\d|7[0-79])|82[124])\\d{4}"
                ],
                [
                    "868(?:(?:2[5-9]|3\\d)\\d|4(?:3[0-6]|[6-9]\\d)|6(?:20|78|8\\d)|7(?:0[1-9]|1[02-9]|[2-9]\\d))\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "868619\\d{4}"
                ]
            ]
        ],
        "TV": [
            "688",
            "00",
            "(?:2|7\\d\\d|90)\\d{4}",
            [
                5,
                6,
                7
            ],
            [
                [
                    "(\\d{2})(\\d{3})",
                    "$1 $2",
                    [
                        "2"
                    ]
                ],
                [
                    "(\\d{2})(\\d{4})",
                    "$1 $2",
                    [
                        "90"
                    ]
                ],
                [
                    "(\\d{2})(\\d{5})",
                    "$1 $2",
                    [
                        "7"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2[02-9]\\d{3}",
                    [
                        5
                    ]
                ],
                [
                    "(?:7[01]\\d|90)\\d{4}",
                    [
                        6,
                        7
                    ]
                ]
            ]
        ],
        "TW": [
            "886",
            "0(?:0[25-79]|19)",
            "[2-689]\\d{8}|7\\d{9,10}|[2-8]\\d{7}|2\\d{6}",
            [
                7,
                8,
                9,
                10,
                11
            ],
            [
                [
                    "(\\d{2})(\\d)(\\d{4})",
                    "$1 $2 $3",
                    [
                        "202"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[258]0"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3,4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[23568]|4(?:0[02-48]|[1-47-9])|7[1-9]",
                        "[23568]|4(?:0[2-48]|[1-47-9])|(?:400|7)[1-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[49]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4,5})",
                    "$1 $2 $3",
                    [
                        "7"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2[2-8]\\d|370|55[01]|7[1-9])\\d{6}|4(?:(?:0(?:0[1-9]|[2-48]\\d)|1[023]\\d)\\d{4,5}|(?:[239]\\d\\d|4(?:0[56]|12|49))\\d{5})|6(?:[01]\\d{7}|4(?:0[56]|12|24|4[09])\\d{4,5})|8(?:(?:2(?:3\\d|4[0-269]|[578]0|66)|36[24-9]|90\\d\\d)\\d{4}|4(?:0[56]|12|24|4[09])\\d{4,5})|(?:2(?:2(?:0\\d\\d|4(?:0[68]|[249]0|3[0-467]|5[0-25-9]|6[0235689]))|(?:3(?:[09]\\d|1[0-4])|(?:4\\d|5[0-49]|6[0-29]|7[0-5])\\d)\\d)|(?:(?:3[2-9]|5[2-8]|6[0-35-79]|8[7-9])\\d\\d|4(?:2(?:[089]\\d|7[1-9])|(?:3[0-4]|[78]\\d|9[01])\\d))\\d)\\d{3}",
                    [
                        8,
                        9
                    ]
                ],
                [
                    "(?:40001[0-2]|9[0-8]\\d{4})\\d{3}",
                    [
                        9
                    ]
                ],
                [
                    "80[0-79]\\d{6}|800\\d{5}",
                    [
                        8,
                        9
                    ]
                ],
                [
                    "20(?:[013-9]\\d\\d|2)\\d{4}",
                    [
                        7,
                        9
                    ]
                ],
                [
                    "99\\d{7}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "50[0-46-9]\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                [
                    "7010(?:[0-2679]\\d|3[0-7]|8[0-5])\\d{5}|70\\d{8}",
                    [
                        10,
                        11
                    ]
                ]
            ],
            0,
            "#"
        ],
        "TZ": [
            "255",
            "00[056]",
            "(?:[25-8]\\d|41|90)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{2})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[89]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[24]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{7})",
                    "$1 $2",
                    [
                        "5"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[67]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2[2-8]\\d{7}"
                ],
                [
                    "(?:6[125-9]|7[13-9])\\d{7}"
                ],
                [
                    "80[08]\\d{6}"
                ],
                [
                    "90\\d{7}"
                ],
                0,
                0,
                0,
                0,
                [
                    "41\\d{7}"
                ],
                [
                    "8(?:40|6[01])\\d{6}"
                ]
            ]
        ],
        "UA": [
            "380",
            "00",
            "[89]\\d{9}|[3-9]\\d{8}",
            [
                9,
                10
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "6[12][29]|(?:3[1-8]|4[136-8]|5[12457]|6[49])2|(?:56|65)[24]",
                        "6[12][29]|(?:35|4[1378]|5[12457]|6[49])2|(?:56|65)[24]|(?:3[1-46-8]|46)2[013-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{5})",
                    "$1 $2",
                    [
                        "3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6[0135689]|7[4-6])|6(?:[12][3-7]|[459])",
                        "3[1-8]|4(?:[1367]|[45][6-9]|8[4-6])|5(?:[1-5]|6(?:[015689]|3[02389])|7[4-6])|6(?:[12][3-7]|[459])"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[3-7]|89|9[1-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[89]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:3[1-8]|4[13-8]|5[1-7]|6[12459])\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "790\\d{6}|(?:39|50|6[36-8]|7[1-357]|9[1-9])\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "800[1-8]\\d{5,6}"
                ],
                [
                    "900[239]\\d{5,6}"
                ],
                0,
                0,
                0,
                0,
                [
                    "89[1-579]\\d{6}",
                    [
                        9
                    ]
                ]
            ],
            "0~0"
        ],
        "UG": [
            "256",
            "00[057]",
            "800\\d{6}|(?:[29]0|[347]\\d)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{4})(\\d{5})",
                    "$1 $2",
                    [
                        "202",
                        "2024"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{6})",
                    "$1 $2",
                    [
                        "[27-9]|4(?:6[45]|[7-9])"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{7})",
                    "$1 $2",
                    [
                        "[34]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "20(?:(?:240|30[67])\\d|6(?:00[0-2]|30[0-4]))\\d{3}|(?:20(?:[017]\\d|2[5-9]|3[1-4]|5[0-4]|6[15-9])|[34]\\d{3})\\d{5}"
                ],
                [
                    "72[48]0\\d{5}|7(?:[015-8]\\d|2[067]|36|4[0-8]|9[089])\\d{6}"
                ],
                [
                    "800[1-3]\\d{5}"
                ],
                [
                    "90[1-3]\\d{6}"
                ]
            ]
        ],
        "US": [
            "1",
            "011",
            "[2-9]\\d{9}|3\\d{6}",
            [
                10
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1-$2",
                    [
                        "310"
                    ],
                    0,
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "($1) $2-$3",
                    [
                        "[2-9]"
                    ],
                    0,
                    1,
                    "$1-$2-$3"
                ]
            ],
            "1",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:3052(?:0[0-8]|[1-9]\\d)|5056(?:[0-35-9]\\d|4[0-468]))\\d{4}|(?:2742|305[3-9]|472[247-9]|505[2-57-9]|983[2-47-9])\\d{6}|(?:2(?:0[1-35-9]|1[02-9]|2[03-57-9]|3[1459]|4[08]|5[1-46]|6[0279]|7[0269]|8[13])|3(?:0[1-47-9]|1[02-9]|2[0135-79]|3[0-24679]|4[167]|5[0-2]|6[01349]|8[056])|4(?:0[124-9]|1[02-579]|2[3-5]|3[0245]|4[023578]|58|6[349]|7[0589]|8[04])|5(?:0[1-47-9]|1[0235-8]|20|3[0149]|4[01]|5[179]|6[1-47]|7[0-5]|8[0256])|6(?:0[1-35-9]|1[024-9]|2[03689]|3[016]|4[0156]|5[01679]|6[0-279]|78|8[0-29])|7(?:0[1-46-8]|1[2-9]|2[04-8]|3[0-247]|4[037]|5[47]|6[02359]|7[0-59]|8[156])|8(?:0[1-68]|1[02-8]|2[0168]|3[0-2589]|4[03578]|5[046-9]|6[02-5]|7[028])|9(?:0[1346-9]|1[02-9]|2[0589]|3[0146-8]|4[01357-9]|5[12469]|7[0-389]|8[04-69]))[2-9]\\d{6}"
                ],
                [
                    ""
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ],
                0,
                0,
                0,
                [
                    "305209\\d{4}"
                ]
            ]
        ],
        "UY": [
            "598",
            "0(?:0|1[3-9]\\d)",
            "0004\\d{2,9}|[1249]\\d{7}|(?:[49]\\d|80)\\d{5}",
            [
                6,
                7,
                8,
                9,
                10,
                11,
                12,
                13
            ],
            [
                [
                    "(\\d{3})(\\d{3,4})",
                    "$1 $2",
                    [
                        "0"
                    ]
                ],
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[49]0|8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "9"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[124]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{2,4})",
                    "$1 $2 $3",
                    [
                        "0"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})(\\d{2,4})",
                    "$1 $2 $3 $4",
                    [
                        "0"
                    ]
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1(?:770|9(?:20|[89]7))|(?:2\\d|4[2-7])\\d\\d)\\d{4}",
                    [
                        8
                    ]
                ],
                [
                    "9[1-9]\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "0004\\d{2,9}|(?:405|80[05])\\d{4}"
                ],
                [
                    "90[0-8]\\d{4}",
                    [
                        7
                    ]
                ]
            ],
            "00",
            " int. "
        ],
        "UZ": [
            "998",
            "00",
            "(?:20|33|[5-9]\\d)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "[235-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:55\\d\\d|6(?:1(?:22|3[124]|4[1-4]|5[1-3578]|64)|2(?:22|3[0-57-9]|41)|5(?:22|3[3-7]|5[024-8])|[69]\\d\\d|7(?:[23]\\d|7[69]))|7(?:0(?:5[4-9]|6[0146]|7[124-6]|9[135-8])|[168]\\d\\d|2(?:22|3[13-57-9]|4[1-3579]|5[14])|3(?:2\\d|3[1578]|4[1-35-7]|5[1-57]|61)|4(?:2\\d|3[1-579]|7[1-79])|5(?:22|5[1-9]|6[1457])|9(?:22|5[1-9])))\\d{5}"
                ],
                [
                    "(?:(?:[25]0|33|8[78]|9[0-57-9])\\d{3}|6(?:1(?:2(?:2[01]|98)|35[0-4]|50\\d|61[23]|7(?:[01][017]|4\\d|55|9[5-9]))|2(?:(?:11|7\\d)\\d|2(?:[12]1|9[01379])|5(?:[126]\\d|3[0-4]))|5(?:19[01]|2(?:27|9[26])|(?:30|59|7\\d)\\d)|6(?:2(?:1[5-9]|2[0367]|38|41|52|60)|(?:3[79]|9[0-3])\\d|4(?:56|83)|7(?:[07]\\d|1[017]|3[07]|4[047]|5[057]|67|8[0178]|9[79]))|7(?:2(?:24|3[237]|4[5-9]|7[15-8])|5(?:7[12]|8[0589])|7(?:0\\d|[39][07])|9(?:0\\d|7[079])))|7(?:[07]\\d{3}|2(?:2(?:2[79]|95)|3(?:2[5-9]|6[0-6])|57\\d|7(?:0\\d|1[17]|2[27]|3[37]|44|5[057]|66|88))|3(?:2(?:1[0-6]|21|3[469]|7[159])|(?:33|9[4-6])\\d|5(?:0[0-4]|5[579]|9\\d)|7(?:[0-3579]\\d|4[0467]|6[67]|8[078]))|4(?:2(?:29|5[0257]|6[0-7]|7[1-57])|5(?:1[0-4]|8\\d|9[5-9])|7(?:0\\d|1[024589]|2[0-27]|3[0137]|[46][07]|5[01]|7[5-9]|9[079])|9(?:7[015-9]|[89]\\d))|5(?:112|2(?:0\\d|2[29]|[49]4)|3[1568]\\d|52[6-9]|7(?:0[01578]|1[017]|[23]7|4[047]|[5-7]\\d|8[78]|9[079]))|9(?:22[128]|3(?:2[0-4]|7\\d)|57[02569]|7(?:2[05-9]|3[37]|4\\d|60|7[2579]|87|9[07]))))\\d{4}"
                ]
            ]
        ],
        "VA": [
            "39",
            "00",
            "0\\d{5,10}|3[0-8]\\d{7,10}|55\\d{8}|8\\d{5}(?:\\d{2,4})?|(?:1\\d|39)\\d{7,8}",
            [
                6,
                7,
                8,
                9,
                10,
                11,
                12
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            "06698",
            [
                [
                    "06698\\d{1,6}",
                    [
                        6,
                        7,
                        8,
                        9,
                        10,
                        11
                    ]
                ],
                [
                    "3[1-9]\\d{8}|3[2-9]\\d{7}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "80(?:0\\d{3}|3)\\d{3}",
                    [
                        6,
                        9
                    ]
                ],
                [
                    "(?:0878\\d{3}|89(?:2\\d|3[04]|4(?:[0-4]|[5-9]\\d\\d)|5[0-4]))\\d\\d|(?:1(?:44|6[346])|89(?:38|5[5-9]|9))\\d{6}",
                    [
                        6,
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "1(?:78\\d|99)\\d{6}",
                    [
                        9,
                        10
                    ]
                ],
                [
                    "3[2-8]\\d{9,10}",
                    [
                        11,
                        12
                    ]
                ],
                0,
                0,
                [
                    "55\\d{8}",
                    [
                        10
                    ]
                ],
                [
                    "84(?:[08]\\d{3}|[17])\\d{3}",
                    [
                        6,
                        9
                    ]
                ]
            ]
        ],
        "VC": [
            "1",
            "011",
            "(?:[58]\\d\\d|784|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-7]\\d{6})$|1",
            "784$1",
            0,
            "784",
            [
                [
                    "784(?:266|3(?:6[6-9]|7\\d|8[0-6])|4(?:38|5[0-36-8]|8[0-8])|5(?:55|7[0-2]|93)|638|784)\\d{4}"
                ],
                [
                    "784(?:4(?:3[0-5]|5[45]|89|9[0-8])|5(?:2[6-9]|3[0-4])|720)\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ],
                0,
                0,
                0,
                [
                    "78451[0-2]\\d{4}"
                ]
            ]
        ],
        "VE": [
            "58",
            "00",
            "[68]00\\d{7}|(?:[24]\\d|[59]0)\\d{8}",
            [
                10
            ],
            [
                [
                    "(\\d{3})(\\d{7})",
                    "$1-$2",
                    [
                        "[24-689]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:12|3[457-9]|[467]\\d|[58][1-9]|9[1-6])|[4-6]00)\\d{7}"
                ],
                [
                    "4(?:1[24-8]|2[246])\\d{7}"
                ],
                [
                    "800\\d{7}"
                ],
                [
                    "90[01]\\d{7}"
                ],
                0,
                0,
                [
                    "501\\d{7}"
                ]
            ]
        ],
        "VG": [
            "1",
            "011",
            "(?:284|[58]\\d\\d|900)\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-578]\\d{6})$|1",
            "284$1",
            0,
            "284",
            [
                [
                    "284(?:229|4(?:22|9[45])|774|8(?:52|6[459]))\\d{4}"
                ],
                [
                    "284(?:245|3(?:0[0-3]|4[0-7]|68|9[34])|4(?:4[0-6]|68|9[69])|5(?:4[0-7]|68|9[69]))\\d{4}"
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "VI": [
            "1",
            "011",
            "[58]\\d{9}|(?:34|90)0\\d{7}",
            [
                10
            ],
            0,
            "1",
            0,
            "([2-9]\\d{6})$|1",
            "340$1",
            0,
            "340",
            [
                [
                    "340(?:2(?:0\\d|10|2[06-8]|4[49]|77)|3(?:32|44)|4(?:2[23]|44|7[34]|89)|5(?:1[34]|55)|6(?:2[56]|4[23]|77|9[023])|7(?:1[2-57-9]|2[57]|7\\d)|884|998)\\d{4}"
                ],
                [
                    ""
                ],
                [
                    "8(?:00|33|44|55|66|77|88)[2-9]\\d{6}"
                ],
                [
                    "900[2-9]\\d{6}"
                ],
                [
                    "52(?:3(?:[2-46-9][02-9]\\d|5(?:[02-46-9]\\d|5[0-46-9]))|4(?:[2-478][02-9]\\d|5(?:[034]\\d|2[024-9]|5[0-46-9])|6(?:0[1-9]|[2-9]\\d)|9(?:[05-9]\\d|2[0-5]|49)))\\d{4}|52[34][2-9]1[02-9]\\d{4}|5(?:00|2[125-9]|33|44|66|77|88)[2-9]\\d{6}"
                ]
            ]
        ],
        "VN": [
            "84",
            "00",
            "[12]\\d{9}|[135-9]\\d{8}|[16]\\d{7}|[16-8]\\d{6}",
            [
                7,
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{5})",
                    "$1 $2",
                    [
                        "80"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{4})(\\d{4,6})",
                    "$1 $2",
                    [
                        "1"
                    ],
                    0,
                    1
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "6"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[357-9]"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "2[48]"
                    ],
                    "0$1",
                    1
                ],
                [
                    "(\\d{3})(\\d{4})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "2"
                    ],
                    "0$1",
                    1
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "2(?:0[3-9]|1[0-689]|2[0-25-9]|[38][2-9]|4[2-8]|5[124-9]|6[0-39]|7[0-7]|9[0-4679])\\d{7}",
                    [
                        10
                    ]
                ],
                [
                    "(?:5(?:2[238]|59)|89[6-9]|99[013-9])\\d{6}|(?:3\\d|5[1689]|7[06-9]|8[1-8]|9[0-8])\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "1800\\d{4,6}|12(?:0[13]|28)\\d{4}",
                    [
                        8,
                        9,
                        10
                    ]
                ],
                [
                    "1900\\d{4,6}",
                    [
                        8,
                        9,
                        10
                    ]
                ],
                0,
                0,
                [
                    "(?:[17]99|80\\d)\\d{4}|69\\d{5,6}",
                    [
                        7,
                        8
                    ]
                ],
                0,
                [
                    "672\\d{6}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "VU": [
            "678",
            "00",
            "[57-9]\\d{6}|(?:[238]\\d|48)\\d{3}",
            [
                5,
                7
            ],
            [
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "[57-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:38[0-8]|48[4-9])\\d\\d|(?:2[02-9]|3[4-7]|88)\\d{3}",
                    [
                        5
                    ]
                ],
                [
                    "(?:[58]\\d|7[013-7])\\d{5}",
                    [
                        7
                    ]
                ],
                [
                    "81[18]\\d\\d",
                    [
                        5
                    ]
                ],
                0,
                0,
                0,
                [
                    "(?:3[03]|900\\d)\\d{3}"
                ],
                0,
                [
                    "9(?:0[1-9]|1[01])\\d{4}",
                    [
                        7
                    ]
                ]
            ]
        ],
        "WF": [
            "681",
            "00",
            "(?:40|72|8\\d{4})\\d{4}|[89]\\d{5}",
            [
                6,
                9
            ],
            [
                [
                    "(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3",
                    [
                        "[47-9]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{2})(\\d{2})(\\d{2})",
                    "$1 $2 $3 $4",
                    [
                        "8"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "72\\d{4}",
                    [
                        6
                    ]
                ],
                [
                    "(?:72|8[23])\\d{4}",
                    [
                        6
                    ]
                ],
                [
                    "80[0-5]\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                0,
                [
                    "[48]0\\d{4}",
                    [
                        6
                    ]
                ],
                0,
                0,
                [
                    "9[23]\\d{4}",
                    [
                        6
                    ]
                ]
            ]
        ],
        "WS": [
            "685",
            "0",
            "(?:[2-6]|8\\d{5})\\d{4}|[78]\\d{6}|[68]\\d{5}",
            [
                5,
                6,
                7,
                10
            ],
            [
                [
                    "(\\d{5})",
                    "$1",
                    [
                        "[2-5]|6[1-9]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3,7})",
                    "$1 $2",
                    [
                        "[68]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{5})",
                    "$1 $2",
                    [
                        "7"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "6[1-9]\\d{3}|(?:[2-5]|60)\\d{4}",
                    [
                        5,
                        6
                    ]
                ],
                [
                    "(?:7[1-35-7]|8(?:[3-7]|9\\d{3}))\\d{5}",
                    [
                        7,
                        10
                    ]
                ],
                [
                    "800\\d{3}",
                    [
                        6
                    ]
                ]
            ]
        ],
        "XK": [
            "383",
            "00",
            "2\\d{7,8}|3\\d{7,11}|(?:4\\d\\d|[89]00)\\d{5}",
            [
                8,
                9,
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{3})(\\d{5})",
                    "$1 $2",
                    [
                        "[89]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[2-4]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "2|39"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{7,10})",
                    "$1 $2",
                    [
                        "3"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "38\\d{6,10}|(?:2[89]|39)(?:0\\d{5,6}|[1-9]\\d{5})"
                ],
                [
                    "4[3-9]\\d{6}",
                    [
                        8
                    ]
                ],
                [
                    "800\\d{5}",
                    [
                        8
                    ]
                ],
                [
                    "900\\d{5}",
                    [
                        8
                    ]
                ]
            ]
        ],
        "YE": [
            "967",
            "00",
            "(?:1|7\\d)\\d{7}|[1-7]\\d{6}",
            [
                7,
                8,
                9
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "[1-6]|7(?:[24-6]|8[0-7])"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "7"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "78[0-7]\\d{4}|17\\d{6}|(?:[12][2-68]|3[2358]|4[2-58]|5[2-6]|6[3-58]|7[24-6])\\d{5}",
                    [
                        7,
                        8
                    ]
                ],
                [
                    "7[01378]\\d{7}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "YT": [
            "262",
            "00",
            "7093\\d{5}|(?:80|9\\d)\\d{7}|(?:26|63)9\\d{6}",
            [
                9
            ],
            0,
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "269(?:0[0-467]|15|5[0-4]|6\\d|[78]0)\\d{4}"
                ],
                [
                    "(?:639(?:0[0-79]|1[019]|[267]\\d|3[09]|40|5[05-9]|9[04-79])|7093[5-7])\\d{4}"
                ],
                [
                    "80\\d{7}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "9(?:(?:39|47)8[01]|769\\d)\\d{4}"
                ]
            ]
        ],
        "ZA": [
            "27",
            "00",
            "[1-79]\\d{8}|8\\d{4,9}",
            [
                5,
                6,
                7,
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{2})(\\d{3,4})",
                    "$1 $2",
                    [
                        "8[1-4]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{2,3})",
                    "$1 $2 $3",
                    [
                        "8[1-4]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "860"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[1-9]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "8"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:2(?:0330|4302)|52087)0\\d{3}|(?:1[0-8]|2[1-378]|3[1-69]|4\\d|5[1346-8])\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "(?:1(?:3492[0-25]|4495[0235]|549(?:20|5[01]))|4[34]492[01])\\d{3}|8[1-4]\\d{3,7}|(?:2[27]|47|54)4950\\d{3}|(?:1(?:049[2-4]|9[12]\\d\\d)|(?:50[0-2]|6\\d\\d|7(?:[0-46-9]\\d|5[0-4]))\\d\\d|8(?:5\\d{3}|7(?:08[67]|158|28[5-9]|310)))\\d{4}|(?:1[6-8]|28|3[2-69]|4[025689]|5[36-8])4920\\d{3}|(?:12|[2-5]1)492\\d{4}",
                    [
                        5,
                        6,
                        7,
                        8,
                        9
                    ]
                ],
                [
                    "80\\d{7}",
                    [
                        9
                    ]
                ],
                [
                    "(?:86[2-9]|9[0-2]\\d)\\d{6}",
                    [
                        9
                    ]
                ],
                0,
                0,
                [
                    "861\\d{6,7}",
                    [
                        9,
                        10
                    ]
                ],
                0,
                [
                    "87(?:08[0-589]|15[0-79]|28[0-4]|31[1-9])\\d{4}|87(?:[02][0-79]|1[0-46-9]|3[02-9]|[4-9]\\d)\\d{5}",
                    [
                        9
                    ]
                ],
                [
                    "860\\d{6}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "ZM": [
            "260",
            "00",
            "800\\d{6}|(?:21|[579]\\d|63)\\d{7}",
            [
                9
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[28]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{7})",
                    "$1 $2",
                    [
                        "[579]"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "21[1-8]\\d{6}"
                ],
                [
                    "(?:[59][5-8]|7[5-9])\\d{7}"
                ],
                [
                    "800\\d{6}"
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "63\\d{7}"
                ]
            ]
        ],
        "ZW": [
            "263",
            "00",
            "2(?:[0-57-9]\\d{6,8}|6[0-24-9]\\d{6,7})|[38]\\d{9}|[35-8]\\d{8}|[3-6]\\d{7}|[1-689]\\d{6}|[1-3569]\\d{5}|[1356]\\d{4}",
            [
                5,
                6,
                7,
                8,
                9,
                10
            ],
            [
                [
                    "(\\d{3})(\\d{3,5})",
                    "$1 $2",
                    [
                        "2(?:0[45]|2[278]|[49]8)|3(?:[09]8|17)|6(?:[29]8|37|75)|[23][78]|(?:33|5[15]|6[68])[78]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d)(\\d{3})(\\d{2,4})",
                    "$1 $2 $3",
                    [
                        "[49]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{4})",
                    "$1 $2",
                    [
                        "80"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{7})",
                    "$1 $2",
                    [
                        "24|8[13-59]|(?:2[05-79]|39|5[45]|6[15-8])2",
                        "2(?:02[014]|4|[56]20|[79]2)|392|5(?:42|525)|6(?:[16-8]21|52[013])|8[13-59]"
                    ],
                    "(0$1)"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "7"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "2(?:1[39]|2[0157]|[378]|[56][14])|3(?:12|29)",
                        "2(?:1[39]|2[0157]|[378]|[56][14])|3(?:123|29)"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{6})",
                    "$1 $2",
                    [
                        "8"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3,5})",
                    "$1 $2",
                    [
                        "1|2(?:0[0-36-9]|12|29|[56])|3(?:1[0-689]|[24-6])|5(?:[0236-9]|1[2-4])|6(?:[013-59]|7[0-46-9])|(?:33|55|6[68])[0-69]|(?:29|3[09]|62)[0-79]"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{2})(\\d{3})(\\d{3,4})",
                    "$1 $2 $3",
                    [
                        "29[013-9]|39|54"
                    ],
                    "0$1"
                ],
                [
                    "(\\d{4})(\\d{3,5})",
                    "$1 $2",
                    [
                        "(?:25|54)8",
                        "258|5483"
                    ],
                    "0$1"
                ]
            ],
            "0",
            0,
            0,
            0,
            0,
            0,
            [
                [
                    "(?:1(?:(?:3\\d|9)\\d|[4-8])|2(?:(?:(?:0(?:2[014]|5)|(?:2[0157]|31|84|9)\\d\\d|[56](?:[14]\\d\\d|20)|7(?:[089]|2[03]|[35]\\d\\d))\\d|4(?:2\\d\\d|8))\\d|1(?:2|[39]\\d{4}))|3(?:(?:123|(?:29\\d|92)\\d)\\d\\d|7(?:[19]|[56]\\d))|5(?:0|1[2-478]|26|[37]2|4(?:2\\d{3}|83)|5(?:25\\d\\d|[78])|[689]\\d)|6(?:(?:[16-8]21|28|52[013])\\d\\d|[39])|8(?:[1349]28|523)\\d\\d)\\d{3}|(?:4\\d\\d|9[2-9])\\d{4,5}|(?:(?:2(?:(?:(?:0|8[146])\\d|7[1-7])\\d|2(?:[278]\\d|92)|58(?:2\\d|3))|3(?:[26]|9\\d{3})|5(?:4\\d|5)\\d\\d)\\d|6(?:(?:(?:[0-246]|[78]\\d)\\d|37)\\d|5[2-8]))\\d\\d|(?:2(?:[569]\\d|8[2-57-9])|3(?:[013-59]\\d|8[37])|6[89]8)\\d{3}"
                ],
                [
                    "7(?:[1278]\\d|3[1-9])\\d{6}",
                    [
                        9
                    ]
                ],
                [
                    "80(?:[01]\\d|20|8[0-8])\\d{3}",
                    [
                        7
                    ]
                ],
                0,
                0,
                0,
                0,
                0,
                [
                    "86(?:1[12]|22|30|44|55|77|8[368])\\d{6}",
                    [
                        10
                    ]
                ]
            ]
        ]
    },
    "nonGeographic": {
        "800": [
            "800",
            0,
            "(?:00|[1-9]\\d)\\d{6}",
            [
                8
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "\\d"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                0,
                0,
                [
                    "(?:00|[1-9]\\d)\\d{6}"
                ]
            ]
        ],
        "808": [
            "808",
            0,
            "[1-9]\\d{7}",
            [
                8
            ],
            [
                [
                    "(\\d{4})(\\d{4})",
                    "$1 $2",
                    [
                        "[1-9]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "[1-9]\\d{7}"
                ]
            ]
        ],
        "870": [
            "870",
            0,
            "7\\d{11}|[235-7]\\d{8}",
            [
                9,
                12
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "[235-7]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                0,
                [
                    "(?:[356]|774[45])\\d{8}|7[6-8]\\d{7}"
                ],
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "2\\d{8}",
                    [
                        9
                    ]
                ]
            ]
        ],
        "878": [
            "878",
            0,
            "10\\d{10}",
            [
                12
            ],
            [
                [
                    "(\\d{2})(\\d{5})(\\d{5})",
                    "$1 $2 $3",
                    [
                        "1"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "10\\d{10}"
                ]
            ]
        ],
        "881": [
            "881",
            0,
            "6\\d{9}|[0-36-9]\\d{8}",
            [
                9,
                10
            ],
            [
                [
                    "(\\d)(\\d{3})(\\d{5})",
                    "$1 $2 $3",
                    [
                        "[0-37-9]"
                    ]
                ],
                [
                    "(\\d)(\\d{3})(\\d{5,6})",
                    "$1 $2 $3",
                    [
                        "6"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                0,
                [
                    "6\\d{9}|[0-36-9]\\d{8}"
                ]
            ]
        ],
        "882": [
            "882",
            0,
            "[13]\\d{6}(?:\\d{2,5})?|[19]\\d{7}|(?:[25]\\d\\d|4)\\d{7}(?:\\d{2})?",
            [
                7,
                8,
                9,
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{2})(\\d{5})",
                    "$1 $2",
                    [
                        "16|342"
                    ]
                ],
                [
                    "(\\d{2})(\\d{6})",
                    "$1 $2",
                    [
                        "49"
                    ]
                ],
                [
                    "(\\d{2})(\\d{2})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "1[36]|9"
                    ]
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "3[23]"
                    ]
                ],
                [
                    "(\\d{2})(\\d{3,4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "16"
                    ]
                ],
                [
                    "(\\d{2})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "10|23|3(?:[15]|4[57])|4|51"
                    ]
                ],
                [
                    "(\\d{3})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "34"
                    ]
                ],
                [
                    "(\\d{2})(\\d{4,5})(\\d{5})",
                    "$1 $2 $3",
                    [
                        "[1-35]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                0,
                [
                    "342\\d{4}|(?:337|49)\\d{6}|(?:3(?:2|47|7\\d{3})|50\\d{3})\\d{7}",
                    [
                        7,
                        8,
                        9,
                        10,
                        12
                    ]
                ],
                0,
                0,
                0,
                [
                    "348[57]\\d{7}",
                    [
                        11
                    ]
                ],
                0,
                0,
                [
                    "1(?:3(?:0[0347]|[13][0139]|2[035]|4[013568]|6[0459]|7[06]|8[15-8]|9[0689])\\d{4}|6\\d{5,10})|(?:345\\d|9[89])\\d{6}|(?:10|2(?:3|85\\d)|3(?:[15]|[69]\\d\\d)|4[15-8]|51)\\d{8}"
                ]
            ]
        ],
        "883": [
            "883",
            0,
            "(?:[1-4]\\d|51)\\d{6,10}",
            [
                8,
                9,
                10,
                11,
                12
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{2,8})",
                    "$1 $2 $3",
                    [
                        "[14]|2[24-689]|3[02-689]|51[24-9]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3",
                    [
                        "510"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "21"
                    ]
                ],
                [
                    "(\\d{4})(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "51[13]"
                    ]
                ],
                [
                    "(\\d{3})(\\d{3})(\\d{3})(\\d{3})",
                    "$1 $2 $3 $4",
                    [
                        "[235]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "(?:2(?:00\\d\\d|10)|(?:370[1-9]|51\\d0)\\d)\\d{7}|51(?:00\\d{5}|[24-9]0\\d{4,7})|(?:1[0-79]|2[24-689]|3[02-689]|4[0-4])0\\d{5,9}"
                ]
            ]
        ],
        "888": [
            "888",
            0,
            "\\d{11}",
            [
                11
            ],
            [
                [
                    "(\\d{3})(\\d{3})(\\d{5})",
                    "$1 $2 $3"
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                0,
                0,
                0,
                0,
                0,
                0,
                [
                    "\\d{11}"
                ]
            ]
        ],
        "979": [
            "979",
            0,
            "[1359]\\d{8}",
            [
                9
            ],
            [
                [
                    "(\\d)(\\d{4})(\\d{4})",
                    "$1 $2 $3",
                    [
                        "[1359]"
                    ]
                ]
            ],
            0,
            0,
            0,
            0,
            0,
            0,
            [
                0,
                0,
                0,
                [
                    "[1359]\\d{8}"
                ]
            ]
        ]
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iECDG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PhoneNumber", ()=>(0, _phoneNumberJsDefault.default));
parcelHelpers.export(exports, "ParseError", ()=>(0, _parseErrorJsDefault.default));
// `parsePhoneNumber()` named export has been renamed to `parsePhoneNumberWithError()`.
parcelHelpers.export(exports, "parsePhoneNumberWithError", ()=>(0, _parsePhoneNumberWithErrorJsDefault.default));
parcelHelpers.export(exports, "parsePhoneNumber", ()=>(0, _parsePhoneNumberWithErrorJsDefault.default));
// `parsePhoneNumberFromString()` named export is now considered legacy:
// it has been promoted to a default export due to being too verbose.
parcelHelpers.export(exports, "default", ()=>(0, _parsePhoneNumberJsDefault.default));
parcelHelpers.export(exports, "parsePhoneNumberFromString", ()=>(0, _parsePhoneNumberJsDefault.default));
parcelHelpers.export(exports, "isValidPhoneNumber", ()=>(0, _isValidPhoneNumberJsDefault.default));
parcelHelpers.export(exports, "isPossiblePhoneNumber", ()=>(0, _isPossiblePhoneNumberJsDefault.default));
parcelHelpers.export(exports, "validatePhoneNumberLength", ()=>(0, _validatePhoneNumberLengthJsDefault.default));
// Deprecated.
parcelHelpers.export(exports, "findNumbers", ()=>(0, _findNumbersJsDefault.default));
parcelHelpers.export(exports, "searchNumbers", ()=>(0, _searchNumbersJsDefault.default));
parcelHelpers.export(exports, "findPhoneNumbersInText", ()=>(0, _findPhoneNumbersInTextJsDefault.default));
parcelHelpers.export(exports, "searchPhoneNumbersInText", ()=>(0, _searchPhoneNumbersInTextJsDefault.default));
parcelHelpers.export(exports, "PhoneNumberMatcher", ()=>(0, _phoneNumberMatcherJsDefault.default));
parcelHelpers.export(exports, "AsYouType", ()=>(0, _asYouTypeJsDefault.default));
parcelHelpers.export(exports, "DIGIT_PLACEHOLDER", ()=>(0, _asYouTypeFormatterJs.DIGIT_PLACEHOLDER));
parcelHelpers.export(exports, "getCountries", ()=>(0, _getCountriesJsDefault.default));
parcelHelpers.export(exports, "Metadata", ()=>(0, _metadataJsDefault.default));
parcelHelpers.export(exports, "isSupportedCountry", ()=>(0, _metadataJs.isSupportedCountry));
parcelHelpers.export(exports, "getCountryCallingCode", ()=>(0, _metadataJs.getCountryCallingCode));
parcelHelpers.export(exports, "getExtPrefix", ()=>(0, _metadataJs.getExtPrefix));
parcelHelpers.export(exports, "getExampleNumber", ()=>(0, _getExampleNumberJsDefault.default));
parcelHelpers.export(exports, "formatIncompletePhoneNumber", ()=>(0, _formatIncompletePhoneNumberJsDefault.default));
parcelHelpers.export(exports, "parseIncompletePhoneNumber", ()=>(0, _parseIncompletePhoneNumberJsDefault.default));
parcelHelpers.export(exports, "parsePhoneNumberCharacter", ()=>(0, _parseIncompletePhoneNumberJs.parsePhoneNumberCharacter));
parcelHelpers.export(exports, "parseDigits", ()=>(0, _parseDigitsJsDefault.default));
parcelHelpers.export(exports, "parseRFC3966", ()=>(0, _rfc3966Js.parseRFC3966));
parcelHelpers.export(exports, "formatRFC3966", ()=>(0, _rfc3966Js.formatRFC3966));
var _phoneNumberJs = require("../es6/PhoneNumber.js");
var _phoneNumberJsDefault = parcelHelpers.interopDefault(_phoneNumberJs);
var _parseErrorJs = require("../es6/ParseError.js");
var _parseErrorJsDefault = parcelHelpers.interopDefault(_parseErrorJs);
var _parsePhoneNumberWithErrorJs = require("../es6/parsePhoneNumberWithError.js");
var _parsePhoneNumberWithErrorJsDefault = parcelHelpers.interopDefault(_parsePhoneNumberWithErrorJs);
var _parsePhoneNumberJs = require("../es6/parsePhoneNumber.js");
var _parsePhoneNumberJsDefault = parcelHelpers.interopDefault(_parsePhoneNumberJs);
var _isValidPhoneNumberJs = require("../es6/isValidPhoneNumber.js");
var _isValidPhoneNumberJsDefault = parcelHelpers.interopDefault(_isValidPhoneNumberJs);
var _isPossiblePhoneNumberJs = require("../es6/isPossiblePhoneNumber.js");
var _isPossiblePhoneNumberJsDefault = parcelHelpers.interopDefault(_isPossiblePhoneNumberJs);
var _validatePhoneNumberLengthJs = require("../es6/validatePhoneNumberLength.js");
var _validatePhoneNumberLengthJsDefault = parcelHelpers.interopDefault(_validatePhoneNumberLengthJs);
var _findNumbersJs = require("../es6/legacy/findNumbers.js");
var _findNumbersJsDefault = parcelHelpers.interopDefault(_findNumbersJs);
var _searchNumbersJs = require("../es6/legacy/searchNumbers.js");
var _searchNumbersJsDefault = parcelHelpers.interopDefault(_searchNumbersJs);
var _findPhoneNumbersInTextJs = require("../es6/findPhoneNumbersInText.js");
var _findPhoneNumbersInTextJsDefault = parcelHelpers.interopDefault(_findPhoneNumbersInTextJs);
var _searchPhoneNumbersInTextJs = require("../es6/searchPhoneNumbersInText.js");
var _searchPhoneNumbersInTextJsDefault = parcelHelpers.interopDefault(_searchPhoneNumbersInTextJs);
var _phoneNumberMatcherJs = require("../es6/PhoneNumberMatcher.js");
var _phoneNumberMatcherJsDefault = parcelHelpers.interopDefault(_phoneNumberMatcherJs);
var _asYouTypeJs = require("../es6/AsYouType.js");
var _asYouTypeJsDefault = parcelHelpers.interopDefault(_asYouTypeJs);
var _asYouTypeFormatterJs = require("../es6/AsYouTypeFormatter.js");
var _getCountriesJs = require("../es6/getCountries.js");
var _getCountriesJsDefault = parcelHelpers.interopDefault(_getCountriesJs);
var _metadataJs = require("../es6/metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _getExampleNumberJs = require("../es6/getExampleNumber.js");
var _getExampleNumberJsDefault = parcelHelpers.interopDefault(_getExampleNumberJs);
var _formatIncompletePhoneNumberJs = require("../es6/formatIncompletePhoneNumber.js");
var _formatIncompletePhoneNumberJsDefault = parcelHelpers.interopDefault(_formatIncompletePhoneNumberJs);
var _parseIncompletePhoneNumberJs = require("../es6/parseIncompletePhoneNumber.js");
var _parseIncompletePhoneNumberJsDefault = parcelHelpers.interopDefault(_parseIncompletePhoneNumberJs);
var _parseDigitsJs = require("../es6/helpers/parseDigits.js");
var _parseDigitsJsDefault = parcelHelpers.interopDefault(_parseDigitsJs);
var _rfc3966Js = require("../es6/helpers/RFC3966.js");

},{"../es6/PhoneNumber.js":"drUtL","../es6/ParseError.js":"1OCLf","../es6/parsePhoneNumberWithError.js":"5oHey","../es6/parsePhoneNumber.js":"6vhsG","../es6/isValidPhoneNumber.js":"gxuN1","../es6/isPossiblePhoneNumber.js":"ljX98","../es6/validatePhoneNumberLength.js":"5LLic","../es6/legacy/findNumbers.js":"kIvNg","../es6/legacy/searchNumbers.js":"3O402","../es6/findPhoneNumbersInText.js":"5Duhf","../es6/searchPhoneNumbersInText.js":"4uJX9","../es6/PhoneNumberMatcher.js":"acFQ1","../es6/AsYouType.js":"37zKi","../es6/AsYouTypeFormatter.js":"5AtxE","../es6/getCountries.js":"lvvWk","../es6/metadata.js":"aLNxH","../es6/getExampleNumber.js":"42kQ2","../es6/formatIncompletePhoneNumber.js":"f5oRw","../es6/parseIncompletePhoneNumber.js":"5VQUZ","../es6/helpers/parseDigits.js":"72H5y","../es6/helpers/RFC3966.js":"4FdJ8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"drUtL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>PhoneNumber);
var _metadataJs = require("./metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _isPossibleJs = require("./isPossible.js");
var _isPossibleJsDefault = parcelHelpers.interopDefault(_isPossibleJs);
var _isValidJs = require("./isValid.js"); // import checkNumberLength from './helpers/checkNumberLength.js'
var _isValidJsDefault = parcelHelpers.interopDefault(_isValidJs);
var _getNumberTypeJs = require("./helpers/getNumberType.js");
var _getNumberTypeJsDefault = parcelHelpers.interopDefault(_getNumberTypeJs);
var _getPossibleCountriesForNumberJs = require("./helpers/getPossibleCountriesForNumber.js");
var _getPossibleCountriesForNumberJsDefault = parcelHelpers.interopDefault(_getPossibleCountriesForNumberJs);
var _extractCountryCallingCodeJs = require("./helpers/extractCountryCallingCode.js");
var _extractCountryCallingCodeJsDefault = parcelHelpers.interopDefault(_extractCountryCallingCodeJs);
var _isObjectJs = require("./helpers/isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _formatJs = require("./format.js");
var _formatJsDefault = parcelHelpers.interopDefault(_formatJs);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
var PhoneNumber = /*#__PURE__*/ function() {
    /**
   * @param  {string} countryOrCountryCallingCode
   * @param  {string} nationalNumber
   * @param  {object} metadata  Metadata JSON
   * @return {PhoneNumber}
   */ function PhoneNumber(countryOrCountryCallingCode, nationalNumber, metadata) {
        _classCallCheck(this, PhoneNumber);
        // Validate `countryOrCountryCallingCode` argument.
        if (!countryOrCountryCallingCode) throw new TypeError('First argument is required');
        if (typeof countryOrCountryCallingCode !== 'string') throw new TypeError('First argument must be a string');
         // In case of public API use: `constructor(number, metadata)`.
        // Transform the arguments from `constructor(number, metadata)` to
        // `constructor(countryOrCountryCallingCode, nationalNumber, metadata)`.
        if (typeof countryOrCountryCallingCode === 'string') {
            if (countryOrCountryCallingCode[0] === '+' && !nationalNumber) throw new TypeError('`metadata` argument not passed');
            if ((0, _isObjectJsDefault.default)(nationalNumber) && (0, _isObjectJsDefault.default)(nationalNumber.countries)) {
                metadata = nationalNumber;
                var e164Number = countryOrCountryCallingCode;
                if (!E164_NUMBER_REGEXP.test(e164Number)) throw new Error('Invalid `number` argument passed: must consist of a "+" followed by digits');
                var _extractCountryCallin = (0, _extractCountryCallingCodeJsDefault.default)(e164Number, undefined, undefined, metadata), _countryCallingCode = _extractCountryCallin.countryCallingCode, number = _extractCountryCallin.number;
                nationalNumber = number;
                countryOrCountryCallingCode = _countryCallingCode;
                if (!nationalNumber) throw new Error('Invalid `number` argument passed: too short');
            }
        } // Validate `nationalNumber` argument.
        if (!nationalNumber) throw new TypeError('`nationalNumber` argument is required');
        if (typeof nationalNumber !== 'string') throw new TypeError('`nationalNumber` argument must be a string');
         // Validate `metadata` argument.
        (0, _metadataJs.validateMetadata)(metadata); // Initialize properties.
        var _getCountryAndCountry = getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadata), country = _getCountryAndCountry.country, countryCallingCode = _getCountryAndCountry.countryCallingCode;
        this.country = country;
        this.countryCallingCode = countryCallingCode;
        this.nationalNumber = nationalNumber;
        this.number = '+' + this.countryCallingCode + this.nationalNumber; // Exclude `metadata` property output from `PhoneNumber.toString()`
        // so that it doesn't clutter the console output of Node.js.
        // Previously, when Node.js did `console.log(new PhoneNumber(...))`,
        // it would output the whole internal structure of the `metadata` object.
        this.getMetadata = function() {
            return metadata;
        };
    }
    _createClass(PhoneNumber, [
        {
            key: "setExt",
            value: function setExt(ext) {
                this.ext = ext;
            }
        },
        {
            key: "getPossibleCountries",
            value: function getPossibleCountries() {
                if (this.country) return [
                    this.country
                ];
                return (0, _getPossibleCountriesForNumberJsDefault.default)(this.countryCallingCode, this.nationalNumber, this.getMetadata());
            }
        },
        {
            key: "isPossible",
            value: function isPossible() {
                return (0, _isPossibleJsDefault.default)(this, {
                    v2: true
                }, this.getMetadata());
            }
        },
        {
            key: "isValid",
            value: function isValid() {
                return (0, _isValidJsDefault.default)(this, {
                    v2: true
                }, this.getMetadata());
            }
        },
        {
            key: "isNonGeographic",
            value: function isNonGeographic() {
                var metadata = new (0, _metadataJsDefault.default)(this.getMetadata());
                return metadata.isNonGeographicCallingCode(this.countryCallingCode);
            }
        },
        {
            key: "isEqual",
            value: function isEqual(phoneNumber) {
                return this.number === phoneNumber.number && this.ext === phoneNumber.ext;
            } // This function was originally meant to be an equivalent for `validatePhoneNumberLength()`,
        },
        {
            key: "getType",
            value: function getType() {
                return (0, _getNumberTypeJsDefault.default)(this, {
                    v2: true
                }, this.getMetadata());
            }
        },
        {
            key: "format",
            value: function format(_format, options) {
                return (0, _formatJsDefault.default)(this, _format, options ? _objectSpread(_objectSpread({}, options), {}, {
                    v2: true
                }) : {
                    v2: true
                }, this.getMetadata());
            }
        },
        {
            key: "formatNational",
            value: function formatNational(options) {
                return this.format('NATIONAL', options);
            }
        },
        {
            key: "formatInternational",
            value: function formatInternational(options) {
                return this.format('INTERNATIONAL', options);
            }
        },
        {
            key: "getURI",
            value: function getURI(options) {
                return this.format('RFC3966', options);
            }
        }
    ]);
    return PhoneNumber;
}();
var isCountryCode = function isCountryCode(value) {
    return /^[A-Z]{2}$/.test(value);
};
function getCountryAndCountryCallingCode(countryOrCountryCallingCode, metadataJson) {
    var country;
    var countryCallingCode;
    var metadata = new (0, _metadataJsDefault.default)(metadataJson); // If country code is passed then derive `countryCallingCode` from it.
    // Also store the country code as `.country`.
    if (isCountryCode(countryOrCountryCallingCode)) {
        country = countryOrCountryCallingCode;
        metadata.selectNumberingPlan(country);
        countryCallingCode = metadata.countryCallingCode();
    } else {
        countryCallingCode = countryOrCountryCallingCode;
        /* istanbul ignore if */ if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
            if (metadata.isNonGeographicCallingCode(countryCallingCode)) country = '001';
        }
    }
    return {
        country: country,
        countryCallingCode: countryCallingCode
    };
}
var E164_NUMBER_REGEXP = /^\+\d+$/;

},{"./metadata.js":"aLNxH","./isPossible.js":"4HMsQ","./isValid.js":"lILWs","./helpers/getNumberType.js":"gnC5I","./helpers/getPossibleCountriesForNumber.js":"j8v3p","./helpers/extractCountryCallingCode.js":"7hO6r","./helpers/isObject.js":"hnBQE","./format.js":"cbv0v","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aLNxH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>Metadata);
parcelHelpers.export(exports, "validateMetadata", ()=>validateMetadata) // Babel transforms `typeof` into some "branches"
;
/**
 * Returns extension prefix for a country.
 * @param  {string} country
 * @param  {object} metadata
 * @return {string?}
 * @example
 * // Returns " ext. "
 * getExtPrefix("US")
 */ parcelHelpers.export(exports, "getExtPrefix", ()=>getExtPrefix);
/**
 * Returns "country calling code" for a country.
 * Throws an error if the country doesn't exist or isn't supported by this library.
 * @param  {string} country
 * @param  {object} metadata
 * @return {string}
 * @example
 * // Returns "44"
 * getCountryCallingCode("GB")
 */ parcelHelpers.export(exports, "getCountryCallingCode", ()=>getCountryCallingCode);
parcelHelpers.export(exports, "isSupportedCountry", ()=>isSupportedCountry);
var _semverCompareJs = require("./tools/semver-compare.js");
var _semverCompareJsDefault = parcelHelpers.interopDefault(_semverCompareJs);
var _isObjectJs = require("./helpers/isObject.js"); // Added "possibleLengths" and renamed
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
// "country_phone_code_to_countries" to "country_calling_codes".
var V2 = '1.0.18'; // Added "idd_prefix" and "default_idd_prefix".
var V3 = '1.2.0'; // Moved `001` country code to "nonGeographic" section of metadata.
var V4 = '1.7.35';
var DEFAULT_EXT_PREFIX = ' ext. ';
var CALLING_CODE_REG_EXP = /^\d+$/;
/**
 * See: https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md
 */ var Metadata = /*#__PURE__*/ function() {
    function Metadata(metadata) {
        _classCallCheck(this, Metadata);
        validateMetadata(metadata);
        this.metadata = metadata;
        setVersion.call(this, metadata);
    }
    _createClass(Metadata, [
        {
            key: "getCountries",
            value: function getCountries() {
                return Object.keys(this.metadata.countries).filter(function(_) {
                    return _ !== '001';
                });
            }
        },
        {
            key: "getCountryMetadata",
            value: function getCountryMetadata(countryCode) {
                return this.metadata.countries[countryCode];
            }
        },
        {
            key: "nonGeographic",
            value: function nonGeographic() {
                if (this.v1 || this.v2 || this.v3) return; // `nonGeographical` was a typo.
                // It's present in metadata generated from `1.7.35` to `1.7.37`.
                // The test case could be found by searching for "nonGeographical".
                return this.metadata.nonGeographic || this.metadata.nonGeographical;
            }
        },
        {
            key: "hasCountry",
            value: function hasCountry(country) {
                return this.getCountryMetadata(country) !== undefined;
            }
        },
        {
            key: "hasCallingCode",
            value: function hasCallingCode(callingCode) {
                if (this.getCountryCodesForCallingCode(callingCode)) return true;
                if (this.nonGeographic()) {
                    if (this.nonGeographic()[callingCode]) return true;
                } else {
                    // A hacky workaround for old custom metadata (generated before V4).
                    var countryCodes = this.countryCallingCodes()[callingCode];
                    if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') return true;
                }
            }
        },
        {
            key: "isNonGeographicCallingCode",
            value: function isNonGeographicCallingCode(callingCode) {
                if (this.nonGeographic()) return this.nonGeographic()[callingCode] ? true : false;
                else return this.getCountryCodesForCallingCode(callingCode) ? false : true;
            } // Deprecated.
        },
        {
            key: "country",
            value: function country(countryCode) {
                return this.selectNumberingPlan(countryCode);
            }
        },
        {
            key: "selectNumberingPlan",
            value: function selectNumberingPlan(countryCode, callingCode) {
                // Supports just passing `callingCode` as the first argument.
                if (countryCode && CALLING_CODE_REG_EXP.test(countryCode)) {
                    callingCode = countryCode;
                    countryCode = null;
                }
                if (countryCode && countryCode !== '001') {
                    if (!this.hasCountry(countryCode)) throw new Error("Unknown country: ".concat(countryCode));
                    this.numberingPlan = new NumberingPlan(this.getCountryMetadata(countryCode), this);
                } else if (callingCode) {
                    if (!this.hasCallingCode(callingCode)) throw new Error("Unknown calling code: ".concat(callingCode));
                    this.numberingPlan = new NumberingPlan(this.getNumberingPlanMetadata(callingCode), this);
                } else this.numberingPlan = undefined;
                return this;
            }
        },
        {
            key: "getCountryCodesForCallingCode",
            value: function getCountryCodesForCallingCode(callingCode) {
                var countryCodes = this.countryCallingCodes()[callingCode];
                if (countryCodes) {
                    // Metadata before V4 included "non-geographic entity" calling codes
                    // inside `country_calling_codes` (for example, `"881":["001"]`).
                    // Now the semantics of `country_calling_codes` has changed:
                    // it's specifically for "countries" now.
                    // Older versions of custom metadata will simply skip parsing
                    // "non-geographic entity" phone numbers with new versions
                    // of this library: it's not considered a bug,
                    // because such numbers are extremely rare,
                    // and developers extremely rarely use custom metadata.
                    if (countryCodes.length === 1 && countryCodes[0].length === 3) return;
                    return countryCodes;
                }
            }
        },
        {
            key: "getCountryCodeForCallingCode",
            value: function getCountryCodeForCallingCode(callingCode) {
                var countryCodes = this.getCountryCodesForCallingCode(callingCode);
                if (countryCodes) return countryCodes[0];
            }
        },
        {
            key: "getNumberingPlanMetadata",
            value: function getNumberingPlanMetadata(callingCode) {
                var countryCode = this.getCountryCodeForCallingCode(callingCode);
                if (countryCode) return this.getCountryMetadata(countryCode);
                if (this.nonGeographic()) {
                    var metadata = this.nonGeographic()[callingCode];
                    if (metadata) return metadata;
                } else {
                    // A hacky workaround for old custom metadata (generated before V4).
                    // In that metadata, there was no concept of "non-geographic" metadata
                    // so metadata for `001` country code was stored along with other countries.
                    // The test case can be found by searching for:
                    // "should work around `nonGeographic` metadata not existing".
                    var countryCodes = this.countryCallingCodes()[callingCode];
                    if (countryCodes && countryCodes.length === 1 && countryCodes[0] === '001') return this.metadata.countries['001'];
                }
            } // Deprecated.
        },
        {
            key: "countryCallingCode",
            value: function countryCallingCode() {
                return this.numberingPlan.callingCode();
            } // Deprecated.
        },
        {
            key: "IDDPrefix",
            value: function IDDPrefix() {
                return this.numberingPlan.IDDPrefix();
            } // Deprecated.
        },
        {
            key: "defaultIDDPrefix",
            value: function defaultIDDPrefix() {
                return this.numberingPlan.defaultIDDPrefix();
            } // Deprecated.
        },
        {
            key: "nationalNumberPattern",
            value: function nationalNumberPattern() {
                return this.numberingPlan.nationalNumberPattern();
            } // Deprecated.
        },
        {
            key: "possibleLengths",
            value: function possibleLengths() {
                return this.numberingPlan.possibleLengths();
            } // Deprecated.
        },
        {
            key: "formats",
            value: function formats() {
                return this.numberingPlan.formats();
            } // Deprecated.
        },
        {
            key: "nationalPrefixForParsing",
            value: function nationalPrefixForParsing() {
                return this.numberingPlan.nationalPrefixForParsing();
            } // Deprecated.
        },
        {
            key: "nationalPrefixTransformRule",
            value: function nationalPrefixTransformRule() {
                return this.numberingPlan.nationalPrefixTransformRule();
            } // Deprecated.
        },
        {
            key: "leadingDigits",
            value: function leadingDigits() {
                return this.numberingPlan.leadingDigits();
            } // Deprecated.
        },
        {
            key: "hasTypes",
            value: function hasTypes() {
                return this.numberingPlan.hasTypes();
            } // Deprecated.
        },
        {
            key: "type",
            value: function type(_type) {
                return this.numberingPlan.type(_type);
            } // Deprecated.
        },
        {
            key: "ext",
            value: function ext() {
                return this.numberingPlan.ext();
            }
        },
        {
            key: "countryCallingCodes",
            value: function countryCallingCodes() {
                if (this.v1) return this.metadata.country_phone_code_to_countries;
                return this.metadata.country_calling_codes;
            } // Deprecated.
        },
        {
            key: "chooseCountryByCountryCallingCode",
            value: function chooseCountryByCountryCallingCode(callingCode) {
                return this.selectNumberingPlan(callingCode);
            }
        },
        {
            key: "hasSelectedNumberingPlan",
            value: function hasSelectedNumberingPlan() {
                return this.numberingPlan !== undefined;
            }
        }
    ]);
    return Metadata;
}();
var NumberingPlan = /*#__PURE__*/ function() {
    function NumberingPlan(metadata, globalMetadataObject) {
        _classCallCheck(this, NumberingPlan);
        this.globalMetadataObject = globalMetadataObject;
        this.metadata = metadata;
        setVersion.call(this, globalMetadataObject.metadata);
    }
    _createClass(NumberingPlan, [
        {
            key: "callingCode",
            value: function callingCode() {
                return this.metadata[0];
            } // Formatting information for regions which share
        },
        {
            key: "getDefaultCountryMetadataForRegion",
            value: function getDefaultCountryMetadataForRegion() {
                return this.globalMetadataObject.getNumberingPlanMetadata(this.callingCode());
            } // Is always present.
        },
        {
            key: "IDDPrefix",
            value: function IDDPrefix() {
                if (this.v1 || this.v2) return;
                return this.metadata[1];
            } // Is only present when a country supports multiple IDD prefixes.
        },
        {
            key: "defaultIDDPrefix",
            value: function defaultIDDPrefix() {
                if (this.v1 || this.v2) return;
                return this.metadata[12];
            }
        },
        {
            key: "nationalNumberPattern",
            value: function nationalNumberPattern() {
                if (this.v1 || this.v2) return this.metadata[1];
                return this.metadata[2];
            } // "possible length" data is always present in Google's metadata.
        },
        {
            key: "possibleLengths",
            value: function possibleLengths() {
                if (this.v1) return;
                return this.metadata[this.v2 ? 2 : 3];
            }
        },
        {
            key: "_getFormats",
            value: function _getFormats(metadata) {
                return metadata[this.v1 ? 2 : this.v2 ? 3 : 4];
            } // For countries of the same region (e.g. NANPA)
        },
        {
            key: "formats",
            value: function formats() {
                var _this = this;
                var formats = this._getFormats(this.metadata) || this._getFormats(this.getDefaultCountryMetadataForRegion()) || [];
                return formats.map(function(_) {
                    return new Format(_, _this);
                });
            }
        },
        {
            key: "nationalPrefix",
            value: function nationalPrefix() {
                return this.metadata[this.v1 ? 3 : this.v2 ? 4 : 5];
            }
        },
        {
            key: "_getNationalPrefixFormattingRule",
            value: function _getNationalPrefixFormattingRule(metadata) {
                return metadata[this.v1 ? 4 : this.v2 ? 5 : 6];
            } // For countries of the same region (e.g. NANPA)
        },
        {
            key: "nationalPrefixFormattingRule",
            value: function nationalPrefixFormattingRule() {
                return this._getNationalPrefixFormattingRule(this.metadata) || this._getNationalPrefixFormattingRule(this.getDefaultCountryMetadataForRegion());
            }
        },
        {
            key: "_nationalPrefixForParsing",
            value: function _nationalPrefixForParsing() {
                return this.metadata[this.v1 ? 5 : this.v2 ? 6 : 7];
            }
        },
        {
            key: "nationalPrefixForParsing",
            value: function nationalPrefixForParsing() {
                // If `national_prefix_for_parsing` is not set explicitly,
                // then infer it from `national_prefix` (if any)
                return this._nationalPrefixForParsing() || this.nationalPrefix();
            }
        },
        {
            key: "nationalPrefixTransformRule",
            value: function nationalPrefixTransformRule() {
                return this.metadata[this.v1 ? 6 : this.v2 ? 7 : 8];
            }
        },
        {
            key: "_getNationalPrefixIsOptionalWhenFormatting",
            value: function _getNationalPrefixIsOptionalWhenFormatting() {
                return !!this.metadata[this.v1 ? 7 : this.v2 ? 8 : 9];
            } // For countries of the same region (e.g. NANPA)
        },
        {
            key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
            value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
                return this._getNationalPrefixIsOptionalWhenFormatting(this.metadata) || this._getNationalPrefixIsOptionalWhenFormatting(this.getDefaultCountryMetadataForRegion());
            }
        },
        {
            key: "leadingDigits",
            value: function leadingDigits() {
                return this.metadata[this.v1 ? 8 : this.v2 ? 9 : 10];
            }
        },
        {
            key: "types",
            value: function types() {
                return this.metadata[this.v1 ? 9 : this.v2 ? 10 : 11];
            }
        },
        {
            key: "hasTypes",
            value: function hasTypes() {
                // Versions 1.2.0 - 1.2.4: can be `[]`.
                /* istanbul ignore next */ if (this.types() && this.types().length === 0) return false;
                 // Versions <= 1.2.4: can be `undefined`.
                // Version >= 1.2.5: can be `0`.
                return !!this.types();
            }
        },
        {
            key: "type",
            value: function type(_type2) {
                if (this.hasTypes() && getType(this.types(), _type2)) return new Type(getType(this.types(), _type2), this);
            }
        },
        {
            key: "ext",
            value: function ext() {
                if (this.v1 || this.v2) return DEFAULT_EXT_PREFIX;
                return this.metadata[13] || DEFAULT_EXT_PREFIX;
            }
        }
    ]);
    return NumberingPlan;
}();
var Format = /*#__PURE__*/ function() {
    function Format(format, metadata) {
        _classCallCheck(this, Format);
        this._format = format;
        this.metadata = metadata;
    }
    _createClass(Format, [
        {
            key: "pattern",
            value: function pattern() {
                return this._format[0];
            }
        },
        {
            key: "format",
            value: function format() {
                return this._format[1];
            }
        },
        {
            key: "leadingDigitsPatterns",
            value: function leadingDigitsPatterns() {
                return this._format[2] || [];
            }
        },
        {
            key: "nationalPrefixFormattingRule",
            value: function nationalPrefixFormattingRule() {
                return this._format[3] || this.metadata.nationalPrefixFormattingRule();
            }
        },
        {
            key: "nationalPrefixIsOptionalWhenFormattingInNationalFormat",
            value: function nationalPrefixIsOptionalWhenFormattingInNationalFormat() {
                return !!this._format[4] || this.metadata.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
            }
        },
        {
            key: "nationalPrefixIsMandatoryWhenFormattingInNationalFormat",
            value: function nationalPrefixIsMandatoryWhenFormattingInNationalFormat() {
                // National prefix is omitted if there's no national prefix formatting rule
                // set for this country, or when the national prefix formatting rule
                // contains no national prefix itself, or when this rule is set but
                // national prefix is optional for this phone number format
                // (and it is not enforced explicitly)
                return this.usesNationalPrefix() && !this.nationalPrefixIsOptionalWhenFormattingInNationalFormat();
            } // Checks whether national prefix formatting rule contains national prefix.
        },
        {
            key: "usesNationalPrefix",
            value: function usesNationalPrefix() {
                return this.nationalPrefixFormattingRule() && // Check that national prefix formatting rule is not a "dummy" one.
                !FIRST_GROUP_ONLY_PREFIX_PATTERN.test(this.nationalPrefixFormattingRule()) // In compressed metadata, `this.nationalPrefixFormattingRule()` is `0`
                 ? true : false;
            }
        },
        {
            key: "internationalFormat",
            value: function internationalFormat() {
                return this._format[5] || this.format();
            }
        }
    ]);
    return Format;
}();
/**
 * A pattern that is used to determine if the national prefix formatting rule
 * has the first group only, i.e., does not start with the national prefix.
 * Note that the pattern explicitly allows for unbalanced parentheses.
 */ var FIRST_GROUP_ONLY_PREFIX_PATTERN = /^\(?\$1\)?$/;
var Type = /*#__PURE__*/ function() {
    function Type(type, metadata) {
        _classCallCheck(this, Type);
        this.type = type;
        this.metadata = metadata;
    }
    _createClass(Type, [
        {
            key: "pattern",
            value: function pattern() {
                if (this.metadata.v1) return this.type;
                return this.type[0];
            }
        },
        {
            key: "possibleLengths",
            value: function possibleLengths() {
                if (this.metadata.v1) return;
                return this.type[1] || this.metadata.possibleLengths();
            }
        }
    ]);
    return Type;
}();
function getType(types, type) {
    switch(type){
        case 'FIXED_LINE':
            return types[0];
        case 'MOBILE':
            return types[1];
        case 'TOLL_FREE':
            return types[2];
        case 'PREMIUM_RATE':
            return types[3];
        case 'PERSONAL_NUMBER':
            return types[4];
        case 'VOICEMAIL':
            return types[5];
        case 'UAN':
            return types[6];
        case 'PAGER':
            return types[7];
        case 'VOIP':
            return types[8];
        case 'SHARED_COST':
            return types[9];
    }
}
function validateMetadata(metadata) {
    if (!metadata) throw new Error('[libphonenumber-js] `metadata` argument not passed. Check your arguments.');
     // `country_phone_code_to_countries` was renamed to `country_calling_codes` in `1.0.18`.
    // For that reason, it's not used in this detection algorithm.
    // Instead, it detects by `countries: {}` property existence.
    if (!(0, _isObjectJsDefault.default)(metadata) || !(0, _isObjectJsDefault.default)(metadata.countries)) throw new Error("[libphonenumber-js] `metadata` argument was passed but it's not a valid metadata. Must be an object having `.countries` child object property. Got ".concat((0, _isObjectJsDefault.default)(metadata) ? 'an object of shape: { ' + Object.keys(metadata).join(', ') + ' }' : 'a ' + typeOf(metadata) + ': ' + metadata, "."));
}
// so istanbul will show this as "branch not covered".
/* istanbul ignore next */ var typeOf = function typeOf(_) {
    return _typeof(_);
};
function getExtPrefix(country, metadata) {
    metadata = new Metadata(metadata);
    if (metadata.hasCountry(country)) return metadata.country(country).ext();
    return DEFAULT_EXT_PREFIX;
}
function getCountryCallingCode(country, metadata) {
    metadata = new Metadata(metadata);
    if (metadata.hasCountry(country)) return metadata.country(country).countryCallingCode();
    throw new Error("Unknown country: ".concat(country));
}
function isSupportedCountry(country, metadata) {
    // metadata = new Metadata(metadata)
    // return metadata.hasCountry(country)
    return metadata.countries.hasOwnProperty(country);
}
function setVersion(metadata) {
    var version = metadata.version;
    if (typeof version === 'number') {
        this.v1 = version === 1;
        this.v2 = version === 2;
        this.v3 = version === 3;
        this.v4 = version === 4;
    } else {
        if (!version) this.v1 = true;
        else if ((0, _semverCompareJsDefault.default)(version, V3) === -1) this.v2 = true;
        else if ((0, _semverCompareJsDefault.default)(version, V4) === -1) this.v3 = true;
        else this.v4 = true;
    }
} // const ISO_COUNTRY_CODE = /^[A-Z]{2}$/
 // function isCountryCode(countryCode) {
 // 	return ISO_COUNTRY_CODE.test(countryCodeOrCountryCallingCode)
 // }

},{"./tools/semver-compare.js":"5xUHU","./helpers/isObject.js":"hnBQE","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5xUHU":[function(require,module,exports,__globalThis) {
// Copy-pasted from:
// https://github.com/substack/semver-compare/blob/master/index.js
//
// Inlining this function because some users reported issues with
// importing from `semver-compare` in a browser with ES6 "native" modules.
//
// Fixes `semver-compare` not being able to compare versions with alpha/beta/etc "tags".
// https://github.com/catamphetamine/libphonenumber-js/issues/381
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>function(a, b) {
        a = a.split('-');
        b = b.split('-');
        var pa = a[0].split('.');
        var pb = b[0].split('.');
        for(var i = 0; i < 3; i++){
            var na = Number(pa[i]);
            var nb = Number(pb[i]);
            if (na > nb) return 1;
            if (nb > na) return -1;
            if (!isNaN(na) && isNaN(nb)) return 1;
            if (isNaN(na) && !isNaN(nb)) return -1;
        }
        if (a[1] && b[1]) return a[1] > b[1] ? 1 : a[1] < b[1] ? -1 : 0;
        return !a[1] && b[1] ? 1 : a[1] && !b[1] ? -1 : 0;
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hnBQE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isObject);
var objectConstructor = {}.constructor;
function isObject(object) {
    return object !== undefined && object !== null && object.constructor === objectConstructor;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4HMsQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isPossiblePhoneNumber);
parcelHelpers.export(exports, "isPossibleNumber", ()=>isPossibleNumber);
var _metadataJs = require("./metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _checkNumberLengthJs = require("./helpers/checkNumberLength.js");
var _checkNumberLengthJsDefault = parcelHelpers.interopDefault(_checkNumberLengthJs);
function isPossiblePhoneNumber(input, options, metadata) {
    /* istanbul ignore if */ if (options === undefined) options = {};
    metadata = new (0, _metadataJsDefault.default)(metadata);
    if (options.v2) {
        if (!input.countryCallingCode) throw new Error('Invalid phone number object passed');
        metadata.selectNumberingPlan(input.countryCallingCode);
    } else {
        if (!input.phone) return false;
        if (input.country) {
            if (!metadata.hasCountry(input.country)) throw new Error("Unknown country: ".concat(input.country));
            metadata.country(input.country);
        } else {
            if (!input.countryCallingCode) throw new Error('Invalid phone number object passed');
            metadata.selectNumberingPlan(input.countryCallingCode);
        }
    } // Old metadata (< 1.0.18) had no "possible length" data.
    if (metadata.possibleLengths()) return isPossibleNumber(input.phone || input.nationalNumber, metadata);
    else {
        // There was a bug between `1.7.35` and `1.7.37` where "possible_lengths"
        // were missing for "non-geographical" numbering plans.
        // Just assume the number is possible in such cases:
        // it's unlikely that anyone generated their custom metadata
        // in that short period of time (one day).
        // This code can be removed in some future major version update.
        if (input.countryCallingCode && metadata.isNonGeographicCallingCode(input.countryCallingCode)) // "Non-geographic entities" did't have `possibleLengths`
        // due to a bug in metadata generation process.
        return true;
        else throw new Error('Missing "possibleLengths" in metadata. Perhaps the metadata has been generated before v1.0.18.');
    }
}
function isPossibleNumber(nationalNumber, metadata) {
    //, isInternational) {
    switch((0, _checkNumberLengthJsDefault.default)(nationalNumber, metadata)){
        case 'IS_POSSIBLE':
            return true;
        // This library ignores "local-only" phone numbers (for simplicity).
        // See the readme for more info on what are "local-only" phone numbers.
        // case 'IS_POSSIBLE_LOCAL_ONLY':
        // 	return !isInternational
        default:
            return false;
    }
}

},{"./metadata.js":"aLNxH","./helpers/checkNumberLength.js":"4xVnQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4xVnQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>checkNumberLength);
// Should only be called for the "new" metadata which has "possible lengths".
parcelHelpers.export(exports, "checkNumberLengthForType", ()=>checkNumberLengthForType);
var _mergeArraysJs = require("./mergeArrays.js");
var _mergeArraysJsDefault = parcelHelpers.interopDefault(_mergeArraysJs);
function checkNumberLength(nationalNumber, metadata) {
    return checkNumberLengthForType(nationalNumber, undefined, metadata);
} // Checks whether a number is possible for the country based on its length.
function checkNumberLengthForType(nationalNumber, type, metadata) {
    var type_info = metadata.type(type); // There should always be "<possiblePengths/>" set for every type element.
    // This is declared in the XML schema.
    // For size efficiency, where a sub-description (e.g. fixed-line)
    // has the same "<possiblePengths/>" as the "general description", this is missing,
    // so we fall back to the "general description". Where no numbers of the type
    // exist at all, there is one possible length (-1) which is guaranteed
    // not to match the length of any real phone number.
    var possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths(); // let local_lengths    = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()
    // Metadata before version `1.0.18` didn't contain `possible_lengths`.
    if (!possible_lengths) return 'IS_POSSIBLE';
    if (type === 'FIXED_LINE_OR_MOBILE') {
        // No such country in metadata.
        /* istanbul ignore next */ if (!metadata.type('FIXED_LINE')) // The rare case has been encountered where no fixedLine data is available
        // (true for some non-geographic entities), so we just check mobile.
        return checkNumberLengthForType(nationalNumber, 'MOBILE', metadata);
        var mobile_type = metadata.type('MOBILE');
        if (mobile_type) // Merge the mobile data in if there was any. "Concat" creates a new
        // array, it doesn't edit possible_lengths in place, so we don't need a copy.
        // Note that when adding the possible lengths from mobile, we have
        // to again check they aren't empty since if they are this indicates
        // they are the same as the general desc and should be obtained from there.
        possible_lengths = (0, _mergeArraysJsDefault.default)(possible_lengths, mobile_type.possibleLengths()); // The current list is sorted; we need to merge in the new list and
    } else if (type && !type_info) return 'INVALID_LENGTH';
    var actual_length = nationalNumber.length; // In `libphonenumber-js` all "local-only" formats are dropped for simplicity.
    // // This is safe because there is never an overlap beween the possible lengths
    // // and the local-only lengths; this is checked at build time.
    // if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)
    // {
    // 	return 'IS_POSSIBLE_LOCAL_ONLY'
    // }
    var minimum_length = possible_lengths[0];
    if (minimum_length === actual_length) return 'IS_POSSIBLE';
    if (minimum_length > actual_length) return 'TOO_SHORT';
    if (possible_lengths[possible_lengths.length - 1] < actual_length) return 'TOO_LONG';
     // We skip the first element since we've already checked it.
    return possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH';
}

},{"./mergeArrays.js":"dsT2b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dsT2b":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>mergeArrays);
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function mergeArrays(a, b) {
    var merged = a.slice();
    for(var _iterator = _createForOfIteratorHelperLoose(b), _step; !(_step = _iterator()).done;){
        var element = _step.value;
        if (a.indexOf(element) < 0) merged.push(element);
    }
    return merged.sort(function(a, b) {
        return a - b;
    }); // ES6 version, requires Set polyfill.
// let merged = new Set(a)
// for (const element of b) {
// 	merged.add(i)
// }
// return Array.from(merged).sort((a, b) => a - b)
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lILWs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isValidNumber);
var _metadataJs = require("./metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _matchesEntirelyJs = require("./helpers/matchesEntirely.js");
var _matchesEntirelyJsDefault = parcelHelpers.interopDefault(_matchesEntirelyJs);
var _getNumberTypeJs = require("./helpers/getNumberType.js");
var _getNumberTypeJsDefault = parcelHelpers.interopDefault(_getNumberTypeJs);
function isValidNumber(input, options, metadata) {
    // If assigning the `{}` default value is moved to the arguments above,
    // code coverage would decrease for some weird reason.
    options = options || {};
    metadata = new (0, _metadataJsDefault.default)(metadata);
    metadata.selectNumberingPlan(input.country, input.countryCallingCode); // By default, countries only have type regexps when it's required for
    // distinguishing different countries having the same `countryCallingCode`.
    if (metadata.hasTypes()) return (0, _getNumberTypeJsDefault.default)(input, options, metadata.metadata) !== undefined;
     // If there are no type regexps for this country in metadata then use
    // `nationalNumberPattern` as a "better than nothing" replacement.
    var nationalNumber = options.v2 ? input.nationalNumber : input.phone;
    return (0, _matchesEntirelyJsDefault.default)(nationalNumber, metadata.nationalNumberPattern());
}

},{"./metadata.js":"aLNxH","./helpers/matchesEntirely.js":"k0Xh7","./helpers/getNumberType.js":"gnC5I","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k0Xh7":[function(require,module,exports,__globalThis) {
/**
 * Checks whether the entire input sequence can be matched
 * against the regular expression.
 * @return {boolean}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>matchesEntirely);
function matchesEntirely(text, regular_expression) {
    // If assigning the `''` default value is moved to the arguments above,
    // code coverage would decrease for some weird reason.
    text = text || '';
    return new RegExp('^(?:' + regular_expression + ')$').test(text);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gnC5I":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getNumberType);
parcelHelpers.export(exports, "isNumberTypeEqualTo", ()=>isNumberTypeEqualTo);
var _metadataJs = require("../metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _matchesEntirelyJs = require("./matchesEntirely.js");
var _matchesEntirelyJsDefault = parcelHelpers.interopDefault(_matchesEntirelyJs);
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
var NON_FIXED_LINE_PHONE_TYPES = [
    'MOBILE',
    'PREMIUM_RATE',
    'TOLL_FREE',
    'SHARED_COST',
    'VOIP',
    'PERSONAL_NUMBER',
    'PAGER',
    'UAN',
    'VOICEMAIL'
]; // Finds out national phone number type (fixed line, mobile, etc)
function getNumberType(input, options, metadata) {
    // If assigning the `{}` default value is moved to the arguments above,
    // code coverage would decrease for some weird reason.
    options = options || {}; // When `parse()` returns an empty object  `{}` 
    // that means that the phone number is malformed,
    // so it can't possibly be valid.
    if (!input.country && !input.countryCallingCode) return;
    metadata = new (0, _metadataJsDefault.default)(metadata);
    metadata.selectNumberingPlan(input.country, input.countryCallingCode);
    var nationalNumber = options.v2 ? input.nationalNumber : input.phone; // The following is copy-pasted from the original function:
    // https://github.com/googlei18n/libphonenumber/blob/3ea547d4fbaa2d0b67588904dfa5d3f2557c27ff/javascript/i18n/phonenumbers/phonenumberutil.js#L2835
    // Is this national number even valid for this country
    if (!(0, _matchesEntirelyJsDefault.default)(nationalNumber, metadata.nationalNumberPattern())) return;
     // Is it fixed line number
    if (isNumberTypeEqualTo(nationalNumber, 'FIXED_LINE', metadata)) {
        // Because duplicate regular expressions are removed
        // to reduce metadata size, if "mobile" pattern is ""
        // then it means it was removed due to being a duplicate of the fixed-line pattern.
        //
        if (metadata.type('MOBILE') && metadata.type('MOBILE').pattern() === '') return 'FIXED_LINE_OR_MOBILE';
         // `MOBILE` type pattern isn't included if it matched `FIXED_LINE` one.
        // For example, for "US" country.
        // Old metadata (< `1.0.18`) had a specific "types" data structure
        // that happened to be `undefined` for `MOBILE` in that case.
        // Newer metadata (>= `1.0.18`) has another data structure that is
        // not `undefined` for `MOBILE` in that case (it's just an empty array).
        // So this `if` is just for backwards compatibility with old metadata.
        if (!metadata.type('MOBILE')) return 'FIXED_LINE_OR_MOBILE';
         // Check if the number happens to qualify as both fixed line and mobile.
        // (no such country in the minimal metadata set)
        /* istanbul ignore if */ if (isNumberTypeEqualTo(nationalNumber, 'MOBILE', metadata)) return 'FIXED_LINE_OR_MOBILE';
        return 'FIXED_LINE';
    }
    for(var _iterator = _createForOfIteratorHelperLoose(NON_FIXED_LINE_PHONE_TYPES), _step; !(_step = _iterator()).done;){
        var type = _step.value;
        if (isNumberTypeEqualTo(nationalNumber, type, metadata)) return type;
    }
}
function isNumberTypeEqualTo(nationalNumber, type, metadata) {
    type = metadata.type(type);
    if (!type || !type.pattern()) return false;
     // Check if any possible number lengths are present;
    // if so, we use them to avoid checking
    // the validation pattern if they don't match.
    // If they are absent, this means they match
    // the general description, which we have
    // already checked before a specific number type.
    if (type.possibleLengths() && type.possibleLengths().indexOf(nationalNumber.length) < 0) return false;
    return (0, _matchesEntirelyJsDefault.default)(nationalNumber, type.pattern());
}

},{"../metadata.js":"aLNxH","./matchesEntirely.js":"k0Xh7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j8v3p":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getPossibleCountriesForNumber);
var _metadataJs = require("../metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
function getPossibleCountriesForNumber(callingCode, nationalNumber, metadata) {
    var _metadata = new (0, _metadataJsDefault.default)(metadata);
    var possibleCountries = _metadata.getCountryCodesForCallingCode(callingCode);
    if (!possibleCountries) return [];
    return possibleCountries.filter(function(country) {
        return couldNationalNumberBelongToCountry(nationalNumber, country, metadata);
    });
}
function couldNationalNumberBelongToCountry(nationalNumber, country, metadata) {
    var _metadata = new (0, _metadataJsDefault.default)(metadata);
    _metadata.selectNumberingPlan(country);
    if (_metadata.numberingPlan.possibleLengths().indexOf(nationalNumber.length) >= 0) return true;
    return false;
}

},{"../metadata.js":"aLNxH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7hO6r":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>extractCountryCallingCode);
var _stripIddPrefixJs = require("./stripIddPrefix.js");
var _stripIddPrefixJsDefault = parcelHelpers.interopDefault(_stripIddPrefixJs);
var _extractCountryCallingCodeFromInternationalNumberWithoutPlusSignJs = require("./extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js");
var _extractCountryCallingCodeFromInternationalNumberWithoutPlusSignJsDefault = parcelHelpers.interopDefault(_extractCountryCallingCodeFromInternationalNumberWithoutPlusSignJs);
var _metadataJs = require("../metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _constantsJs = require("../constants.js");
function extractCountryCallingCode(number, country, callingCode, metadata) {
    if (!number) return {};
    var isNumberWithIddPrefix; // If this is not an international phone number,
    // then either extract an "IDD" prefix, or extract a
    // country calling code from a number by autocorrecting it
    // by prepending a leading `+` in cases when it starts
    // with the country calling code.
    // https://wikitravel.org/en/International_dialling_prefix
    // https://github.com/catamphetamine/libphonenumber-js/issues/376
    if (number[0] !== '+') {
        // Convert an "out-of-country" dialing phone number
        // to a proper international phone number.
        var numberWithoutIDD = (0, _stripIddPrefixJsDefault.default)(number, country, callingCode, metadata); // If an IDD prefix was stripped then
        // convert the number to international one
        // for subsequent parsing.
        if (numberWithoutIDD && numberWithoutIDD !== number) {
            isNumberWithIddPrefix = true;
            number = '+' + numberWithoutIDD;
        } else {
            // Check to see if the number starts with the country calling code
            // for the default country. If so, we remove the country calling code,
            // and do some checks on the validity of the number before and after.
            // https://github.com/catamphetamine/libphonenumber-js/issues/376
            if (country || callingCode) {
                var _extractCountryCallin = (0, _extractCountryCallingCodeFromInternationalNumberWithoutPlusSignJsDefault.default)(number, country, callingCode, metadata), countryCallingCode = _extractCountryCallin.countryCallingCode, shorterNumber = _extractCountryCallin.number;
                if (countryCallingCode) return {
                    countryCallingCodeSource: 'FROM_NUMBER_WITHOUT_PLUS_SIGN',
                    countryCallingCode: countryCallingCode,
                    number: shorterNumber
                };
            }
            return {
                // No need to set it to `UNSPECIFIED`. It can be just `undefined`.
                // countryCallingCodeSource: 'UNSPECIFIED',
                number: number
            };
        }
    } // Fast abortion: country codes do not begin with a '0'
    if (number[1] === '0') return {};
    metadata = new (0, _metadataJsDefault.default)(metadata); // The thing with country phone codes
    // is that they are orthogonal to each other
    // i.e. there's no such country phone code A
    // for which country phone code B exists
    // where B starts with A.
    // Therefore, while scanning digits,
    // if a valid country code is found,
    // that means that it is the country code.
    //
    var i = 2;
    while(i - 1 <= (0, _constantsJs.MAX_LENGTH_COUNTRY_CODE) && i <= number.length){
        var _countryCallingCode = number.slice(1, i);
        if (metadata.hasCallingCode(_countryCallingCode)) {
            metadata.selectNumberingPlan(_countryCallingCode);
            return {
                countryCallingCodeSource: isNumberWithIddPrefix ? 'FROM_NUMBER_WITH_IDD' : 'FROM_NUMBER_WITH_PLUS_SIGN',
                countryCallingCode: _countryCallingCode,
                number: number.slice(i)
            };
        }
        i++;
    }
    return {};
} // The possible values for the returned `countryCallingCodeSource` are:
 //
 // Copy-pasted from:
 // https://github.com/google/libphonenumber/blob/master/resources/phonenumber.proto
 //
 // // The source from which the country_code is derived. This is not set in the
 // // general parsing method, but in the method that parses and keeps raw_input.
 // // New fields could be added upon request.
 // enum CountryCodeSource {
 //  // Default value returned if this is not set, because the phone number was
 //  // created using parse, not parseAndKeepRawInput. hasCountryCodeSource will
 //  // return false if this is the case.
 //  UNSPECIFIED = 0;
 //
 //  // The country_code is derived based on a phone number with a leading "+",
 //  // e.g. the French number "+33 1 42 68 53 00".
 //  FROM_NUMBER_WITH_PLUS_SIGN = 1;
 //
 //  // The country_code is derived based on a phone number with a leading IDD,
 //  // e.g. the French number "011 33 1 42 68 53 00", as it is dialled from US.
 //  FROM_NUMBER_WITH_IDD = 5;
 //
 //  // The country_code is derived based on a phone number without a leading
 //  // "+", e.g. the French number "33 1 42 68 53 00" when defaultCountry is
 //  // supplied as France.
 //  FROM_NUMBER_WITHOUT_PLUS_SIGN = 10;
 //
 //  // The country_code is derived NOT based on the phone number itself, but
 //  // from the defaultCountry parameter provided in the parsing function by the
 //  // clients. This happens mostly for numbers written in the national format
 //  // (without country code). For example, this would be set when parsing the
 //  // French number "01 42 68 53 00", when defaultCountry is supplied as
 //  // France.
 //  FROM_DEFAULT_COUNTRY = 20;
 // }

},{"./stripIddPrefix.js":"3Df7S","./extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js":"iGfqH","../metadata.js":"aLNxH","../constants.js":"8uTTN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3Df7S":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>stripIddPrefix);
var _metadataJs = require("../metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _constantsJs = require("../constants.js");
var CAPTURING_DIGIT_PATTERN = new RegExp('([' + (0, _constantsJs.VALID_DIGITS) + '])');
function stripIddPrefix(number, country, callingCode, metadata) {
    if (!country) return;
     // Check if the number is IDD-prefixed.
    var countryMetadata = new (0, _metadataJsDefault.default)(metadata);
    countryMetadata.selectNumberingPlan(country, callingCode);
    var IDDPrefixPattern = new RegExp(countryMetadata.IDDPrefix());
    if (number.search(IDDPrefixPattern) !== 0) return;
     // Strip IDD prefix.
    number = number.slice(number.match(IDDPrefixPattern)[0].length); // If there're any digits after an IDD prefix,
    // then those digits are a country calling code.
    // Since no country code starts with a `0`,
    // the code below validates that the next digit (if present) is not `0`.
    var matchedGroups = number.match(CAPTURING_DIGIT_PATTERN);
    if (matchedGroups && matchedGroups[1] != null && matchedGroups[1].length > 0) {
        if (matchedGroups[1] === '0') return;
    }
    return number;
}

},{"../metadata.js":"aLNxH","../constants.js":"8uTTN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8uTTN":[function(require,module,exports,__globalThis) {
// The minimum length of the national significant number.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MIN_LENGTH_FOR_NSN", ()=>MIN_LENGTH_FOR_NSN);
parcelHelpers.export(exports, "MAX_LENGTH_FOR_NSN", ()=>MAX_LENGTH_FOR_NSN);
parcelHelpers.export(exports, "MAX_LENGTH_COUNTRY_CODE", ()=>MAX_LENGTH_COUNTRY_CODE);
parcelHelpers.export(exports, "VALID_DIGITS", ()=>VALID_DIGITS);
parcelHelpers.export(exports, "WHITESPACE", ()=>WHITESPACE);
parcelHelpers.export(exports, "VALID_PUNCTUATION", ()=>VALID_PUNCTUATION);
parcelHelpers.export(exports, "PLUS_CHARS", ()=>PLUS_CHARS);
var MIN_LENGTH_FOR_NSN = 2; // The ITU says the maximum length should be 15,
var MAX_LENGTH_FOR_NSN = 17; // The maximum length of the country calling code.
var MAX_LENGTH_COUNTRY_CODE = 3; // Digits accepted in phone numbers
var VALID_DIGITS = "0-9\uFF10-\uFF19\u0660-\u0669\u06F0-\u06F9"; // `DASHES` will be right after the opening square bracket of the "character class"
var DASHES = "-\u2010-\u2015\u2212\u30FC\uFF0D";
var SLASHES = "\uFF0F/";
var DOTS = "\uFF0E.";
var WHITESPACE = " \xA0\xAD\u200B\u2060\u3000";
var BRACKETS = "()\uFF08\uFF09\uFF3B\uFF3D\\[\\]"; // export const OPENING_BRACKETS = '(\uFF08\uFF3B\\\['
var TILDES = "~\u2053\u223C\uFF5E"; // Regular expression of acceptable punctuation found in phone numbers. This
var VALID_PUNCTUATION = "".concat(DASHES).concat(SLASHES).concat(DOTS).concat(WHITESPACE).concat(BRACKETS).concat(TILDES);
var PLUS_CHARS = "+\uFF0B"; // const LEADING_PLUS_CHARS_PATTERN = new RegExp('^[' + PLUS_CHARS + ']+')

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iGfqH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>extractCountryCallingCodeFromInternationalNumberWithoutPlusSign);
var _metadataJs = require("../metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _matchesEntirelyJs = require("./matchesEntirely.js");
var _matchesEntirelyJsDefault = parcelHelpers.interopDefault(_matchesEntirelyJs);
var _extractNationalNumberJs = require("./extractNationalNumber.js");
var _extractNationalNumberJsDefault = parcelHelpers.interopDefault(_extractNationalNumberJs);
var _checkNumberLengthJs = require("./checkNumberLength.js");
var _checkNumberLengthJsDefault = parcelHelpers.interopDefault(_checkNumberLengthJs);
var _getCountryCallingCodeJs = require("../getCountryCallingCode.js");
var _getCountryCallingCodeJsDefault = parcelHelpers.interopDefault(_getCountryCallingCodeJs);
function extractCountryCallingCodeFromInternationalNumberWithoutPlusSign(number, country, callingCode, metadata) {
    var countryCallingCode = country ? (0, _getCountryCallingCodeJsDefault.default)(country, metadata) : callingCode;
    if (number.indexOf(countryCallingCode) === 0) {
        metadata = new (0, _metadataJsDefault.default)(metadata);
        metadata.selectNumberingPlan(country, callingCode);
        var possibleShorterNumber = number.slice(countryCallingCode.length);
        var _extractNationalNumbe = (0, _extractNationalNumberJsDefault.default)(possibleShorterNumber, metadata), possibleShorterNationalNumber = _extractNationalNumbe.nationalNumber;
        var _extractNationalNumbe2 = (0, _extractNationalNumberJsDefault.default)(number, metadata), nationalNumber = _extractNationalNumbe2.nationalNumber; // If the number was not valid before but is valid now,
        // or if it was too long before, we consider the number
        // with the country calling code stripped to be a better result
        // and keep that instead.
        // For example, in Germany (+49), `49` is a valid area code,
        // so if a number starts with `49`, it could be both a valid
        // national German number or an international number without
        // a leading `+`.
        if (!(0, _matchesEntirelyJsDefault.default)(nationalNumber, metadata.nationalNumberPattern()) && (0, _matchesEntirelyJsDefault.default)(possibleShorterNationalNumber, metadata.nationalNumberPattern()) || (0, _checkNumberLengthJsDefault.default)(nationalNumber, metadata) === 'TOO_LONG') return {
            countryCallingCode: countryCallingCode,
            number: possibleShorterNumber
        };
    }
    return {
        number: number
    };
}

},{"../metadata.js":"aLNxH","./matchesEntirely.js":"k0Xh7","./extractNationalNumber.js":"4McYG","./checkNumberLength.js":"4xVnQ","../getCountryCallingCode.js":"ivhFo","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4McYG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>extractNationalNumber);
var _extractNationalNumberFromPossiblyIncompleteNumberJs = require("./extractNationalNumberFromPossiblyIncompleteNumber.js");
var _extractNationalNumberFromPossiblyIncompleteNumberJsDefault = parcelHelpers.interopDefault(_extractNationalNumberFromPossiblyIncompleteNumberJs);
var _matchesEntirelyJs = require("./matchesEntirely.js");
var _matchesEntirelyJsDefault = parcelHelpers.interopDefault(_matchesEntirelyJs);
var _checkNumberLengthJs = require("./checkNumberLength.js");
var _checkNumberLengthJsDefault = parcelHelpers.interopDefault(_checkNumberLengthJs);
function extractNationalNumber(number, metadata) {
    // Parsing national prefixes and carrier codes
    // is only required for local phone numbers
    // but some people don't understand that
    // and sometimes write international phone numbers
    // with national prefixes (or maybe even carrier codes).
    // http://ucken.blogspot.ru/2016/03/trunk-prefixes-in-skype4b.html
    // Google's original library forgives such mistakes
    // and so does this library, because it has been requested:
    // https://github.com/catamphetamine/libphonenumber-js/issues/127
    var _extractNationalNumbe = (0, _extractNationalNumberFromPossiblyIncompleteNumberJsDefault.default)(number, metadata), carrierCode = _extractNationalNumbe.carrierCode, nationalNumber = _extractNationalNumbe.nationalNumber;
    if (nationalNumber !== number) {
        if (!shouldHaveExtractedNationalPrefix(number, nationalNumber, metadata)) // Don't strip the national prefix.
        return {
            nationalNumber: number
        };
         // Check the national (significant) number length after extracting national prefix and carrier code.
        // Legacy generated metadata (before `1.0.18`) didn't support the "possible lengths" feature.
        if (metadata.possibleLengths()) {
            // The number remaining after stripping the national prefix and carrier code
            // should be long enough to have a possible length for the country.
            // Otherwise, don't strip the national prefix and carrier code,
            // since the original number could be a valid number.
            // This check has been copy-pasted "as is" from Google's original library:
            // https://github.com/google/libphonenumber/blob/876268eb1ad6cdc1b7b5bef17fc5e43052702d57/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L3236-L3250
            // It doesn't check for the "possibility" of the original `number`.
            // I guess it's fine not checking that one. It works as is anyway.
            if (!isPossibleIncompleteNationalNumber(nationalNumber, metadata)) // Don't strip the national prefix.
            return {
                nationalNumber: number
            };
        }
    }
    return {
        nationalNumber: nationalNumber,
        carrierCode: carrierCode
    };
} // In some countries, the same digit could be a national prefix
// or a leading digit of a valid phone number.
// For example, in Russia, national prefix is `8`,
// and also `800 555 35 35` is a valid number
// in which `8` is not a national prefix, but the first digit
// of a national (significant) number.
// Same's with Belarus:
// `82004910060` is a valid national (significant) number,
// but `2004910060` is not.
// To support such cases (to prevent the code from always stripping
// national prefix), a condition is imposed: a national prefix
// is not extracted when the original number is "viable" and the
// resultant number is not, a "viable" national number being the one
// that matches `national_number_pattern`.
function shouldHaveExtractedNationalPrefix(nationalNumberBefore, nationalNumberAfter, metadata) {
    // The equivalent in Google's code is:
    // https://github.com/google/libphonenumber/blob/e326fa1fc4283bb05eb35cb3c15c18f98a31af33/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L2969-L3004
    if ((0, _matchesEntirelyJsDefault.default)(nationalNumberBefore, metadata.nationalNumberPattern()) && !(0, _matchesEntirelyJsDefault.default)(nationalNumberAfter, metadata.nationalNumberPattern())) return false;
     // This "is possible" national number (length) check has been commented out
    // because it's superceded by the (effectively) same check done in the
    // `extractNationalNumber()` function after it calls `shouldHaveExtractedNationalPrefix()`.
    // In other words, why run the same check twice if it could only be run once.
    // // Check the national (significant) number length after extracting national prefix and carrier code.
    // // Fixes a minor "weird behavior" bug: https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/57
    // // (Legacy generated metadata (before `1.0.18`) didn't support the "possible lengths" feature).
    // if (metadata.possibleLengths()) {
    // 	if (isPossibleIncompleteNationalNumber(nationalNumberBefore, metadata) &&
    // 		!isPossibleIncompleteNationalNumber(nationalNumberAfter, metadata)) {
    // 		return false
    // 	}
    // }
    return true;
}
function isPossibleIncompleteNationalNumber(nationalNumber, metadata) {
    switch((0, _checkNumberLengthJsDefault.default)(nationalNumber, metadata)){
        case 'TOO_SHORT':
        case 'INVALID_LENGTH':
            // This library ignores "local-only" phone numbers (for simplicity).
            // See the readme for more info on what are "local-only" phone numbers.
            // case 'IS_POSSIBLE_LOCAL_ONLY':
            return false;
        default:
            return true;
    }
}

},{"./extractNationalNumberFromPossiblyIncompleteNumber.js":"WOiQY","./matchesEntirely.js":"k0Xh7","./checkNumberLength.js":"4xVnQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"WOiQY":[function(require,module,exports,__globalThis) {
/**
 * Strips any national prefix (such as 0, 1) present in a
 * (possibly incomplete) number provided.
 * "Carrier codes" are only used  in Colombia and Brazil,
 * and only when dialing within those countries from a mobile phone to a fixed line number.
 * Sometimes it won't actually strip national prefix
 * and will instead prepend some digits to the `number`:
 * for example, when number `2345678` is passed with `VI` country selected,
 * it will return `{ number: "3402345678" }`, because `340` area code is prepended.
 * @param {string} number  National number digits.
 * @param {object} metadata  Metadata with country selected.
 * @return {object} `{ nationalNumber: string, nationalPrefix: string? carrierCode: string? }`. Even if a national prefix was extracted, it's not necessarily present in the returned object, so don't rely on its presence in the returned object in order to find out whether a national prefix has been extracted or not.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>extractNationalNumberFromPossiblyIncompleteNumber);
function extractNationalNumberFromPossiblyIncompleteNumber(number, metadata) {
    if (number && metadata.numberingPlan.nationalPrefixForParsing()) {
        // See METADATA.md for the description of
        // `national_prefix_for_parsing` and `national_prefix_transform_rule`.
        // Attempt to parse the first digits as a national prefix.
        var prefixPattern = new RegExp('^(?:' + metadata.numberingPlan.nationalPrefixForParsing() + ')');
        var prefixMatch = prefixPattern.exec(number);
        if (prefixMatch) {
            var nationalNumber;
            var carrierCode; // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule
            // If a `national_prefix_for_parsing` has any "capturing groups"
            // then it means that the national (significant) number is equal to
            // those "capturing groups" transformed via `national_prefix_transform_rule`,
            // and nothing could be said about the actual national prefix:
            // what is it and was it even there.
            // If a `national_prefix_for_parsing` doesn't have any "capturing groups",
            // then everything it matches is a national prefix.
            // To determine whether `national_prefix_for_parsing` matched any
            // "capturing groups", the value of the result of calling `.exec()`
            // is looked at, and if it has non-undefined values where there're
            // "capturing groups" in the regular expression, then it means
            // that "capturing groups" have been matched.
            // It's not possible to tell whether there'll be any "capturing gropus"
            // before the matching process, because a `national_prefix_for_parsing`
            // could exhibit both behaviors.
            var capturedGroupsCount = prefixMatch.length - 1;
            var hasCapturedGroups = capturedGroupsCount > 0 && prefixMatch[capturedGroupsCount];
            if (metadata.nationalPrefixTransformRule() && hasCapturedGroups) {
                nationalNumber = number.replace(prefixPattern, metadata.nationalPrefixTransformRule()); // If there's more than one captured group,
                // then carrier code is the second one.
                if (capturedGroupsCount > 1) carrierCode = prefixMatch[1];
            } else {
                // `prefixBeforeNationalNumber` is the whole substring matched by
                // the `national_prefix_for_parsing` regular expression.
                // There seem to be no guarantees that it's just a national prefix.
                // For example, if there's a carrier code, it's gonna be a
                // part of `prefixBeforeNationalNumber` too.
                var prefixBeforeNationalNumber = prefixMatch[0];
                nationalNumber = number.slice(prefixBeforeNationalNumber.length); // If there's at least one captured group,
                // then carrier code is the first one.
                if (hasCapturedGroups) carrierCode = prefixMatch[1];
            } // Tries to guess whether a national prefix was present in the input.
            // This is not something copy-pasted from Google's library:
            // they don't seem to have an equivalent for that.
            // So this isn't an "officially approved" way of doing something like that.
            // But since there seems no other existing method, this library uses it.
            var nationalPrefix;
            if (hasCapturedGroups) {
                var possiblePositionOfTheFirstCapturedGroup = number.indexOf(prefixMatch[1]);
                var possibleNationalPrefix = number.slice(0, possiblePositionOfTheFirstCapturedGroup); // Example: an Argentinian (AR) phone number `0111523456789`.
                // `prefixMatch[0]` is `01115`, and `$1` is `11`,
                // and the rest of the phone number is `23456789`.
                // The national number is transformed via `9$1` to `91123456789`.
                // National prefix `0` is detected being present at the start.
                // if (possibleNationalPrefix.indexOf(metadata.numberingPlan.nationalPrefix()) === 0) {
                if (possibleNationalPrefix === metadata.numberingPlan.nationalPrefix()) nationalPrefix = metadata.numberingPlan.nationalPrefix();
            } else nationalPrefix = prefixMatch[0];
            return {
                nationalNumber: nationalNumber,
                nationalPrefix: nationalPrefix,
                carrierCode: carrierCode
            };
        }
    }
    return {
        nationalNumber: number
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ivhFo":[function(require,module,exports,__globalThis) {
// Deprecated. Import from 'metadata.js' directly instead.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>(0, _metadataJs.getCountryCallingCode));
var _metadataJs = require("./metadata.js");

},{"./metadata.js":"aLNxH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cbv0v":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>formatNumber);
parcelHelpers.export(exports, "chooseFormatForNumber", ()=>chooseFormatForNumber);
// This is a port of Google Android `libphonenumber`'s
// `phonenumberutil.js` of December 31th, 2018.
//
// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js
var _matchesEntirelyJs = require("./helpers/matchesEntirely.js");
var _matchesEntirelyJsDefault = parcelHelpers.interopDefault(_matchesEntirelyJs);
var _formatNationalNumberUsingFormatJs = require("./helpers/formatNationalNumberUsingFormat.js");
var _formatNationalNumberUsingFormatJsDefault = parcelHelpers.interopDefault(_formatNationalNumberUsingFormatJs);
var _metadataJs = require("./metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _getIddPrefixJs = require("./helpers/getIddPrefix.js");
var _getIddPrefixJsDefault = parcelHelpers.interopDefault(_getIddPrefixJs);
var _rfc3966Js = require("./helpers/RFC3966.js");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
var DEFAULT_OPTIONS = {
    formatExtension: function formatExtension(formattedNumber, extension, metadata) {
        return "".concat(formattedNumber).concat(metadata.ext()).concat(extension);
    }
};
function formatNumber(input, format, options, metadata) {
    // Apply default options.
    if (options) options = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);
    else options = DEFAULT_OPTIONS;
    metadata = new (0, _metadataJsDefault.default)(metadata);
    if (input.country && input.country !== '001') {
        // Validate `input.country`.
        if (!metadata.hasCountry(input.country)) throw new Error("Unknown country: ".concat(input.country));
        metadata.country(input.country);
    } else if (input.countryCallingCode) metadata.selectNumberingPlan(input.countryCallingCode);
    else return input.phone || '';
    var countryCallingCode = metadata.countryCallingCode();
    var nationalNumber = options.v2 ? input.nationalNumber : input.phone; // This variable should have been declared inside `case`s
    // but Babel has a bug and it says "duplicate variable declaration".
    var number;
    switch(format){
        case 'NATIONAL':
            // Legacy argument support.
            // (`{ country: ..., phone: '' }`)
            if (!nationalNumber) return '';
            number = formatNationalNumber(nationalNumber, input.carrierCode, 'NATIONAL', metadata, options);
            return addExtension(number, input.ext, metadata, options.formatExtension);
        case 'INTERNATIONAL':
            // Legacy argument support.
            // (`{ country: ..., phone: '' }`)
            if (!nationalNumber) return "+".concat(countryCallingCode);
            number = formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata, options);
            number = "+".concat(countryCallingCode, " ").concat(number);
            return addExtension(number, input.ext, metadata, options.formatExtension);
        case 'E.164':
            // `E.164` doesn't define "phone number extensions".
            return "+".concat(countryCallingCode).concat(nationalNumber);
        case 'RFC3966':
            return (0, _rfc3966Js.formatRFC3966)({
                number: "+".concat(countryCallingCode).concat(nationalNumber),
                ext: input.ext
            });
        // For reference, here's Google's IDD formatter:
        // https://github.com/google/libphonenumber/blob/32719cf74e68796788d1ca45abc85dcdc63ba5b9/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberUtil.java#L1546
        // Not saying that this IDD formatter replicates it 1:1, but it seems to work.
        // Who would even need to format phone numbers in IDD format anyway?
        case 'IDD':
            if (!options.fromCountry) return; // throw new Error('`fromCountry` option not passed for IDD-prefixed formatting.')
            var formattedNumber = formatIDD(nationalNumber, input.carrierCode, countryCallingCode, options.fromCountry, metadata);
            return addExtension(formattedNumber, input.ext, metadata, options.formatExtension);
        default:
            throw new Error("Unknown \"format\" argument passed to \"formatNumber()\": \"".concat(format, "\""));
    }
}
function formatNationalNumber(number, carrierCode, formatAs, metadata, options) {
    var format = chooseFormatForNumber(metadata.formats(), number);
    if (!format) return number;
    return (0, _formatNationalNumberUsingFormatJsDefault.default)(number, format, {
        useInternationalFormat: formatAs === 'INTERNATIONAL',
        withNationalPrefix: format.nationalPrefixIsOptionalWhenFormattingInNationalFormat() && options && options.nationalPrefix === false ? false : true,
        carrierCode: carrierCode,
        metadata: metadata
    });
}
function chooseFormatForNumber(availableFormats, nationalNnumber) {
    for(var _iterator = _createForOfIteratorHelperLoose(availableFormats), _step; !(_step = _iterator()).done;){
        var format = _step.value;
        // Validate leading digits.
        // The test case for "else path" could be found by searching for
        // "format.leadingDigitsPatterns().length === 0".
        if (format.leadingDigitsPatterns().length > 0) {
            // The last leading_digits_pattern is used here, as it is the most detailed
            var lastLeadingDigitsPattern = format.leadingDigitsPatterns()[format.leadingDigitsPatterns().length - 1]; // If leading digits don't match then move on to the next phone number format
            if (nationalNnumber.search(lastLeadingDigitsPattern) !== 0) continue;
        } // Check that the national number matches the phone number format regular expression
        if ((0, _matchesEntirelyJsDefault.default)(nationalNnumber, format.pattern())) return format;
    }
}
function addExtension(formattedNumber, ext, metadata, formatExtension) {
    return ext ? formatExtension(formattedNumber, ext, metadata) : formattedNumber;
}
function formatIDD(nationalNumber, carrierCode, countryCallingCode, fromCountry, metadata) {
    var fromCountryCallingCode = (0, _metadataJs.getCountryCallingCode)(fromCountry, metadata.metadata); // When calling within the same country calling code.
    if (fromCountryCallingCode === countryCallingCode) {
        var formattedNumber = formatNationalNumber(nationalNumber, carrierCode, 'NATIONAL', metadata); // For NANPA regions, return the national format for these regions
        // but prefix it with the country calling code.
        if (countryCallingCode === '1') return countryCallingCode + ' ' + formattedNumber;
         // If regions share a country calling code, the country calling code need
        // not be dialled. This also applies when dialling within a region, so this
        // if clause covers both these cases. Technically this is the case for
        // dialling from La Reunion to other overseas departments of France (French
        // Guiana, Martinique, Guadeloupe), but not vice versa - so we don't cover
        // this edge case for now and for those cases return the version including
        // country calling code. Details here:
        // http://www.petitfute.com/voyage/225-info-pratiques-reunion
        //
        return formattedNumber;
    }
    var iddPrefix = (0, _getIddPrefixJsDefault.default)(fromCountry, undefined, metadata.metadata);
    if (iddPrefix) return "".concat(iddPrefix, " ").concat(countryCallingCode, " ").concat(formatNationalNumber(nationalNumber, null, 'INTERNATIONAL', metadata));
}

},{"./helpers/matchesEntirely.js":"k0Xh7","./helpers/formatNationalNumberUsingFormat.js":"d2uis","./metadata.js":"aLNxH","./helpers/getIddPrefix.js":"2iJyf","./helpers/RFC3966.js":"4FdJ8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d2uis":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FIRST_GROUP_PATTERN", ()=>FIRST_GROUP_PATTERN);
parcelHelpers.export(exports, "default", ()=>formatNationalNumberUsingFormat);
var _applyInternationalSeparatorStyleJs = require("./applyInternationalSeparatorStyle.js"); // This was originally set to $1 but there are some countries for which the
var _applyInternationalSeparatorStyleJsDefault = parcelHelpers.interopDefault(_applyInternationalSeparatorStyleJs);
var FIRST_GROUP_PATTERN = /(\$\d)/;
function formatNationalNumberUsingFormat(number, format, _ref) {
    var useInternationalFormat = _ref.useInternationalFormat, withNationalPrefix = _ref.withNationalPrefix, carrierCode = _ref.carrierCode, metadata = _ref.metadata;
    var formattedNumber = number.replace(new RegExp(format.pattern()), useInternationalFormat ? format.internationalFormat() : // because that one is only used when formatting phone numbers
    // for dialing from a mobile phone, and this is not a dialing library.
    // carrierCode && format.domesticCarrierCodeFormattingRule()
    // 	// First, replace the $CC in the formatting rule with the desired carrier code.
    // 	// Then, replace the $FG in the formatting rule with the first group
    // 	// and the carrier code combined in the appropriate way.
    // 	? format.format().replace(FIRST_GROUP_PATTERN, format.domesticCarrierCodeFormattingRule().replace('$CC', carrierCode))
    // 	: (
    // 		withNationalPrefix && format.nationalPrefixFormattingRule()
    // 			? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())
    // 			: format.format()
    // 	)
    withNationalPrefix && format.nationalPrefixFormattingRule() ? format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule()) : format.format());
    if (useInternationalFormat) return (0, _applyInternationalSeparatorStyleJsDefault.default)(formattedNumber);
    return formattedNumber;
}

},{"./applyInternationalSeparatorStyle.js":"9wS3s","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9wS3s":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>applyInternationalSeparatorStyle);
var _constantsJs = require("../constants.js"); // Removes brackets and replaces dashes with spaces.
function applyInternationalSeparatorStyle(formattedNumber) {
    return formattedNumber.replace(new RegExp("[".concat((0, _constantsJs.VALID_PUNCTUATION), "]+"), 'g'), ' ').trim();
}

},{"../constants.js":"8uTTN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2iJyf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getIddPrefix);
var _metadataJs = require("../metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
/**
 * Pattern that makes it easy to distinguish whether a region has a single
 * international dialing prefix or not. If a region has a single international
 * prefix (e.g. 011 in USA), it will be represented as a string that contains
 * a sequence of ASCII digits, and possibly a tilde, which signals waiting for
 * the tone. If there are multiple available international prefixes in a
 * region, they will be represented as a regex string that always contains one
 * or more characters that are not ASCII digits or a tilde.
 */ var SINGLE_IDD_PREFIX_REG_EXP = /^[\d]+(?:[~\u2053\u223C\uFF5E][\d]+)?$/; // For regions that have multiple IDD prefixes
function getIddPrefix(country, callingCode, metadata) {
    var countryMetadata = new (0, _metadataJsDefault.default)(metadata);
    countryMetadata.selectNumberingPlan(country, callingCode);
    if (countryMetadata.defaultIDDPrefix()) return countryMetadata.defaultIDDPrefix();
    if (SINGLE_IDD_PREFIX_REG_EXP.test(countryMetadata.IDDPrefix())) return countryMetadata.IDDPrefix();
}

},{"../metadata.js":"aLNxH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4FdJ8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @param  {string} text - Phone URI (RFC 3966).
 * @return {object} `{ ?number, ?ext }`.
 */ parcelHelpers.export(exports, "parseRFC3966", ()=>parseRFC3966);
/**
 * @param  {object} - `{ ?number, ?extension }`.
 * @return {string} Phone URI (RFC 3966).
 */ parcelHelpers.export(exports, "formatRFC3966", ()=>formatRFC3966);
var _isViablePhoneNumberJs = require("./isViablePhoneNumber.js"); // https://www.ietf.org/rfc/rfc3966.txt
var _isViablePhoneNumberJsDefault = parcelHelpers.interopDefault(_isViablePhoneNumberJs);
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function parseRFC3966(text) {
    var number;
    var ext; // Replace "tel:" with "tel=" for parsing convenience.
    text = text.replace(/^tel:/, 'tel=');
    for(var _iterator = _createForOfIteratorHelperLoose(text.split(';')), _step; !(_step = _iterator()).done;){
        var part = _step.value;
        var _part$split = part.split('='), _part$split2 = _slicedToArray(_part$split, 2), name = _part$split2[0], value = _part$split2[1];
        switch(name){
            case 'tel':
                number = value;
                break;
            case 'ext':
                ext = value;
                break;
            case 'phone-context':
                // Only "country contexts" are supported.
                // "Domain contexts" are ignored.
                if (value[0] === '+') number = value + number;
                break;
        }
    } // If the phone number is not viable, then abort.
    if (!(0, _isViablePhoneNumberJsDefault.default)(number)) return {};
    var result = {
        number: number
    };
    if (ext) result.ext = ext;
    return result;
}
function formatRFC3966(_ref) {
    var number = _ref.number, ext = _ref.ext;
    if (!number) return '';
    if (number[0] !== '+') throw new Error("\"formatRFC3966()\" expects \"number\" to be in E.164 format.");
    return "tel:".concat(number).concat(ext ? ';ext=' + ext : '');
}

},{"./isViablePhoneNumber.js":"79bGg","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"79bGg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "VALID_PHONE_NUMBER", ()=>VALID_PHONE_NUMBER);
parcelHelpers.export(exports, "VALID_PHONE_NUMBER_WITH_EXTENSION", ()=>VALID_PHONE_NUMBER_WITH_EXTENSION);
parcelHelpers.export(exports, "default", ()=>isViablePhoneNumber);
// number like "abcde" and a valid phone number that a user has just
// started inputting, like "+1" or "1": both these cases would be
// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this
// library can provide a more detailed error message  whether it's
// really "not a number", or is it just a start of a valid phone number.
parcelHelpers.export(exports, "isViablePhoneNumberStart", ()=>isViablePhoneNumberStart);
var _constantsJs = require("../constants.js");
var _createExtensionPatternJs = require("./extension/createExtensionPattern.js"); //  Regular expression of viable phone numbers. This is location independent.
var _createExtensionPatternJsDefault = parcelHelpers.interopDefault(_createExtensionPatternJs);
//  Checks we have at least three leading digits, and only valid punctuation,
//  alpha characters and digits in the phone number. Does not include extension
//  data. The symbol 'x' is allowed here as valid punctuation since it is often
//  used as a placeholder for carrier codes, for example in Brazilian phone
//  numbers. We also allow multiple '+' characters at the start.
//
//  Corresponds to the following:
//  [digits]{minLengthNsn}|
//  plus_sign*
//  (([punctuation]|[star])*[digits]){3,}([punctuation]|[star]|[digits]|[alpha])*
//
//  The first reg-ex is to allow short numbers (two digits long) to be parsed if
//  they are entered as "15" etc, but only if there is no punctuation in them.
//  The second expression restricts the number of digits to three or more, but
//  then allows them to be in international form, and to have alpha-characters
//  and punctuation. We split up the two reg-exes here and combine them when
//  creating the reg-ex VALID_PHONE_NUMBER_PATTERN itself so we can prefix it
//  with ^ and append $ to each branch.
//
//  "Note VALID_PUNCTUATION starts with a -,
//   so must be the first in the range" (c) Google devs.
//  (wtf did they mean by saying that; probably nothing)
//
var MIN_LENGTH_PHONE_NUMBER_PATTERN = '[' + (0, _constantsJs.VALID_DIGITS) + ']{' + (0, _constantsJs.MIN_LENGTH_FOR_NSN) + '}'; //
var VALID_PHONE_NUMBER = '[' + (0, _constantsJs.PLUS_CHARS) + ']{0,1}' + '(?:' + '[' + (0, _constantsJs.VALID_PUNCTUATION) + ']*' + '[' + (0, _constantsJs.VALID_DIGITS) + ']' + '){3,}' + '[' + (0, _constantsJs.VALID_PUNCTUATION) + (0, _constantsJs.VALID_DIGITS) + ']*'; // This regular expression isn't present in Google's `libphonenumber`
// and is only used to determine whether the phone number being input
// is too short for it to even consider it a "valid" number.
// This is just a way to differentiate between a really invalid phone
// number like "abcde" and a valid phone number that a user has just
// started inputting, like "+1" or "1": both these cases would be
// considered `NOT_A_NUMBER` by Google's `libphonenumber`, but this
// library can provide a more detailed error message  whether it's
// really "not a number", or is it just a start of a valid phone number.
var VALID_PHONE_NUMBER_START_REG_EXP = new RegExp("^[" + (0, _constantsJs.PLUS_CHARS) + ']{0,1}' + '(?:' + '[' + (0, _constantsJs.VALID_PUNCTUATION) + ']*' + '[' + (0, _constantsJs.VALID_DIGITS) + ']' + '){1,2}' + '$', 'i');
var VALID_PHONE_NUMBER_WITH_EXTENSION = VALID_PHONE_NUMBER + // Phone number extensions
'(?:' + (0, _createExtensionPatternJsDefault.default)() + ')?'; // The combined regular expression for valid phone numbers:
//
var VALID_PHONE_NUMBER_PATTERN = new RegExp('^' + MIN_LENGTH_PHONE_NUMBER_PATTERN + '$' + '|' + // Or a longer fully parsed phone number (min 3 characters)
'^' + VALID_PHONE_NUMBER_WITH_EXTENSION + '$', 'i'); // Checks to see if the string of characters could possibly be a phone number at
function isViablePhoneNumber(number) {
    return number.length >= (0, _constantsJs.MIN_LENGTH_FOR_NSN) && VALID_PHONE_NUMBER_PATTERN.test(number);
} // This is just a way to differentiate between a really invalid phone
function isViablePhoneNumberStart(number) {
    return VALID_PHONE_NUMBER_START_REG_EXP.test(number);
}

},{"../constants.js":"8uTTN","./extension/createExtensionPattern.js":"bb5kV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bb5kV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createExtensionPattern);
var _constantsJs = require("../../constants.js"); // The RFC 3966 format for extensions.
var RFC3966_EXTN_PREFIX = ';ext=';
/**
 * Helper method for constructing regular expressions for parsing. Creates
 * an expression that captures up to max_length digits.
 * @return {string} RegEx pattern to capture extension digits.
 */ var getExtensionDigitsPattern = function getExtensionDigitsPattern(maxLength) {
    return "([".concat((0, _constantsJs.VALID_DIGITS), "]{1,").concat(maxLength, "})");
};
function createExtensionPattern(purpose) {
    // We cap the maximum length of an extension based on the ambiguity of the way
    // the extension is prefixed. As per ITU, the officially allowed length for
    // extensions is actually 40, but we don't support this since we haven't seen real
    // examples and this introduces many false interpretations as the extension labels
    // are not standardized.
    /** @type {string} */ var extLimitAfterExplicitLabel = '20';
    /** @type {string} */ var extLimitAfterLikelyLabel = '15';
    /** @type {string} */ var extLimitAfterAmbiguousChar = '9';
    /** @type {string} */ var extLimitWhenNotSure = '6';
    /** @type {string} */ var possibleSeparatorsBetweenNumberAndExtLabel = "[ \xA0\\t,]*"; // Optional full stop (.) or colon, followed by zero or more spaces/tabs/commas.
    /** @type {string} */ var possibleCharsAfterExtLabel = "[:\\.\uFF0E]?[ \xA0\\t,-]*";
    /** @type {string} */ var optionalExtnSuffix = "#?"; // Here the extension is called out in more explicit way, i.e mentioning it obvious
    // patterns like "ext.".
    /** @type {string} */ var explicitExtLabels = "(?:e?xt(?:ensi(?:o\u0301?|\xF3))?n?|\uFF45?\uFF58\uFF54\uFF4E?|\u0434\u043E\u0431|anexo)"; // One-character symbols that can be used to indicate an extension, and less
    // commonly used or more ambiguous extension labels.
    /** @type {string} */ var ambiguousExtLabels = "(?:[x\uFF58#\uFF03~\uFF5E]|int|\uFF49\uFF4E\uFF54)"; // When extension is not separated clearly.
    /** @type {string} */ var ambiguousSeparator = "[- ]+"; // This is the same as possibleSeparatorsBetweenNumberAndExtLabel, but not matching
    // comma as extension label may have it.
    /** @type {string} */ var possibleSeparatorsNumberExtLabelNoComma = "[ \xA0\\t]*"; // ",," is commonly used for auto dialling the extension when connected. First
    // comma is matched through possibleSeparatorsBetweenNumberAndExtLabel, so we do
    // not repeat it here. Semi-colon works in Iphone and Android also to pop up a
    // button with the extension number following.
    /** @type {string} */ var autoDiallingAndExtLabelsFound = "(?:,{2}|;)";
    /** @type {string} */ var rfcExtn = RFC3966_EXTN_PREFIX + getExtensionDigitsPattern(extLimitAfterExplicitLabel);
    /** @type {string} */ var explicitExtn = possibleSeparatorsBetweenNumberAndExtLabel + explicitExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterExplicitLabel) + optionalExtnSuffix;
    /** @type {string} */ var ambiguousExtn = possibleSeparatorsBetweenNumberAndExtLabel + ambiguousExtLabels + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix;
    /** @type {string} */ var americanStyleExtnWithSuffix = ambiguousSeparator + getExtensionDigitsPattern(extLimitWhenNotSure) + "#";
    /** @type {string} */ var autoDiallingExtn = possibleSeparatorsNumberExtLabelNoComma + autoDiallingAndExtLabelsFound + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterLikelyLabel) + optionalExtnSuffix;
    /** @type {string} */ var onlyCommasExtn = possibleSeparatorsNumberExtLabelNoComma + "(?:,)+" + possibleCharsAfterExtLabel + getExtensionDigitsPattern(extLimitAfterAmbiguousChar) + optionalExtnSuffix; // The first regular expression covers RFC 3966 format, where the extension is added
    // using ";ext=". The second more generic where extension is mentioned with explicit
    // labels like "ext:". In both the above cases we allow more numbers in extension than
    // any other extension labels. The third one captures when single character extension
    // labels or less commonly used labels are used. In such cases we capture fewer
    // extension digits in order to reduce the chance of falsely interpreting two
    // numbers beside each other as a number + extension. The fourth one covers the
    // special case of American numbers where the extension is written with a hash
    // at the end, such as "- 503#". The fifth one is exclusively for extension
    // autodialling formats which are used when dialling and in this case we accept longer
    // extensions. The last one is more liberal on the number of commas that acts as
    // extension labels, so we have a strict cap on the number of digits in such extensions.
    return rfcExtn + "|" + explicitExtn + "|" + ambiguousExtn + "|" + americanStyleExtnWithSuffix + "|" + autoDiallingExtn + "|" + onlyCommasExtn;
}

},{"../../constants.js":"8uTTN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1OCLf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>ParseError);
function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) throw new TypeError("Super expression must either be null or a function");
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else result = Super.apply(this, arguments);
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) return call;
    else if (call !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return self;
}
function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) _construct = Reflect.construct;
    else _construct = function _construct(Parent, args, Class) {
        var a = [
            null
        ];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
    };
    return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
// https://stackoverflow.com/a/46971044/970769
// "Breaking changes in Typescript 2.1"
// "Extending built-ins like Error, Array, and Map may no longer work."
// "As a recommendation, you can manually adjust the prototype immediately after any super(...) calls."
// https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
var ParseError = /*#__PURE__*/ function(_Error) {
    _inherits(ParseError, _Error);
    var _super = _createSuper(ParseError);
    function ParseError(code) {
        var _this;
        _classCallCheck(this, ParseError);
        _this = _super.call(this, code); // Set the prototype explicitly.
        // Any subclass of FooError will have to manually set the prototype as well.
        Object.setPrototypeOf(_assertThisInitialized(_this), ParseError.prototype);
        _this.name = _this.constructor.name;
        return _this;
    }
    return _createClass(ParseError);
}(/*#__PURE__*/ _wrapNativeSuper(Error));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5oHey":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parsePhoneNumberWithError);
var _parsePhoneNumberWithErrorJs = require("./parsePhoneNumberWithError_.js");
var _parsePhoneNumberWithErrorJsDefault = parcelHelpers.interopDefault(_parsePhoneNumberWithErrorJs);
var _normalizeArgumentsJs = require("./normalizeArguments.js");
var _normalizeArgumentsJsDefault = parcelHelpers.interopDefault(_normalizeArgumentsJs);
function parsePhoneNumberWithError() {
    var _normalizeArguments = (0, _normalizeArgumentsJsDefault.default)(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
    return (0, _parsePhoneNumberWithErrorJsDefault.default)(text, options, metadata);
}

},{"./parsePhoneNumberWithError_.js":"98gEV","./normalizeArguments.js":"6iUxl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"98gEV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parsePhoneNumberWithError);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function parsePhoneNumberWithError(text, options, metadata) {
    return (0, _parseJsDefault.default)(text, _objectSpread(_objectSpread({}, options), {}, {
        v2: true
    }), metadata);
}

},{"./parse.js":"hc7pH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hc7pH":[function(require,module,exports,__globalThis) {
// This is a port of Google Android `libphonenumber`'s
// `phonenumberutil.js` of December 31th, 2018.
//
// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parse);
var _constantsJs = require("./constants.js");
var _parseErrorJs = require("./ParseError.js");
var _parseErrorJsDefault = parcelHelpers.interopDefault(_parseErrorJs);
var _metadataJs = require("./metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _isViablePhoneNumberJs = require("./helpers/isViablePhoneNumber.js");
var _isViablePhoneNumberJsDefault = parcelHelpers.interopDefault(_isViablePhoneNumberJs);
var _extractExtensionJs = require("./helpers/extension/extractExtension.js");
var _extractExtensionJsDefault = parcelHelpers.interopDefault(_extractExtensionJs);
var _parseIncompletePhoneNumberJs = require("./parseIncompletePhoneNumber.js");
var _parseIncompletePhoneNumberJsDefault = parcelHelpers.interopDefault(_parseIncompletePhoneNumberJs);
var _getCountryCallingCodeJs = require("./getCountryCallingCode.js");
var _getCountryCallingCodeJsDefault = parcelHelpers.interopDefault(_getCountryCallingCodeJs);
var _isPossibleJs = require("./isPossible.js"); // import { parseRFC3966 } from './helpers/RFC3966.js'
var _phoneNumberJs = require("./PhoneNumber.js");
var _phoneNumberJsDefault = parcelHelpers.interopDefault(_phoneNumberJs);
var _matchesEntirelyJs = require("./helpers/matchesEntirely.js");
var _matchesEntirelyJsDefault = parcelHelpers.interopDefault(_matchesEntirelyJs);
var _extractCountryCallingCodeJs = require("./helpers/extractCountryCallingCode.js");
var _extractCountryCallingCodeJsDefault = parcelHelpers.interopDefault(_extractCountryCallingCodeJs);
var _extractNationalNumberJs = require("./helpers/extractNationalNumber.js");
var _extractNationalNumberJsDefault = parcelHelpers.interopDefault(_extractNationalNumberJs);
var _stripIddPrefixJs = require("./helpers/stripIddPrefix.js");
var _stripIddPrefixJsDefault = parcelHelpers.interopDefault(_stripIddPrefixJs);
var _getCountryByCallingCodeJs = require("./helpers/getCountryByCallingCode.js");
var _getCountryByCallingCodeJsDefault = parcelHelpers.interopDefault(_getCountryByCallingCodeJs);
var _extractFormattedPhoneNumberFromPossibleRfc3966NumberUriJs = require("./helpers/extractFormattedPhoneNumberFromPossibleRfc3966NumberUri.js"); // We don't allow input strings for parsing to be longer than 250 chars.
var _extractFormattedPhoneNumberFromPossibleRfc3966NumberUriJsDefault = parcelHelpers.interopDefault(_extractFormattedPhoneNumberFromPossibleRfc3966NumberUriJs);
// This prevents malicious input from consuming CPU.
var MAX_INPUT_STRING_LENGTH = 250; // This consists of the plus symbol, digits, and arabic-indic digits.
var PHONE_NUMBER_START_PATTERN = new RegExp('[' + (0, _constantsJs.PLUS_CHARS) + (0, _constantsJs.VALID_DIGITS) + ']'); // Regular expression of trailing characters that we want to remove.
// A trailing `#` is sometimes used when writing phone numbers with extensions in US.
// Example: "+1 (645) 123 1234-910#" number has extension "910".
var AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + (0, _constantsJs.VALID_DIGITS) + '#' + ']+$');
var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false; // Examples:
function parse(text, options, metadata) {
    // If assigning the `{}` default value is moved to the arguments above,
    // code coverage would decrease for some weird reason.
    options = options || {};
    metadata = new (0, _metadataJsDefault.default)(metadata); // Validate `defaultCountry`.
    if (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {
        if (options.v2) throw new (0, _parseErrorJsDefault.default)('INVALID_COUNTRY');
        throw new Error("Unknown country: ".concat(options.defaultCountry));
    } // Parse the phone number.
    var _parseInput = parseInput(text, options.v2, options.extract), formattedPhoneNumber = _parseInput.number, ext = _parseInput.ext, error = _parseInput.error; // If the phone number is not viable then return nothing.
    if (!formattedPhoneNumber) {
        if (options.v2) {
            if (error === 'TOO_SHORT') throw new (0, _parseErrorJsDefault.default)('TOO_SHORT');
            throw new (0, _parseErrorJsDefault.default)('NOT_A_NUMBER');
        }
        return {};
    }
    var _parsePhoneNumber = parsePhoneNumber(formattedPhoneNumber, options.defaultCountry, options.defaultCallingCode, metadata), country = _parsePhoneNumber.country, nationalNumber = _parsePhoneNumber.nationalNumber, countryCallingCode = _parsePhoneNumber.countryCallingCode, countryCallingCodeSource = _parsePhoneNumber.countryCallingCodeSource, carrierCode = _parsePhoneNumber.carrierCode;
    if (!metadata.hasSelectedNumberingPlan()) {
        if (options.v2) throw new (0, _parseErrorJsDefault.default)('INVALID_COUNTRY');
        return {};
    } // Validate national (significant) number length.
    if (!nationalNumber || nationalNumber.length < (0, _constantsJs.MIN_LENGTH_FOR_NSN)) {
        // Won't throw here because the regexp already demands length > 1.
        /* istanbul ignore if */ if (options.v2) throw new (0, _parseErrorJsDefault.default)('TOO_SHORT');
         // Google's demo just throws an error in this case.
        return {};
    } // Validate national (significant) number length.
    //
    // A sidenote:
    //
    // They say that sometimes national (significant) numbers
    // can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).
    // https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36
    // Such numbers will just be discarded.
    //
    if (nationalNumber.length > (0, _constantsJs.MAX_LENGTH_FOR_NSN)) {
        if (options.v2) throw new (0, _parseErrorJsDefault.default)('TOO_LONG');
         // Google's demo just throws an error in this case.
        return {};
    }
    if (options.v2) {
        var phoneNumber = new (0, _phoneNumberJsDefault.default)(countryCallingCode, nationalNumber, metadata.metadata);
        if (country) phoneNumber.country = country;
        if (carrierCode) phoneNumber.carrierCode = carrierCode;
        if (ext) phoneNumber.ext = ext;
        phoneNumber.__countryCallingCodeSource = countryCallingCodeSource;
        return phoneNumber;
    } // Check if national phone number pattern matches the number.
    // National number pattern is different for each country,
    // even for those ones which are part of the "NANPA" group.
    var valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ? (0, _matchesEntirelyJsDefault.default)(nationalNumber, metadata.nationalNumberPattern()) : false;
    if (!options.extended) return valid ? result(country, nationalNumber, ext) : {};
     // isInternational: countryCallingCode !== undefined
    return {
        country: country,
        countryCallingCode: countryCallingCode,
        carrierCode: carrierCode,
        valid: valid,
        possible: valid ? true : options.extended === true && metadata.possibleLengths() && (0, _isPossibleJs.isPossibleNumber)(nationalNumber, metadata) ? true : false,
        phone: nationalNumber,
        ext: ext
    };
}
/**
 * Extracts a formatted phone number from text.
 * Doesn't guarantee that the extracted phone number
 * is a valid phone number (for example, doesn't validate its length).
 * @param  {string} text
 * @param  {boolean} [extract]  If `false`, then will parse the entire `text` as a phone number.
 * @param  {boolean} [throwOnError]  By default, it won't throw if the text is too long.
 * @return {string}
 * @example
 * // Returns "(213) 373-4253".
 * extractFormattedPhoneNumber("Call (213) 373-4253 for assistance.")
 */ function _extractFormattedPhoneNumber(text, extract, throwOnError) {
    if (!text) return;
    if (text.length > MAX_INPUT_STRING_LENGTH) {
        if (throwOnError) throw new (0, _parseErrorJsDefault.default)('TOO_LONG');
        return;
    }
    if (extract === false) return text;
     // Attempt to extract a possible number from the string passed in
    var startsAt = text.search(PHONE_NUMBER_START_PATTERN);
    if (startsAt < 0) return;
    return text // Trim everything to the left of the phone number
    .slice(startsAt) // Remove trailing non-numerical characters
    .replace(AFTER_PHONE_NUMBER_END_PATTERN, '');
}
/**
 * @param  {string} text - Input.
 * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.
 * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.
 * @return {object} `{ ?number, ?ext }`.
 */ function parseInput(text, v2, extract) {
    // // Parse RFC 3966 phone number URI.
    // if (text && text.indexOf('tel:') === 0) {
    // 	return parseRFC3966(text)
    // }
    // let number = extractFormattedPhoneNumber(text, extract, v2)
    var number = (0, _extractFormattedPhoneNumberFromPossibleRfc3966NumberUriJsDefault.default)(text, {
        extractFormattedPhoneNumber: function extractFormattedPhoneNumber(text) {
            return _extractFormattedPhoneNumber(text, extract, v2);
        }
    }); // If the phone number is not viable, then abort.
    if (!number) return {};
    if (!(0, _isViablePhoneNumberJsDefault.default)(number)) {
        if ((0, _isViablePhoneNumberJs.isViablePhoneNumberStart)(number)) return {
            error: 'TOO_SHORT'
        };
        return {};
    } // Attempt to parse extension first, since it doesn't require region-specific
    // data and we want to have the non-normalised number here.
    var withExtensionStripped = (0, _extractExtensionJsDefault.default)(number);
    if (withExtensionStripped.ext) return withExtensionStripped;
    return {
        number: number
    };
}
/**
 * Creates `parse()` result object.
 */ function result(country, nationalNumber, ext) {
    var result = {
        country: country,
        phone: nationalNumber
    };
    if (ext) result.ext = ext;
    return result;
}
/**
 * Parses a viable phone number.
 * @param {string} formattedPhoneNumber  Example: "(213) 373-4253".
 * @param {string} [defaultCountry]
 * @param {string} [defaultCallingCode]
 * @param {Metadata} metadata
 * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.
 */ function parsePhoneNumber(formattedPhoneNumber, defaultCountry, defaultCallingCode, metadata) {
    // Extract calling code from phone number.
    var _extractCountryCallin = (0, _extractCountryCallingCodeJsDefault.default)((0, _parseIncompletePhoneNumberJsDefault.default)(formattedPhoneNumber), defaultCountry, defaultCallingCode, metadata.metadata), countryCallingCodeSource = _extractCountryCallin.countryCallingCodeSource, countryCallingCode = _extractCountryCallin.countryCallingCode, number = _extractCountryCallin.number; // Choose a country by `countryCallingCode`.
    var country;
    if (countryCallingCode) metadata.selectNumberingPlan(countryCallingCode);
    else if (number && (defaultCountry || defaultCallingCode)) {
        metadata.selectNumberingPlan(defaultCountry, defaultCallingCode);
        if (defaultCountry) country = defaultCountry;
        else {
            /* istanbul ignore if */ if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
                if (metadata.isNonGeographicCallingCode(defaultCallingCode)) country = '001';
            }
        }
        countryCallingCode = defaultCallingCode || (0, _getCountryCallingCodeJsDefault.default)(defaultCountry, metadata.metadata);
    } else return {};
    if (!number) return {
        countryCallingCodeSource: countryCallingCodeSource,
        countryCallingCode: countryCallingCode
    };
    var _extractNationalNumbe = (0, _extractNationalNumberJsDefault.default)((0, _parseIncompletePhoneNumberJsDefault.default)(number), metadata), nationalNumber = _extractNationalNumbe.nationalNumber, carrierCode = _extractNationalNumbe.carrierCode; // Sometimes there are several countries
    // corresponding to the same country phone code
    // (e.g. NANPA countries all having `1` country phone code).
    // Therefore, to reliably determine the exact country,
    // national (significant) number should have been parsed first.
    //
    // When `metadata.json` is generated, all "ambiguous" country phone codes
    // get their countries populated with the full set of
    // "phone number type" regular expressions.
    //
    var exactCountry = (0, _getCountryByCallingCodeJsDefault.default)(countryCallingCode, {
        nationalNumber: nationalNumber,
        defaultCountry: defaultCountry,
        metadata: metadata
    });
    if (exactCountry) {
        country = exactCountry;
        /* istanbul ignore if */ if (exactCountry === '001') ;
        else metadata.country(country);
    }
    return {
        country: country,
        countryCallingCode: countryCallingCode,
        countryCallingCodeSource: countryCallingCodeSource,
        nationalNumber: nationalNumber,
        carrierCode: carrierCode
    };
}

},{"./constants.js":"8uTTN","./ParseError.js":"1OCLf","./metadata.js":"aLNxH","./helpers/isViablePhoneNumber.js":"79bGg","./helpers/extension/extractExtension.js":"226Km","./parseIncompletePhoneNumber.js":"5VQUZ","./getCountryCallingCode.js":"ivhFo","./isPossible.js":"4HMsQ","./PhoneNumber.js":"drUtL","./helpers/matchesEntirely.js":"k0Xh7","./helpers/extractCountryCallingCode.js":"7hO6r","./helpers/extractNationalNumber.js":"4McYG","./helpers/stripIddPrefix.js":"3Df7S","./helpers/getCountryByCallingCode.js":"8e2dy","./helpers/extractFormattedPhoneNumberFromPossibleRfc3966NumberUri.js":"g3hHM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"226Km":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>extractExtension);
var _createExtensionPatternJs = require("./createExtensionPattern.js"); // Regexp of all known extension prefixes used by different regions followed by
var _createExtensionPatternJsDefault = parcelHelpers.interopDefault(_createExtensionPatternJs);
// 1 or more valid digits, for use when parsing.
var EXTN_PATTERN = new RegExp('(?:' + (0, _createExtensionPatternJsDefault.default)() + ')$', 'i'); // Strips any extension (as in, the part of the number dialled after the call is
function extractExtension(number) {
    var start = number.search(EXTN_PATTERN);
    if (start < 0) return {};
     // If we find a potential extension, and the number preceding this is a viable
    // number, we assume it is an extension.
    var numberWithoutExtension = number.slice(0, start);
    var matches = number.match(EXTN_PATTERN);
    var i = 1;
    while(i < matches.length){
        if (matches[i]) return {
            number: numberWithoutExtension,
            ext: matches[i]
        };
        i++;
    }
}

},{"./createExtensionPattern.js":"bb5kV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5VQUZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parseIncompletePhoneNumber);
/**
 * Parses next character while parsing phone number digits (including a `+`)
 * from text: discards everything except `+` and digits, and `+` is only allowed
 * at the start of a phone number.
 * For example, is used in `react-phone-number-input` where it uses
 * [`input-format`](https://gitlab.com/catamphetamine/input-format).
 * @param  {string} character - Yet another character from raw input string.
 * @param  {string?} prevParsedCharacters - Previous parsed characters.
 * @param  {function?} emitEvent - An optional "emit event" function.
 * @return {string?} The parsed character.
 */ parcelHelpers.export(exports, "parsePhoneNumberCharacter", ()=>parsePhoneNumberCharacter);
var _parseDigitsJs = require("./helpers/parseDigits.js");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function parseIncompletePhoneNumber(string) {
    var result = ''; // Using `.split('')` here instead of normal `for ... of`
    // because the importing application doesn't neccessarily include an ES6 polyfill.
    // The `.split('')` approach discards "exotic" UTF-8 characters
    // (the ones consisting of four bytes) but digits
    // (including non-European ones) don't fall into that range
    // so such "exotic" characters would be discarded anyway.
    for(var _iterator = _createForOfIteratorHelperLoose(string.split('')), _step; !(_step = _iterator()).done;){
        var character = _step.value;
        result += parsePhoneNumberCharacter(character, result) || '';
    }
    return result;
}
function parsePhoneNumberCharacter(character, prevParsedCharacters, emitEvent) {
    // Only allow a leading `+`.
    if (character === '+') {
        // If this `+` is not the first parsed character
        // then discard it.
        if (prevParsedCharacters) {
            // `emitEvent` argument was added to this `export`ed function on Dec 26th, 2023.
            // Any 3rd-party code that used to `import` and call this function before that
            // won't be passing any `emitEvent` argument.
            //
            // The addition of the `emitEvent` argument was to fix the slightly-weird behavior
            // of parsing an input string when the user inputs something like `"2+7"
            // https://github.com/catamphetamine/react-phone-number-input/issues/437
            //
            // If the parser encounters an unexpected `+` in a string being parsed
            // then it simply discards that out-of-place `+` and any following characters.
            //
            if (typeof emitEvent === 'function') emitEvent('end');
            return;
        }
        return '+';
    } // Allow digits.
    return (0, _parseDigitsJs.parseDigit)(character);
}

},{"./helpers/parseDigits.js":"72H5y","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"72H5y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DIGITS", ()=>DIGITS);
parcelHelpers.export(exports, "parseDigit", ()=>parseDigit);
parcelHelpers.export(exports, "default", ()=>parseDigits);
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
var DIGITS = {
    '0': '0',
    '1': '1',
    '2': '2',
    '3': '3',
    '4': '4',
    '5': '5',
    '6': '6',
    '7': '7',
    '8': '8',
    '9': '9',
    "\uFF10": '0',
    // Fullwidth digit 0
    "\uFF11": '1',
    // Fullwidth digit 1
    "\uFF12": '2',
    // Fullwidth digit 2
    "\uFF13": '3',
    // Fullwidth digit 3
    "\uFF14": '4',
    // Fullwidth digit 4
    "\uFF15": '5',
    // Fullwidth digit 5
    "\uFF16": '6',
    // Fullwidth digit 6
    "\uFF17": '7',
    // Fullwidth digit 7
    "\uFF18": '8',
    // Fullwidth digit 8
    "\uFF19": '9',
    // Fullwidth digit 9
    "\u0660": '0',
    // Arabic-indic digit 0
    "\u0661": '1',
    // Arabic-indic digit 1
    "\u0662": '2',
    // Arabic-indic digit 2
    "\u0663": '3',
    // Arabic-indic digit 3
    "\u0664": '4',
    // Arabic-indic digit 4
    "\u0665": '5',
    // Arabic-indic digit 5
    "\u0666": '6',
    // Arabic-indic digit 6
    "\u0667": '7',
    // Arabic-indic digit 7
    "\u0668": '8',
    // Arabic-indic digit 8
    "\u0669": '9',
    // Arabic-indic digit 9
    "\u06F0": '0',
    // Eastern-Arabic digit 0
    "\u06F1": '1',
    // Eastern-Arabic digit 1
    "\u06F2": '2',
    // Eastern-Arabic digit 2
    "\u06F3": '3',
    // Eastern-Arabic digit 3
    "\u06F4": '4',
    // Eastern-Arabic digit 4
    "\u06F5": '5',
    // Eastern-Arabic digit 5
    "\u06F6": '6',
    // Eastern-Arabic digit 6
    "\u06F7": '7',
    // Eastern-Arabic digit 7
    "\u06F8": '8',
    // Eastern-Arabic digit 8
    "\u06F9": '9' // Eastern-Arabic digit 9
};
function parseDigit(character) {
    return DIGITS[character];
}
function parseDigits(string) {
    var result = ''; // Using `.split('')` here instead of normal `for ... of`
    // because the importing application doesn't neccessarily include an ES6 polyfill.
    // The `.split('')` approach discards "exotic" UTF-8 characters
    // (the ones consisting of four bytes) but digits
    // (including non-European ones) don't fall into that range
    // so such "exotic" characters would be discarded anyway.
    for(var _iterator = _createForOfIteratorHelperLoose(string.split('')), _step; !(_step = _iterator()).done;){
        var character = _step.value;
        var digit = parseDigit(character);
        if (digit) result += digit;
    }
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8e2dy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getCountryByCallingCode);
var _getCountryByNationalNumberJs = require("./getCountryByNationalNumber.js");
var _getCountryByNationalNumberJsDefault = parcelHelpers.interopDefault(_getCountryByNationalNumberJs);
var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
function getCountryByCallingCode(callingCode, _ref) {
    var nationalPhoneNumber = _ref.nationalNumber, defaultCountry = _ref.defaultCountry, metadata = _ref.metadata;
    /* istanbul ignore if */ if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
        if (metadata.isNonGeographicCallingCode(callingCode)) return '001';
    }
    var possibleCountries = metadata.getCountryCodesForCallingCode(callingCode);
    if (!possibleCountries) return;
     // If there's just one country corresponding to the country code,
    // then just return it, without further phone number digits validation.
    if (possibleCountries.length === 1) return possibleCountries[0];
    return (0, _getCountryByNationalNumberJsDefault.default)(nationalPhoneNumber, {
        countries: possibleCountries,
        defaultCountry: defaultCountry,
        metadata: metadata.metadata
    });
}

},{"./getCountryByNationalNumber.js":"yAbSK","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"yAbSK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getCountryByNationalNumber);
var _metadataJs = require("../metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _getNumberTypeJs = require("./getNumberType.js");
var _getNumberTypeJsDefault = parcelHelpers.interopDefault(_getNumberTypeJs);
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function getCountryByNationalNumber(nationalPhoneNumber, _ref) {
    var countries = _ref.countries, defaultCountry = _ref.defaultCountry, metadata = _ref.metadata;
    // Re-create `metadata` because it will be selecting a `country`.
    metadata = new (0, _metadataJsDefault.default)(metadata); // const matchingCountries = []
    for(var _iterator = _createForOfIteratorHelperLoose(countries), _step; !(_step = _iterator()).done;){
        var country = _step.value;
        metadata.country(country); // "Leading digits" patterns are only defined for about 20% of all countries.
        // By definition, matching "leading digits" is a sufficient but not a necessary
        // condition for a phone number to belong to a country.
        // The point of "leading digits" check is that it's the fastest one to get a match.
        // https://gitlab.com/catamphetamine/libphonenumber-js/blob/master/METADATA.md#leading_digits
        // I'd suppose that "leading digits" patterns are mutually exclusive for different countries
        // because of the intended use of that feature.
        if (metadata.leadingDigits()) {
            if (nationalPhoneNumber && nationalPhoneNumber.search(metadata.leadingDigits()) === 0) return country;
        } else if ((0, _getNumberTypeJsDefault.default)({
            phone: nationalPhoneNumber,
            country: country
        }, undefined, metadata.metadata)) // If both the `defaultCountry` and the "main" one match the phone number,
        // don't prefer the `defaultCountry` over the "main" one.
        // https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/154
        return country; // // If the `defaultCountry` is among the `matchingCountries` then return it.
    } // // Return the first ("main") one of the `matchingCountries`.
// if (matchingCountries.length > 0) {
// 	return matchingCountries[0]
// }
}

},{"../metadata.js":"aLNxH","./getNumberType.js":"gnC5I","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g3hHM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>extractFormattedPhoneNumberFromPossibleRfc3966NumberUri);
var _extractPhoneContextJs = require("./extractPhoneContext.js");
var _extractPhoneContextJsDefault = parcelHelpers.interopDefault(_extractPhoneContextJs);
var _parseErrorJs = require("../ParseError.js");
var _parseErrorJsDefault = parcelHelpers.interopDefault(_parseErrorJs);
function extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(numberToParse, _ref) {
    var extractFormattedPhoneNumber = _ref.extractFormattedPhoneNumber;
    var phoneContext = (0, _extractPhoneContextJsDefault.default)(numberToParse);
    if (!(0, _extractPhoneContextJs.isPhoneContextValid)(phoneContext)) throw new (0, _parseErrorJsDefault.default)('NOT_A_NUMBER');
    var phoneNumberString;
    if (phoneContext === null) // Extract a possible number from the string passed in.
    // (this strips leading characters that could not be the start of a phone number)
    phoneNumberString = extractFormattedPhoneNumber(numberToParse) || '';
    else {
        phoneNumberString = ''; // If the phone context contains a phone number prefix, we need to capture
        // it, whereas domains will be ignored.
        if (phoneContext.charAt(0) === (0, _extractPhoneContextJs.PLUS_SIGN)) phoneNumberString += phoneContext;
         // Now append everything between the "tel:" prefix and the phone-context.
        // This should include the national number, an optional extension or
        // isdn-subaddress component. Note we also handle the case when "tel:" is
        // missing, as we have seen in some of the phone number inputs.
        // In that case, we append everything from the beginning.
        var indexOfRfc3966Prefix = numberToParse.indexOf((0, _extractPhoneContextJs.RFC3966_PREFIX_));
        var indexOfNationalNumber; // RFC 3966 "tel:" prefix is preset at this stage because
        // `isPhoneContextValid()` requires it to be present.
        /* istanbul ignore else */ if (indexOfRfc3966Prefix >= 0) indexOfNationalNumber = indexOfRfc3966Prefix + (0, _extractPhoneContextJs.RFC3966_PREFIX_).length;
        else indexOfNationalNumber = 0;
        var indexOfPhoneContext = numberToParse.indexOf((0, _extractPhoneContextJs.RFC3966_PHONE_CONTEXT_));
        phoneNumberString += numberToParse.substring(indexOfNationalNumber, indexOfPhoneContext);
    } // Delete the isdn-subaddress and everything after it if it is present.
    // Note extension won't appear at the same time with isdn-subaddress
    // according to paragraph 5.3 of the RFC3966 spec.
    var indexOfIsdn = phoneNumberString.indexOf((0, _extractPhoneContextJs.RFC3966_ISDN_SUBADDRESS_));
    if (indexOfIsdn > 0) phoneNumberString = phoneNumberString.substring(0, indexOfIsdn);
     // If both phone context and isdn-subaddress are absent but other
    // parameters are present, the parameters are left in nationalNumber.
    // This is because we are concerned about deleting content from a potential
    // number string when there is no strong evidence that the number is
    // actually written in RFC3966.
    if (phoneNumberString !== '') return phoneNumberString;
}

},{"./extractPhoneContext.js":"fXGNa","../ParseError.js":"1OCLf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fXGNa":[function(require,module,exports,__globalThis) {
// When phone numbers are written in `RFC3966` format  `"tel:+12133734253"` 
// they can have their "calling code" part written separately in a `phone-context` parameter.
// Example: `"tel:12133734253;phone-context=+1"`.
// This function parses the full phone number from the local number and the `phone-context`
// when the `phone-context` contains a `+` sign.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PLUS_SIGN", ()=>PLUS_SIGN);
parcelHelpers.export(exports, "RFC3966_PREFIX_", ()=>RFC3966_PREFIX_);
parcelHelpers.export(exports, "RFC3966_PHONE_CONTEXT_", ()=>RFC3966_PHONE_CONTEXT_);
parcelHelpers.export(exports, "RFC3966_ISDN_SUBADDRESS_", ()=>RFC3966_ISDN_SUBADDRESS_);
parcelHelpers.export(exports, "default", ()=>extractPhoneContext);
/**
 * Returns whether the value of phoneContext follows the syntax defined in RFC3966.
 *
 * @param {string|null} phoneContext
 * @return {boolean}
 */ parcelHelpers.export(exports, "isPhoneContextValid", ()=>isPhoneContextValid);
var _constantsJs = require("../constants.js");
var PLUS_SIGN = '+';
var RFC3966_VISUAL_SEPARATOR_ = '[\\-\\.\\(\\)]?';
var RFC3966_PHONE_DIGIT_ = "([" + (0, _constantsJs.VALID_DIGITS) + ']' + '|' + RFC3966_VISUAL_SEPARATOR_ + ')';
var RFC3966_GLOBAL_NUMBER_DIGITS_ = "^\\" + PLUS_SIGN + RFC3966_PHONE_DIGIT_ + '*' + '[' + (0, _constantsJs.VALID_DIGITS) + ']' + RFC3966_PHONE_DIGIT_ + '*' + '$';
/**
 * Regular expression of valid global-number-digits for the phone-context
 * parameter, following the syntax defined in RFC3966.
 */ var RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_ = new RegExp(RFC3966_GLOBAL_NUMBER_DIGITS_, 'g'); // In this port of Google's library, we don't accept alpha characters in phone numbers.
// const ALPHANUM_ = VALID_ALPHA_ + VALID_DIGITS
var ALPHANUM_ = (0, _constantsJs.VALID_DIGITS);
var RFC3966_DOMAINLABEL_ = '[' + ALPHANUM_ + ']+((\\-)*[' + ALPHANUM_ + '])*';
var VALID_ALPHA_ = 'a-zA-Z';
var RFC3966_TOPLABEL_ = '[' + VALID_ALPHA_ + ']+((\\-)*[' + ALPHANUM_ + '])*';
var RFC3966_DOMAINNAME_ = '^(' + RFC3966_DOMAINLABEL_ + '\\.)*' + RFC3966_TOPLABEL_ + '\\.?$';
/**
 * Regular expression of valid domainname for the phone-context parameter,
 * following the syntax defined in RFC3966.
 */ var RFC3966_DOMAINNAME_PATTERN_ = new RegExp(RFC3966_DOMAINNAME_, 'g');
var RFC3966_PREFIX_ = 'tel:';
var RFC3966_PHONE_CONTEXT_ = ';phone-context=';
var RFC3966_ISDN_SUBADDRESS_ = ';isub=';
function extractPhoneContext(numberToExtractFrom) {
    var indexOfPhoneContext = numberToExtractFrom.indexOf(RFC3966_PHONE_CONTEXT_); // If no phone-context parameter is present
    if (indexOfPhoneContext < 0) return null;
    var phoneContextStart = indexOfPhoneContext + RFC3966_PHONE_CONTEXT_.length; // If phone-context parameter is empty
    if (phoneContextStart >= numberToExtractFrom.length) return '';
    var phoneContextEnd = numberToExtractFrom.indexOf(';', phoneContextStart); // If phone-context is not the last parameter
    if (phoneContextEnd >= 0) return numberToExtractFrom.substring(phoneContextStart, phoneContextEnd);
    else return numberToExtractFrom.substring(phoneContextStart);
}
function isPhoneContextValid(phoneContext) {
    if (phoneContext === null) return true;
    if (phoneContext.length === 0) return false;
     // Does phone-context value match pattern of global-number-digits or domainname.
    return RFC3966_GLOBAL_NUMBER_DIGITS_PATTERN_.test(phoneContext) || RFC3966_DOMAINNAME_PATTERN_.test(phoneContext);
}

},{"../constants.js":"8uTTN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6iUxl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>normalizeArguments);
var _isObjectJs = require("./helpers/isObject.js"); // Extracts the following properties from function arguments:
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function normalizeArguments(args) {
    var _Array$prototype$slic = Array.prototype.slice.call(args), _Array$prototype$slic2 = _slicedToArray(_Array$prototype$slic, 4), arg_1 = _Array$prototype$slic2[0], arg_2 = _Array$prototype$slic2[1], arg_3 = _Array$prototype$slic2[2], arg_4 = _Array$prototype$slic2[3];
    var text;
    var options;
    var metadata; // If the phone number is passed as a string.
    // `parsePhoneNumber('88005553535', ...)`.
    if (typeof arg_1 === 'string') text = arg_1;
    else throw new TypeError('A text for parsing must be a string.'); // If "default country" argument is being passed then move it to `options`.
    // `parsePhoneNumber('88005553535', 'RU', [options], metadata)`.
    if (!arg_2 || typeof arg_2 === 'string') {
        if (arg_4) {
            options = arg_3;
            metadata = arg_4;
        } else {
            options = undefined;
            metadata = arg_3;
        }
        if (arg_2) options = _objectSpread({
            defaultCountry: arg_2
        }, options);
    } else if ((0, _isObjectJsDefault.default)(arg_2)) {
        if (arg_3) {
            options = arg_2;
            metadata = arg_3;
        } else metadata = arg_2;
    } else throw new Error("Invalid second argument: ".concat(arg_2));
    return {
        text: text,
        options: options,
        metadata: metadata
    };
}

},{"./helpers/isObject.js":"hnBQE","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6vhsG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parsePhoneNumber);
var _normalizeArgumentsJs = require("./normalizeArguments.js");
var _normalizeArgumentsJsDefault = parcelHelpers.interopDefault(_normalizeArgumentsJs);
var _parsePhoneNumberJs = require("./parsePhoneNumber_.js");
var _parsePhoneNumberJsDefault = parcelHelpers.interopDefault(_parsePhoneNumberJs);
function parsePhoneNumber() {
    var _normalizeArguments = (0, _normalizeArgumentsJsDefault.default)(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
    return (0, _parsePhoneNumberJsDefault.default)(text, options, metadata);
}

},{"./normalizeArguments.js":"6iUxl","./parsePhoneNumber_.js":"ep0vl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ep0vl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parsePhoneNumber);
var _parsePhoneNumberWithErrorJs = require("./parsePhoneNumberWithError_.js");
var _parsePhoneNumberWithErrorJsDefault = parcelHelpers.interopDefault(_parsePhoneNumberWithErrorJs);
var _parseErrorJs = require("./ParseError.js");
var _parseErrorJsDefault = parcelHelpers.interopDefault(_parseErrorJs);
var _metadataJs = require("./metadata.js");
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function parsePhoneNumber(text, options, metadata) {
    // Validate `defaultCountry`.
    if (options && options.defaultCountry && !(0, _metadataJs.isSupportedCountry)(options.defaultCountry, metadata)) options = _objectSpread(_objectSpread({}, options), {}, {
        defaultCountry: undefined
    });
     // Parse phone number.
    try {
        return (0, _parsePhoneNumberWithErrorJsDefault.default)(text, options, metadata);
    } catch (error) {
        /* istanbul ignore else */ if (error instanceof (0, _parseErrorJsDefault.default)) ;
        else throw error;
    }
}

},{"./parsePhoneNumberWithError_.js":"98gEV","./ParseError.js":"1OCLf","./metadata.js":"aLNxH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gxuN1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isValidPhoneNumber);
var _normalizeArgumentsJs = require("./normalizeArguments.js");
var _normalizeArgumentsJsDefault = parcelHelpers.interopDefault(_normalizeArgumentsJs);
var _parsePhoneNumberJs = require("./parsePhoneNumber_.js");
var _parsePhoneNumberJsDefault = parcelHelpers.interopDefault(_parsePhoneNumberJs);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function isValidPhoneNumber() {
    var _normalizeArguments = (0, _normalizeArgumentsJsDefault.default)(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
    options = _objectSpread(_objectSpread({}, options), {}, {
        extract: false
    });
    var phoneNumber = (0, _parsePhoneNumberJsDefault.default)(text, options, metadata);
    return phoneNumber && phoneNumber.isValid() || false;
}

},{"./normalizeArguments.js":"6iUxl","./parsePhoneNumber_.js":"ep0vl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ljX98":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isPossiblePhoneNumber);
var _normalizeArgumentsJs = require("./normalizeArguments.js");
var _normalizeArgumentsJsDefault = parcelHelpers.interopDefault(_normalizeArgumentsJs);
var _parsePhoneNumberJs = require("./parsePhoneNumber_.js");
var _parsePhoneNumberJsDefault = parcelHelpers.interopDefault(_parsePhoneNumberJs);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function isPossiblePhoneNumber() {
    var _normalizeArguments = (0, _normalizeArgumentsJsDefault.default)(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
    options = _objectSpread(_objectSpread({}, options), {}, {
        extract: false
    });
    var phoneNumber = (0, _parsePhoneNumberJsDefault.default)(text, options, metadata);
    return phoneNumber && phoneNumber.isPossible() || false;
}

},{"./normalizeArguments.js":"6iUxl","./parsePhoneNumber_.js":"ep0vl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5LLic":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>validatePhoneNumberLength);
var _normalizeArgumentsJs = require("./normalizeArguments.js");
var _normalizeArgumentsJsDefault = parcelHelpers.interopDefault(_normalizeArgumentsJs);
var _parsePhoneNumberWithErrorJs = require("./parsePhoneNumberWithError_.js");
var _parsePhoneNumberWithErrorJsDefault = parcelHelpers.interopDefault(_parsePhoneNumberWithErrorJs);
var _parseErrorJs = require("./ParseError.js");
var _parseErrorJsDefault = parcelHelpers.interopDefault(_parseErrorJs);
var _metadataJs = require("./metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _checkNumberLengthJs = require("./helpers/checkNumberLength.js");
var _checkNumberLengthJsDefault = parcelHelpers.interopDefault(_checkNumberLengthJs);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function validatePhoneNumberLength() {
    var _normalizeArguments = (0, _normalizeArgumentsJsDefault.default)(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
    options = _objectSpread(_objectSpread({}, options), {}, {
        extract: false
    }); // Parse phone number.
    try {
        var phoneNumber = (0, _parsePhoneNumberWithErrorJsDefault.default)(text, options, metadata);
        metadata = new (0, _metadataJsDefault.default)(metadata);
        metadata.selectNumberingPlan(phoneNumber.countryCallingCode);
        var result = (0, _checkNumberLengthJsDefault.default)(phoneNumber.nationalNumber, metadata);
        if (result !== 'IS_POSSIBLE') return result;
    } catch (error) {
        /* istanbul ignore else */ if (error instanceof (0, _parseErrorJsDefault.default)) return error.message;
        else throw error;
    }
}

},{"./normalizeArguments.js":"6iUxl","./parsePhoneNumberWithError_.js":"98gEV","./ParseError.js":"1OCLf","./metadata.js":"aLNxH","./helpers/checkNumberLength.js":"4xVnQ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kIvNg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>findNumbers);
var _phoneNumberMatcherJs = require("../PhoneNumberMatcher.js");
var _phoneNumberMatcherJsDefault = parcelHelpers.interopDefault(_phoneNumberMatcherJs);
var _normalizeArgumentsJs = require("../normalizeArguments.js");
var _normalizeArgumentsJsDefault = parcelHelpers.interopDefault(_normalizeArgumentsJs);
function findNumbers() {
    var _normalizeArguments = (0, _normalizeArgumentsJsDefault.default)(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
    var matcher = new (0, _phoneNumberMatcherJsDefault.default)(text, options, metadata);
    var results = [];
    while(matcher.hasNext())results.push(matcher.next());
    return results;
}

},{"../PhoneNumberMatcher.js":"acFQ1","../normalizeArguments.js":"6iUxl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"acFQ1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>PhoneNumberMatcher);
/**
 * A port of Google's `PhoneNumberMatcher.java`.
 * https://github.com/googlei18n/libphonenumber/blob/master/java/libphonenumber/src/com/google/i18n/phonenumbers/PhoneNumberMatcher.java
 * Date: 08.03.2018.
 */ var _phoneNumberJs = require("./PhoneNumber.js");
var _phoneNumberJsDefault = parcelHelpers.interopDefault(_phoneNumberJs);
var _constantsJs = require("./constants.js");
var _createExtensionPatternJs = require("./helpers/extension/createExtensionPattern.js");
var _createExtensionPatternJsDefault = parcelHelpers.interopDefault(_createExtensionPatternJs);
var _regExpCacheJs = require("./findNumbers/RegExpCache.js");
var _regExpCacheJsDefault = parcelHelpers.interopDefault(_regExpCacheJs);
var _utilJs = require("./findNumbers/util.js");
var _utf8Js = require("./findNumbers/utf-8.js");
var _leniencyJs = require("./findNumbers/Leniency.js");
var _leniencyJsDefault = parcelHelpers.interopDefault(_leniencyJs);
var _parsePreCandidateJs = require("./findNumbers/parsePreCandidate.js");
var _parsePreCandidateJsDefault = parcelHelpers.interopDefault(_parsePreCandidateJs);
var _isValidPreCandidateJs = require("./findNumbers/isValidPreCandidate.js");
var _isValidPreCandidateJsDefault = parcelHelpers.interopDefault(_isValidPreCandidateJs);
var _isValidCandidateJs = require("./findNumbers/isValidCandidate.js");
var _isValidCandidateJsDefault = parcelHelpers.interopDefault(_isValidCandidateJs);
var _metadataJs = require("./metadata.js");
var _parsePhoneNumberJs = require("./parsePhoneNumber.js");
var _parsePhoneNumberJsDefault = parcelHelpers.interopDefault(_parsePhoneNumberJs);
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
var EXTN_PATTERNS_FOR_MATCHING = (0, _createExtensionPatternJsDefault.default)('matching');
/**
 * Patterns used to extract phone numbers from a larger phone-number-like pattern. These are
 * ordered according to specificity. For example, white-space is last since that is frequently
 * used in numbers, not just to separate two numbers. We have separate patterns since we don't
 * want to break up the phone-number-like text on more than one different kind of symbol at one
 * time, although symbols of the same type (e.g. space) can be safely grouped together.
 *
 * Note that if there is a match, we will always check any text found up to the first match as
 * well.
 */ var INNER_MATCHES = [
    '\\/+(.*)/',
    // phone number. Will match a pattern like "(650) 223 3345 (754) 223 3321".
    '(\\([^(]*)',
    // We require a space on either side of the hyphen for it to be considered a separator.
    "(?:".concat((0, _utf8Js.pZ), "-|-").concat((0, _utf8Js.pZ), ")").concat((0, _utf8Js.pZ), "*(.+)"),
    // possible that it's supposed to be used to break two numbers without spaces, and we haven't
    // seen many instances of it used within a number.
    "[\u2012-\u2015\uFF0D]".concat((0, _utf8Js.pZ), "*(.+)"),
    "\\.+".concat((0, _utf8Js.pZ), "*([^.]+)"),
    "".concat((0, _utf8Js.pZ), "+(").concat((0, _utf8Js.PZ), "+)")
]; // Limit on the number of leading (plus) characters.
var leadLimit = (0, _utilJs.limit)(0, 2); // Limit on the number of consecutive punctuation characters.
var punctuationLimit = (0, _utilJs.limit)(0, 4);
/* The maximum number of digits allowed in a digit-separated block. As we allow all digits in a
 * single block, set high enough to accommodate the entire national number and the international
 * country code. */ var digitBlockLimit = (0, _constantsJs.MAX_LENGTH_FOR_NSN) + (0, _constantsJs.MAX_LENGTH_COUNTRY_CODE); // Limit on the number of blocks separated by punctuation.
// Uses digitBlockLimit since some formats use spaces to separate each digit.
var blockLimit = (0, _utilJs.limit)(0, digitBlockLimit);
/* A punctuation sequence allowing white space. */ var punctuation = "[".concat((0, _constantsJs.VALID_PUNCTUATION), "]") + punctuationLimit; // A digits block without punctuation.
var digitSequence = (0, _utf8Js.pNd) + (0, _utilJs.limit)(1, digitBlockLimit);
/**
 * Phone number pattern allowing optional punctuation.
 * The phone number pattern used by `find()`, similar to
 * VALID_PHONE_NUMBER, but with the following differences:
 * <ul>
 *   <li>All captures are limited in order to place an upper bound to the text matched by the
 *       pattern.
 * <ul>
 *   <li>Leading punctuation / plus signs are limited.
 *   <li>Consecutive occurrences of punctuation are limited.
 *   <li>Number of digits is limited.
 * </ul>
 *   <li>No whitespace is allowed at the start or end.
 *   <li>No alpha digits (vanity numbers such as 1-800-SIX-FLAGS) are currently supported.
 * </ul>
 */ var PATTERN = '(?:' + (0, _isValidCandidateJs.LEAD_CLASS) + punctuation + ')' + leadLimit + digitSequence + '(?:' + punctuation + digitSequence + ')' + blockLimit + '(?:' + EXTN_PATTERNS_FOR_MATCHING + ')?'; // Regular expression of trailing characters that we want to remove.
// We remove all characters that are not alpha or numerical characters.
// The hash character is retained here, as it may signify
// the previous block was an extension.
//
// // Don't know what does '&&' mean here.
// const UNWANTED_END_CHAR_PATTERN = new RegExp(`[[\\P{N}&&\\P{L}]&&[^#]]+$`)
//
var UNWANTED_END_CHAR_PATTERN = new RegExp("[^".concat((0, _utf8Js._pN)).concat((0, _utf8Js._pL), "#]+$"));
var NON_DIGITS_PATTERN = /(\D+)/;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
/**
 * A stateful class that finds and extracts telephone numbers from {@linkplain CharSequence text}.
 * Instances can be created using the {@linkplain PhoneNumberUtil#findNumbers factory methods} in
 * {@link PhoneNumberUtil}.
 *
 * <p>Vanity numbers (phone numbers using alphabetic digits such as <tt>1-800-SIX-FLAGS</tt> are
 * not found.
 *
 * <p>This class is not thread-safe.
 */ var PhoneNumberMatcher = /*#__PURE__*/ function() {
    /**
   * @param {string} text  the character sequence that we will search, null for no text.
   * @param {'POSSIBLE'|'VALID'|'STRICT_GROUPING'|'EXACT_GROUPING'} [options.leniency]  The leniency to use when evaluating candidate phone numbers. See `source/findNumbers/Leniency.js` for more details.
   * @param {number} [options.maxTries]  The maximum number of invalid numbers to try before giving up on the text. This is to cover degenerate cases where the text has a lot of false positives in it. Must be >= 0.
   */ function PhoneNumberMatcher() {
        var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var metadata = arguments.length > 2 ? arguments[2] : undefined;
        _classCallCheck(this, PhoneNumberMatcher);
        options = {
            v2: options.v2,
            defaultCallingCode: options.defaultCallingCode,
            defaultCountry: options.defaultCountry && (0, _metadataJs.isSupportedCountry)(options.defaultCountry, metadata) ? options.defaultCountry : undefined,
            leniency: options.leniency || (options.extended ? 'POSSIBLE' : 'VALID'),
            maxTries: options.maxTries || MAX_SAFE_INTEGER
        }; // Validate `leniency`.
        if (!options.leniency) throw new TypeError('`leniency` is required');
        if (options.leniency !== 'POSSIBLE' && options.leniency !== 'VALID') throw new TypeError("Invalid `leniency`: \"".concat(options.leniency, "\". Supported values: \"POSSIBLE\", \"VALID\"."));
         // Validate `maxTries`.
        if (options.maxTries < 0) throw new TypeError('`maxTries` must be `>= 0`');
        this.text = text;
        this.options = options;
        this.metadata = metadata; // The degree of phone number validation.
        this.leniency = (0, _leniencyJsDefault.default)[options.leniency];
        if (!this.leniency) throw new TypeError("Unknown leniency: \"".concat(options.leniency, "\""));
        /** The maximum number of retries after matching an invalid number. */ this.maxTries = options.maxTries;
        this.PATTERN = new RegExp(PATTERN, 'ig');
        /** The iteration tristate. */ this.state = 'NOT_READY';
        /** The next index to start searching at. Undefined in {@link State#DONE}. */ this.searchIndex = 0; // A cache for frequently used country-specific regular expressions. Set to 32 to cover ~2-3
        // countries being used for the same doc with ~10 patterns for each country. Some pages will have
        // a lot more countries in use, but typically fewer numbers for each so expanding the cache for
        // that use-case won't have a lot of benefit.
        this.regExpCache = new (0, _regExpCacheJsDefault.default)(32);
    }
    /**
   * Attempts to find the next subsequence in the searched sequence on or after {@code searchIndex}
   * that represents a phone number. Returns the next match, null if none was found.
   *
   * @param index  the search index to start searching at
   * @return  the phone number match found, null if none can be found
   */ _createClass(PhoneNumberMatcher, [
        {
            key: "find",
            value: function find() {
                // // Reset the regular expression.
                // this.PATTERN.lastIndex = index
                var matches;
                while(this.maxTries > 0 && (matches = this.PATTERN.exec(this.text)) !== null){
                    var candidate = matches[0];
                    var offset = matches.index;
                    candidate = (0, _parsePreCandidateJsDefault.default)(candidate);
                    if ((0, _isValidPreCandidateJsDefault.default)(candidate, offset, this.text)) {
                        var match = this.parseAndVerify(candidate, offset, this.text) // If that failed, try to find an "inner match" -
                         || this.extractInnerMatch(candidate, offset, this.text);
                        if (match) {
                            if (this.options.v2) return {
                                startsAt: match.startsAt,
                                endsAt: match.endsAt,
                                number: match.phoneNumber
                            };
                            else {
                                var phoneNumber = match.phoneNumber;
                                var result = {
                                    startsAt: match.startsAt,
                                    endsAt: match.endsAt,
                                    phone: phoneNumber.nationalNumber
                                };
                                if (phoneNumber.country) {
                                    /* istanbul ignore if */ if (USE_NON_GEOGRAPHIC_COUNTRY_CODE && country === '001') result.countryCallingCode = phoneNumber.countryCallingCode;
                                    else result.country = phoneNumber.country;
                                } else result.countryCallingCode = phoneNumber.countryCallingCode;
                                if (phoneNumber.ext) result.ext = phoneNumber.ext;
                                return result;
                            }
                        }
                    }
                    this.maxTries--;
                }
            }
        },
        {
            key: "extractInnerMatch",
            value: function extractInnerMatch(substring, offset, text) {
                for(var _iterator = _createForOfIteratorHelperLoose(INNER_MATCHES), _step; !(_step = _iterator()).done;){
                    var innerMatchPattern = _step.value;
                    var isFirstMatch = true;
                    var candidateMatch = void 0;
                    var innerMatchRegExp = new RegExp(innerMatchPattern, 'g');
                    while(this.maxTries > 0 && (candidateMatch = innerMatchRegExp.exec(substring)) !== null){
                        if (isFirstMatch) {
                            // We should handle any group before this one too.
                            var _candidate = (0, _utilJs.trimAfterFirstMatch)(UNWANTED_END_CHAR_PATTERN, substring.slice(0, candidateMatch.index));
                            var _match = this.parseAndVerify(_candidate, offset, text);
                            if (_match) return _match;
                            this.maxTries--;
                            isFirstMatch = false;
                        }
                        var candidate = (0, _utilJs.trimAfterFirstMatch)(UNWANTED_END_CHAR_PATTERN, candidateMatch[1]); // Java code does `groupMatcher.start(1)` here,
                        // but there's no way in javascript to get a `candidate` start index,
                        // therefore resort to using this kind of an approximation.
                        // (`groupMatcher` is called `candidateInSubstringMatch` in this javascript port)
                        // https://stackoverflow.com/questions/15934353/get-index-of-each-capture-in-a-javascript-regex
                        var candidateIndexGuess = substring.indexOf(candidate, candidateMatch.index);
                        var match = this.parseAndVerify(candidate, offset + candidateIndexGuess, text);
                        if (match) return match;
                        this.maxTries--;
                    }
                }
            }
        },
        {
            key: "parseAndVerify",
            value: function parseAndVerify(candidate, offset, text) {
                if (!(0, _isValidCandidateJsDefault.default)(candidate, offset, text, this.options.leniency)) return;
                var phoneNumber = (0, _parsePhoneNumberJsDefault.default)(candidate, {
                    extended: true,
                    defaultCountry: this.options.defaultCountry,
                    defaultCallingCode: this.options.defaultCallingCode
                }, this.metadata);
                if (!phoneNumber) return;
                if (!phoneNumber.isPossible()) return;
                if (this.leniency(phoneNumber, {
                    candidate: candidate,
                    defaultCountry: this.options.defaultCountry,
                    metadata: this.metadata,
                    regExpCache: this.regExpCache
                })) return {
                    startsAt: offset,
                    endsAt: offset + candidate.length,
                    phoneNumber: phoneNumber
                };
            }
        },
        {
            key: "hasNext",
            value: function hasNext() {
                if (this.state === 'NOT_READY') {
                    this.lastMatch = this.find(); // (this.searchIndex)
                    if (this.lastMatch) // this.searchIndex = this.lastMatch.endsAt
                    this.state = 'READY';
                    else this.state = 'DONE';
                }
                return this.state === 'READY';
            }
        },
        {
            key: "next",
            value: function next() {
                // Check the state and find the next match as a side-effect if necessary.
                if (!this.hasNext()) throw new Error('No next element');
                 // Don't retain that memory any longer than necessary.
                var result = this.lastMatch;
                this.lastMatch = null;
                this.state = 'NOT_READY';
                return result;
            }
        }
    ]);
    return PhoneNumberMatcher;
}();

},{"./PhoneNumber.js":"drUtL","./constants.js":"8uTTN","./helpers/extension/createExtensionPattern.js":"bb5kV","./findNumbers/RegExpCache.js":"9FXhc","./findNumbers/util.js":"bzzcb","./findNumbers/utf-8.js":"5N0U1","./findNumbers/Leniency.js":"aP0Ih","./findNumbers/parsePreCandidate.js":"6UmgW","./findNumbers/isValidPreCandidate.js":"1NhFQ","./findNumbers/isValidCandidate.js":"3xs94","./metadata.js":"aLNxH","./parsePhoneNumber.js":"6vhsG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9FXhc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>RegExpCache);
var _lrucacheJs = require("./LRUCache.js"); // A cache for frequently used country-specific regular expressions. Set to 32 to cover ~2-3
var _lrucacheJsDefault = parcelHelpers.interopDefault(_lrucacheJs);
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
// countries being used for the same doc with ~10 patterns for each country. Some pages will have
// a lot more countries in use, but typically fewer numbers for each so expanding the cache for
// that use-case won't have a lot of benefit.
var RegExpCache = /*#__PURE__*/ function() {
    function RegExpCache(size) {
        _classCallCheck(this, RegExpCache);
        this.cache = new (0, _lrucacheJsDefault.default)(size);
    }
    _createClass(RegExpCache, [
        {
            key: "getPatternForRegExp",
            value: function getPatternForRegExp(pattern) {
                var regExp = this.cache.get(pattern);
                if (!regExp) {
                    regExp = new RegExp('^' + pattern);
                    this.cache.put(pattern, regExp);
                }
                return regExp;
            }
        }
    ]);
    return RegExpCache;
}();

},{"./LRUCache.js":"6xdJt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6xdJt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>LRUCache);
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
// https://medium.com/dsinjs/implementing-lru-cache-in-javascript-94ba6755cda9
var Node = /*#__PURE__*/ _createClass(function Node(key, value) {
    var next = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var prev = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    _classCallCheck(this, Node);
    this.key = key;
    this.value = value;
    this.next = next;
    this.prev = prev;
});
var LRUCache = /*#__PURE__*/ function() {
    //set default limit of 10 if limit is not passed.
    function LRUCache() {
        var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
        _classCallCheck(this, LRUCache);
        this.size = 0;
        this.limit = limit;
        this.head = null;
        this.tail = null;
        this.cache = {};
    } // Write Node to head of LinkedList
    // update cache with Node key and Node reference
    _createClass(LRUCache, [
        {
            key: "put",
            value: function put(key, value) {
                this.ensureLimit();
                if (!this.head) this.head = this.tail = new Node(key, value);
                else {
                    var node = new Node(key, value, this.head);
                    this.head.prev = node;
                    this.head = node;
                } //Update the cache map
                this.cache[key] = this.head;
                this.size++;
            } // Read from cache map and make that node as new Head of LinkedList
        },
        {
            key: "get",
            value: function get(key) {
                if (this.cache[key]) {
                    var value = this.cache[key].value; // node removed from it's position and cache
                    this.remove(key); // write node again to the head of LinkedList to make it most recently used
                    this.put(key, value);
                    return value;
                }
                console.log("Item not available in cache for key ".concat(key));
            }
        },
        {
            key: "ensureLimit",
            value: function ensureLimit() {
                if (this.size === this.limit) this.remove(this.tail.key);
            }
        },
        {
            key: "remove",
            value: function remove(key) {
                var node = this.cache[key];
                if (node.prev !== null) node.prev.next = node.next;
                else this.head = node.next;
                if (node.next !== null) node.next.prev = node.prev;
                else this.tail = node.prev;
                delete this.cache[key];
                this.size--;
            }
        },
        {
            key: "clear",
            value: function clear() {
                this.head = null;
                this.tail = null;
                this.size = 0;
                this.cache = {};
            } // // Invokes the callback function with every node of the chain and the index of the node.
        }
    ]);
    return LRUCache;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bzzcb":[function(require,module,exports,__globalThis) {
/** Returns a regular expression quantifier with an upper and lower limit. */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "limit", ()=>limit);
/**
 * Trims away any characters after the first match of {@code pattern} in {@code candidate},
 * returning the trimmed version.
 */ parcelHelpers.export(exports, "trimAfterFirstMatch", ()=>trimAfterFirstMatch);
parcelHelpers.export(exports, "startsWith", ()=>startsWith);
parcelHelpers.export(exports, "endsWith", ()=>endsWith);
function limit(lower, upper) {
    if (lower < 0 || upper <= 0 || upper < lower) throw new TypeError();
    return "{".concat(lower, ",").concat(upper, "}");
}
function trimAfterFirstMatch(regexp, string) {
    var index = string.search(regexp);
    if (index >= 0) return string.slice(0, index);
    return string;
}
function startsWith(string, substring) {
    return string.indexOf(substring) === 0;
}
function endsWith(string, substring) {
    return string.indexOf(substring, string.length - substring.length) === string.length - substring.length;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5N0U1":[function(require,module,exports,__globalThis) {
// Javascript doesn't support UTF-8 regular expressions.
// So mimicking them here.
// Copy-pasted from `PhoneNumberMatcher.js`.
/**
 * "\p{Z}" is any kind of whitespace or invisible separator ("Separator").
 * http://www.regular-expressions.info/unicode.html
 * "\P{Z}" is the reverse of "\p{Z}".
 * "\p{N}" is any kind of numeric character in any script ("Number").
 * "\p{Nd}" is a digit zero through nine in any script except "ideographic scripts" ("Decimal_Digit_Number").
 * "\p{Sc}" is a currency symbol ("Currency_Symbol").
 * "\p{L}" is any kind of letter from any language ("Letter").
 * "\p{Mn}" is "non-spacing mark".
 *
 * Javascript doesn't support Unicode Regular Expressions
 * so substituting it with this explicit set of characters.
 *
 * https://stackoverflow.com/questions/13210194/javascript-regex-equivalent-of-a-za-z-using-pl
 * https://github.com/danielberndt/babel-plugin-utf-8-regex/blob/master/src/transformer.js
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pZ", ()=>pZ);
parcelHelpers.export(exports, "PZ", ()=>PZ);
parcelHelpers.export(exports, "_pN", ()=>_pN);
parcelHelpers.export(exports, "pNd", ()=>pNd);
parcelHelpers.export(exports, "_pL", ()=>_pL);
/**
 * Helper method to determine if a character is a Latin-script letter or not.
 * For our purposes, combining marks should also return true since we assume
 * they have been added to a preceding Latin character.
 */ parcelHelpers.export(exports, "isLatinLetter", ()=>isLatinLetter);
parcelHelpers.export(exports, "isInvalidPunctuationSymbol", ()=>isInvalidPunctuationSymbol);
var _pZ = " \xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000";
var pZ = "[".concat(_pZ, "]");
var PZ = "[^".concat(_pZ, "]");
var _pN = "0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19"; // const pN = `[${_pN}]`
var _pNd = "0-9\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0BE6-\u0BEF\u0C66-\u0C6F\u0CE6-\u0CEF\u0D66-\u0D6F\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F29\u1040-\u1049\u1090-\u1099\u17E0-\u17E9\u1810-\u1819\u1946-\u194F\u19D0-\u19D9\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\uA620-\uA629\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19";
var pNd = "[".concat(_pNd, "]");
var _pL = "A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var pL = "[".concat(_pL, "]");
var pL_regexp = new RegExp(pL);
var _pSc = "$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20B9\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6";
var pSc = "[".concat(_pSc, "]");
var pSc_regexp = new RegExp(pSc);
var _pMn = "\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u08FE\u0900-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1DC0-\u1DE6\u1DFC-\u1DFF\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE26";
var pMn = "[".concat(_pMn, "]");
var pMn_regexp = new RegExp(pMn);
var _InBasic_Latin = "\0-\x7F";
var _InLatin_1_Supplement = "\x80-\xFF";
var _InLatin_Extended_A = "\u0100-\u017F";
var _InLatin_Extended_Additional = "\u1E00-\u1EFF";
var _InLatin_Extended_B = "\u0180-\u024F";
var _InCombining_Diacritical_Marks = "\u0300-\u036F";
var latinLetterRegexp = new RegExp('[' + _InBasic_Latin + _InLatin_1_Supplement + _InLatin_Extended_A + _InLatin_Extended_Additional + _InLatin_Extended_B + _InCombining_Diacritical_Marks + ']');
function isLatinLetter(letter) {
    // Combining marks are a subset of non-spacing-mark.
    if (!pL_regexp.test(letter) && !pMn_regexp.test(letter)) return false;
    return latinLetterRegexp.test(letter);
}
function isInvalidPunctuationSymbol(character) {
    return character === '%' || pSc_regexp.test(character);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aP0Ih":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "containsMoreThanOneSlashInNationalNumber", ()=>containsMoreThanOneSlashInNationalNumber);
var _isValidJs = require("../isValid.js");
var _isValidJsDefault = parcelHelpers.interopDefault(_isValidJs);
var _parseDigitsJs = require("../helpers/parseDigits.js");
var _parseDigitsJsDefault = parcelHelpers.interopDefault(_parseDigitsJs);
var _matchPhoneNumberStringAgainstPhoneNumberJs = require("./matchPhoneNumberStringAgainstPhoneNumber.js");
var _matchPhoneNumberStringAgainstPhoneNumberJsDefault = parcelHelpers.interopDefault(_matchPhoneNumberStringAgainstPhoneNumberJs);
var _metadataJs = require("../metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _getCountryByCallingCodeJs = require("../helpers/getCountryByCallingCode.js");
var _getCountryByCallingCodeJsDefault = parcelHelpers.interopDefault(_getCountryByCallingCodeJs);
var _formatJs = require("../format.js");
var _utilJs = require("./util.js");
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/**
 * Leniency when finding potential phone numbers in text segments
 * The levels here are ordered in increasing strictness.
 */ exports.default = {
    /**
   * Phone numbers accepted are "possible", but not necessarily "valid".
   */ POSSIBLE: function POSSIBLE(phoneNumber, _ref) {
        var candidate = _ref.candidate, metadata = _ref.metadata;
        return true;
    },
    /**
   * Phone numbers accepted are "possible" and "valid".
   * Numbers written in national format must have their national-prefix
   * present if it is usually written for a number of this type.
   */ VALID: function VALID(phoneNumber, _ref2) {
        var candidate = _ref2.candidate, defaultCountry = _ref2.defaultCountry, metadata = _ref2.metadata;
        if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata)) return false;
         // Skipped for simplicity.
        // return isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })
        return true;
    },
    /**
   * Phone numbers accepted are "valid" and
   * are grouped in a possible way for this locale. For example, a US number written as
   * "65 02 53 00 00" and "650253 0000" are not accepted at this leniency level, whereas
   * "650 253 0000", "650 2530000" or "6502530000" are.
   * Numbers with more than one '/' symbol in the national significant number
   * are also dropped at this level.
   *
   * Warning: This level might result in lower coverage especially for regions outside of
   * country code "+1". If you are not sure about which level to use,
   * email the discussion group libphonenumber-discuss@googlegroups.com.
   */ STRICT_GROUPING: function STRICT_GROUPING(phoneNumber, _ref3) {
        var candidate = _ref3.candidate, defaultCountry = _ref3.defaultCountry, metadata = _ref3.metadata, regExpCache = _ref3.regExpCache;
        if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, {
            defaultCountry: defaultCountry,
            metadata: metadata
        })) return false;
        return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsRemainGrouped, regExpCache);
    },
    /**
   * Phone numbers accepted are "valid" and are grouped in the same way
   * that we would have formatted it, or as a single block.
   * For example, a US number written as "650 2530000" is not accepted
   * at this leniency level, whereas "650 253 0000" or "6502530000" are.
   * Numbers with more than one '/' symbol are also dropped at this level.
   *
   * Warning: This level might result in lower coverage especially for regions outside of
   * country code "+1". If you are not sure about which level to use, email the discussion group
   * libphonenumber-discuss@googlegroups.com.
   */ EXACT_GROUPING: function EXACT_GROUPING(phoneNumber, _ref4) {
        var candidate = _ref4.candidate, defaultCountry = _ref4.defaultCountry, metadata = _ref4.metadata, regExpCache = _ref4.regExpCache;
        if (!phoneNumber.isValid() || !containsOnlyValidXChars(phoneNumber, candidate, metadata) || containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) || !isNationalPrefixPresentIfRequired(phoneNumber, {
            defaultCountry: defaultCountry,
            metadata: metadata
        })) return false;
        return checkNumberGroupingIsValid(phoneNumber, candidate, metadata, allNumberGroupsAreExactlyPresent, regExpCache);
    }
};
function containsOnlyValidXChars(phoneNumber, candidate, metadata) {
    // The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the
    // national significant number or (2) an extension sign, in which case they always precede the
    // extension number. We assume a carrier code is more than 1 digit, so the first case has to
    // have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'
    // or 'X'. We ignore the character if it appears as the last character of the string.
    for(var index = 0; index < candidate.length - 1; index++){
        var charAtIndex = candidate.charAt(index);
        if (charAtIndex === 'x' || charAtIndex === 'X') {
            var charAtNextIndex = candidate.charAt(index + 1);
            if (charAtNextIndex === 'x' || charAtNextIndex === 'X') {
                // This is the carrier code case, in which the 'X's always precede the national
                // significant number.
                index++;
                if ((0, _matchPhoneNumberStringAgainstPhoneNumberJsDefault.default)(candidate.substring(index), phoneNumber, metadata) !== 'NSN_MATCH') return false;
                 // This is the extension sign case, in which the 'x' or 'X' should always precede the
            // extension number.
            } else {
                var ext = (0, _parseDigitsJsDefault.default)(candidate.substring(index));
                if (ext) {
                    if (phoneNumber.ext !== ext) return false;
                } else {
                    if (phoneNumber.ext) return false;
                }
            }
        }
    }
    return true;
}
function isNationalPrefixPresentIfRequired(phoneNumber, _ref5) {
    var defaultCountry = _ref5.defaultCountry, _metadata = _ref5.metadata;
    // First, check how we deduced the country code. If it was written in international format, then
    // the national prefix is not required.
    if (phoneNumber.__countryCallingCodeSource !== 'FROM_DEFAULT_COUNTRY') return true;
    var metadata = new (0, _metadataJsDefault.default)(_metadata);
    metadata.selectNumberingPlan(phoneNumber.countryCallingCode);
    var phoneNumberRegion = phoneNumber.country || (0, _getCountryByCallingCodeJsDefault.default)(phoneNumber.countryCallingCode, {
        nationalNumber: phoneNumber.nationalNumber,
        defaultCountry: defaultCountry,
        metadata: metadata
    }); // Check if a national prefix should be present when formatting this number.
    var nationalNumber = phoneNumber.nationalNumber;
    var format = (0, _formatJs.chooseFormatForNumber)(metadata.numberingPlan.formats(), nationalNumber); // To do this, we check that a national prefix formatting rule was present
    // and that it wasn't just the first-group symbol ($1) with punctuation.
    if (format.nationalPrefixFormattingRule()) {
        if (metadata.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) // The national-prefix is optional in these cases, so we don't need to check if it was present.
        return true;
        if (!format.usesNationalPrefix()) // National Prefix not needed for this number.
        return true;
        return Boolean(phoneNumber.nationalPrefix);
    }
    return true;
}
function containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) {
    var firstSlashInBodyIndex = candidate.indexOf('/');
    if (firstSlashInBodyIndex < 0) // No slashes, this is okay.
    return false;
     // Now look for a second one.
    var secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1);
    if (secondSlashInBodyIndex < 0) // Only one slash, this is okay.
    return false;
     // If the first slash is after the country calling code, this is permitted.
    var candidateHasCountryCode = phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITH_PLUS_SIGN' || phoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITHOUT_PLUS_SIGN';
    if (candidateHasCountryCode && (0, _parseDigitsJsDefault.default)(candidate.substring(0, firstSlashInBodyIndex)) === phoneNumber.countryCallingCode) // Any more slashes and this is illegal.
    return candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0;
    return true;
}
function checkNumberGroupingIsValid(number, candidate, metadata, checkGroups, regExpCache) {
    var normalizedCandidate, formattedNumberGroups, alternateFormats, nationalSignificantNumber, _iterator, _step, alternateFormat, leadingDigitsRegExp;
    throw new Error('This part of code hasn\'t been ported');
}
/**
 * Helper method to get the national-number part of a number, formatted without any national
 * prefix, and return it as a set of digit blocks that would be formatted together following
 * standard formatting rules.
 */ function getNationalNumberGroups(metadata, number, formattingPattern) {
    var nationalSignificantNumber, rfc3966Format, endIndex, startIndex;
    throw new Error('This part of code hasn\'t been ported');
}
function allNumberGroupsAreExactlyPresent(metadata, number, normalizedCandidate, formattedNumberGroups) {
    var candidateGroups, candidateNumberGroupIndex, formattedNumberGroupIndex;
    throw new Error('This part of code hasn\'t been ported');
}
function allNumberGroupsRemainGrouped(metadata, number, normalizedCandidate, formattedNumberGroups) {
    var fromIndex, countryCode, i, region, nationalSignificantNumber;
    throw new Error('This part of code hasn\'t been ported');
}

},{"../isValid.js":"lILWs","../helpers/parseDigits.js":"72H5y","./matchPhoneNumberStringAgainstPhoneNumber.js":"f5MIZ","../metadata.js":"aLNxH","../helpers/getCountryByCallingCode.js":"8e2dy","../format.js":"cbv0v","./util.js":"bzzcb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f5MIZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>matchPhoneNumberStringAgainstPhoneNumber);
var _parsePhoneNumberJs = require("../parsePhoneNumber.js");
var _parsePhoneNumberJsDefault = parcelHelpers.interopDefault(_parsePhoneNumberJs);
function matchPhoneNumberStringAgainstPhoneNumber(phoneNumberString, phoneNumber, metadata) {
    // Parse `phoneNumberString`.
    var phoneNumberStringContainsCallingCode = true;
    var parsedPhoneNumber = (0, _parsePhoneNumberJsDefault.default)(phoneNumberString, metadata);
    if (!parsedPhoneNumber) {
        // If `phoneNumberString` didn't contain a country calling code
        // then substitute it with the `phoneNumber`'s country calling code.
        phoneNumberStringContainsCallingCode = false;
        parsedPhoneNumber = (0, _parsePhoneNumberJsDefault.default)(phoneNumberString, {
            defaultCallingCode: phoneNumber.countryCallingCode
        }, metadata);
    }
    if (!parsedPhoneNumber) return 'INVALID_NUMBER';
     // Check that the extensions match.
    if (phoneNumber.ext) {
        if (parsedPhoneNumber.ext !== phoneNumber.ext) return 'NO_MATCH';
    } else {
        if (parsedPhoneNumber.ext) return 'NO_MATCH';
    } // Check that country calling codes match.
    if (phoneNumberStringContainsCallingCode) {
        if (phoneNumber.countryCallingCode !== parsedPhoneNumber.countryCallingCode) return 'NO_MATCH';
    } // Check if the whole numbers match.
    if (phoneNumber.number === parsedPhoneNumber.number) {
        if (phoneNumberStringContainsCallingCode) return 'EXACT_MATCH';
        else return 'NSN_MATCH';
    } // Check if one national number is a "suffix" of the other.
    if (phoneNumber.nationalNumber.indexOf(parsedPhoneNumber.nationalNumber) === 0 || parsedPhoneNumber.nationalNumber.indexOf(phoneNumber.nationalNumber) === 0) // "A SHORT_NSN_MATCH occurs if there is a difference because of the
    //  presence or absence of an 'Italian leading zero', the presence or
    //  absence of an extension, or one NSN being a shorter variant of the
    //  other."
    return 'SHORT_NSN_MATCH';
    return 'NO_MATCH';
}

},{"../parsePhoneNumber.js":"6vhsG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6UmgW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>parsePreCandidate);
var _utilJs = require("./util.js"); // Regular expression of characters typically used to start a second phone number for the purposes
// of parsing. This allows us to strip off parts of the number that are actually the start of
// another number, such as for: (530) 583-6985 x302/x2303 -> the second extension here makes this
// actually two phone numbers, (530) 583-6985 x302 and (530) 583-6985 x2303. We remove the second
// extension so that the first number is parsed correctly.
//
// Matches a slash (\ or /) followed by a space followed by an `x`.
//
var SECOND_NUMBER_START_PATTERN = /[\\/] *x/;
function parsePreCandidate(candidate) {
    // Check for extra numbers at the end.
    // TODO: This is the place to start when trying to support extraction of multiple phone number
    // from split notations (+41 79 123 45 67 / 68).
    return (0, _utilJs.trimAfterFirstMatch)(SECOND_NUMBER_START_PATTERN, candidate);
}

},{"./util.js":"bzzcb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1NhFQ":[function(require,module,exports,__globalThis) {
// Matches strings that look like dates using "/" as a separator.
// Examples: 3/10/2011, 31/10/96 or 08/31/95.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isValidPreCandidate);
var SLASH_SEPARATED_DATES = /(?:(?:[0-3]?\d\/[01]?\d)|(?:[01]?\d\/[0-3]?\d))\/(?:[12]\d)?\d{2}/; // Matches timestamps.
// Examples: "2012-01-02 08:00".
// Note that the reg-ex does not include the
// trailing ":\d\d" -- that is covered by TIME_STAMPS_SUFFIX.
var TIME_STAMPS = /[12]\d{3}[-/]?[01]\d[-/]?[0-3]\d +[0-2]\d$/;
var TIME_STAMPS_SUFFIX_LEADING = /^:[0-5]\d/;
function isValidPreCandidate(candidate, offset, text) {
    // Skip a match that is more likely to be a date.
    if (SLASH_SEPARATED_DATES.test(candidate)) return false;
     // Skip potential time-stamps.
    if (TIME_STAMPS.test(candidate)) {
        var followingText = text.slice(offset + candidate.length);
        if (TIME_STAMPS_SUFFIX_LEADING.test(followingText)) return false;
    }
    return true;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3xs94":[function(require,module,exports,__globalThis) {
// Copy-pasted from `PhoneNumberMatcher.js`.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LEAD_CLASS", ()=>LEAD_CLASS);
parcelHelpers.export(exports, "default", ()=>isValidCandidate);
var _constantsJs = require("../constants.js");
var _utilJs = require("./util.js");
var _utf8Js = require("./utf-8.js");
var OPENING_PARENS = "(\\[\uFF08\uFF3B";
var CLOSING_PARENS = ")\\]\uFF09\uFF3D";
var NON_PARENS = "[^".concat(OPENING_PARENS).concat(CLOSING_PARENS, "]");
var LEAD_CLASS = "[".concat(OPENING_PARENS).concat((0, _constantsJs.PLUS_CHARS), "]"); // Punctuation that may be at the start of a phone number - brackets and plus signs.
var LEAD_CLASS_LEADING = new RegExp('^' + LEAD_CLASS); // Limit on the number of pairs of brackets in a phone number.
var BRACKET_PAIR_LIMIT = (0, _utilJs.limit)(0, 3);
/**
 * Pattern to check that brackets match. Opening brackets should be closed within a phone number.
 * This also checks that there is something inside the brackets. Having no brackets at all is also
 * fine.
 *
 * An opening bracket at the beginning may not be closed, but subsequent ones should be.  It's
 * also possible that the leading bracket was dropped, so we shouldn't be surprised if we see a
 * closing bracket first. We limit the sets of brackets in a phone number to four.
 */ var MATCHING_BRACKETS_ENTIRE = new RegExp("^(?:[" + OPENING_PARENS + "])?" + "(?:" + NON_PARENS + "+" + "[" + CLOSING_PARENS + "])?" + NON_PARENS + "+" + "(?:[" + OPENING_PARENS + "]" + NON_PARENS + "+[" + CLOSING_PARENS + "])" + BRACKET_PAIR_LIMIT + NON_PARENS + "*" + '$');
/**
 * Matches strings that look like publication pages. Example:
 * <pre>Computing Complete Answers to Queries in the Presence of Limited Access Patterns.
 * Chen Li. VLDB J. 12(3): 211-227 (2003).</pre>
 *
 * The string "211-227 (2003)" is not a telephone number.
 */ var PUB_PAGES = /\d{1,5}-+\d{1,5}\s{0,4}\(\d{1,4}/;
function isValidCandidate(candidate, offset, text, leniency) {
    // Check the candidate doesn't contain any formatting
    // which would indicate that it really isn't a phone number.
    if (!MATCHING_BRACKETS_ENTIRE.test(candidate) || PUB_PAGES.test(candidate)) return;
     // If leniency is set to VALID or stricter, we also want to skip numbers that are surrounded
    // by Latin alphabetic characters, to skip cases like abc8005001234 or 8005001234def.
    if (leniency !== 'POSSIBLE') {
        // If the candidate is not at the start of the text,
        // and does not start with phone-number punctuation,
        // check the previous character.
        if (offset > 0 && !LEAD_CLASS_LEADING.test(candidate)) {
            var previousChar = text[offset - 1]; // We return null if it is a latin letter or an invalid punctuation symbol.
            if ((0, _utf8Js.isInvalidPunctuationSymbol)(previousChar) || (0, _utf8Js.isLatinLetter)(previousChar)) return false;
        }
        var lastCharIndex = offset + candidate.length;
        if (lastCharIndex < text.length) {
            var nextChar = text[lastCharIndex];
            if ((0, _utf8Js.isInvalidPunctuationSymbol)(nextChar) || (0, _utf8Js.isLatinLetter)(nextChar)) return false;
        }
    }
    return true;
}

},{"../constants.js":"8uTTN","./util.js":"bzzcb","./utf-8.js":"5N0U1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3O402":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>searchNumbers);
var _normalizeArgumentsJs = require("../normalizeArguments.js");
var _normalizeArgumentsJsDefault = parcelHelpers.interopDefault(_normalizeArgumentsJs);
var _phoneNumberMatcherJs = require("../PhoneNumberMatcher.js");
var _phoneNumberMatcherJsDefault = parcelHelpers.interopDefault(_phoneNumberMatcherJs);
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function searchNumbers() {
    var _normalizeArguments = (0, _normalizeArgumentsJsDefault.default)(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
    var matcher = new (0, _phoneNumberMatcherJsDefault.default)(text, options, metadata);
    return _defineProperty({}, Symbol.iterator, function() {
        return {
            next: function next() {
                if (matcher.hasNext()) return {
                    done: false,
                    value: matcher.next()
                };
                return {
                    done: true
                };
            }
        };
    });
}

},{"../normalizeArguments.js":"6iUxl","../PhoneNumberMatcher.js":"acFQ1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5Duhf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>findPhoneNumbersInText);
var _phoneNumberMatcherJs = require("./PhoneNumberMatcher.js");
var _phoneNumberMatcherJsDefault = parcelHelpers.interopDefault(_phoneNumberMatcherJs);
var _normalizeArgumentsJs = require("./normalizeArguments.js");
var _normalizeArgumentsJsDefault = parcelHelpers.interopDefault(_normalizeArgumentsJs);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function findPhoneNumbersInText() {
    var _normalizeArguments = (0, _normalizeArgumentsJsDefault.default)(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
    var matcher = new (0, _phoneNumberMatcherJsDefault.default)(text, _objectSpread(_objectSpread({}, options), {}, {
        v2: true
    }), metadata);
    var results = [];
    while(matcher.hasNext())results.push(matcher.next());
    return results;
}

},{"./PhoneNumberMatcher.js":"acFQ1","./normalizeArguments.js":"6iUxl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4uJX9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>searchPhoneNumbersInText);
var _phoneNumberMatcherJs = require("./PhoneNumberMatcher.js");
var _phoneNumberMatcherJsDefault = parcelHelpers.interopDefault(_phoneNumberMatcherJs);
var _normalizeArgumentsJs = require("./normalizeArguments.js");
var _normalizeArgumentsJsDefault = parcelHelpers.interopDefault(_normalizeArgumentsJs);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _defineProperty(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
function searchPhoneNumbersInText() {
    var _normalizeArguments = (0, _normalizeArgumentsJsDefault.default)(arguments), text = _normalizeArguments.text, options = _normalizeArguments.options, metadata = _normalizeArguments.metadata;
    var matcher = new (0, _phoneNumberMatcherJsDefault.default)(text, _objectSpread(_objectSpread({}, options), {}, {
        v2: true
    }), metadata);
    return _defineProperty({}, Symbol.iterator, function() {
        return {
            next: function next() {
                if (matcher.hasNext()) return {
                    done: false,
                    value: matcher.next()
                };
                return {
                    done: true
                };
            }
        };
    });
}

},{"./PhoneNumberMatcher.js":"acFQ1","./normalizeArguments.js":"6iUxl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"37zKi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>AsYouType);
var _metadataJs = require("./metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
var _phoneNumberJs = require("./PhoneNumber.js");
var _phoneNumberJsDefault = parcelHelpers.interopDefault(_phoneNumberJs);
var _asYouTypeStateJs = require("./AsYouTypeState.js");
var _asYouTypeStateJsDefault = parcelHelpers.interopDefault(_asYouTypeStateJs);
var _asYouTypeFormatterJs = require("./AsYouTypeFormatter.js");
var _asYouTypeFormatterJsDefault = parcelHelpers.interopDefault(_asYouTypeFormatterJs);
var _asYouTypeParserJs = require("./AsYouTypeParser.js");
var _asYouTypeParserJsDefault = parcelHelpers.interopDefault(_asYouTypeParserJs);
var _getCountryByCallingCodeJs = require("./helpers/getCountryByCallingCode.js");
var _getCountryByCallingCodeJsDefault = parcelHelpers.interopDefault(_getCountryByCallingCodeJs);
var _getCountryByNationalNumberJs = require("./helpers/getCountryByNationalNumber.js");
var _getCountryByNationalNumberJsDefault = parcelHelpers.interopDefault(_getCountryByNationalNumberJs);
var _isObjectJs = require("./helpers/isObject.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
var USE_NON_GEOGRAPHIC_COUNTRY_CODE = false;
var AsYouType = /*#__PURE__*/ function() {
    /**
   * @param {(string|object)?} [optionsOrDefaultCountry] - The default country used for parsing non-international phone numbers. Can also be an `options` object.
   * @param {Object} metadata
   */ function AsYouType(optionsOrDefaultCountry, metadata) {
        _classCallCheck(this, AsYouType);
        this.metadata = new (0, _metadataJsDefault.default)(metadata);
        var _this$getCountryAndCa = this.getCountryAndCallingCode(optionsOrDefaultCountry), _this$getCountryAndCa2 = _slicedToArray(_this$getCountryAndCa, 2), defaultCountry = _this$getCountryAndCa2[0], defaultCallingCode = _this$getCountryAndCa2[1]; // `this.defaultCountry` and `this.defaultCallingCode` aren't required to be in sync.
        // For example, `this.defaultCountry` could be `"AR"` and `this.defaultCallingCode` could be `undefined`.
        // So `this.defaultCountry` and `this.defaultCallingCode` are totally independent.
        this.defaultCountry = defaultCountry;
        this.defaultCallingCode = defaultCallingCode;
        this.reset();
    }
    _createClass(AsYouType, [
        {
            key: "getCountryAndCallingCode",
            value: function getCountryAndCallingCode(optionsOrDefaultCountry) {
                // Set `defaultCountry` and `defaultCallingCode` options.
                var defaultCountry;
                var defaultCallingCode; // Turns out `null` also has type "object". Weird.
                if (optionsOrDefaultCountry) {
                    if ((0, _isObjectJsDefault.default)(optionsOrDefaultCountry)) {
                        defaultCountry = optionsOrDefaultCountry.defaultCountry;
                        defaultCallingCode = optionsOrDefaultCountry.defaultCallingCode;
                    } else defaultCountry = optionsOrDefaultCountry;
                }
                if (defaultCountry && !this.metadata.hasCountry(defaultCountry)) defaultCountry = undefined;
                if (defaultCallingCode) {
                    /* istanbul ignore if */ if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
                        if (this.metadata.isNonGeographicCallingCode(defaultCallingCode)) defaultCountry = '001';
                    }
                }
                return [
                    defaultCountry,
                    defaultCallingCode
                ];
            }
        },
        {
            key: "input",
            value: function input(text) {
                var _this$parser$input = this.parser.input(text, this.state), digits = _this$parser$input.digits, justLeadingPlus = _this$parser$input.justLeadingPlus;
                if (justLeadingPlus) this.formattedOutput = '+';
                else if (digits) {
                    this.determineTheCountryIfNeeded(); // Match the available formats by the currently available leading digits.
                    if (this.state.nationalSignificantNumber) this.formatter.narrowDownMatchingFormats(this.state);
                    var formattedNationalNumber;
                    if (this.metadata.hasSelectedNumberingPlan()) formattedNationalNumber = this.formatter.format(digits, this.state);
                    if (formattedNationalNumber === undefined) // See if another national (significant) number could be re-extracted.
                    {
                        if (this.parser.reExtractNationalSignificantNumber(this.state)) {
                            this.determineTheCountryIfNeeded(); // If it could, then re-try formatting the new national (significant) number.
                            var nationalDigits = this.state.getNationalDigits();
                            if (nationalDigits) formattedNationalNumber = this.formatter.format(nationalDigits, this.state);
                        }
                    }
                    this.formattedOutput = formattedNationalNumber ? this.getFullNumber(formattedNationalNumber) : this.getNonFormattedNumber();
                }
                return this.formattedOutput;
            }
        },
        {
            key: "reset",
            value: function reset() {
                var _this = this;
                this.state = new (0, _asYouTypeStateJsDefault.default)({
                    onCountryChange: function onCountryChange(country) {
                        // Before version `1.6.0`, the official `AsYouType` formatter API
                        // included the `.country` property of an `AsYouType` instance.
                        // Since that property (along with the others) have been moved to
                        // `this.state`, `this.country` property is emulated for compatibility
                        // with the old versions.
                        _this.country = country;
                    },
                    onCallingCodeChange: function onCallingCodeChange(callingCode, country) {
                        _this.metadata.selectNumberingPlan(country, callingCode);
                        _this.formatter.reset(_this.metadata.numberingPlan, _this.state);
                        _this.parser.reset(_this.metadata.numberingPlan);
                    }
                });
                this.formatter = new (0, _asYouTypeFormatterJsDefault.default)({
                    state: this.state,
                    metadata: this.metadata
                });
                this.parser = new (0, _asYouTypeParserJsDefault.default)({
                    defaultCountry: this.defaultCountry,
                    defaultCallingCode: this.defaultCallingCode,
                    metadata: this.metadata,
                    state: this.state,
                    onNationalSignificantNumberChange: function onNationalSignificantNumberChange() {
                        _this.determineTheCountryIfNeeded();
                        _this.formatter.reset(_this.metadata.numberingPlan, _this.state);
                    }
                });
                this.state.reset({
                    country: this.defaultCountry,
                    callingCode: this.defaultCallingCode
                });
                this.formattedOutput = '';
                return this;
            }
        },
        {
            key: "isInternational",
            value: function isInternational() {
                return this.state.international;
            }
        },
        {
            key: "getCallingCode",
            value: function getCallingCode() {
                // If the number is being input in national format and some "default calling code"
                // has been passed to `AsYouType` constructor, then `this.state.callingCode`
                // is equal to that "default calling code".
                //
                // If the number is being input in national format and no "default calling code"
                // has been passed to `AsYouType` constructor, then returns `undefined`,
                // even if a "default country" has been passed to `AsYouType` constructor.
                //
                if (this.isInternational()) return this.state.callingCode;
            } // A legacy alias.
        },
        {
            key: "getCountryCallingCode",
            value: function getCountryCallingCode() {
                return this.getCallingCode();
            }
        },
        {
            key: "getCountry",
            value: function getCountry() {
                var digits = this.state.digits; // Return `undefined` if no digits have been input yet.
                if (digits) return this._getCountry();
            }
        },
        {
            key: "_getCountry",
            value: function _getCountry() {
                var country = this.state.country;
                /* istanbul ignore if */ if (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {
                    // `AsYouType.getCountry()` returns `undefined`
                    // for "non-geographic" phone numbering plans.
                    if (country === '001') return;
                }
                return country;
            }
        },
        {
            key: "determineTheCountryIfNeeded",
            value: function determineTheCountryIfNeeded() {
                // Suppose a user enters a phone number in international format,
                // and there're several countries corresponding to that country calling code,
                // and a country has been derived from the number, and then
                // a user enters one more digit and the number is no longer
                // valid for the derived country, so the country should be re-derived
                // on every new digit in those cases.
                //
                // If the phone number is being input in national format,
                // then it could be a case when `defaultCountry` wasn't specified
                // when creating `AsYouType` instance, and just `defaultCallingCode` was specified,
                // and that "calling code" could correspond to a "non-geographic entity",
                // or there could be several countries corresponding to that country calling code.
                // In those cases, `this.country` is `undefined` and should be derived
                // from the number. Again, if country calling code is ambiguous, then
                // `this.country` should be re-derived with each new digit.
                //
                if (!this.state.country || this.isCountryCallingCodeAmbiguous()) this.determineTheCountry();
            } // Prepends `+CountryCode ` in case of an international phone number
        },
        {
            key: "getFullNumber",
            value: function getFullNumber(formattedNationalNumber) {
                var _this2 = this;
                if (this.isInternational()) {
                    var prefix = function prefix(text) {
                        return _this2.formatter.getInternationalPrefixBeforeCountryCallingCode(_this2.state, {
                            spacing: text ? true : false
                        }) + text;
                    };
                    var callingCode = this.state.callingCode;
                    if (!callingCode) return prefix("".concat(this.state.getDigitsWithoutInternationalPrefix()));
                    if (!formattedNationalNumber) return prefix(callingCode);
                    return prefix("".concat(callingCode, " ").concat(formattedNationalNumber));
                }
                return formattedNationalNumber;
            }
        },
        {
            key: "getNonFormattedNationalNumberWithPrefix",
            value: function getNonFormattedNationalNumberWithPrefix() {
                var _this$state = this.state, nationalSignificantNumber = _this$state.nationalSignificantNumber, complexPrefixBeforeNationalSignificantNumber = _this$state.complexPrefixBeforeNationalSignificantNumber, nationalPrefix = _this$state.nationalPrefix;
                var number = nationalSignificantNumber;
                var prefix = complexPrefixBeforeNationalSignificantNumber || nationalPrefix;
                if (prefix) number = prefix + number;
                return number;
            }
        },
        {
            key: "getNonFormattedNumber",
            value: function getNonFormattedNumber() {
                var nationalSignificantNumberMatchesInput = this.state.nationalSignificantNumberMatchesInput;
                return this.getFullNumber(nationalSignificantNumberMatchesInput ? this.getNonFormattedNationalNumberWithPrefix() : this.state.getNationalDigits());
            }
        },
        {
            key: "getNonFormattedTemplate",
            value: function getNonFormattedTemplate() {
                var number = this.getNonFormattedNumber();
                if (number) return number.replace(/[\+\d]/g, (0, _asYouTypeFormatterJs.DIGIT_PLACEHOLDER));
            }
        },
        {
            key: "isCountryCallingCodeAmbiguous",
            value: function isCountryCallingCodeAmbiguous() {
                var callingCode = this.state.callingCode;
                var countryCodes = this.metadata.getCountryCodesForCallingCode(callingCode);
                return countryCodes && countryCodes.length > 1;
            } // Determines the country of the phone number
        },
        {
            key: "determineTheCountry",
            value: function determineTheCountry() {
                this.state.setCountry((0, _getCountryByCallingCodeJsDefault.default)(this.isInternational() ? this.state.callingCode : this.defaultCallingCode, {
                    nationalNumber: this.state.nationalSignificantNumber,
                    defaultCountry: this.defaultCountry,
                    metadata: this.metadata
                }));
            }
        },
        {
            key: "getNumberValue",
            value: function getNumberValue() {
                var _this$state2 = this.state, digits = _this$state2.digits, callingCode = _this$state2.callingCode, country = _this$state2.country, nationalSignificantNumber = _this$state2.nationalSignificantNumber; // Will return `undefined` if no digits have been input.
                if (!digits) return;
                if (this.isInternational()) {
                    if (callingCode) return '+' + callingCode + nationalSignificantNumber;
                    else return '+' + digits;
                } else if (country || callingCode) {
                    var callingCode_ = country ? this.metadata.countryCallingCode() : callingCode;
                    return '+' + callingCode_ + nationalSignificantNumber;
                }
            }
        },
        {
            key: "getNumber",
            value: function getNumber() {
                var _this$state3 = this.state, nationalSignificantNumber = _this$state3.nationalSignificantNumber, carrierCode = _this$state3.carrierCode, callingCode = _this$state3.callingCode; // `this._getCountry()` is basically same as `this.state.country`
                // with the only change that it return `undefined` in case of a
                // "non-geographic" numbering plan instead of `"001"` "internal use" value.
                var country = this._getCountry();
                if (!nationalSignificantNumber) return;
                 // `state.country` and `state.callingCode` aren't required to be in sync.
                // For example, `country` could be `"AR"` and `callingCode` could be `undefined`.
                // So `country` and `callingCode` are totally independent.
                if (!country && !callingCode) return;
                 // By default, if `defaultCountry` parameter was passed when
                // creating `AsYouType` instance, `state.country` is gonna be
                // that `defaultCountry`, which doesn't entirely conform with
                // `parsePhoneNumber()`'s behavior where it attempts to determine
                // the country more precisely in cases when multiple countries
                // could correspond to the same `countryCallingCode`.
                // https://gitlab.com/catamphetamine/libphonenumber-js/-/issues/103#note_1417192969
                //
                // Because `AsYouType.getNumber()` method is supposed to be a 1:1
                // equivalent for `parsePhoneNumber(AsYouType.getNumberValue())`,
                // then it should also behave accordingly in cases of `country` ambiguity.
                // That's how users of this library would expect it to behave anyway.
                //
                if (country) {
                    if (country === this.defaultCountry) {
                        // `state.country` and `state.callingCode` aren't required to be in sync.
                        // For example, `state.country` could be `"AR"` and `state.callingCode` could be `undefined`.
                        // So `state.country` and `state.callingCode` are totally independent.
                        var metadata = new (0, _metadataJsDefault.default)(this.metadata.metadata);
                        metadata.selectNumberingPlan(country);
                        var _callingCode = metadata.numberingPlan.callingCode();
                        var ambiguousCountries = this.metadata.getCountryCodesForCallingCode(_callingCode);
                        if (ambiguousCountries.length > 1) {
                            var exactCountry = (0, _getCountryByNationalNumberJsDefault.default)(nationalSignificantNumber, {
                                countries: ambiguousCountries,
                                defaultCountry: this.defaultCountry,
                                metadata: this.metadata.metadata
                            });
                            if (exactCountry) country = exactCountry;
                        }
                    }
                }
                var phoneNumber = new (0, _phoneNumberJsDefault.default)(country || callingCode, nationalSignificantNumber, this.metadata.metadata);
                if (carrierCode) phoneNumber.carrierCode = carrierCode;
                 // Phone number extensions are not supported by "As You Type" formatter.
                return phoneNumber;
            }
        },
        {
            key: "isPossible",
            value: function isPossible() {
                var phoneNumber = this.getNumber();
                if (!phoneNumber) return false;
                return phoneNumber.isPossible();
            }
        },
        {
            key: "isValid",
            value: function isValid() {
                var phoneNumber = this.getNumber();
                if (!phoneNumber) return false;
                return phoneNumber.isValid();
            }
        },
        {
            key: "getNationalNumber",
            value: function getNationalNumber() {
                return this.state.nationalSignificantNumber;
            }
        },
        {
            key: "getChars",
            value: function getChars() {
                return (this.state.international ? '+' : '') + this.state.digits;
            }
        },
        {
            key: "getTemplate",
            value: function getTemplate() {
                return this.formatter.getTemplate(this.state) || this.getNonFormattedTemplate() || '';
            }
        }
    ]);
    return AsYouType;
}();

},{"./metadata.js":"aLNxH","./PhoneNumber.js":"drUtL","./AsYouTypeState.js":"aFEp3","./AsYouTypeFormatter.js":"5AtxE","./AsYouTypeParser.js":"c2YJs","./helpers/getCountryByCallingCode.js":"8e2dy","./helpers/getCountryByNationalNumber.js":"yAbSK","./helpers/isObject.js":"hnBQE","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aFEp3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>AsYouTypeState);
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
// This "state" object simply holds the state of the "AsYouType" parser:
//
// * `country?: string`
// * `callingCode?: string`
// * `digits: string`
// * `international: boolean`
// * `missingPlus: boolean`
// * `IDDPrefix?: string`
// * `carrierCode?: string`
// * `nationalPrefix?: string`
// * `nationalSignificantNumber?: string`
// * `nationalSignificantNumberMatchesInput: boolean`
// * `complexPrefixBeforeNationalSignificantNumber?: string`
//
// `state.country` and `state.callingCode` aren't required to be in sync.
// For example, `state.country` could be `"AR"` and `state.callingCode` could be `undefined`.
// So `state.country` and `state.callingCode` are totally independent.
//
var AsYouTypeState = /*#__PURE__*/ function() {
    function AsYouTypeState(_ref) {
        var onCountryChange = _ref.onCountryChange, onCallingCodeChange = _ref.onCallingCodeChange;
        _classCallCheck(this, AsYouTypeState);
        this.onCountryChange = onCountryChange;
        this.onCallingCodeChange = onCallingCodeChange;
    }
    _createClass(AsYouTypeState, [
        {
            key: "reset",
            value: function reset(_ref2) {
                var country = _ref2.country, callingCode = _ref2.callingCode;
                this.international = false;
                this.missingPlus = false;
                this.IDDPrefix = undefined;
                this.callingCode = undefined;
                this.digits = '';
                this.resetNationalSignificantNumber();
                this.initCountryAndCallingCode(country, callingCode);
            }
        },
        {
            key: "resetNationalSignificantNumber",
            value: function resetNationalSignificantNumber() {
                this.nationalSignificantNumber = this.getNationalDigits();
                this.nationalSignificantNumberMatchesInput = true;
                this.nationalPrefix = undefined;
                this.carrierCode = undefined;
                this.complexPrefixBeforeNationalSignificantNumber = undefined;
            }
        },
        {
            key: "update",
            value: function update(properties) {
                for(var _i = 0, _Object$keys = Object.keys(properties); _i < _Object$keys.length; _i++){
                    var key = _Object$keys[_i];
                    this[key] = properties[key];
                }
            }
        },
        {
            key: "initCountryAndCallingCode",
            value: function initCountryAndCallingCode(country, callingCode) {
                this.setCountry(country);
                this.setCallingCode(callingCode);
            }
        },
        {
            key: "setCountry",
            value: function setCountry(country) {
                this.country = country;
                this.onCountryChange(country);
            }
        },
        {
            key: "setCallingCode",
            value: function setCallingCode(callingCode) {
                this.callingCode = callingCode;
                this.onCallingCodeChange(callingCode, this.country);
            }
        },
        {
            key: "startInternationalNumber",
            value: function startInternationalNumber(country, callingCode) {
                // Prepend the `+` to parsed input.
                this.international = true; // If a default country was set then reset it
                // because an explicitly international phone
                // number is being entered.
                this.initCountryAndCallingCode(country, callingCode);
            }
        },
        {
            key: "appendDigits",
            value: function appendDigits(nextDigits) {
                this.digits += nextDigits;
            }
        },
        {
            key: "appendNationalSignificantNumberDigits",
            value: function appendNationalSignificantNumberDigits(nextDigits) {
                this.nationalSignificantNumber += nextDigits;
            }
        },
        {
            key: "getNationalDigits",
            value: function getNationalDigits() {
                if (this.international) return this.digits.slice((this.IDDPrefix ? this.IDDPrefix.length : 0) + (this.callingCode ? this.callingCode.length : 0));
                return this.digits;
            }
        },
        {
            key: "getDigitsWithoutInternationalPrefix",
            value: function getDigitsWithoutInternationalPrefix() {
                if (this.international) {
                    if (this.IDDPrefix) return this.digits.slice(this.IDDPrefix.length);
                }
                return this.digits;
            }
        }
    ]);
    return AsYouTypeState;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5AtxE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DIGIT_PLACEHOLDER", ()=>(0, _asYouTypeFormatterUtilJs.DIGIT_PLACEHOLDER));
parcelHelpers.export(exports, "default", ()=>AsYouTypeFormatter);
var _asYouTypeFormatterUtilJs = require("./AsYouTypeFormatter.util.js");
var _asYouTypeFormatterCompleteJs = require("./AsYouTypeFormatter.complete.js");
var _asYouTypeFormatterCompleteJsDefault = parcelHelpers.interopDefault(_asYouTypeFormatterCompleteJs);
var _asYouTypeFormatterPatternMatcherJs = require("./AsYouTypeFormatter.PatternMatcher.js");
var _asYouTypeFormatterPatternMatcherJsDefault = parcelHelpers.interopDefault(_asYouTypeFormatterPatternMatcherJs);
var _parseDigitsJs = require("./helpers/parseDigits.js");
var _parseDigitsJsDefault = parcelHelpers.interopDefault(_parseDigitsJs);
var _formatNationalNumberUsingFormatJs = require("./helpers/formatNationalNumberUsingFormat.js");
var _constantsJs = require("./constants.js");
var _applyInternationalSeparatorStyleJs = require("./helpers/applyInternationalSeparatorStyle.js"); // Used in phone number format template creation.
var _applyInternationalSeparatorStyleJsDefault = parcelHelpers.interopDefault(_applyInternationalSeparatorStyleJs);
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
// Could be any digit, I guess.
var DUMMY_DIGIT = '9'; // I don't know why is it exactly `15`
var LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15; // Create a phone number consisting only of the digit 9 that matches the
// `number_pattern` by applying the pattern to the "longest phone number" string.
var LONGEST_DUMMY_PHONE_NUMBER = (0, _asYouTypeFormatterUtilJs.repeat)(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH); // A set of characters that, if found in a national prefix formatting rules, are an indicator to
// us that we should separate the national prefix from the number when formatting.
var NATIONAL_PREFIX_SEPARATORS_PATTERN = /[- ]/; // Deprecated: Google has removed some formatting pattern related code from their repo.
// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c
// "We no longer have numbers in formatting matching patterns, only \d."
// Because this library supports generating custom metadata
// some users may still be using old metadata so the relevant
// code seems to stay until some next major version update.
var SUPPORT_LEGACY_FORMATTING_PATTERNS = true; // A pattern that is used to match character classes in regular expressions.
// An example of a character class is "[1-4]".
var CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function() {
    return /\[([^\[\]])*\]/g;
}; // Any digit in a regular expression that actually denotes a digit. For
// example, in the regular expression "80[0-2]\d{6,10}", the first 2 digits
// (8 and 0) are standalone digits, but the rest are not.
// Two look-aheads are needed because the number following \\d could be a
// two-digit number, since the phone number can be as long as 15 digits.
var CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && function() {
    return /\d(?=[^,}][^,}])/g;
}; // A regular expression that is used to determine if a `format` is
// suitable to be used in the "as you type formatter".
// A `format` is suitable when the resulting formatted number has
// the same digits as the user has entered.
//
// In the simplest case, that would mean that the format
// doesn't add any additional digits when formatting a number.
// Google says that it also shouldn't add "star" (`*`) characters,
// like it does in some Israeli formats.
// Such basic format would only contain "valid punctuation"
// and "captured group" identifiers ($1, $2, etc).
//
// An example of a format that adds additional digits:
//
// Country: `AR` (Argentina).
// Format:
// {
//    "pattern": "(\\d)(\\d{2})(\\d{4})(\\d{4})",
//    "leading_digits_patterns": ["91"],
//    "national_prefix_formatting_rule": "0$1",
//    "format": "$2 15-$3-$4",
//    "international_format": "$1 $2 $3-$4"
// }
//
// In the format above, the `format` adds `15` to the digits when formatting a number.
// A sidenote: this format actually is suitable because `national_prefix_for_parsing`
// has previously removed `15` from a national number, so re-adding `15` in `format`
// doesn't actually result in any extra digits added to user's input.
// But verifying that would be a complex procedure, so the code chooses a simpler path:
// it simply filters out all `format`s that contain anything but "captured group" ids.
//
// This regular expression is called `ELIGIBLE_FORMAT_PATTERN` in Google's
// `libphonenumber` code.
//
var NON_ALTERING_FORMAT_REG_EXP = new RegExp('[' + (0, _constantsJs.VALID_PUNCTUATION) + ']*' + // Google developers say:
// "We require that the first matching group is present in the
//  output pattern to ensure no data is lost while formatting."
'\\$1' + '[' + (0, _constantsJs.VALID_PUNCTUATION) + ']*' + '(\\$\\d[' + (0, _constantsJs.VALID_PUNCTUATION) + ']*)*' + '$'); // This is the minimum length of the leading digits of a phone number
// to guarantee the first "leading digits pattern" for a phone number format
// to be preemptive.
var MIN_LEADING_DIGITS_LENGTH = 3;
var AsYouTypeFormatter = /*#__PURE__*/ function() {
    function AsYouTypeFormatter(_ref) {
        var state = _ref.state, metadata = _ref.metadata;
        _classCallCheck(this, AsYouTypeFormatter);
        this.metadata = metadata;
        this.resetFormat();
    }
    _createClass(AsYouTypeFormatter, [
        {
            key: "resetFormat",
            value: function resetFormat() {
                this.chosenFormat = undefined;
                this.template = undefined;
                this.nationalNumberTemplate = undefined;
                this.populatedNationalNumberTemplate = undefined;
                this.populatedNationalNumberTemplatePosition = -1;
            }
        },
        {
            key: "reset",
            value: function reset(numberingPlan, state) {
                this.resetFormat();
                if (numberingPlan) {
                    this.isNANP = numberingPlan.callingCode() === '1';
                    this.matchingFormats = numberingPlan.formats();
                    if (state.nationalSignificantNumber) this.narrowDownMatchingFormats(state);
                } else {
                    this.isNANP = undefined;
                    this.matchingFormats = [];
                }
            }
        },
        {
            key: "format",
            value: function format(nextDigits, state) {
                var _this = this;
                // See if the phone number digits can be formatted as a complete phone number.
                // If not, use the results from `formatNationalNumberWithNextDigits()`,
                // which formats based on the chosen formatting pattern.
                //
                // Attempting to format complete phone number first is how it's done
                // in Google's `libphonenumber`, so this library just follows it.
                // Google's `libphonenumber` code doesn't explain in detail why does it
                // attempt to format digits as a complete phone number
                // instead of just going with a previoulsy (or newly) chosen `format`:
                //
                // "Checks to see if there is an exact pattern match for these digits.
                //  If so, we should use this instead of any other formatting template
                //  whose leadingDigitsPattern also matches the input."
                //
                if ((0, _asYouTypeFormatterCompleteJs.canFormatCompleteNumber)(state.nationalSignificantNumber, this.metadata)) for(var _iterator = _createForOfIteratorHelperLoose(this.matchingFormats), _step; !(_step = _iterator()).done;){
                    var format = _step.value;
                    var formattedCompleteNumber = (0, _asYouTypeFormatterCompleteJsDefault.default)(state, format, {
                        metadata: this.metadata,
                        shouldTryNationalPrefixFormattingRule: function shouldTryNationalPrefixFormattingRule(format) {
                            return _this.shouldTryNationalPrefixFormattingRule(format, {
                                international: state.international,
                                nationalPrefix: state.nationalPrefix
                            });
                        },
                        getSeparatorAfterNationalPrefix: function getSeparatorAfterNationalPrefix(format) {
                            return _this.getSeparatorAfterNationalPrefix(format);
                        }
                    });
                    if (formattedCompleteNumber) {
                        this.resetFormat();
                        this.chosenFormat = format;
                        this.setNationalNumberTemplate(formattedCompleteNumber.replace(/\d/g, (0, _asYouTypeFormatterUtilJs.DIGIT_PLACEHOLDER)), state);
                        this.populatedNationalNumberTemplate = formattedCompleteNumber; // With a new formatting template, the matched position
                        // using the old template needs to be reset.
                        this.populatedNationalNumberTemplatePosition = this.template.lastIndexOf((0, _asYouTypeFormatterUtilJs.DIGIT_PLACEHOLDER));
                        return formattedCompleteNumber;
                    }
                }
                 // Format the digits as a partial (incomplete) phone number
                // using the previously chosen formatting pattern (or a newly chosen one).
                return this.formatNationalNumberWithNextDigits(nextDigits, state);
            } // Formats the next phone number digits.
        },
        {
            key: "formatNationalNumberWithNextDigits",
            value: function formatNationalNumberWithNextDigits(nextDigits, state) {
                var previouslyChosenFormat = this.chosenFormat; // Choose a format from the list of matching ones.
                var newlyChosenFormat = this.chooseFormat(state);
                if (newlyChosenFormat) {
                    if (newlyChosenFormat === previouslyChosenFormat) // If it can format the next (current) digits
                    // using the previously chosen phone number format
                    // then return the updated formatted number.
                    return this.formatNextNationalNumberDigits(nextDigits);
                    else // If a more appropriate phone number format
                    // has been chosen for these "leading digits",
                    // then re-format the national phone number part
                    // using the newly selected format.
                    return this.formatNextNationalNumberDigits(state.getNationalDigits());
                }
            }
        },
        {
            key: "narrowDownMatchingFormats",
            value: function narrowDownMatchingFormats(_ref2) {
                var _this2 = this;
                var nationalSignificantNumber = _ref2.nationalSignificantNumber, nationalPrefix = _ref2.nationalPrefix, international = _ref2.international;
                var leadingDigits = nationalSignificantNumber; // "leading digits" pattern list starts with a
                // "leading digits" pattern fitting a maximum of 3 leading digits.
                // So, after a user inputs 3 digits of a national (significant) phone number
                // this national (significant) number can already be formatted.
                // The next "leading digits" pattern is for 4 leading digits max,
                // and the "leading digits" pattern after it is for 5 leading digits max, etc.
                // This implementation is different from Google's
                // in that it searches for a fitting format
                // even if the user has entered less than
                // `MIN_LEADING_DIGITS_LENGTH` digits of a national number.
                // Because some leading digit patterns already match for a single first digit.
                var leadingDigitsPatternIndex = leadingDigits.length - MIN_LEADING_DIGITS_LENGTH;
                if (leadingDigitsPatternIndex < 0) leadingDigitsPatternIndex = 0;
                this.matchingFormats = this.matchingFormats.filter(function(format) {
                    return _this2.formatSuits(format, international, nationalPrefix) && _this2.formatMatches(format, leadingDigits, leadingDigitsPatternIndex);
                }); // If there was a phone number format chosen
                // and it no longer holds given the new leading digits then reset it.
                // The test for this `if` condition is marked as:
                // "Reset a chosen format when it no longer holds given the new leading digits".
                // To construct a valid test case for this one can find a country
                // in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`
                // and yielding another format for 4 `<leadingDigits>` (Australia in this case).
                if (this.chosenFormat && this.matchingFormats.indexOf(this.chosenFormat) === -1) this.resetFormat();
            }
        },
        {
            key: "formatSuits",
            value: function formatSuits(format, international, nationalPrefix) {
                // When a prefix before a national (significant) number is
                // simply a national prefix, then it's parsed as `this.nationalPrefix`.
                // In more complex cases, a prefix before national (significant) number
                // could include a national prefix as well as some "capturing groups",
                // and in that case there's no info whether a national prefix has been parsed.
                // If national prefix is not used when formatting a phone number
                // using this format, but a national prefix has been entered by the user,
                // and was extracted, then discard such phone number format.
                // In Google's "AsYouType" formatter code, the equivalent would be this part:
                // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L175-L184
                if (nationalPrefix && !format.usesNationalPrefix() && // !format.domesticCarrierCodeFormattingRule() &&
                !format.nationalPrefixIsOptionalWhenFormattingInNationalFormat()) return false;
                 // If national prefix is mandatory for this phone number format
                // and there're no guarantees that a national prefix is present in user input
                // then discard this phone number format as not suitable.
                // In Google's "AsYouType" formatter code, the equivalent would be this part:
                // https://github.com/google/libphonenumber/blob/0a45cfd96e71cad8edb0e162a70fcc8bd9728933/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L185-L193
                if (!international && !nationalPrefix && format.nationalPrefixIsMandatoryWhenFormattingInNationalFormat()) return false;
                return true;
            }
        },
        {
            key: "formatMatches",
            value: function formatMatches(format, leadingDigits, leadingDigitsPatternIndex) {
                var leadingDigitsPatternsCount = format.leadingDigitsPatterns().length; // If this format is not restricted to a certain
                // leading digits pattern then it fits.
                // The test case could be found by searching for "leadingDigitsPatternsCount === 0".
                if (leadingDigitsPatternsCount === 0) return true;
                 // Start narrowing down the list of possible formats based on the leading digits.
                // (only previously matched formats take part in the narrowing down process)
                // `leading_digits_patterns` start with 3 digits min
                // and then go up from there one digit at a time.
                leadingDigitsPatternIndex = Math.min(leadingDigitsPatternIndex, leadingDigitsPatternsCount - 1);
                var leadingDigitsPattern = format.leadingDigitsPatterns()[leadingDigitsPatternIndex]; // Google imposes a requirement on the leading digits
                // to be minimum 3 digits long in order to be eligible
                // for checking those with a leading digits pattern.
                //
                // Since `leading_digits_patterns` start with 3 digits min,
                // Google's original `libphonenumber` library only starts
                // excluding any non-matching formats only when the
                // national number entered so far is at least 3 digits long,
                // otherwise format matching would give false negatives.
                //
                // For example, when the digits entered so far are `2`
                // and the leading digits pattern is `21` 
                // it's quite obvious in this case that the format could be the one
                // but due to the absence of further digits it would give false negative.
                //
                // Also, `leading_digits_patterns` doesn't always correspond to a single
                // digits count. For example, `60|8` pattern would already match `8`
                // but the `60` part would require having at least two leading digits,
                // so the whole pattern would require inputting two digits first in order to
                // decide on whether it matches the input, even when the input is "80".
                //
                // This library  `libphonenumber-js`  allows filtering by `leading_digits_patterns`
                // even when there's only 1 or 2 digits of the national (significant) number.
                // To do that, it uses a non-strict pattern matcher written specifically for that.
                //
                if (leadingDigits.length < MIN_LEADING_DIGITS_LENGTH) // Before leading digits < 3 matching was implemented:
                // return true
                //
                // After leading digits < 3 matching was implemented:
                try {
                    return new (0, _asYouTypeFormatterPatternMatcherJsDefault.default)(leadingDigitsPattern).match(leadingDigits, {
                        allowOverflow: true
                    }) !== undefined;
                } catch (error) /* istanbul ignore next */ {
                    // There's a slight possibility that there could be some undiscovered bug
                    // in the pattern matcher code. Since the "leading digits < 3 matching"
                    // feature is not "essential" for operation, it can fall back to the old way
                    // in case of any issues rather than halting the application's execution.
                    console.error(error);
                    return true;
                }
                 // If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are
                // available then use the usual regular expression matching.
                //
                // The whole pattern is wrapped in round brackets (`()`) because
                // the pattern can use "or" operator (`|`) at the top level of the pattern.
                //
                return new RegExp("^(".concat(leadingDigitsPattern, ")")).test(leadingDigits);
            }
        },
        {
            key: "getFormatFormat",
            value: function getFormatFormat(format, international) {
                return international ? format.internationalFormat() : format.format();
            }
        },
        {
            key: "chooseFormat",
            value: function chooseFormat(state) {
                var _this3 = this;
                var _loop = function _loop() {
                    var format = _step2.value;
                    // If this format is currently being used
                    // and is still suitable, then stick to it.
                    if (_this3.chosenFormat === format) return "break";
                     // Sometimes, a formatting rule inserts additional digits in a phone number,
                    // and "as you type" formatter can't do that: it should only use the digits
                    // that the user has input.
                    //
                    // For example, in Argentina, there's a format for mobile phone numbers:
                    //
                    // {
                    //    "pattern": "(\\d)(\\d{2})(\\d{4})(\\d{4})",
                    //    "leading_digits_patterns": ["91"],
                    //    "national_prefix_formatting_rule": "0$1",
                    //    "format": "$2 15-$3-$4",
                    //    "international_format": "$1 $2 $3-$4"
                    // }
                    //
                    // In that format, `international_format` is used instead of `format`
                    // because `format` inserts `15` in the formatted number,
                    // and `AsYouType` formatter should only use the digits
                    // the user has actually input, without adding any extra digits.
                    // In this case, it wouldn't make a difference, because the `15`
                    // is first stripped when applying `national_prefix_for_parsing`
                    // and then re-added when using `format`, so in reality it doesn't
                    // add any new digits to the number, but to detect that, the code
                    // would have to be more complex: it would have to try formatting
                    // the digits using the format and then see if any digits have
                    // actually been added or removed, and then, every time a new digit
                    // is input, it should re-check whether the chosen format doesn't
                    // alter the digits.
                    //
                    // Google's code doesn't go that far, and so does this library:
                    // it simply requires that a `format` doesn't add any additonal
                    // digits to user's input.
                    //
                    // Also, people in general should move from inputting phone numbers
                    // in national format (possibly with national prefixes)
                    // and use international phone number format instead:
                    // it's a logical thing in the modern age of mobile phones,
                    // globalization and the internet.
                    //
                    /* istanbul ignore if */ if (!NON_ALTERING_FORMAT_REG_EXP.test(_this3.getFormatFormat(format, state.international))) return "continue";
                    if (!_this3.createTemplateForFormat(format, state)) {
                        // Remove the format if it can't generate a template.
                        _this3.matchingFormats = _this3.matchingFormats.filter(function(_) {
                            return _ !== format;
                        });
                        return "continue";
                    }
                    _this3.chosenFormat = format;
                    return "break";
                };
                // When there are multiple available formats, the formatter uses the first
                // format where a formatting template could be created.
                //
                // For some weird reason, `istanbul` says "else path not taken"
                // for the `for of` line below. Supposedly that means that
                // the loop doesn't ever go over the last element in the list.
                // That's true because there always is `this.chosenFormat`
                // when `this.matchingFormats` is non-empty.
                // And, for some weird reason, it doesn't think that the case
                // with empty `this.matchingFormats` qualifies for a valid "else" path.
                // So simply muting this `istanbul` warning.
                // It doesn't skip the contents of the `for of` loop,
                // it just skips the `for of` line.
                //
                /* istanbul ignore next */ for(var _iterator2 = _createForOfIteratorHelperLoose(this.matchingFormats.slice()), _step2; !(_step2 = _iterator2()).done;){
                    var _ret = _loop();
                    if (_ret === "break") break;
                    if (_ret === "continue") continue;
                }
                if (!this.chosenFormat) // No format matches the national (significant) phone number.
                this.resetFormat();
                return this.chosenFormat;
            }
        },
        {
            key: "createTemplateForFormat",
            value: function createTemplateForFormat(format, state) {
                // The formatter doesn't format numbers when numberPattern contains '|', e.g.
                // (20|3)\d{4}. In those cases we quickly return.
                // (Though there's no such format in current metadata)
                /* istanbul ignore if */ if (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) return;
                 // Get formatting template for this phone number format
                var template = this.getTemplateForFormat(format, state); // If the national number entered is too long
                // for any phone number format, then abort.
                if (template) {
                    this.setNationalNumberTemplate(template, state);
                    return true;
                }
            }
        },
        {
            key: "getSeparatorAfterNationalPrefix",
            value: function getSeparatorAfterNationalPrefix(format) {
                // `US` metadata doesn't have a `national_prefix_formatting_rule`,
                // so the `if` condition below doesn't apply to `US`,
                // but in reality there shoudl be a separator
                // between a national prefix and a national (significant) number.
                // So `US` national prefix separator is a "special" "hardcoded" case.
                if (this.isNANP) return ' ';
                 // If a `format` has a `national_prefix_formatting_rule`
                // and that rule has a separator after a national prefix,
                // then it means that there should be a separator
                // between a national prefix and a national (significant) number.
                if (format && format.nationalPrefixFormattingRule() && NATIONAL_PREFIX_SEPARATORS_PATTERN.test(format.nationalPrefixFormattingRule())) return ' ';
                 // At this point, there seems to be no clear evidence that
                // there should be a separator between a national prefix
                // and a national (significant) number. So don't insert one.
                return '';
            }
        },
        {
            key: "getInternationalPrefixBeforeCountryCallingCode",
            value: function getInternationalPrefixBeforeCountryCallingCode(_ref3, options) {
                var IDDPrefix = _ref3.IDDPrefix, missingPlus = _ref3.missingPlus;
                if (IDDPrefix) return options && options.spacing === false ? IDDPrefix : IDDPrefix + ' ';
                if (missingPlus) return '';
                return '+';
            }
        },
        {
            key: "getTemplate",
            value: function getTemplate(state) {
                if (!this.template) return;
                 // `this.template` holds the template for a "complete" phone number.
                // The currently entered phone number is most likely not "complete",
                // so trim all non-populated digits.
                var index = -1;
                var i = 0;
                var internationalPrefix = state.international ? this.getInternationalPrefixBeforeCountryCallingCode(state, {
                    spacing: false
                }) : '';
                while(i < internationalPrefix.length + state.getDigitsWithoutInternationalPrefix().length){
                    index = this.template.indexOf((0, _asYouTypeFormatterUtilJs.DIGIT_PLACEHOLDER), index + 1);
                    i++;
                }
                return (0, _asYouTypeFormatterUtilJs.cutAndStripNonPairedParens)(this.template, index + 1);
            }
        },
        {
            key: "setNationalNumberTemplate",
            value: function setNationalNumberTemplate(template, state) {
                this.nationalNumberTemplate = template;
                this.populatedNationalNumberTemplate = template; // With a new formatting template, the matched position
                // using the old template needs to be reset.
                this.populatedNationalNumberTemplatePosition = -1; // For convenience, the public `.template` property
                // contains the whole international number
                // if the phone number being input is international:
                // 'x' for the '+' sign, 'x'es for the country phone code,
                // a spacebar and then the template for the formatted national number.
                if (state.international) this.template = this.getInternationalPrefixBeforeCountryCallingCode(state).replace(/[\d\+]/g, (0, _asYouTypeFormatterUtilJs.DIGIT_PLACEHOLDER)) + (0, _asYouTypeFormatterUtilJs.repeat)((0, _asYouTypeFormatterUtilJs.DIGIT_PLACEHOLDER), state.callingCode.length) + ' ' + template;
                else this.template = template;
            }
        },
        {
            key: "getTemplateForFormat",
            value: function getTemplateForFormat(format, _ref4) {
                var nationalSignificantNumber = _ref4.nationalSignificantNumber, international = _ref4.international, nationalPrefix = _ref4.nationalPrefix, complexPrefixBeforeNationalSignificantNumber = _ref4.complexPrefixBeforeNationalSignificantNumber;
                var pattern = format.pattern();
                /* istanbul ignore else */ if (SUPPORT_LEGACY_FORMATTING_PATTERNS) pattern = pattern // Replace anything in the form of [..] with \d
                .replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\d') // Replace any standalone digit (not the one in `{}`) with \d
                .replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\d');
                 // Generate a dummy national number (consisting of `9`s)
                // that fits this format's `pattern`.
                //
                // This match will always succeed,
                // because the "longest dummy phone number"
                // has enough length to accomodate any possible
                // national phone number format pattern.
                //
                var digits = LONGEST_DUMMY_PHONE_NUMBER.match(pattern)[0]; // If the national number entered is too long
                // for any phone number format, then abort.
                if (nationalSignificantNumber.length > digits.length) return;
                 // Get a formatting template which can be used to efficiently format
                // a partial number where digits are added one by one.
                // Below `strictPattern` is used for the
                // regular expression (with `^` and `$`).
                // This wasn't originally in Google's `libphonenumber`
                // and I guess they don't really need it
                // because they're not using "templates" to format phone numbers
                // but I added `strictPattern` after encountering
                // South Korean phone number formatting bug.
                //
                // Non-strict regular expression bug demonstration:
                //
                // this.nationalSignificantNumber : `111111111` (9 digits)
                //
                // pattern : (\d{2})(\d{3,4})(\d{4})
                // format : `$1 $2 $3`
                // digits : `9999999999` (10 digits)
                //
                // '9999999999'.replace(new RegExp(/(\d{2})(\d{3,4})(\d{4})/g), '$1 $2 $3') = "99 9999 9999"
                //
                // template : xx xxxx xxxx
                //
                // But the correct template in this case is `xx xxx xxxx`.
                // The template was generated incorrectly because of the
                // `{3,4}` variability in the `pattern`.
                //
                // The fix is, if `this.nationalSignificantNumber` has already sufficient length
                // to satisfy the `pattern` completely then `this.nationalSignificantNumber`
                // is used instead of `digits`.
                var strictPattern = new RegExp('^' + pattern + '$');
                var nationalNumberDummyDigits = nationalSignificantNumber.replace(/\d/g, DUMMY_DIGIT); // If `this.nationalSignificantNumber` has already sufficient length
                // to satisfy the `pattern` completely then use it
                // instead of `digits`.
                if (strictPattern.test(nationalNumberDummyDigits)) digits = nationalNumberDummyDigits;
                var numberFormat = this.getFormatFormat(format, international);
                var nationalPrefixIncludedInTemplate; // If a user did input a national prefix (and that's guaranteed),
                // and if a `format` does have a national prefix formatting rule,
                // then see if that national prefix formatting rule
                // prepends exactly the same national prefix the user has input.
                // If that's the case, then use the `format` with the national prefix formatting rule.
                // Otherwise, use  the `format` without the national prefix formatting rule,
                // and prepend a national prefix manually to it.
                if (this.shouldTryNationalPrefixFormattingRule(format, {
                    international: international,
                    nationalPrefix: nationalPrefix
                })) {
                    var numberFormatWithNationalPrefix = numberFormat.replace((0, _formatNationalNumberUsingFormatJs.FIRST_GROUP_PATTERN), format.nationalPrefixFormattingRule()); // If `national_prefix_formatting_rule` of a `format` simply prepends
                    // national prefix at the start of a national (significant) number,
                    // then such formatting can be used with `AsYouType` formatter.
                    // There seems to be no `else` case: everywhere in metadata,
                    // national prefix formatting rule is national prefix + $1,
                    // or `($1)`, in which case such format isn't even considered
                    // when the user has input a national prefix.
                    /* istanbul ignore else */ if ((0, _parseDigitsJsDefault.default)(format.nationalPrefixFormattingRule()) === (nationalPrefix || '') + (0, _parseDigitsJsDefault.default)('$1')) {
                        numberFormat = numberFormatWithNationalPrefix;
                        nationalPrefixIncludedInTemplate = true; // Replace all digits of the national prefix in the formatting template
                        // with `DIGIT_PLACEHOLDER`s.
                        if (nationalPrefix) {
                            var i = nationalPrefix.length;
                            while(i > 0){
                                numberFormat = numberFormat.replace(/\d/, (0, _asYouTypeFormatterUtilJs.DIGIT_PLACEHOLDER));
                                i--;
                            }
                        }
                    }
                } // Generate formatting template for this phone number format.
                var template = digits // Format the dummy phone number according to the format.
                .replace(new RegExp(pattern), numberFormat) // Replace each dummy digit with a DIGIT_PLACEHOLDER.
                .replace(new RegExp(DUMMY_DIGIT, 'g'), (0, _asYouTypeFormatterUtilJs.DIGIT_PLACEHOLDER)); // If a prefix of a national (significant) number is not as simple
                // as just a basic national prefix, then just prepend such prefix
                // before the national (significant) number, optionally spacing
                // the two with a whitespace.
                if (!nationalPrefixIncludedInTemplate) {
                    if (complexPrefixBeforeNationalSignificantNumber) // Prepend the prefix to the template manually.
                    template = (0, _asYouTypeFormatterUtilJs.repeat)((0, _asYouTypeFormatterUtilJs.DIGIT_PLACEHOLDER), complexPrefixBeforeNationalSignificantNumber.length) + ' ' + template;
                    else if (nationalPrefix) // Prepend national prefix to the template manually.
                    template = (0, _asYouTypeFormatterUtilJs.repeat)((0, _asYouTypeFormatterUtilJs.DIGIT_PLACEHOLDER), nationalPrefix.length) + this.getSeparatorAfterNationalPrefix(format) + template;
                }
                if (international) template = (0, _applyInternationalSeparatorStyleJsDefault.default)(template);
                return template;
            }
        },
        {
            key: "formatNextNationalNumberDigits",
            value: function formatNextNationalNumberDigits(digits) {
                var result = (0, _asYouTypeFormatterUtilJs.populateTemplateWithDigits)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition, digits);
                if (!result) {
                    // Reset the format.
                    this.resetFormat();
                    return;
                }
                this.populatedNationalNumberTemplate = result[0];
                this.populatedNationalNumberTemplatePosition = result[1]; // Return the formatted phone number so far.
                return (0, _asYouTypeFormatterUtilJs.cutAndStripNonPairedParens)(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1); // The old way which was good for `input-format` but is not so good
            // for `react-phone-number-input`'s default input (`InputBasic`).
            // return closeNonPairedParens(this.populatedNationalNumberTemplate, this.populatedNationalNumberTemplatePosition + 1)
            // 	.replace(new RegExp(DIGIT_PLACEHOLDER, 'g'), ' ')
            }
        },
        {
            key: "shouldTryNationalPrefixFormattingRule",
            value: function shouldTryNationalPrefixFormattingRule(format, _ref5) {
                var international = _ref5.international, nationalPrefix = _ref5.nationalPrefix;
                if (format.nationalPrefixFormattingRule()) {
                    // In some countries, `national_prefix_formatting_rule` is `($1)`,
                    // so it applies even if the user hasn't input a national prefix.
                    // `format.usesNationalPrefix()` detects such cases.
                    var usesNationalPrefix = format.usesNationalPrefix();
                    if (usesNationalPrefix && nationalPrefix || !usesNationalPrefix && !international) return true;
                }
            }
        }
    ]);
    return AsYouTypeFormatter;
}();

},{"./AsYouTypeFormatter.util.js":"3K1JY","./AsYouTypeFormatter.complete.js":"4NQIo","./AsYouTypeFormatter.PatternMatcher.js":"1BMp1","./helpers/parseDigits.js":"72H5y","./helpers/formatNationalNumberUsingFormat.js":"d2uis","./constants.js":"8uTTN","./helpers/applyInternationalSeparatorStyle.js":"9wS3s","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3K1JY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DIGIT_PLACEHOLDER", ()=>DIGIT_PLACEHOLDER);
// Unicode-unsafe (because using `.split()`).
parcelHelpers.export(exports, "countOccurences", ()=>countOccurences) // Repeats a string (or a symbol) N times.
;
// http://stackoverflow.com/questions/202605/repeat-string-javascript
parcelHelpers.export(exports, "repeat", ()=>repeat);
parcelHelpers.export(exports, "cutAndStripNonPairedParens", ()=>cutAndStripNonPairedParens);
parcelHelpers.export(exports, "closeNonPairedParens", ()=>closeNonPairedParens);
parcelHelpers.export(exports, "stripNonPairedParens", ()=>stripNonPairedParens);
parcelHelpers.export(exports, "populateTemplateWithDigits", ()=>populateTemplateWithDigits);
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
var DIGIT_PLACEHOLDER = 'x'; // '\u2008' (punctuation space)
var DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER); // Counts all occurences of a symbol in a string.
function countOccurences(symbol, string) {
    var count = 0; // Using `.split('')` to iterate through a string here
    // to avoid requiring `Symbol.iterator` polyfill.
    // `.split('')` is generally not safe for Unicode,
    // but in this particular case for counting brackets it is safe.
    // for (const character of string)
    for(var _iterator = _createForOfIteratorHelperLoose(string.split('')), _step; !(_step = _iterator()).done;){
        var character = _step.value;
        if (character === symbol) count++;
    }
    return count;
}
function repeat(string, times) {
    if (times < 1) return '';
    var result = '';
    while(times > 1){
        if (times & 1) result += string;
        times >>= 1;
        string += string;
    }
    return result + string;
}
function cutAndStripNonPairedParens(string, cutBeforeIndex) {
    if (string[cutBeforeIndex] === ')') cutBeforeIndex++;
    return stripNonPairedParens(string.slice(0, cutBeforeIndex));
}
function closeNonPairedParens(template, cut_before) {
    var retained_template = template.slice(0, cut_before);
    var opening_braces = countOccurences('(', retained_template);
    var closing_braces = countOccurences(')', retained_template);
    var dangling_braces = opening_braces - closing_braces;
    while(dangling_braces > 0 && cut_before < template.length){
        if (template[cut_before] === ')') dangling_braces--;
        cut_before++;
    }
    return template.slice(0, cut_before);
}
function stripNonPairedParens(string) {
    var dangling_braces = [];
    var i = 0;
    while(i < string.length){
        if (string[i] === '(') dangling_braces.push(i);
        else if (string[i] === ')') dangling_braces.pop();
        i++;
    }
    var start = 0;
    var cleared_string = '';
    dangling_braces.push(string.length);
    for(var _i = 0, _dangling_braces = dangling_braces; _i < _dangling_braces.length; _i++){
        var index = _dangling_braces[_i];
        cleared_string += string.slice(start, index);
        start = index + 1;
    }
    return cleared_string;
}
function populateTemplateWithDigits(template, position, digits) {
    // Using `.split('')` to iterate through a string here
    // to avoid requiring `Symbol.iterator` polyfill.
    // `.split('')` is generally not safe for Unicode,
    // but in this particular case for `digits` it is safe.
    // for (const digit of digits)
    for(var _iterator2 = _createForOfIteratorHelperLoose(digits.split('')), _step2; !(_step2 = _iterator2()).done;){
        var digit = _step2.value;
        // If there is room for more digits in current `template`,
        // then set the next digit in the `template`,
        // and return the formatted digits so far.
        // If more digits are entered than the current format could handle.
        if (template.slice(position + 1).search(DIGIT_PLACEHOLDER_MATCHER) < 0) return;
        position = template.search(DIGIT_PLACEHOLDER_MATCHER);
        template = template.replace(DIGIT_PLACEHOLDER_MATCHER, digit);
    }
    return [
        template,
        position
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4NQIo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>formatCompleteNumber);
parcelHelpers.export(exports, "canFormatCompleteNumber", ()=>canFormatCompleteNumber);
var _checkNumberLengthJs = require("./helpers/checkNumberLength.js");
var _checkNumberLengthJsDefault = parcelHelpers.interopDefault(_checkNumberLengthJs);
var _parseDigitsJs = require("./helpers/parseDigits.js");
var _parseDigitsJsDefault = parcelHelpers.interopDefault(_parseDigitsJs);
var _formatNationalNumberUsingFormatJs = require("./helpers/formatNationalNumberUsingFormat.js");
var _formatNationalNumberUsingFormatJsDefault = parcelHelpers.interopDefault(_formatNationalNumberUsingFormatJs);
function formatCompleteNumber(state, format, _ref) {
    var metadata = _ref.metadata, shouldTryNationalPrefixFormattingRule = _ref.shouldTryNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref.getSeparatorAfterNationalPrefix;
    var matcher = new RegExp("^(?:".concat(format.pattern(), ")$"));
    if (matcher.test(state.nationalSignificantNumber)) return formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, {
        metadata: metadata,
        shouldTryNationalPrefixFormattingRule: shouldTryNationalPrefixFormattingRule,
        getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix
    });
}
function canFormatCompleteNumber(nationalSignificantNumber, metadata) {
    return (0, _checkNumberLengthJsDefault.default)(nationalSignificantNumber, metadata) === 'IS_POSSIBLE';
}
function formatNationalNumberWithAndWithoutNationalPrefixFormattingRule(state, format, _ref2) {
    var metadata = _ref2.metadata, shouldTryNationalPrefixFormattingRule = _ref2.shouldTryNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref2.getSeparatorAfterNationalPrefix;
    // `format` has already been checked for `nationalPrefix` requirement.
    var nationalSignificantNumber = state.nationalSignificantNumber, international = state.international, nationalPrefix = state.nationalPrefix, carrierCode = state.carrierCode; // Format the number with using `national_prefix_formatting_rule`.
    // If the resulting formatted number is a valid formatted number, then return it.
    //
    // Google's AsYouType formatter is different in a way that it doesn't try
    // to format using the "national prefix formatting rule", and instead it
    // simply prepends a national prefix followed by a " " character.
    // This code does that too, but as a fallback.
    // The reason is that "national prefix formatting rule" may use parentheses,
    // which wouldn't be included has it used the simpler Google's way.
    //
    if (shouldTryNationalPrefixFormattingRule(format)) {
        var formattedNumber = formatNationalNumber(state, format, {
            useNationalPrefixFormattingRule: true,
            getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix,
            metadata: metadata
        });
        if (formattedNumber) return formattedNumber;
    } // Format the number without using `national_prefix_formatting_rule`.
    return formatNationalNumber(state, format, {
        useNationalPrefixFormattingRule: false,
        getSeparatorAfterNationalPrefix: getSeparatorAfterNationalPrefix,
        metadata: metadata
    });
}
function formatNationalNumber(state, format, _ref3) {
    var metadata = _ref3.metadata, useNationalPrefixFormattingRule = _ref3.useNationalPrefixFormattingRule, getSeparatorAfterNationalPrefix = _ref3.getSeparatorAfterNationalPrefix;
    var formattedNationalNumber = (0, _formatNationalNumberUsingFormatJsDefault.default)(state.nationalSignificantNumber, format, {
        carrierCode: state.carrierCode,
        useInternationalFormat: state.international,
        withNationalPrefix: useNationalPrefixFormattingRule,
        metadata: metadata
    });
    if (!useNationalPrefixFormattingRule) {
        if (state.nationalPrefix) // If a national prefix was extracted, then just prepend it,
        // followed by a " " character.
        formattedNationalNumber = state.nationalPrefix + getSeparatorAfterNationalPrefix(format) + formattedNationalNumber;
        else if (state.complexPrefixBeforeNationalSignificantNumber) formattedNationalNumber = state.complexPrefixBeforeNationalSignificantNumber + ' ' + formattedNationalNumber;
    }
    if (isValidFormattedNationalNumber(formattedNationalNumber, state)) return formattedNationalNumber;
} // Check that the formatted phone number contains exactly
// the same digits that have been input by the user.
// For example, when "0111523456789" is input for `AR` country,
// the extracted `this.nationalSignificantNumber` is "91123456789",
// which means that the national part of `this.digits` isn't simply equal to
// `this.nationalPrefix` + `this.nationalSignificantNumber`.
//
// Also, a `format` can add extra digits to the `this.nationalSignificantNumber`
// being formatted via `metadata[country].national_prefix_transform_rule`.
// For example, for `VI` country, it prepends `340` to the national number,
// and if this check hasn't been implemented, then there would be a bug
// when `340` "area coude" is "duplicated" during input for `VI` country:
// https://github.com/catamphetamine/libphonenumber-js/issues/318
//
// So, all these "gotchas" are filtered out.
//
// In the original Google's code, the comments say:
// "Check that we didn't remove nor add any extra digits when we matched
// this formatting pattern. This usually happens after we entered the last
// digit during AYTF. Eg: In case of MX, we swallow mobile token (1) when
// formatted but AYTF should retain all the number entered and not change
// in order to match a format (of same leading digits and length) display
// in that way."
// "If it's the same (i.e entered number and format is same), then it's
// safe to return this in formatted number as nothing is lost / added."
// Otherwise, don't use this format.
// https://github.com/google/libphonenumber/commit/3e7c1f04f5e7200f87fb131e6f85c6e99d60f510#diff-9149457fa9f5d608a11bb975c6ef4bc5
// https://github.com/google/libphonenumber/commit/3ac88c7106e7dcb553bcc794b15f19185928a1c6#diff-2dcb77e833422ee304da348b905cde0b
//
function isValidFormattedNationalNumber(formattedNationalNumber, state) {
    return (0, _parseDigitsJsDefault.default)(formattedNationalNumber) === state.getNationalDigits();
}

},{"./helpers/checkNumberLength.js":"4xVnQ","./helpers/parseDigits.js":"72H5y","./helpers/formatNationalNumberUsingFormat.js":"d2uis","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1BMp1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Matches `characters` against a pattern compiled into a `tree`.
 * @param  {string[]} characters
 * @param  {Tree} tree  A pattern compiled into a `tree`. See the `*.d.ts` file for the description of the `tree` structure.
 * @param  {boolean} last  Whether it's the last (rightmost) subtree on its level of the match tree.
 * @return {object} See the `*.d.ts` file for the description of the result object.
 */ parcelHelpers.export(exports, "default", ()=>PatternMatcher);
var _asYouTypeFormatterPatternParserJs = require("./AsYouTypeFormatter.PatternParser.js");
var _asYouTypeFormatterPatternParserJsDefault = parcelHelpers.interopDefault(_asYouTypeFormatterPatternParserJs);
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
var PatternMatcher = /*#__PURE__*/ function() {
    function PatternMatcher(pattern) {
        _classCallCheck(this, PatternMatcher);
        this.matchTree = new (0, _asYouTypeFormatterPatternParserJsDefault.default)().parse(pattern);
    }
    _createClass(PatternMatcher, [
        {
            key: "match",
            value: function match(string) {
                var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, allowOverflow = _ref.allowOverflow;
                if (!string) throw new Error('String is required');
                var result = _match(string.split(''), this.matchTree, true);
                if (result && result.match) delete result.matchedChars;
                if (result && result.overflow) {
                    if (!allowOverflow) return;
                }
                return result;
            }
        }
    ]);
    return PatternMatcher;
}();
function _match(characters, tree, last) {
    // If `tree` is a string, then `tree` is a single character.
    // That's because when a pattern is parsed, multi-character-string parts
    // of a pattern are compiled into arrays of single characters.
    // I still wrote this piece of code for a "general" hypothetical case
    // when `tree` could be a string of several characters, even though
    // such case is not possible with the current implementation.
    if (typeof tree === 'string') {
        var characterString = characters.join('');
        if (tree.indexOf(characterString) === 0) {
            // `tree` is always a single character.
            // If `tree.indexOf(characterString) === 0`
            // then `characters.length === tree.length`.
            /* istanbul ignore else */ if (characters.length === tree.length) return {
                match: true,
                matchedChars: characters
            };
             // `tree` is always a single character.
            // If `tree.indexOf(characterString) === 0`
            // then `characters.length === tree.length`.
            /* istanbul ignore next */ return {
                partialMatch: true // matchedChars: characters
            };
        }
        if (characterString.indexOf(tree) === 0) {
            if (last) {
                // The `else` path is not possible because `tree` is always a single character.
                // The `else` case for `characters.length > tree.length` would be
                // `characters.length <= tree.length` which means `characters.length <= 1`.
                // `characters` array can't be empty, so that means `characters === [tree]`,
                // which would also mean `tree.indexOf(characterString) === 0` and that'd mean
                // that the `if (tree.indexOf(characterString) === 0)` condition before this
                // `if` condition would be entered, and returned from there, not reaching this code.
                /* istanbul ignore else */ if (characters.length > tree.length) return {
                    overflow: true
                };
            }
            return {
                match: true,
                matchedChars: characters.slice(0, tree.length)
            };
        }
        return;
    }
    if (Array.isArray(tree)) {
        var restCharacters = characters.slice();
        var i = 0;
        while(i < tree.length){
            var subtree = tree[i];
            var result = _match(restCharacters, subtree, last && i === tree.length - 1);
            if (!result) return;
            else if (result.overflow) return result;
            else if (result.match) {
                // Continue with the next subtree with the rest of the characters.
                restCharacters = restCharacters.slice(result.matchedChars.length);
                if (restCharacters.length === 0) {
                    if (i === tree.length - 1) return {
                        match: true,
                        matchedChars: characters
                    };
                    else return {
                        partialMatch: true // matchedChars: characters
                    };
                }
            } else {
                /* istanbul ignore else */ if (result.partialMatch) return {
                    partialMatch: true // matchedChars: characters
                };
                else throw new Error("Unsupported match result:\n".concat(JSON.stringify(result, null, 2)));
            }
            i++;
        } // If `last` then overflow has already been checked
        // by the last element of the `tree` array.
        /* istanbul ignore if */ if (last) return {
            overflow: true
        };
        return {
            match: true,
            matchedChars: characters.slice(0, characters.length - restCharacters.length)
        };
    }
    switch(tree.op){
        case '|':
            var partialMatch;
            for(var _iterator = _createForOfIteratorHelperLoose(tree.args), _step; !(_step = _iterator()).done;){
                var branch = _step.value;
                var _result = _match(characters, branch, last);
                if (_result) {
                    if (_result.overflow) return _result;
                    else if (_result.match) return {
                        match: true,
                        matchedChars: _result.matchedChars
                    };
                    else {
                        /* istanbul ignore else */ if (_result.partialMatch) partialMatch = true;
                        else throw new Error("Unsupported match result:\n".concat(JSON.stringify(_result, null, 2)));
                    }
                }
            }
            if (partialMatch) return {
                partialMatch: true // matchedChars: ...
            };
             // Not even a partial match.
            return;
        case '[]':
            for(var _iterator2 = _createForOfIteratorHelperLoose(tree.args), _step2; !(_step2 = _iterator2()).done;){
                var _char = _step2.value;
                if (characters[0] === _char) {
                    if (characters.length === 1) return {
                        match: true,
                        matchedChars: characters
                    };
                    if (last) return {
                        overflow: true
                    };
                    return {
                        match: true,
                        matchedChars: [
                            _char
                        ]
                    };
                }
            } // No character matches.
            return;
        /* istanbul ignore next */ default:
            throw new Error("Unsupported instruction tree: ".concat(tree));
    }
}

},{"./AsYouTypeFormatter.PatternParser.js":"jXvLU","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jXvLU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>PatternParser);
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
var PatternParser = /*#__PURE__*/ function() {
    function PatternParser() {
        _classCallCheck(this, PatternParser);
    }
    _createClass(PatternParser, [
        {
            key: "parse",
            value: function parse(pattern) {
                this.context = [
                    {
                        or: true,
                        instructions: []
                    }
                ];
                this.parsePattern(pattern);
                if (this.context.length !== 1) throw new Error('Non-finalized contexts left when pattern parse ended');
                var _this$context$ = this.context[0], branches = _this$context$.branches, instructions = _this$context$.instructions;
                if (branches) return {
                    op: '|',
                    args: branches.concat([
                        expandSingleElementArray(instructions)
                    ])
                };
                /* istanbul ignore if */ if (instructions.length === 0) throw new Error('Pattern is required');
                if (instructions.length === 1) return instructions[0];
                return instructions;
            }
        },
        {
            key: "startContext",
            value: function startContext(context) {
                this.context.push(context);
            }
        },
        {
            key: "endContext",
            value: function endContext() {
                this.context.pop();
            }
        },
        {
            key: "getContext",
            value: function getContext() {
                return this.context[this.context.length - 1];
            }
        },
        {
            key: "parsePattern",
            value: function parsePattern(pattern) {
                if (!pattern) throw new Error('Pattern is required');
                var match = pattern.match(OPERATOR);
                if (!match) {
                    if (ILLEGAL_CHARACTER_REGEXP.test(pattern)) throw new Error("Illegal characters found in a pattern: ".concat(pattern));
                    this.getContext().instructions = this.getContext().instructions.concat(pattern.split(''));
                    return;
                }
                var operator = match[1];
                var before = pattern.slice(0, match.index);
                var rightPart = pattern.slice(match.index + operator.length);
                switch(operator){
                    case '(?:':
                        if (before) this.parsePattern(before);
                        this.startContext({
                            or: true,
                            instructions: [],
                            branches: []
                        });
                        break;
                    case ')':
                        if (!this.getContext().or) throw new Error('")" operator must be preceded by "(?:" operator');
                        if (before) this.parsePattern(before);
                        if (this.getContext().instructions.length === 0) throw new Error('No instructions found after "|" operator in an "or" group');
                        var _this$getContext = this.getContext(), branches = _this$getContext.branches;
                        branches.push(expandSingleElementArray(this.getContext().instructions));
                        this.endContext();
                        this.getContext().instructions.push({
                            op: '|',
                            args: branches
                        });
                        break;
                    case '|':
                        if (!this.getContext().or) throw new Error('"|" operator can only be used inside "or" groups');
                        if (before) this.parsePattern(before);
                         // The top-level is an implicit "or" group, if required.
                        if (!this.getContext().branches) {
                            // `branches` are not defined only for the root implicit "or" operator.
                            /* istanbul ignore else */ if (this.context.length === 1) this.getContext().branches = [];
                            else throw new Error('"branches" not found in an "or" group context');
                        }
                        this.getContext().branches.push(expandSingleElementArray(this.getContext().instructions));
                        this.getContext().instructions = [];
                        break;
                    case '[':
                        if (before) this.parsePattern(before);
                        this.startContext({
                            oneOfSet: true
                        });
                        break;
                    case ']':
                        if (!this.getContext().oneOfSet) throw new Error('"]" operator must be preceded by "[" operator');
                        this.endContext();
                        this.getContext().instructions.push({
                            op: '[]',
                            args: parseOneOfSet(before)
                        });
                        break;
                    /* istanbul ignore next */ default:
                        throw new Error("Unknown operator: ".concat(operator));
                }
                if (rightPart) this.parsePattern(rightPart);
            }
        }
    ]);
    return PatternParser;
}();
function parseOneOfSet(pattern) {
    var values = [];
    var i = 0;
    while(i < pattern.length){
        if (pattern[i] === '-') {
            if (i === 0 || i === pattern.length - 1) throw new Error("Couldn't parse a one-of set pattern: ".concat(pattern));
            var prevValue = pattern[i - 1].charCodeAt(0) + 1;
            var nextValue = pattern[i + 1].charCodeAt(0) - 1;
            var value = prevValue;
            while(value <= nextValue){
                values.push(String.fromCharCode(value));
                value++;
            }
        } else values.push(pattern[i]);
        i++;
    }
    return values;
}
var ILLEGAL_CHARACTER_REGEXP = /[\(\)\[\]\?\:\|]/;
var OPERATOR = new RegExp("(\\||\\(\\?\\:|\\)|\\[|\\])");
function expandSingleElementArray(array) {
    if (array.length === 1) return array[0];
    return array;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c2YJs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Extracts formatted phone number from text (if there's any).
 * @param  {string} text
 * @return {string} [formattedPhoneNumber]
 */ parcelHelpers.export(exports, "default", ()=>AsYouTypeParser);
/**
 * Extracts formatted phone number digits (and a `+`) from text (if there're any).
 * @param  {string} text
 * @return {any[]}
 */ parcelHelpers.export(exports, "extractFormattedDigitsAndPlus", ()=>extractFormattedDigitsAndPlus);
var _extractCountryCallingCodeJs = require("./helpers/extractCountryCallingCode.js");
var _extractCountryCallingCodeJsDefault = parcelHelpers.interopDefault(_extractCountryCallingCodeJs);
var _extractCountryCallingCodeFromInternationalNumberWithoutPlusSignJs = require("./helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js");
var _extractCountryCallingCodeFromInternationalNumberWithoutPlusSignJsDefault = parcelHelpers.interopDefault(_extractCountryCallingCodeFromInternationalNumberWithoutPlusSignJs);
var _extractNationalNumberFromPossiblyIncompleteNumberJs = require("./helpers/extractNationalNumberFromPossiblyIncompleteNumber.js");
var _extractNationalNumberFromPossiblyIncompleteNumberJsDefault = parcelHelpers.interopDefault(_extractNationalNumberFromPossiblyIncompleteNumberJs);
var _stripIddPrefixJs = require("./helpers/stripIddPrefix.js");
var _stripIddPrefixJsDefault = parcelHelpers.interopDefault(_stripIddPrefixJs);
var _parseDigitsJs = require("./helpers/parseDigits.js");
var _parseDigitsJsDefault = parcelHelpers.interopDefault(_parseDigitsJs);
var _constantsJs = require("./constants.js");
function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
var VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART = '[' + (0, _constantsJs.VALID_PUNCTUATION) + (0, _constantsJs.VALID_DIGITS) + ']+';
var VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN = new RegExp('^' + VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART + '$', 'i');
var VALID_FORMATTED_PHONE_NUMBER_PART = "(?:[" + (0, _constantsJs.PLUS_CHARS) + ']' + '[' + (0, _constantsJs.VALID_PUNCTUATION) + (0, _constantsJs.VALID_DIGITS) + ']*' + '|' + '[' + (0, _constantsJs.VALID_PUNCTUATION) + (0, _constantsJs.VALID_DIGITS) + ']+' + ')';
var AFTER_PHONE_NUMBER_DIGITS_END_PATTERN = new RegExp('[^' + (0, _constantsJs.VALID_PUNCTUATION) + (0, _constantsJs.VALID_DIGITS) + ']+' + '.*' + '$'); // Tests whether `national_prefix_for_parsing` could match
// different national prefixes.
// Matches anything that's not a digit or a square bracket.
var COMPLEX_NATIONAL_PREFIX = /[^\d\[\]]/;
var AsYouTypeParser = /*#__PURE__*/ function() {
    function AsYouTypeParser(_ref) {
        var defaultCountry = _ref.defaultCountry, defaultCallingCode = _ref.defaultCallingCode, metadata = _ref.metadata, onNationalSignificantNumberChange = _ref.onNationalSignificantNumberChange;
        _classCallCheck(this, AsYouTypeParser);
        this.defaultCountry = defaultCountry;
        this.defaultCallingCode = defaultCallingCode;
        this.metadata = metadata;
        this.onNationalSignificantNumberChange = onNationalSignificantNumberChange;
    }
    _createClass(AsYouTypeParser, [
        {
            key: "input",
            value: function input(text, state) {
                var _extractFormattedDigi = extractFormattedDigitsAndPlus(text), _extractFormattedDigi2 = _slicedToArray(_extractFormattedDigi, 2), formattedDigits = _extractFormattedDigi2[0], hasPlus = _extractFormattedDigi2[1];
                var digits = (0, _parseDigitsJsDefault.default)(formattedDigits); // Checks for a special case: just a leading `+` has been entered.
                var justLeadingPlus;
                if (hasPlus) {
                    if (!state.digits) {
                        state.startInternationalNumber();
                        if (!digits) justLeadingPlus = true;
                    }
                }
                if (digits) this.inputDigits(digits, state);
                return {
                    digits: digits,
                    justLeadingPlus: justLeadingPlus
                };
            }
        },
        {
            key: "inputDigits",
            value: function inputDigits(nextDigits, state) {
                var digits = state.digits;
                var hasReceivedThreeLeadingDigits = digits.length < 3 && digits.length + nextDigits.length >= 3; // Append phone number digits.
                state.appendDigits(nextDigits); // Attempt to extract IDD prefix:
                // Some users input their phone number in international format,
                // but in an "out-of-country" dialing format instead of using the leading `+`.
                // https://github.com/catamphetamine/libphonenumber-js/issues/185
                // Detect such numbers as soon as there're at least 3 digits.
                // Google's library attempts to extract IDD prefix at 3 digits,
                // so this library just copies that behavior.
                // I guess that's because the most commot IDD prefixes are
                // `00` (Europe) and `011` (US).
                // There exist really long IDD prefixes too:
                // for example, in Australia the default IDD prefix is `0011`,
                // and it could even be as long as `14880011`.
                // An IDD prefix is extracted here, and then every time when
                // there's a new digit and the number couldn't be formatted.
                if (hasReceivedThreeLeadingDigits) this.extractIddPrefix(state);
                if (this.isWaitingForCountryCallingCode(state)) {
                    if (!this.extractCountryCallingCode(state)) return;
                } else state.appendNationalSignificantNumberDigits(nextDigits);
                 // If a phone number is being input in international format,
                // then it's not valid for it to have a national prefix.
                // Still, some people incorrectly input such numbers with a national prefix.
                // In such cases, only attempt to strip a national prefix if the number becomes too long.
                // (but that is done later, not here)
                if (!state.international) {
                    if (!this.hasExtractedNationalSignificantNumber) this.extractNationalSignificantNumber(state.getNationalDigits(), function(stateUpdate) {
                        return state.update(stateUpdate);
                    });
                }
            }
        },
        {
            key: "isWaitingForCountryCallingCode",
            value: function isWaitingForCountryCallingCode(_ref2) {
                var international = _ref2.international, callingCode = _ref2.callingCode;
                return international && !callingCode;
            } // Extracts a country calling code from a number
        },
        {
            key: "extractCountryCallingCode",
            value: function extractCountryCallingCode(state) {
                var _extractCountryCallin = (0, _extractCountryCallingCodeJsDefault.default)('+' + state.getDigitsWithoutInternationalPrefix(), this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), countryCallingCode = _extractCountryCallin.countryCallingCode, number = _extractCountryCallin.number;
                if (countryCallingCode) {
                    state.setCallingCode(countryCallingCode);
                    state.update({
                        nationalSignificantNumber: number
                    });
                    return true;
                }
            }
        },
        {
            key: "reset",
            value: function reset(numberingPlan) {
                if (numberingPlan) {
                    this.hasSelectedNumberingPlan = true;
                    var nationalPrefixForParsing = numberingPlan._nationalPrefixForParsing();
                    this.couldPossiblyExtractAnotherNationalSignificantNumber = nationalPrefixForParsing && COMPLEX_NATIONAL_PREFIX.test(nationalPrefixForParsing);
                } else {
                    this.hasSelectedNumberingPlan = undefined;
                    this.couldPossiblyExtractAnotherNationalSignificantNumber = undefined;
                }
            }
        },
        {
            key: "extractNationalSignificantNumber",
            value: function extractNationalSignificantNumber(nationalDigits, setState) {
                if (!this.hasSelectedNumberingPlan) return;
                var _extractNationalNumbe = (0, _extractNationalNumberFromPossiblyIncompleteNumberJsDefault.default)(nationalDigits, this.metadata), nationalPrefix = _extractNationalNumbe.nationalPrefix, nationalNumber = _extractNationalNumbe.nationalNumber, carrierCode = _extractNationalNumbe.carrierCode;
                if (nationalNumber === nationalDigits) return;
                this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);
                return true;
            }
        },
        {
            key: "extractAnotherNationalSignificantNumber",
            value: function extractAnotherNationalSignificantNumber(nationalDigits, prevNationalSignificantNumber, setState) {
                if (!this.hasExtractedNationalSignificantNumber) return this.extractNationalSignificantNumber(nationalDigits, setState);
                if (!this.couldPossiblyExtractAnotherNationalSignificantNumber) return;
                var _extractNationalNumbe2 = (0, _extractNationalNumberFromPossiblyIncompleteNumberJsDefault.default)(nationalDigits, this.metadata), nationalPrefix = _extractNationalNumbe2.nationalPrefix, nationalNumber = _extractNationalNumbe2.nationalNumber, carrierCode = _extractNationalNumbe2.carrierCode; // If a national prefix has been extracted previously,
                // then it's always extracted as additional digits are added.
                // That's assuming `extractNationalNumberFromPossiblyIncompleteNumber()`
                // doesn't do anything different from what it currently does.
                // So, just in case, here's this check, though it doesn't occur.
                /* istanbul ignore if */ if (nationalNumber === prevNationalSignificantNumber) return;
                this.onExtractedNationalNumber(nationalPrefix, carrierCode, nationalNumber, nationalDigits, setState);
                return true;
            }
        },
        {
            key: "onExtractedNationalNumber",
            value: function onExtractedNationalNumber(nationalPrefix, carrierCode, nationalSignificantNumber, nationalDigits, setState) {
                var complexPrefixBeforeNationalSignificantNumber;
                var nationalSignificantNumberMatchesInput; // This check also works with empty `this.nationalSignificantNumber`.
                var nationalSignificantNumberIndex = nationalDigits.lastIndexOf(nationalSignificantNumber); // If the extracted national (significant) number is the
                // last substring of the `digits`, then it means that it hasn't been altered:
                // no digits have been removed from the national (significant) number
                // while applying `national_prefix_transform_rule`.
                // https://gitlab.com/catamphetamine/libphonenumber-js/-/blob/master/METADATA.md#national_prefix_for_parsing--national_prefix_transform_rule
                if (nationalSignificantNumberIndex >= 0 && nationalSignificantNumberIndex === nationalDigits.length - nationalSignificantNumber.length) {
                    nationalSignificantNumberMatchesInput = true; // If a prefix of a national (significant) number is not as simple
                    // as just a basic national prefix, then such prefix is stored in
                    // `this.complexPrefixBeforeNationalSignificantNumber` property and will be
                    // prepended "as is" to the national (significant) number to produce
                    // a formatted result.
                    var prefixBeforeNationalNumber = nationalDigits.slice(0, nationalSignificantNumberIndex); // `prefixBeforeNationalNumber` is always non-empty,
                    // because `onExtractedNationalNumber()` isn't called
                    // when a national (significant) number hasn't been actually "extracted":
                    // when a national (significant) number is equal to the national part of `digits`,
                    // then `onExtractedNationalNumber()` doesn't get called.
                    if (prefixBeforeNationalNumber !== nationalPrefix) complexPrefixBeforeNationalSignificantNumber = prefixBeforeNationalNumber;
                }
                setState({
                    nationalPrefix: nationalPrefix,
                    carrierCode: carrierCode,
                    nationalSignificantNumber: nationalSignificantNumber,
                    nationalSignificantNumberMatchesInput: nationalSignificantNumberMatchesInput,
                    complexPrefixBeforeNationalSignificantNumber: complexPrefixBeforeNationalSignificantNumber
                }); // `onExtractedNationalNumber()` is only called when
                // the national (significant) number actually did change.
                this.hasExtractedNationalSignificantNumber = true;
                this.onNationalSignificantNumberChange();
            }
        },
        {
            key: "reExtractNationalSignificantNumber",
            value: function reExtractNationalSignificantNumber(state) {
                // Attempt to extract a national prefix.
                //
                // Some people incorrectly input national prefix
                // in an international phone number.
                // For example, some people write British phone numbers as `+44(0)...`.
                //
                // Also, in some rare cases, it is valid for a national prefix
                // to be a part of an international phone number.
                // For example, mobile phone numbers in Mexico are supposed to be
                // dialled internationally using a `1` national prefix,
                // so the national prefix will be part of an international number.
                //
                // Quote from:
                // https://www.mexperience.com/dialing-cell-phones-in-mexico/
                //
                // "Dialing a Mexican cell phone from abroad
                // When you are calling a cell phone number in Mexico from outside Mexico,
                // its necessary to dial an additional 1 after Mexicos country code
                // (which is 52) and before the area code.
                // You also ignore the 045, and simply dial the area code and the
                // cell phones number.
                //
                // If you dont add the 1, youll receive a recorded announcement
                // asking you to redial using it.
                //
                // For example, if you are calling from the USA to a cell phone
                // in Mexico City, you would dial +52  1  55  1234 5678.
                // (Note that this is different to calling a land line in Mexico City
                // from abroad, where the number dialed would be +52  55  1234 5678)".
                //
                // Google's demo output:
                // https://libphonenumber.appspot.com/phonenumberparser?number=%2b5215512345678&country=MX
                //
                if (this.extractAnotherNationalSignificantNumber(state.getNationalDigits(), state.nationalSignificantNumber, function(stateUpdate) {
                    return state.update(stateUpdate);
                })) return true;
                 // If no format matches the phone number, then it could be
                // "a really long IDD" (quote from a comment in Google's library).
                // An IDD prefix is first extracted when the user has entered at least 3 digits,
                // and then here  every time when there's a new digit and the number
                // couldn't be formatted.
                // For example, in Australia the default IDD prefix is `0011`,
                // and it could even be as long as `14880011`.
                //
                // Could also check `!hasReceivedThreeLeadingDigits` here
                // to filter out the case when this check duplicates the one
                // already performed when there're 3 leading digits,
                // but it's not a big deal, and in most cases there
                // will be a suitable `format` when there're 3 leading digits.
                //
                if (this.extractIddPrefix(state)) {
                    this.extractCallingCodeAndNationalSignificantNumber(state);
                    return true;
                } // Google's AsYouType formatter supports sort of an "autocorrection" feature
                // when it "autocorrects" numbers that have been input for a country
                // with that country's calling code.
                // Such "autocorrection" feature looks weird, but different people have been requesting it:
                // https://github.com/catamphetamine/libphonenumber-js/issues/376
                // https://github.com/catamphetamine/libphonenumber-js/issues/375
                // https://github.com/catamphetamine/libphonenumber-js/issues/316
                if (this.fixMissingPlus(state)) {
                    this.extractCallingCodeAndNationalSignificantNumber(state);
                    return true;
                }
            }
        },
        {
            key: "extractIddPrefix",
            value: function extractIddPrefix(state) {
                // An IDD prefix can't be present in a number written with a `+`.
                // Also, don't re-extract an IDD prefix if has already been extracted.
                var international = state.international, IDDPrefix = state.IDDPrefix, digits = state.digits, nationalSignificantNumber = state.nationalSignificantNumber;
                if (international || IDDPrefix) return;
                 // Some users input their phone number in "out-of-country"
                // dialing format instead of using the leading `+`.
                // https://github.com/catamphetamine/libphonenumber-js/issues/185
                // Detect such numbers.
                var numberWithoutIDD = (0, _stripIddPrefixJsDefault.default)(digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata);
                if (numberWithoutIDD !== undefined && numberWithoutIDD !== digits) {
                    // If an IDD prefix was stripped then convert the IDD-prefixed number
                    // to international number for subsequent parsing.
                    state.update({
                        IDDPrefix: digits.slice(0, digits.length - numberWithoutIDD.length)
                    });
                    this.startInternationalNumber(state, {
                        country: undefined,
                        callingCode: undefined
                    });
                    return true;
                }
            }
        },
        {
            key: "fixMissingPlus",
            value: function fixMissingPlus(state) {
                if (!state.international) {
                    var _extractCountryCallin2 = (0, _extractCountryCallingCodeFromInternationalNumberWithoutPlusSignJsDefault.default)(state.digits, this.defaultCountry, this.defaultCallingCode, this.metadata.metadata), newCallingCode = _extractCountryCallin2.countryCallingCode, number = _extractCountryCallin2.number;
                    if (newCallingCode) {
                        state.update({
                            missingPlus: true
                        });
                        this.startInternationalNumber(state, {
                            country: state.country,
                            callingCode: newCallingCode
                        });
                        return true;
                    }
                }
            }
        },
        {
            key: "startInternationalNumber",
            value: function startInternationalNumber(state, _ref3) {
                var country = _ref3.country, callingCode = _ref3.callingCode;
                state.startInternationalNumber(country, callingCode); // If a national (significant) number has been extracted before, reset it.
                if (state.nationalSignificantNumber) {
                    state.resetNationalSignificantNumber();
                    this.onNationalSignificantNumberChange();
                    this.hasExtractedNationalSignificantNumber = undefined;
                }
            }
        },
        {
            key: "extractCallingCodeAndNationalSignificantNumber",
            value: function extractCallingCodeAndNationalSignificantNumber(state) {
                if (this.extractCountryCallingCode(state)) // `this.extractCallingCode()` is currently called when the number
                // couldn't be formatted during the standard procedure.
                // Normally, the national prefix would be re-extracted
                // for an international number if such number couldn't be formatted,
                // but since it's already not able to be formatted,
                // there won't be yet another retry, so also extract national prefix here.
                this.extractNationalSignificantNumber(state.getNationalDigits(), function(stateUpdate) {
                    return state.update(stateUpdate);
                });
            }
        }
    ]);
    return AsYouTypeParser;
}();
function extractFormattedPhoneNumber(text) {
    // Attempt to extract a possible number from the string passed in.
    var startsAt = text.search(VALID_FORMATTED_PHONE_NUMBER_PART);
    if (startsAt < 0) return;
     // Trim everything to the left of the phone number.
    text = text.slice(startsAt); // Trim the `+`.
    var hasPlus;
    if (text[0] === '+') {
        hasPlus = true;
        text = text.slice(1);
    } // Trim everything to the right of the phone number.
    text = text.replace(AFTER_PHONE_NUMBER_DIGITS_END_PATTERN, ''); // Re-add the previously trimmed `+`.
    if (hasPlus) text = '+' + text;
    return text;
}
/**
 * Extracts formatted phone number digits (and a `+`) from text (if there're any).
 * @param  {string} text
 * @return {any[]}
 */ function _extractFormattedDigitsAndPlus(text) {
    // Extract a formatted phone number part from text.
    var extractedNumber = extractFormattedPhoneNumber(text) || ''; // Trim a `+`.
    if (extractedNumber[0] === '+') return [
        extractedNumber.slice(1),
        true
    ];
    return [
        extractedNumber
    ];
}
function extractFormattedDigitsAndPlus(text) {
    var _extractFormattedDigi3 = _extractFormattedDigitsAndPlus(text), _extractFormattedDigi4 = _slicedToArray(_extractFormattedDigi3, 2), formattedDigits = _extractFormattedDigi4[0], hasPlus = _extractFormattedDigi4[1]; // If the extracted phone number part
    // can possibly be a part of some valid phone number
    // then parse phone number characters from a formatted phone number.
    if (!VALID_FORMATTED_PHONE_NUMBER_DIGITS_PART_PATTERN.test(formattedDigits)) formattedDigits = '';
    return [
        formattedDigits,
        hasPlus
    ];
}

},{"./helpers/extractCountryCallingCode.js":"7hO6r","./helpers/extractCountryCallingCodeFromInternationalNumberWithoutPlusSign.js":"iGfqH","./helpers/extractNationalNumberFromPossiblyIncompleteNumber.js":"WOiQY","./helpers/stripIddPrefix.js":"3Df7S","./helpers/parseDigits.js":"72H5y","./constants.js":"8uTTN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lvvWk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getCountries);
var _metadataJs = require("./metadata.js");
var _metadataJsDefault = parcelHelpers.interopDefault(_metadataJs);
function getCountries(metadata) {
    return new (0, _metadataJsDefault.default)(metadata).getCountries();
}

},{"./metadata.js":"aLNxH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"42kQ2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getExampleNumber);
var _phoneNumberJs = require("./PhoneNumber.js");
var _phoneNumberJsDefault = parcelHelpers.interopDefault(_phoneNumberJs);
function getExampleNumber(country, examples, metadata) {
    if (examples[country]) return new (0, _phoneNumberJsDefault.default)(country, examples[country], metadata);
}

},{"./PhoneNumber.js":"drUtL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f5oRw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>formatIncompletePhoneNumber);
var _asYouTypeJs = require("./AsYouType.js");
var _asYouTypeJsDefault = parcelHelpers.interopDefault(_asYouTypeJs);
function formatIncompletePhoneNumber(value, optionsOrDefaultCountry, metadata) {
    if (!metadata) {
        metadata = optionsOrDefaultCountry;
        optionsOrDefaultCountry = undefined;
    }
    return new (0, _asYouTypeJsDefault.default)(optionsOrDefaultCountry, metadata).input(value);
}

},{"./AsYouType.js":"37zKi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fonYF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parsePhoneNumber", ()=>parsePhoneNumber);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
var _indexJsDefault = parcelHelpers.interopDefault(_indexJs);
function parsePhoneNumber() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJsDefault.default), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7YQVd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isValidPhoneNumber", ()=>isValidPhoneNumber);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function isValidPhoneNumber() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.isValidPhoneNumber), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4Y8Oi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isPossiblePhoneNumber", ()=>isPossiblePhoneNumber);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function isPossiblePhoneNumber() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.isPossiblePhoneNumber), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eTnz1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "validatePhoneNumberLength", ()=>validatePhoneNumberLength);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function validatePhoneNumberLength() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.validatePhoneNumberLength), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f5n8d":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "findNumbers", ()=>findNumbers);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function findNumbers() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.findNumbers), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gGhau":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "searchNumbers", ()=>searchNumbers);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function searchNumbers() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.searchNumbers), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6omsZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "findPhoneNumbersInText", ()=>findPhoneNumbersInText);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function findPhoneNumbersInText() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.findPhoneNumbersInText), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5I1Qk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "searchPhoneNumbersInText", ()=>searchPhoneNumbersInText);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function searchPhoneNumbersInText() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.searchPhoneNumbersInText), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iRdV7":[function(require,module,exports,__globalThis) {
// Importing from a ".js" file is a workaround for Node.js "ES Modules"
// importing system which is even uncapable of importing "*.json" files.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PhoneNumberMatcher", ()=>PhoneNumberMatcher);
var _metadataMaxJsonJs = require("../../metadata.max.json.js");
var _metadataMaxJsonJsDefault = parcelHelpers.interopDefault(_metadataMaxJsonJs);
var _indexJs = require("../../core/index.js");
function PhoneNumberMatcher(text, options) {
    return (0, _indexJs.PhoneNumberMatcher).call(this, text, options, (0, _metadataMaxJsonJsDefault.default));
}
PhoneNumberMatcher.prototype = Object.create((0, _indexJs.PhoneNumberMatcher).prototype, {});
PhoneNumberMatcher.prototype.constructor = PhoneNumberMatcher;

},{"../../metadata.max.json.js":"8d2g5","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fWNGu":[function(require,module,exports,__globalThis) {
// Importing from a ".js" file is a workaround for Node.js "ES Modules"
// importing system which is even uncapable of importing "*.json" files.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AsYouType", ()=>AsYouType);
var _metadataMaxJsonJs = require("../../metadata.max.json.js");
var _metadataMaxJsonJsDefault = parcelHelpers.interopDefault(_metadataMaxJsonJs);
var _indexJs = require("../../core/index.js");
function AsYouType(country) {
    return (0, _indexJs.AsYouType).call(this, country, (0, _metadataMaxJsonJsDefault.default));
}
AsYouType.prototype = Object.create((0, _indexJs.AsYouType).prototype, {});
AsYouType.prototype.constructor = AsYouType;

},{"../../metadata.max.json.js":"8d2g5","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iiy4r":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isSupportedCountry", ()=>isSupportedCountry);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function isSupportedCountry() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.isSupportedCountry), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bGKH3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getCountries", ()=>getCountries);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function getCountries() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.getCountries), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hMqun":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getCountryCallingCode", ()=>getCountryCallingCode);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function getCountryCallingCode() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.getCountryCallingCode), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9fanj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getExtPrefix", ()=>getExtPrefix);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function getExtPrefix() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.getExtPrefix), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cdZaE":[function(require,module,exports,__globalThis) {
// Importing from a ".js" file is a workaround for Node.js "ES Modules"
// importing system which is even uncapable of importing "*.json" files.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Metadata", ()=>Metadata);
var _metadataMaxJsonJs = require("../../metadata.max.json.js");
var _metadataMaxJsonJsDefault = parcelHelpers.interopDefault(_metadataMaxJsonJs);
var _indexJs = require("../../core/index.js");
function Metadata() {
    return (0, _indexJs.Metadata).call(this, (0, _metadataMaxJsonJsDefault.default));
}
Metadata.prototype = Object.create((0, _indexJs.Metadata).prototype, {});
Metadata.prototype.constructor = Metadata;

},{"../../metadata.max.json.js":"8d2g5","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"deLuu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getExampleNumber", ()=>getExampleNumber);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function getExampleNumber() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.getExampleNumber), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kzSCU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatIncompletePhoneNumber", ()=>formatIncompletePhoneNumber);
var _withMetadataArgumentJs = require("./withMetadataArgument.js");
var _withMetadataArgumentJsDefault = parcelHelpers.interopDefault(_withMetadataArgumentJs);
var _indexJs = require("../../core/index.js");
function formatIncompletePhoneNumber() {
    return (0, _withMetadataArgumentJsDefault.default)((0, _indexJs.formatIncompletePhoneNumber), arguments);
}

},{"./withMetadataArgument.js":"7y4e6","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2Z2vR":[function(require,module,exports,__globalThis) {
// Importing from a ".js" file is a workaround for Node.js "ES Modules"
// importing system which is even uncapable of importing "*.json" files.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PhoneNumber", ()=>PhoneNumber);
var _metadataMaxJsonJs = require("../../metadata.max.json.js");
var _metadataMaxJsonJsDefault = parcelHelpers.interopDefault(_metadataMaxJsonJs);
var _indexJs = require("../../core/index.js");
function PhoneNumber(number) {
    return (0, _indexJs.PhoneNumber).call(this, number, (0, _metadataMaxJsonJsDefault.default));
}
PhoneNumber.prototype = Object.create((0, _indexJs.PhoneNumber).prototype, {});
PhoneNumber.prototype.constructor = PhoneNumber;

},{"../../metadata.max.json.js":"8d2g5","../../core/index.js":"iECDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8jaSh":[function(require,module,exports,__globalThis) {
// biome-ignore lint/performance/noBarrelFile: entrypoint module
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CircularReferenceError", ()=>(0, _abitype.CircularReferenceError));
parcelHelpers.export(exports, "InvalidAbiParameterError", ()=>(0, _abitype.InvalidAbiParameterError));
parcelHelpers.export(exports, "InvalidAbiParametersError", ()=>(0, _abitype.InvalidAbiParametersError));
parcelHelpers.export(exports, "InvalidAbiItemError", ()=>(0, _abitype.InvalidAbiItemError));
parcelHelpers.export(exports, "InvalidAbiTypeParameterError", ()=>(0, _abitype.InvalidAbiTypeParameterError));
parcelHelpers.export(exports, "InvalidFunctionModifierError", ()=>(0, _abitype.InvalidFunctionModifierError));
parcelHelpers.export(exports, "InvalidModifierError", ()=>(0, _abitype.InvalidModifierError));
parcelHelpers.export(exports, "InvalidParameterError", ()=>(0, _abitype.InvalidParameterError));
parcelHelpers.export(exports, "InvalidParenthesisError", ()=>(0, _abitype.InvalidParenthesisError));
parcelHelpers.export(exports, "InvalidSignatureError", ()=>(0, _abitype.InvalidSignatureError));
parcelHelpers.export(exports, "InvalidStructSignatureError", ()=>(0, _abitype.InvalidStructSignatureError));
parcelHelpers.export(exports, "SolidityProtectedKeywordError", ()=>(0, _abitype.SolidityProtectedKeywordError));
parcelHelpers.export(exports, "UnknownTypeError", ()=>(0, _abitype.UnknownTypeError));
parcelHelpers.export(exports, "UnknownSignatureError", ()=>(0, _abitype.UnknownSignatureError));
parcelHelpers.export(exports, "parseAbi", ()=>(0, _abitype.parseAbi));
parcelHelpers.export(exports, "parseAbiItem", ()=>(0, _abitype.parseAbiItem));
parcelHelpers.export(exports, "parseAbiParameter", ()=>(0, _abitype.parseAbiParameter));
parcelHelpers.export(exports, "parseAbiParameters", ()=>(0, _abitype.parseAbiParameters));
parcelHelpers.export(exports, "getContract", ()=>(0, _getContractJs.getContract));
parcelHelpers.export(exports, "WaitForCallsStatusTimeoutError", ()=>(0, _waitForCallsStatusJs.WaitForCallsStatusTimeoutError));
parcelHelpers.export(exports, "createClient", ()=>(0, _createClientJs.createClient));
parcelHelpers.export(exports, "rpcSchema", ()=>(0, _createClientJs.rpcSchema));
parcelHelpers.export(exports, "custom", ()=>(0, _customJs.custom));
parcelHelpers.export(exports, "fallback", ()=>(0, _fallbackJs.fallback));
parcelHelpers.export(exports, "shouldThrow", ()=>(0, _fallbackJs.shouldThrow));
parcelHelpers.export(exports, "http", ()=>(0, _httpJs.http));
parcelHelpers.export(exports, "createPublicClient", ()=>(0, _createPublicClientJs.createPublicClient));
parcelHelpers.export(exports, "createTestClient", ()=>(0, _createTestClientJs.createTestClient));
parcelHelpers.export(exports, "publicActions", ()=>(0, _publicJs.publicActions));
parcelHelpers.export(exports, "testActions", ()=>(0, _testJs.testActions));
parcelHelpers.export(exports, "walletActions", ()=>(0, _walletJs.walletActions));
parcelHelpers.export(exports, "createTransport", ()=>(0, _createTransportJs.createTransport));
parcelHelpers.export(exports, "createWalletClient", ()=>(0, _createWalletClientJs.createWalletClient));
parcelHelpers.export(exports, "webSocket", ()=>(0, _webSocketJs.webSocket));
parcelHelpers.export(exports, "multicall3Abi", ()=>(0, _abisJs.multicall3Abi));
parcelHelpers.export(exports, "erc20Abi", ()=>(0, _abisJs.erc20Abi));
parcelHelpers.export(exports, "erc20Abi_bytes32", ()=>(0, _abisJs.erc20Abi_bytes32));
parcelHelpers.export(exports, "erc721Abi", ()=>(0, _abisJs.erc721Abi));
parcelHelpers.export(exports, "erc1155Abi", ()=>(0, _abisJs.erc1155Abi));
parcelHelpers.export(exports, "erc4626Abi", ()=>(0, _abisJs.erc4626Abi));
parcelHelpers.export(exports, "universalSignatureValidatorAbi", ()=>(0, _abisJs.universalSignatureValidatorAbi));
parcelHelpers.export(exports, "ethAddress", ()=>(0, _addressJs.ethAddress));
parcelHelpers.export(exports, "zeroAddress", ()=>(0, _addressJs.zeroAddress));
parcelHelpers.export(exports, "deploylessCallViaBytecodeBytecode", ()=>(0, _contractsJs.deploylessCallViaBytecodeBytecode));
parcelHelpers.export(exports, "deploylessCallViaFactoryBytecode", ()=>(0, _contractsJs.deploylessCallViaFactoryBytecode));
parcelHelpers.export(exports, "universalSignatureValidatorByteCode", ()=>(0, _contractsJs.universalSignatureValidatorByteCode));
parcelHelpers.export(exports, "etherUnits", ()=>(0, _unitJs.etherUnits));
parcelHelpers.export(exports, "gweiUnits", ()=>(0, _unitJs.gweiUnits));
parcelHelpers.export(exports, "weiUnits", ()=>(0, _unitJs.weiUnits));
parcelHelpers.export(exports, "maxInt8", ()=>(0, _numberJs.maxInt8));
parcelHelpers.export(exports, "maxInt16", ()=>(0, _numberJs.maxInt16));
parcelHelpers.export(exports, "maxInt24", ()=>(0, _numberJs.maxInt24));
parcelHelpers.export(exports, "maxInt32", ()=>(0, _numberJs.maxInt32));
parcelHelpers.export(exports, "maxInt40", ()=>(0, _numberJs.maxInt40));
parcelHelpers.export(exports, "maxInt48", ()=>(0, _numberJs.maxInt48));
parcelHelpers.export(exports, "maxInt56", ()=>(0, _numberJs.maxInt56));
parcelHelpers.export(exports, "maxInt64", ()=>(0, _numberJs.maxInt64));
parcelHelpers.export(exports, "maxInt72", ()=>(0, _numberJs.maxInt72));
parcelHelpers.export(exports, "maxInt80", ()=>(0, _numberJs.maxInt80));
parcelHelpers.export(exports, "maxInt88", ()=>(0, _numberJs.maxInt88));
parcelHelpers.export(exports, "maxInt96", ()=>(0, _numberJs.maxInt96));
parcelHelpers.export(exports, "maxInt104", ()=>(0, _numberJs.maxInt104));
parcelHelpers.export(exports, "maxInt112", ()=>(0, _numberJs.maxInt112));
parcelHelpers.export(exports, "maxInt120", ()=>(0, _numberJs.maxInt120));
parcelHelpers.export(exports, "maxInt128", ()=>(0, _numberJs.maxInt128));
parcelHelpers.export(exports, "maxInt136", ()=>(0, _numberJs.maxInt136));
parcelHelpers.export(exports, "maxInt144", ()=>(0, _numberJs.maxInt144));
parcelHelpers.export(exports, "maxInt152", ()=>(0, _numberJs.maxInt152));
parcelHelpers.export(exports, "maxInt160", ()=>(0, _numberJs.maxInt160));
parcelHelpers.export(exports, "maxInt168", ()=>(0, _numberJs.maxInt168));
parcelHelpers.export(exports, "maxInt176", ()=>(0, _numberJs.maxInt176));
parcelHelpers.export(exports, "maxInt184", ()=>(0, _numberJs.maxInt184));
parcelHelpers.export(exports, "maxInt192", ()=>(0, _numberJs.maxInt192));
parcelHelpers.export(exports, "maxInt200", ()=>(0, _numberJs.maxInt200));
parcelHelpers.export(exports, "maxInt208", ()=>(0, _numberJs.maxInt208));
parcelHelpers.export(exports, "maxInt216", ()=>(0, _numberJs.maxInt216));
parcelHelpers.export(exports, "maxInt224", ()=>(0, _numberJs.maxInt224));
parcelHelpers.export(exports, "maxInt232", ()=>(0, _numberJs.maxInt232));
parcelHelpers.export(exports, "maxInt240", ()=>(0, _numberJs.maxInt240));
parcelHelpers.export(exports, "maxInt248", ()=>(0, _numberJs.maxInt248));
parcelHelpers.export(exports, "maxInt256", ()=>(0, _numberJs.maxInt256));
parcelHelpers.export(exports, "maxUint8", ()=>(0, _numberJs.maxUint8));
parcelHelpers.export(exports, "maxUint16", ()=>(0, _numberJs.maxUint16));
parcelHelpers.export(exports, "maxUint24", ()=>(0, _numberJs.maxUint24));
parcelHelpers.export(exports, "maxUint32", ()=>(0, _numberJs.maxUint32));
parcelHelpers.export(exports, "maxUint40", ()=>(0, _numberJs.maxUint40));
parcelHelpers.export(exports, "maxUint48", ()=>(0, _numberJs.maxUint48));
parcelHelpers.export(exports, "maxUint56", ()=>(0, _numberJs.maxUint56));
parcelHelpers.export(exports, "maxUint64", ()=>(0, _numberJs.maxUint64));
parcelHelpers.export(exports, "maxUint72", ()=>(0, _numberJs.maxUint72));
parcelHelpers.export(exports, "maxUint80", ()=>(0, _numberJs.maxUint80));
parcelHelpers.export(exports, "maxUint88", ()=>(0, _numberJs.maxUint88));
parcelHelpers.export(exports, "maxUint96", ()=>(0, _numberJs.maxUint96));
parcelHelpers.export(exports, "maxUint104", ()=>(0, _numberJs.maxUint104));
parcelHelpers.export(exports, "maxUint112", ()=>(0, _numberJs.maxUint112));
parcelHelpers.export(exports, "maxUint120", ()=>(0, _numberJs.maxUint120));
parcelHelpers.export(exports, "maxUint128", ()=>(0, _numberJs.maxUint128));
parcelHelpers.export(exports, "maxUint136", ()=>(0, _numberJs.maxUint136));
parcelHelpers.export(exports, "maxUint144", ()=>(0, _numberJs.maxUint144));
parcelHelpers.export(exports, "maxUint152", ()=>(0, _numberJs.maxUint152));
parcelHelpers.export(exports, "maxUint160", ()=>(0, _numberJs.maxUint160));
parcelHelpers.export(exports, "maxUint168", ()=>(0, _numberJs.maxUint168));
parcelHelpers.export(exports, "maxUint176", ()=>(0, _numberJs.maxUint176));
parcelHelpers.export(exports, "maxUint184", ()=>(0, _numberJs.maxUint184));
parcelHelpers.export(exports, "maxUint192", ()=>(0, _numberJs.maxUint192));
parcelHelpers.export(exports, "maxUint200", ()=>(0, _numberJs.maxUint200));
parcelHelpers.export(exports, "maxUint208", ()=>(0, _numberJs.maxUint208));
parcelHelpers.export(exports, "maxUint216", ()=>(0, _numberJs.maxUint216));
parcelHelpers.export(exports, "maxUint224", ()=>(0, _numberJs.maxUint224));
parcelHelpers.export(exports, "maxUint232", ()=>(0, _numberJs.maxUint232));
parcelHelpers.export(exports, "maxUint240", ()=>(0, _numberJs.maxUint240));
parcelHelpers.export(exports, "maxUint248", ()=>(0, _numberJs.maxUint248));
parcelHelpers.export(exports, "maxUint256", ()=>(0, _numberJs.maxUint256));
parcelHelpers.export(exports, "minInt8", ()=>(0, _numberJs.minInt8));
parcelHelpers.export(exports, "minInt16", ()=>(0, _numberJs.minInt16));
parcelHelpers.export(exports, "minInt24", ()=>(0, _numberJs.minInt24));
parcelHelpers.export(exports, "minInt32", ()=>(0, _numberJs.minInt32));
parcelHelpers.export(exports, "minInt40", ()=>(0, _numberJs.minInt40));
parcelHelpers.export(exports, "minInt48", ()=>(0, _numberJs.minInt48));
parcelHelpers.export(exports, "minInt56", ()=>(0, _numberJs.minInt56));
parcelHelpers.export(exports, "minInt64", ()=>(0, _numberJs.minInt64));
parcelHelpers.export(exports, "minInt72", ()=>(0, _numberJs.minInt72));
parcelHelpers.export(exports, "minInt80", ()=>(0, _numberJs.minInt80));
parcelHelpers.export(exports, "minInt88", ()=>(0, _numberJs.minInt88));
parcelHelpers.export(exports, "minInt96", ()=>(0, _numberJs.minInt96));
parcelHelpers.export(exports, "minInt104", ()=>(0, _numberJs.minInt104));
parcelHelpers.export(exports, "minInt112", ()=>(0, _numberJs.minInt112));
parcelHelpers.export(exports, "minInt120", ()=>(0, _numberJs.minInt120));
parcelHelpers.export(exports, "minInt128", ()=>(0, _numberJs.minInt128));
parcelHelpers.export(exports, "minInt136", ()=>(0, _numberJs.minInt136));
parcelHelpers.export(exports, "minInt144", ()=>(0, _numberJs.minInt144));
parcelHelpers.export(exports, "minInt152", ()=>(0, _numberJs.minInt152));
parcelHelpers.export(exports, "minInt160", ()=>(0, _numberJs.minInt160));
parcelHelpers.export(exports, "minInt168", ()=>(0, _numberJs.minInt168));
parcelHelpers.export(exports, "minInt176", ()=>(0, _numberJs.minInt176));
parcelHelpers.export(exports, "minInt184", ()=>(0, _numberJs.minInt184));
parcelHelpers.export(exports, "minInt192", ()=>(0, _numberJs.minInt192));
parcelHelpers.export(exports, "minInt200", ()=>(0, _numberJs.minInt200));
parcelHelpers.export(exports, "minInt208", ()=>(0, _numberJs.minInt208));
parcelHelpers.export(exports, "minInt216", ()=>(0, _numberJs.minInt216));
parcelHelpers.export(exports, "minInt224", ()=>(0, _numberJs.minInt224));
parcelHelpers.export(exports, "minInt232", ()=>(0, _numberJs.minInt232));
parcelHelpers.export(exports, "minInt240", ()=>(0, _numberJs.minInt240));
parcelHelpers.export(exports, "minInt248", ()=>(0, _numberJs.minInt248));
parcelHelpers.export(exports, "minInt256", ()=>(0, _numberJs.minInt256));
parcelHelpers.export(exports, "zeroHash", ()=>(0, _bytesJs.zeroHash));
parcelHelpers.export(exports, "presignMessagePrefix", ()=>(0, _stringsJs.presignMessagePrefix));
parcelHelpers.export(exports, "AbiConstructorNotFoundError", ()=>(0, _abiJs.AbiConstructorNotFoundError));
parcelHelpers.export(exports, "AbiConstructorParamsNotFoundError", ()=>(0, _abiJs.AbiConstructorParamsNotFoundError));
parcelHelpers.export(exports, "AbiDecodingDataSizeInvalidError", ()=>(0, _abiJs.AbiDecodingDataSizeInvalidError));
parcelHelpers.export(exports, "AbiDecodingDataSizeTooSmallError", ()=>(0, _abiJs.AbiDecodingDataSizeTooSmallError));
parcelHelpers.export(exports, "AbiDecodingZeroDataError", ()=>(0, _abiJs.AbiDecodingZeroDataError));
parcelHelpers.export(exports, "AbiEncodingArrayLengthMismatchError", ()=>(0, _abiJs.AbiEncodingArrayLengthMismatchError));
parcelHelpers.export(exports, "AbiEncodingLengthMismatchError", ()=>(0, _abiJs.AbiEncodingLengthMismatchError));
parcelHelpers.export(exports, "AbiEncodingBytesSizeMismatchError", ()=>(0, _abiJs.AbiEncodingBytesSizeMismatchError));
parcelHelpers.export(exports, "AbiErrorInputsNotFoundError", ()=>(0, _abiJs.AbiErrorInputsNotFoundError));
parcelHelpers.export(exports, "AbiErrorNotFoundError", ()=>(0, _abiJs.AbiErrorNotFoundError));
parcelHelpers.export(exports, "AbiErrorSignatureNotFoundError", ()=>(0, _abiJs.AbiErrorSignatureNotFoundError));
parcelHelpers.export(exports, "AbiEventNotFoundError", ()=>(0, _abiJs.AbiEventNotFoundError));
parcelHelpers.export(exports, "AbiEventSignatureEmptyTopicsError", ()=>(0, _abiJs.AbiEventSignatureEmptyTopicsError));
parcelHelpers.export(exports, "AbiEventSignatureNotFoundError", ()=>(0, _abiJs.AbiEventSignatureNotFoundError));
parcelHelpers.export(exports, "AbiFunctionNotFoundError", ()=>(0, _abiJs.AbiFunctionNotFoundError));
parcelHelpers.export(exports, "AbiFunctionOutputsNotFoundError", ()=>(0, _abiJs.AbiFunctionOutputsNotFoundError));
parcelHelpers.export(exports, "AbiFunctionSignatureNotFoundError", ()=>(0, _abiJs.AbiFunctionSignatureNotFoundError));
parcelHelpers.export(exports, "BytesSizeMismatchError", ()=>(0, _abiJs.BytesSizeMismatchError));
parcelHelpers.export(exports, "DecodeLogDataMismatch", ()=>(0, _abiJs.DecodeLogDataMismatch));
parcelHelpers.export(exports, "DecodeLogTopicsMismatch", ()=>(0, _abiJs.DecodeLogTopicsMismatch));
parcelHelpers.export(exports, "InvalidAbiDecodingTypeError", ()=>(0, _abiJs.InvalidAbiDecodingTypeError));
parcelHelpers.export(exports, "InvalidAbiEncodingTypeError", ()=>(0, _abiJs.InvalidAbiEncodingTypeError));
parcelHelpers.export(exports, "InvalidArrayError", ()=>(0, _abiJs.InvalidArrayError));
parcelHelpers.export(exports, "InvalidDefinitionTypeError", ()=>(0, _abiJs.InvalidDefinitionTypeError));
parcelHelpers.export(exports, "UnsupportedPackedAbiType", ()=>(0, _abiJs.UnsupportedPackedAbiType));
parcelHelpers.export(exports, "BaseError", ()=>(0, _baseJs.BaseError));
parcelHelpers.export(exports, "setErrorConfig", ()=>(0, _baseJs.setErrorConfig));
parcelHelpers.export(exports, "BlockNotFoundError", ()=>(0, _blockJs.BlockNotFoundError));
parcelHelpers.export(exports, "CallExecutionError", ()=>(0, _contractJs.CallExecutionError));
parcelHelpers.export(exports, "ContractFunctionExecutionError", ()=>(0, _contractJs.ContractFunctionExecutionError));
parcelHelpers.export(exports, "ContractFunctionRevertedError", ()=>(0, _contractJs.ContractFunctionRevertedError));
parcelHelpers.export(exports, "ContractFunctionZeroDataError", ()=>(0, _contractJs.ContractFunctionZeroDataError));
parcelHelpers.export(exports, "RawContractError", ()=>(0, _contractJs.RawContractError));
parcelHelpers.export(exports, "CounterfactualDeploymentFailedError", ()=>(0, _contractJs.CounterfactualDeploymentFailedError));
parcelHelpers.export(exports, "BaseFeeScalarError", ()=>(0, _feeJs.BaseFeeScalarError));
parcelHelpers.export(exports, "Eip1559FeesNotSupportedError", ()=>(0, _feeJs.Eip1559FeesNotSupportedError));
parcelHelpers.export(exports, "MaxFeePerGasTooLowError", ()=>(0, _feeJs.MaxFeePerGasTooLowError));
parcelHelpers.export(exports, "AtomicReadyWalletRejectedUpgradeError", ()=>(0, _rpcJs.AtomicReadyWalletRejectedUpgradeError));
parcelHelpers.export(exports, "AtomicityNotSupportedError", ()=>(0, _rpcJs.AtomicityNotSupportedError));
parcelHelpers.export(exports, "BundleTooLargeError", ()=>(0, _rpcJs.BundleTooLargeError));
parcelHelpers.export(exports, "ChainDisconnectedError", ()=>(0, _rpcJs.ChainDisconnectedError));
parcelHelpers.export(exports, "DuplicateIdError", ()=>(0, _rpcJs.DuplicateIdError));
parcelHelpers.export(exports, "InternalRpcError", ()=>(0, _rpcJs.InternalRpcError));
parcelHelpers.export(exports, "InvalidInputRpcError", ()=>(0, _rpcJs.InvalidInputRpcError));
parcelHelpers.export(exports, "InvalidParamsRpcError", ()=>(0, _rpcJs.InvalidParamsRpcError));
parcelHelpers.export(exports, "InvalidRequestRpcError", ()=>(0, _rpcJs.InvalidRequestRpcError));
parcelHelpers.export(exports, "JsonRpcVersionUnsupportedError", ()=>(0, _rpcJs.JsonRpcVersionUnsupportedError));
parcelHelpers.export(exports, "LimitExceededRpcError", ()=>(0, _rpcJs.LimitExceededRpcError));
parcelHelpers.export(exports, "MethodNotFoundRpcError", ()=>(0, _rpcJs.MethodNotFoundRpcError));
parcelHelpers.export(exports, "MethodNotSupportedRpcError", ()=>(0, _rpcJs.MethodNotSupportedRpcError));
parcelHelpers.export(exports, "ParseRpcError", ()=>(0, _rpcJs.ParseRpcError));
parcelHelpers.export(exports, "ProviderDisconnectedError", ()=>(0, _rpcJs.ProviderDisconnectedError));
parcelHelpers.export(exports, "ProviderRpcError", ()=>(0, _rpcJs.ProviderRpcError));
parcelHelpers.export(exports, "ResourceNotFoundRpcError", ()=>(0, _rpcJs.ResourceNotFoundRpcError));
parcelHelpers.export(exports, "ResourceUnavailableRpcError", ()=>(0, _rpcJs.ResourceUnavailableRpcError));
parcelHelpers.export(exports, "RpcError", ()=>(0, _rpcJs.RpcError));
parcelHelpers.export(exports, "SwitchChainError", ()=>(0, _rpcJs.SwitchChainError));
parcelHelpers.export(exports, "TransactionRejectedRpcError", ()=>(0, _rpcJs.TransactionRejectedRpcError));
parcelHelpers.export(exports, "UnauthorizedProviderError", ()=>(0, _rpcJs.UnauthorizedProviderError));
parcelHelpers.export(exports, "UnknownBundleIdError", ()=>(0, _rpcJs.UnknownBundleIdError));
parcelHelpers.export(exports, "UnknownRpcError", ()=>(0, _rpcJs.UnknownRpcError));
parcelHelpers.export(exports, "UnsupportedChainIdError", ()=>(0, _rpcJs.UnsupportedChainIdError));
parcelHelpers.export(exports, "UnsupportedNonOptionalCapabilityError", ()=>(0, _rpcJs.UnsupportedNonOptionalCapabilityError));
parcelHelpers.export(exports, "UnsupportedProviderMethodError", ()=>(0, _rpcJs.UnsupportedProviderMethodError));
parcelHelpers.export(exports, "UserRejectedRequestError", ()=>(0, _rpcJs.UserRejectedRequestError));
parcelHelpers.export(exports, "ChainDoesNotSupportContract", ()=>(0, _chainJs.ChainDoesNotSupportContract));
parcelHelpers.export(exports, "ChainMismatchError", ()=>(0, _chainJs.ChainMismatchError));
parcelHelpers.export(exports, "ChainNotFoundError", ()=>(0, _chainJs.ChainNotFoundError));
parcelHelpers.export(exports, "ClientChainNotConfiguredError", ()=>(0, _chainJs.ClientChainNotConfiguredError));
parcelHelpers.export(exports, "InvalidChainIdError", ()=>(0, _chainJs.InvalidChainIdError));
parcelHelpers.export(exports, "InvalidBytesBooleanError", ()=>(0, _encodingJs.InvalidBytesBooleanError));
parcelHelpers.export(exports, "IntegerOutOfRangeError", ()=>(0, _encodingJs.IntegerOutOfRangeError));
parcelHelpers.export(exports, "InvalidHexBooleanError", ()=>(0, _encodingJs.InvalidHexBooleanError));
parcelHelpers.export(exports, "InvalidHexValueError", ()=>(0, _encodingJs.InvalidHexValueError));
parcelHelpers.export(exports, "SizeOverflowError", ()=>(0, _encodingJs.SizeOverflowError));
parcelHelpers.export(exports, "EnsAvatarUriResolutionError", ()=>(0, _ensJs.EnsAvatarUriResolutionError));
parcelHelpers.export(exports, "EnsAvatarInvalidNftUriError", ()=>(0, _ensJs.EnsAvatarInvalidNftUriError));
parcelHelpers.export(exports, "EnsAvatarUnsupportedNamespaceError", ()=>(0, _ensJs.EnsAvatarUnsupportedNamespaceError));
parcelHelpers.export(exports, "InvalidDecimalNumberError", ()=>(0, _unitJs1.InvalidDecimalNumberError));
parcelHelpers.export(exports, "EstimateGasExecutionError", ()=>(0, _estimateGasJs.EstimateGasExecutionError));
parcelHelpers.export(exports, "ExecutionRevertedError", ()=>(0, _nodeJs.ExecutionRevertedError));
parcelHelpers.export(exports, "FeeCapTooHighError", ()=>(0, _nodeJs.FeeCapTooHighError));
parcelHelpers.export(exports, "FeeCapTooLowError", ()=>(0, _nodeJs.FeeCapTooLowError));
parcelHelpers.export(exports, "InsufficientFundsError", ()=>(0, _nodeJs.InsufficientFundsError));
parcelHelpers.export(exports, "IntrinsicGasTooHighError", ()=>(0, _nodeJs.IntrinsicGasTooHighError));
parcelHelpers.export(exports, "IntrinsicGasTooLowError", ()=>(0, _nodeJs.IntrinsicGasTooLowError));
parcelHelpers.export(exports, "NonceMaxValueError", ()=>(0, _nodeJs.NonceMaxValueError));
parcelHelpers.export(exports, "NonceTooHighError", ()=>(0, _nodeJs.NonceTooHighError));
parcelHelpers.export(exports, "NonceTooLowError", ()=>(0, _nodeJs.NonceTooLowError));
parcelHelpers.export(exports, "TipAboveFeeCapError", ()=>(0, _nodeJs.TipAboveFeeCapError));
parcelHelpers.export(exports, "TransactionTypeNotSupportedError", ()=>(0, _nodeJs.TransactionTypeNotSupportedError));
parcelHelpers.export(exports, "UnknownNodeError", ()=>(0, _nodeJs.UnknownNodeError));
parcelHelpers.export(exports, "FilterTypeNotSupportedError", ()=>(0, _logJs.FilterTypeNotSupportedError));
parcelHelpers.export(exports, "HttpRequestError", ()=>(0, _requestJs.HttpRequestError));
parcelHelpers.export(exports, "RpcRequestError", ()=>(0, _requestJs.RpcRequestError));
parcelHelpers.export(exports, "TimeoutError", ()=>(0, _requestJs.TimeoutError));
parcelHelpers.export(exports, "SocketClosedError", ()=>(0, _requestJs.SocketClosedError));
parcelHelpers.export(exports, "WebSocketRequestError", ()=>(0, _requestJs.WebSocketRequestError));
parcelHelpers.export(exports, "InvalidAddressError", ()=>(0, _addressJs1.InvalidAddressError));
parcelHelpers.export(exports, "FeeConflictError", ()=>(0, _transactionJs.FeeConflictError));
parcelHelpers.export(exports, "InvalidLegacyVError", ()=>(0, _transactionJs.InvalidLegacyVError));
parcelHelpers.export(exports, "InvalidSerializableTransactionError", ()=>(0, _transactionJs.InvalidSerializableTransactionError));
parcelHelpers.export(exports, "InvalidSerializedTransactionError", ()=>(0, _transactionJs.InvalidSerializedTransactionError));
parcelHelpers.export(exports, "InvalidSerializedTransactionTypeError", ()=>(0, _transactionJs.InvalidSerializedTransactionTypeError));
parcelHelpers.export(exports, "InvalidStorageKeySizeError", ()=>(0, _transactionJs.InvalidStorageKeySizeError));
parcelHelpers.export(exports, "TransactionExecutionError", ()=>(0, _transactionJs.TransactionExecutionError));
parcelHelpers.export(exports, "TransactionNotFoundError", ()=>(0, _transactionJs.TransactionNotFoundError));
parcelHelpers.export(exports, "TransactionReceiptNotFoundError", ()=>(0, _transactionJs.TransactionReceiptNotFoundError));
parcelHelpers.export(exports, "WaitForTransactionReceiptTimeoutError", ()=>(0, _transactionJs.WaitForTransactionReceiptTimeoutError));
parcelHelpers.export(exports, "SizeExceedsPaddingSizeError", ()=>(0, _dataJs.SizeExceedsPaddingSizeError));
parcelHelpers.export(exports, "SliceOffsetOutOfBoundsError", ()=>(0, _dataJs.SliceOffsetOutOfBoundsError));
parcelHelpers.export(exports, "UrlRequiredError", ()=>(0, _transportJs.UrlRequiredError));
parcelHelpers.export(exports, "AccountStateConflictError", ()=>(0, _stateOverrideJs.AccountStateConflictError));
parcelHelpers.export(exports, "StateAssignmentConflictError", ()=>(0, _stateOverrideJs.StateAssignmentConflictError));
parcelHelpers.export(exports, "InvalidDomainError", ()=>(0, _typedDataJs.InvalidDomainError));
parcelHelpers.export(exports, "InvalidPrimaryTypeError", ()=>(0, _typedDataJs.InvalidPrimaryTypeError));
parcelHelpers.export(exports, "InvalidStructTypeError", ()=>(0, _typedDataJs.InvalidStructTypeError));
parcelHelpers.export(exports, "EIP1193ProviderRpcError", ()=>(0, _eip1193Js.ProviderRpcError));
parcelHelpers.export(exports, "labelhash", ()=>(0, _labelhashJs.labelhash));
parcelHelpers.export(exports, "namehash", ()=>(0, _namehashJs.namehash));
parcelHelpers.export(exports, "defineBlock", ()=>(0, _blockJs1.defineBlock));
parcelHelpers.export(exports, "formatBlock", ()=>(0, _blockJs1.formatBlock));
parcelHelpers.export(exports, "formatLog", ()=>(0, _logJs1.formatLog));
parcelHelpers.export(exports, "decodeAbiParameters", ()=>(0, _decodeAbiParametersJs.decodeAbiParameters));
parcelHelpers.export(exports, "decodeDeployData", ()=>(0, _decodeDeployDataJs.decodeDeployData));
parcelHelpers.export(exports, "decodeErrorResult", ()=>(0, _decodeErrorResultJs.decodeErrorResult));
parcelHelpers.export(exports, "decodeEventLog", ()=>(0, _decodeEventLogJs.decodeEventLog));
parcelHelpers.export(exports, "decodeFunctionData", ()=>(0, _decodeFunctionDataJs.decodeFunctionData));
parcelHelpers.export(exports, "decodeFunctionResult", ()=>(0, _decodeFunctionResultJs.decodeFunctionResult));
parcelHelpers.export(exports, "encodeAbiParameters", ()=>(0, _encodeAbiParametersJs.encodeAbiParameters));
parcelHelpers.export(exports, "encodeDeployData", ()=>(0, _encodeDeployDataJs.encodeDeployData));
parcelHelpers.export(exports, "encodeErrorResult", ()=>(0, _encodeErrorResultJs.encodeErrorResult));
parcelHelpers.export(exports, "encodeEventTopics", ()=>(0, _encodeEventTopicsJs.encodeEventTopics));
parcelHelpers.export(exports, "encodeFunctionData", ()=>(0, _encodeFunctionDataJs.encodeFunctionData));
parcelHelpers.export(exports, "prepareEncodeFunctionData", ()=>(0, _prepareEncodeFunctionDataJs.prepareEncodeFunctionData));
parcelHelpers.export(exports, "encodeFunctionResult", ()=>(0, _encodeFunctionResultJs.encodeFunctionResult));
parcelHelpers.export(exports, "parseEventLogs", ()=>(0, _parseEventLogsJs.parseEventLogs));
parcelHelpers.export(exports, "defineTransaction", ()=>(0, _transactionJs1.defineTransaction));
parcelHelpers.export(exports, "formatTransaction", ()=>(0, _transactionJs1.formatTransaction));
parcelHelpers.export(exports, "transactionType", ()=>(0, _transactionJs1.transactionType));
parcelHelpers.export(exports, "defineTransactionReceipt", ()=>(0, _transactionReceiptJs.defineTransactionReceipt));
parcelHelpers.export(exports, "formatTransactionReceipt", ()=>(0, _transactionReceiptJs.formatTransactionReceipt));
parcelHelpers.export(exports, "defineTransactionRequest", ()=>(0, _transactionRequestJs.defineTransactionRequest));
parcelHelpers.export(exports, "formatTransactionRequest", ()=>(0, _transactionRequestJs.formatTransactionRequest));
parcelHelpers.export(exports, "rpcTransactionType", ()=>(0, _transactionRequestJs.rpcTransactionType));
parcelHelpers.export(exports, "getAbiItem", ()=>(0, _getAbiItemJs.getAbiItem));
parcelHelpers.export(exports, "getContractAddress", ()=>(0, _getContractAddressJs.getContractAddress));
parcelHelpers.export(exports, "getCreate2Address", ()=>(0, _getContractAddressJs.getCreate2Address));
parcelHelpers.export(exports, "getCreateAddress", ()=>(0, _getContractAddressJs.getCreateAddress));
parcelHelpers.export(exports, "getSerializedTransactionType", ()=>(0, _getSerializedTransactionTypeJs.getSerializedTransactionType));
parcelHelpers.export(exports, "getTransactionType", ()=>(0, _getTransactionTypeJs.getTransactionType));
parcelHelpers.export(exports, "hashDomain", ()=>(0, _hashTypedDataJs.hashDomain));
parcelHelpers.export(exports, "hashStruct", ()=>(0, _hashTypedDataJs.hashStruct));
parcelHelpers.export(exports, "hashTypedData", ()=>(0, _hashTypedDataJs.hashTypedData));
parcelHelpers.export(exports, "compactSignatureToSignature", ()=>(0, _compactSignatureToSignatureJs.compactSignatureToSignature));
parcelHelpers.export(exports, "hexToCompactSignature", ()=>(0, _parseCompactSignatureJs.parseCompactSignature));
parcelHelpers.export(exports, "parseCompactSignature", ()=>(0, _parseCompactSignatureJs.parseCompactSignature));
parcelHelpers.export(exports, "hexToSignature", ()=>(0, _parseSignatureJs.parseSignature));
parcelHelpers.export(exports, "parseSignature", ()=>(0, _parseSignatureJs.parseSignature));
parcelHelpers.export(exports, "recoverAddress", ()=>(0, _recoverAddressJs.recoverAddress));
parcelHelpers.export(exports, "recoverMessageAddress", ()=>(0, _recoverMessageAddressJs.recoverMessageAddress));
parcelHelpers.export(exports, "recoverPublicKey", ()=>(0, _recoverPublicKeyJs.recoverPublicKey));
parcelHelpers.export(exports, "recoverTransactionAddress", ()=>(0, _recoverTransactionAddressJs.recoverTransactionAddress));
parcelHelpers.export(exports, "recoverTypedDataAddress", ()=>(0, _recoverTypedDataAddressJs.recoverTypedDataAddress));
parcelHelpers.export(exports, "signatureToCompactSignature", ()=>(0, _signatureToCompactSignatureJs.signatureToCompactSignature));
parcelHelpers.export(exports, "compactSignatureToHex", ()=>(0, _serializeCompactSignatureJs.serializeCompactSignature));
parcelHelpers.export(exports, "serializeCompactSignature", ()=>(0, _serializeCompactSignatureJs.serializeCompactSignature));
parcelHelpers.export(exports, "signatureToHex", ()=>(0, _serializeSignatureJs.serializeSignature));
parcelHelpers.export(exports, "serializeSignature", ()=>(0, _serializeSignatureJs.serializeSignature));
parcelHelpers.export(exports, "bytesToRlp", ()=>(0, _toRlpJs.bytesToRlp));
parcelHelpers.export(exports, "hexToRlp", ()=>(0, _toRlpJs.hexToRlp));
parcelHelpers.export(exports, "toRlp", ()=>(0, _toRlpJs.toRlp));
parcelHelpers.export(exports, "verifyHash", ()=>(0, _verifyHashJs.verifyHash));
parcelHelpers.export(exports, "verifyMessage", ()=>(0, _verifyMessageJs.verifyMessage));
parcelHelpers.export(exports, "verifyTypedData", ()=>(0, _verifyTypedDataJs.verifyTypedData));
parcelHelpers.export(exports, "parseErc6492Signature", ()=>(0, _parseErc6492SignatureJs.parseErc6492Signature));
parcelHelpers.export(exports, "isErc6492Signature", ()=>(0, _isErc6492SignatureJs.isErc6492Signature));
parcelHelpers.export(exports, "serializeErc6492Signature", ()=>(0, _serializeErc6492SignatureJs.serializeErc6492Signature));
parcelHelpers.export(exports, "assertRequest", ()=>(0, _assertRequestJs.assertRequest));
parcelHelpers.export(exports, "assertTransactionEIP1559", ()=>(0, _assertTransactionJs.assertTransactionEIP1559));
parcelHelpers.export(exports, "assertTransactionEIP2930", ()=>(0, _assertTransactionJs.assertTransactionEIP2930));
parcelHelpers.export(exports, "assertTransactionLegacy", ()=>(0, _assertTransactionJs.assertTransactionLegacy));
parcelHelpers.export(exports, "boolToBytes", ()=>(0, _toBytesJs.boolToBytes));
parcelHelpers.export(exports, "hexToBytes", ()=>(0, _toBytesJs.hexToBytes));
parcelHelpers.export(exports, "numberToBytes", ()=>(0, _toBytesJs.numberToBytes));
parcelHelpers.export(exports, "stringToBytes", ()=>(0, _toBytesJs.stringToBytes));
parcelHelpers.export(exports, "toBytes", ()=>(0, _toBytesJs.toBytes));
parcelHelpers.export(exports, "boolToHex", ()=>(0, _toHexJs.boolToHex));
parcelHelpers.export(exports, "bytesToHex", ()=>(0, _toHexJs.bytesToHex));
parcelHelpers.export(exports, "numberToHex", ()=>(0, _toHexJs.numberToHex));
parcelHelpers.export(exports, "stringToHex", ()=>(0, _toHexJs.stringToHex));
parcelHelpers.export(exports, "toHex", ()=>(0, _toHexJs.toHex));
parcelHelpers.export(exports, "bytesToBigInt", ()=>(0, _fromBytesJs.bytesToBigInt));
parcelHelpers.export(exports, "bytesToBool", ()=>(0, _fromBytesJs.bytesToBool));
parcelHelpers.export(exports, "bytesToNumber", ()=>(0, _fromBytesJs.bytesToNumber));
parcelHelpers.export(exports, "bytesToString", ()=>(0, _fromBytesJs.bytesToString));
parcelHelpers.export(exports, "fromBytes", ()=>(0, _fromBytesJs.fromBytes));
parcelHelpers.export(exports, "ccipRequest", ()=>(0, _ccipJs.ccipRequest));
parcelHelpers.export(exports, "ccipFetch", ()=>(0, _ccipJs.ccipRequest));
parcelHelpers.export(exports, "offchainLookup", ()=>(0, _ccipJs.offchainLookup));
parcelHelpers.export(exports, "offchainLookupAbiItem", ()=>(0, _ccipJs.offchainLookupAbiItem));
parcelHelpers.export(exports, "offchainLookupSignature", ()=>(0, _ccipJs.offchainLookupSignature));
parcelHelpers.export(exports, "blobsToCommitments", ()=>(0, _blobsToCommitmentsJs.blobsToCommitments));
parcelHelpers.export(exports, "commitmentToVersionedHash", ()=>(0, _commitmentToVersionedHashJs.commitmentToVersionedHash));
parcelHelpers.export(exports, "commitmentsToVersionedHashes", ()=>(0, _commitmentsToVersionedHashesJs.commitmentsToVersionedHashes));
parcelHelpers.export(exports, "sidecarsToVersionedHashes", ()=>(0, _sidecarsToVersionedHashesJs.sidecarsToVersionedHashes));
parcelHelpers.export(exports, "blobsToProofs", ()=>(0, _blobsToProofsJs.blobsToProofs));
parcelHelpers.export(exports, "fromBlobs", ()=>(0, _fromBlobsJs.fromBlobs));
parcelHelpers.export(exports, "toBlobSidecars", ()=>(0, _toBlobSidecarsJs.toBlobSidecars));
parcelHelpers.export(exports, "toBlobs", ()=>(0, _toBlobsJs.toBlobs));
parcelHelpers.export(exports, "defineKzg", ()=>(0, _defineKzgJs.defineKzg));
parcelHelpers.export(exports, "setupKzg", ()=>(0, _setupKzgJs.setupKzg));
parcelHelpers.export(exports, "concat", ()=>(0, _concatJs.concat));
parcelHelpers.export(exports, "concatBytes", ()=>(0, _concatJs.concatBytes));
parcelHelpers.export(exports, "concatHex", ()=>(0, _concatJs.concatHex));
parcelHelpers.export(exports, "assertCurrentChain", ()=>(0, _assertCurrentChainJs.assertCurrentChain));
parcelHelpers.export(exports, "defineChain", ()=>(0, _defineChainJs.defineChain));
parcelHelpers.export(exports, "extractChain", ()=>(0, _extractChainJs.extractChain));
parcelHelpers.export(exports, "getChainContractAddress", ()=>(0, _getChainContractAddressJs.getChainContractAddress));
parcelHelpers.export(exports, "encodePacked", ()=>(0, _encodePackedJs.encodePacked));
parcelHelpers.export(exports, "withCache", ()=>(0, _withCacheJs.withCache));
parcelHelpers.export(exports, "withRetry", ()=>(0, _withRetryJs.withRetry));
parcelHelpers.export(exports, "withTimeout", ()=>(0, _withTimeoutJs.withTimeout));
parcelHelpers.export(exports, "formatEther", ()=>(0, _formatEtherJs.formatEther));
parcelHelpers.export(exports, "formatGwei", ()=>(0, _formatGweiJs.formatGwei));
parcelHelpers.export(exports, "formatUnits", ()=>(0, _formatUnitsJs.formatUnits));
parcelHelpers.export(exports, "fromHex", ()=>(0, _fromHexJs.fromHex));
parcelHelpers.export(exports, "hexToBigInt", ()=>(0, _fromHexJs.hexToBigInt));
parcelHelpers.export(exports, "hexToBool", ()=>(0, _fromHexJs.hexToBool));
parcelHelpers.export(exports, "hexToNumber", ()=>(0, _fromHexJs.hexToNumber));
parcelHelpers.export(exports, "hexToString", ()=>(0, _fromHexJs.hexToString));
parcelHelpers.export(exports, "fromRlp", ()=>(0, _fromRlpJs.fromRlp));
parcelHelpers.export(exports, "checksumAddress", ()=>(0, _getAddressJs.checksumAddress));
parcelHelpers.export(exports, "getAddress", ()=>(0, _getAddressJs.getAddress));
parcelHelpers.export(exports, "getContractError", ()=>(0, _getContractErrorJs.getContractError));
parcelHelpers.export(exports, "toEventSelector", ()=>(0, _toEventSelectorJs.toEventSelector));
parcelHelpers.export(exports, "getEventSelector", ()=>(0, _toEventSelectorJs.toEventSelector));
parcelHelpers.export(exports, "toFunctionSelector", ()=>(0, _toFunctionSelectorJs.toFunctionSelector));
parcelHelpers.export(exports, "getFunctionSelector", ()=>(0, _toFunctionSelectorJs.toFunctionSelector));
parcelHelpers.export(exports, "toEventSignature", ()=>(0, _toEventSignatureJs.toEventSignature));
parcelHelpers.export(exports, "getEventSignature", ()=>(0, _toEventSignatureJs.toEventSignature));
parcelHelpers.export(exports, "toFunctionSignature", ()=>(0, _toFunctionSignatureJs.toFunctionSignature));
parcelHelpers.export(exports, "getFunctionSignature", ()=>(0, _toFunctionSignatureJs.toFunctionSignature));
parcelHelpers.export(exports, "toEventHash", ()=>(0, _toEventHashJs.toEventHash));
parcelHelpers.export(exports, "toFunctionHash", ()=>(0, _toFunctionHashJs.toFunctionHash));
parcelHelpers.export(exports, "hashMessage", ()=>(0, _hashMessageJs.hashMessage));
parcelHelpers.export(exports, "toPrefixedMessage", ()=>(0, _toPrefixedMessageJs.toPrefixedMessage));
parcelHelpers.export(exports, "isAddress", ()=>(0, _isAddressJs.isAddress));
parcelHelpers.export(exports, "isAddressEqual", ()=>(0, _isAddressEqualJs.isAddressEqual));
parcelHelpers.export(exports, "isBytes", ()=>(0, _isBytesJs.isBytes));
parcelHelpers.export(exports, "isHash", ()=>(0, _isHashJs.isHash));
parcelHelpers.export(exports, "isHex", ()=>(0, _isHexJs.isHex));
parcelHelpers.export(exports, "keccak256", ()=>(0, _keccak256Js.keccak256));
parcelHelpers.export(exports, "sha256", ()=>(0, _sha256Js.sha256));
parcelHelpers.export(exports, "ripemd160", ()=>(0, _ripemd160Js.ripemd160));
parcelHelpers.export(exports, "pad", ()=>(0, _padJs.pad));
parcelHelpers.export(exports, "padBytes", ()=>(0, _padJs.padBytes));
parcelHelpers.export(exports, "padHex", ()=>(0, _padJs.padHex));
parcelHelpers.export(exports, "parseEther", ()=>(0, _parseEtherJs.parseEther));
parcelHelpers.export(exports, "parseGwei", ()=>(0, _parseGweiJs.parseGwei));
parcelHelpers.export(exports, "parseTransaction", ()=>(0, _parseTransactionJs.parseTransaction));
parcelHelpers.export(exports, "parseUnits", ()=>(0, _parseUnitsJs.parseUnits));
parcelHelpers.export(exports, "serializeAccessList", ()=>(0, _serializeAccessListJs.serializeAccessList));
parcelHelpers.export(exports, "serializeTransaction", ()=>(0, _serializeTransactionJs.serializeTransaction));
parcelHelpers.export(exports, "size", ()=>(0, _sizeJs.size));
parcelHelpers.export(exports, "slice", ()=>(0, _sliceJs.slice));
parcelHelpers.export(exports, "sliceBytes", ()=>(0, _sliceJs.sliceBytes));
parcelHelpers.export(exports, "sliceHex", ()=>(0, _sliceJs.sliceHex));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJs.stringify));
parcelHelpers.export(exports, "trim", ()=>(0, _trimJs.trim));
parcelHelpers.export(exports, "serializeTypedData", ()=>(0, _typedDataJs1.serializeTypedData));
parcelHelpers.export(exports, "validateTypedData", ()=>(0, _typedDataJs1.validateTypedData));
parcelHelpers.export(exports, "domainSeparator", ()=>(0, _typedDataJs1.domainSeparator));
parcelHelpers.export(exports, "getTypesForEIP712Domain", ()=>(0, _typedDataJs1.getTypesForEIP712Domain));
parcelHelpers.export(exports, "createNonceManager", ()=>(0, _nonceManagerJs.createNonceManager));
parcelHelpers.export(exports, "nonceManager", ()=>(0, _nonceManagerJs.nonceManager));
var _abitype = require("abitype");
var _getContractJs = require("./actions/getContract.js");
var _waitForCallsStatusJs = require("./actions/wallet/waitForCallsStatus.js");
var _createClientJs = require("./clients/createClient.js");
var _customJs = require("./clients/transports/custom.js");
var _fallbackJs = require("./clients/transports/fallback.js");
var _httpJs = require("./clients/transports/http.js");
var _createPublicClientJs = require("./clients/createPublicClient.js");
var _createTestClientJs = require("./clients/createTestClient.js");
var _publicJs = require("./clients/decorators/public.js");
var _testJs = require("./clients/decorators/test.js");
var _walletJs = require("./clients/decorators/wallet.js");
var _createTransportJs = require("./clients/transports/createTransport.js");
var _createWalletClientJs = require("./clients/createWalletClient.js");
var _webSocketJs = require("./clients/transports/webSocket.js");
var _abisJs = require("./constants/abis.js");
var _addressJs = require("./constants/address.js");
var _contractsJs = require("./constants/contracts.js");
var _unitJs = require("./constants/unit.js");
var _numberJs = require("./constants/number.js");
var _bytesJs = require("./constants/bytes.js");
var _stringsJs = require("./constants/strings.js");
var _abiJs = require("./errors/abi.js");
var _baseJs = require("./errors/base.js");
var _blockJs = require("./errors/block.js");
var _contractJs = require("./errors/contract.js");
var _feeJs = require("./errors/fee.js");
var _rpcJs = require("./errors/rpc.js");
var _chainJs = require("./errors/chain.js");
var _encodingJs = require("./errors/encoding.js");
var _ensJs = require("./errors/ens.js");
var _unitJs1 = require("./errors/unit.js");
var _estimateGasJs = require("./errors/estimateGas.js");
var _nodeJs = require("./errors/node.js");
var _logJs = require("./errors/log.js");
var _requestJs = require("./errors/request.js");
var _addressJs1 = require("./errors/address.js");
var _transactionJs = require("./errors/transaction.js");
var _dataJs = require("./errors/data.js");
var _transportJs = require("./errors/transport.js");
var _stateOverrideJs = require("./errors/stateOverride.js");
var _typedDataJs = require("./errors/typedData.js");
var _eip1193Js = require("./types/eip1193.js");
var _labelhashJs = require("./utils/ens/labelhash.js");
var _namehashJs = require("./utils/ens/namehash.js");
var _blockJs1 = require("./utils/formatters/block.js");
var _logJs1 = require("./utils/formatters/log.js");
var _decodeAbiParametersJs = require("./utils/abi/decodeAbiParameters.js");
var _decodeDeployDataJs = require("./utils/abi/decodeDeployData.js");
var _decodeErrorResultJs = require("./utils/abi/decodeErrorResult.js");
var _decodeEventLogJs = require("./utils/abi/decodeEventLog.js");
var _decodeFunctionDataJs = require("./utils/abi/decodeFunctionData.js");
var _decodeFunctionResultJs = require("./utils/abi/decodeFunctionResult.js");
var _encodeAbiParametersJs = require("./utils/abi/encodeAbiParameters.js");
var _encodeDeployDataJs = require("./utils/abi/encodeDeployData.js");
var _encodeErrorResultJs = require("./utils/abi/encodeErrorResult.js");
var _encodeEventTopicsJs = require("./utils/abi/encodeEventTopics.js");
var _encodeFunctionDataJs = require("./utils/abi/encodeFunctionData.js");
var _prepareEncodeFunctionDataJs = require("./utils/abi/prepareEncodeFunctionData.js");
var _encodeFunctionResultJs = require("./utils/abi/encodeFunctionResult.js");
var _parseEventLogsJs = require("./utils/abi/parseEventLogs.js");
var _transactionJs1 = require("./utils/formatters/transaction.js");
var _transactionReceiptJs = require("./utils/formatters/transactionReceipt.js");
var _transactionRequestJs = require("./utils/formatters/transactionRequest.js");
var _getAbiItemJs = require("./utils/abi/getAbiItem.js");
var _getContractAddressJs = require("./utils/address/getContractAddress.js");
var _getSerializedTransactionTypeJs = require("./utils/transaction/getSerializedTransactionType.js");
var _getTransactionTypeJs = require("./utils/transaction/getTransactionType.js");
var _hashTypedDataJs = require("./utils/signature/hashTypedData.js");
var _compactSignatureToSignatureJs = require("./utils/signature/compactSignatureToSignature.js");
var _parseCompactSignatureJs = require("./utils/signature/parseCompactSignature.js");
var _parseSignatureJs = require("./utils/signature/parseSignature.js");
var _recoverAddressJs = require("./utils/signature/recoverAddress.js");
var _recoverMessageAddressJs = require("./utils/signature/recoverMessageAddress.js");
var _recoverPublicKeyJs = require("./utils/signature/recoverPublicKey.js");
var _recoverTransactionAddressJs = require("./utils/signature/recoverTransactionAddress.js");
var _recoverTypedDataAddressJs = require("./utils/signature/recoverTypedDataAddress.js");
var _signatureToCompactSignatureJs = require("./utils/signature/signatureToCompactSignature.js");
var _serializeCompactSignatureJs = require("./utils/signature/serializeCompactSignature.js");
var _serializeSignatureJs = require("./utils/signature/serializeSignature.js");
var _toRlpJs = require("./utils/encoding/toRlp.js");
var _verifyHashJs = require("./utils/signature/verifyHash.js");
var _verifyMessageJs = require("./utils/signature/verifyMessage.js");
var _verifyTypedDataJs = require("./utils/signature/verifyTypedData.js");
var _parseErc6492SignatureJs = require("./utils/signature/parseErc6492Signature.js");
var _isErc6492SignatureJs = require("./utils/signature/isErc6492Signature.js");
var _serializeErc6492SignatureJs = require("./utils/signature/serializeErc6492Signature.js");
var _assertRequestJs = require("./utils/transaction/assertRequest.js");
var _assertTransactionJs = require("./utils/transaction/assertTransaction.js");
var _toBytesJs = require("./utils/encoding/toBytes.js");
var _toHexJs = require("./utils/encoding/toHex.js");
var _fromBytesJs = require("./utils/encoding/fromBytes.js");
var _ccipJs = require("./utils/ccip.js");
var _blobsToCommitmentsJs = require("./utils/blob/blobsToCommitments.js");
var _commitmentToVersionedHashJs = require("./utils/blob/commitmentToVersionedHash.js");
var _commitmentsToVersionedHashesJs = require("./utils/blob/commitmentsToVersionedHashes.js");
var _sidecarsToVersionedHashesJs = require("./utils/blob/sidecarsToVersionedHashes.js");
var _blobsToProofsJs = require("./utils/blob/blobsToProofs.js");
var _fromBlobsJs = require("./utils/blob/fromBlobs.js");
var _toBlobSidecarsJs = require("./utils/blob/toBlobSidecars.js");
var _toBlobsJs = require("./utils/blob/toBlobs.js");
var _defineKzgJs = require("./utils/kzg/defineKzg.js");
var _setupKzgJs = require("./utils/kzg/setupKzg.js");
var _concatJs = require("./utils/data/concat.js");
var _assertCurrentChainJs = require("./utils/chain/assertCurrentChain.js");
var _defineChainJs = require("./utils/chain/defineChain.js");
var _extractChainJs = require("./utils/chain/extractChain.js");
var _getChainContractAddressJs = require("./utils/chain/getChainContractAddress.js");
var _encodePackedJs = require("./utils/abi/encodePacked.js");
var _withCacheJs = require("./utils/promise/withCache.js");
var _withRetryJs = require("./utils/promise/withRetry.js");
var _withTimeoutJs = require("./utils/promise/withTimeout.js");
var _formatEtherJs = require("./utils/unit/formatEther.js");
var _formatGweiJs = require("./utils/unit/formatGwei.js");
var _formatUnitsJs = require("./utils/unit/formatUnits.js");
var _fromHexJs = require("./utils/encoding/fromHex.js");
var _fromRlpJs = require("./utils/encoding/fromRlp.js");
var _getAddressJs = require("./utils/address/getAddress.js");
var _getContractErrorJs = require("./utils/errors/getContractError.js");
var _toEventSelectorJs = require("./utils/hash/toEventSelector.js");
var _toFunctionSelectorJs = require("./utils/hash/toFunctionSelector.js");
var _toEventSignatureJs = require("./utils/hash/toEventSignature.js");
var _toFunctionSignatureJs = require("./utils/hash/toFunctionSignature.js");
var _toEventHashJs = require("./utils/hash/toEventHash.js");
var _toFunctionHashJs = require("./utils/hash/toFunctionHash.js");
var _hashMessageJs = require("./utils/signature/hashMessage.js");
var _toPrefixedMessageJs = require("./utils/signature/toPrefixedMessage.js");
var _isAddressJs = require("./utils/address/isAddress.js");
var _isAddressEqualJs = require("./utils/address/isAddressEqual.js");
var _isBytesJs = require("./utils/data/isBytes.js");
var _isHashJs = require("./utils/hash/isHash.js");
var _isHexJs = require("./utils/data/isHex.js");
var _keccak256Js = require("./utils/hash/keccak256.js");
var _sha256Js = require("./utils/hash/sha256.js");
var _ripemd160Js = require("./utils/hash/ripemd160.js");
var _padJs = require("./utils/data/pad.js");
var _parseEtherJs = require("./utils/unit/parseEther.js");
var _parseGweiJs = require("./utils/unit/parseGwei.js");
var _parseTransactionJs = require("./utils/transaction/parseTransaction.js");
var _parseUnitsJs = require("./utils/unit/parseUnits.js");
var _serializeAccessListJs = require("./utils/transaction/serializeAccessList.js");
var _serializeTransactionJs = require("./utils/transaction/serializeTransaction.js");
var _sizeJs = require("./utils/data/size.js");
var _sliceJs = require("./utils/data/slice.js");
var _stringifyJs = require("./utils/stringify.js");
var _trimJs = require("./utils/data/trim.js");
var _typedDataJs1 = require("./utils/typedData.js");
var _nonceManagerJs = require("./utils/nonceManager.js");

},{"abitype":"6tgJn","./actions/getContract.js":"ah6Mx","./actions/wallet/waitForCallsStatus.js":"hSeJ1","./clients/createClient.js":"7sQFR","./clients/transports/custom.js":"fYXkb","./clients/transports/fallback.js":"f3fvY","./clients/transports/http.js":"hTPjl","./clients/createPublicClient.js":"b5Nfq","./clients/createTestClient.js":"k9AuU","./clients/decorators/public.js":"tXTJF","./clients/decorators/test.js":"fJO79","./clients/decorators/wallet.js":"6yK4d","./clients/transports/createTransport.js":"cK0QC","./clients/createWalletClient.js":"2a2ks","./clients/transports/webSocket.js":"3CJeJ","./constants/abis.js":"ffwQK","./constants/address.js":"gjADG","./constants/contracts.js":"3uCwC","./constants/unit.js":"GgDwZ","./constants/number.js":"4KokG","./constants/bytes.js":"gVXXw","./constants/strings.js":"3bCKG","./errors/abi.js":"7l8j7","./errors/base.js":"3SEPF","./errors/block.js":"iTpgp","./errors/contract.js":"1S92K","./errors/fee.js":"2IQlm","./errors/rpc.js":"jYSPv","./errors/chain.js":"hiOFa","./errors/encoding.js":"45Fmz","./errors/ens.js":"7GanX","./errors/unit.js":"7gJBF","./errors/estimateGas.js":"ae9wC","./errors/node.js":"9Ytun","./errors/log.js":"8NWDn","./errors/request.js":"6LYvf","./errors/address.js":"17VWr","./errors/transaction.js":"4gFzr","./errors/data.js":"kBfpj","./errors/transport.js":"gIsZQ","./errors/stateOverride.js":"3GdPa","./errors/typedData.js":"5Thdu","./types/eip1193.js":"jlvfC","./utils/ens/labelhash.js":"ebwrf","./utils/ens/namehash.js":"exJTH","./utils/formatters/block.js":"kJKKG","./utils/formatters/log.js":"aaYKq","./utils/abi/decodeAbiParameters.js":"hR5FN","./utils/abi/decodeDeployData.js":"4BWEN","./utils/abi/decodeErrorResult.js":"kFalj","./utils/abi/decodeEventLog.js":"8uUoF","./utils/abi/decodeFunctionData.js":"lrq8I","./utils/abi/decodeFunctionResult.js":"j76hM","./utils/abi/encodeAbiParameters.js":"8kHRc","./utils/abi/encodeDeployData.js":"55weO","./utils/abi/encodeErrorResult.js":"6ieIf","./utils/abi/encodeEventTopics.js":"7zHy3","./utils/abi/encodeFunctionData.js":"eQLEb","./utils/abi/prepareEncodeFunctionData.js":"8U0DY","./utils/abi/encodeFunctionResult.js":"fKV1m","./utils/abi/parseEventLogs.js":"3coRk","./utils/formatters/transaction.js":"dhAxe","./utils/formatters/transactionReceipt.js":"1XqTn","./utils/formatters/transactionRequest.js":"dLljr","./utils/abi/getAbiItem.js":"k6BVB","./utils/address/getContractAddress.js":"drHbc","./utils/transaction/getSerializedTransactionType.js":"jYgXM","./utils/transaction/getTransactionType.js":"2MIAC","./utils/signature/hashTypedData.js":"efmTs","./utils/signature/compactSignatureToSignature.js":"1OqbS","./utils/signature/parseCompactSignature.js":"5pPuk","./utils/signature/parseSignature.js":"a2WwA","./utils/signature/recoverAddress.js":"gBtnk","./utils/signature/recoverMessageAddress.js":"7c8Ag","./utils/signature/recoverPublicKey.js":"lLPoN","./utils/signature/recoverTransactionAddress.js":"9lNOC","./utils/signature/recoverTypedDataAddress.js":"gIg5J","./utils/signature/signatureToCompactSignature.js":"koUXF","./utils/signature/serializeCompactSignature.js":"5LzHY","./utils/signature/serializeSignature.js":"3zSx4","./utils/encoding/toRlp.js":"7jPJy","./utils/signature/verifyHash.js":"fuF8L","./utils/signature/verifyMessage.js":"1Nrm7","./utils/signature/verifyTypedData.js":"cHRUy","./utils/signature/parseErc6492Signature.js":"jdT8c","./utils/signature/isErc6492Signature.js":"gaUAz","./utils/signature/serializeErc6492Signature.js":"4KJdz","./utils/transaction/assertRequest.js":"eSiKr","./utils/transaction/assertTransaction.js":"4466I","./utils/encoding/toBytes.js":"8cx1T","./utils/encoding/toHex.js":"9GFC6","./utils/encoding/fromBytes.js":"dY2Xd","./utils/ccip.js":"1rHaX","./utils/blob/blobsToCommitments.js":"lGkWy","./utils/blob/commitmentToVersionedHash.js":"cAPDC","./utils/blob/commitmentsToVersionedHashes.js":"hAdbt","./utils/blob/sidecarsToVersionedHashes.js":"bw1TC","./utils/blob/blobsToProofs.js":"82xng","./utils/blob/fromBlobs.js":"4Wzbt","./utils/blob/toBlobSidecars.js":"iLFBZ","./utils/blob/toBlobs.js":"f9lGV","./utils/kzg/defineKzg.js":"lK8hy","./utils/kzg/setupKzg.js":"f2dU5","./utils/data/concat.js":"6FL5K","./utils/chain/assertCurrentChain.js":"g3OLr","./utils/chain/defineChain.js":"6ZWYk","./utils/chain/extractChain.js":"gNS63","./utils/chain/getChainContractAddress.js":"cNh6w","./utils/abi/encodePacked.js":"11WHb","./utils/promise/withCache.js":"7jin2","./utils/promise/withRetry.js":"3qWqJ","./utils/promise/withTimeout.js":"cETnG","./utils/unit/formatEther.js":"d8qm6","./utils/unit/formatGwei.js":"2vNTy","./utils/unit/formatUnits.js":"jtBPD","./utils/encoding/fromHex.js":"kLfW5","./utils/encoding/fromRlp.js":"4G3aP","./utils/address/getAddress.js":"aGHEi","./utils/errors/getContractError.js":"kESZV","./utils/hash/toEventSelector.js":"4FcAp","./utils/hash/toFunctionSelector.js":"7CpcI","./utils/hash/toEventSignature.js":"3rY9Y","./utils/hash/toFunctionSignature.js":"3tfWZ","./utils/hash/toEventHash.js":"fKDVF","./utils/hash/toFunctionHash.js":"g3FGI","./utils/signature/hashMessage.js":"5oFnZ","./utils/signature/toPrefixedMessage.js":"apapX","./utils/address/isAddress.js":"kdAuv","./utils/address/isAddressEqual.js":"lW8Gp","./utils/data/isBytes.js":"kWPYQ","./utils/hash/isHash.js":"dQrWx","./utils/data/isHex.js":"evOcm","./utils/hash/keccak256.js":"k4CmV","./utils/hash/sha256.js":"6D13u","./utils/hash/ripemd160.js":"c2yQI","./utils/data/pad.js":"aAjQN","./utils/unit/parseEther.js":"SUgRq","./utils/unit/parseGwei.js":"hkYek","./utils/transaction/parseTransaction.js":"a0tzY","./utils/unit/parseUnits.js":"iISUq","./utils/transaction/serializeAccessList.js":"3Pxwu","./utils/transaction/serializeTransaction.js":"eYYNO","./utils/data/size.js":"exELm","./utils/data/slice.js":"hh6kq","./utils/stringify.js":"jKcjI","./utils/data/trim.js":"3ZmMy","./utils/typedData.js":"bBGXA","./utils/nonceManager.js":"9LOeC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6tgJn":[function(require,module,exports,__globalThis) {
// biome-ignore lint/performance/noBarrelFile: <explanation>
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseError", ()=>(0, _errorsJs.BaseError));
parcelHelpers.export(exports, "narrow", ()=>(0, _narrowJs.narrow));
////////////////////////////////////////////////////////////////////////////////////////////////////
// Human-Readable
parcelHelpers.export(exports, "formatAbi", ()=>(0, _formatAbiJs.formatAbi));
parcelHelpers.export(exports, "formatAbiItem", ()=>(0, _formatAbiItemJs.formatAbiItem));
parcelHelpers.export(exports, "formatAbiParameter", ()=>(0, _formatAbiParameterJs.formatAbiParameter));
parcelHelpers.export(exports, "formatAbiParameters", ()=>(0, _formatAbiParametersJs.formatAbiParameters));
parcelHelpers.export(exports, "parseAbi", ()=>(0, _parseAbiJs.parseAbi));
parcelHelpers.export(exports, "parseAbiItem", ()=>(0, _parseAbiItemJs.parseAbiItem));
parcelHelpers.export(exports, "parseAbiParameter", ()=>(0, _parseAbiParameterJs.parseAbiParameter));
parcelHelpers.export(exports, "parseAbiParameters", ()=>(0, _parseAbiParametersJs.parseAbiParameters));
parcelHelpers.export(exports, "UnknownTypeError", ()=>(0, _abiItemJs.UnknownTypeError));
parcelHelpers.export(exports, "InvalidAbiItemError", ()=>(0, _abiItemJs.InvalidAbiItemError));
parcelHelpers.export(exports, "UnknownSolidityTypeError", ()=>(0, _abiItemJs.UnknownSolidityTypeError));
parcelHelpers.export(exports, "InvalidAbiTypeParameterError", ()=>(0, _abiParameterJs.InvalidAbiTypeParameterError));
parcelHelpers.export(exports, "InvalidFunctionModifierError", ()=>(0, _abiParameterJs.InvalidFunctionModifierError));
parcelHelpers.export(exports, "InvalidModifierError", ()=>(0, _abiParameterJs.InvalidModifierError));
parcelHelpers.export(exports, "SolidityProtectedKeywordError", ()=>(0, _abiParameterJs.SolidityProtectedKeywordError));
parcelHelpers.export(exports, "InvalidParameterError", ()=>(0, _abiParameterJs.InvalidParameterError));
parcelHelpers.export(exports, "InvalidAbiParametersError", ()=>(0, _abiParameterJs.InvalidAbiParametersError));
parcelHelpers.export(exports, "InvalidAbiParameterError", ()=>(0, _abiParameterJs.InvalidAbiParameterError));
parcelHelpers.export(exports, "InvalidStructSignatureError", ()=>(0, _signatureJs.InvalidStructSignatureError));
parcelHelpers.export(exports, "InvalidSignatureError", ()=>(0, _signatureJs.InvalidSignatureError));
parcelHelpers.export(exports, "UnknownSignatureError", ()=>(0, _signatureJs.UnknownSignatureError));
parcelHelpers.export(exports, "InvalidParenthesisError", ()=>(0, _splitParametersJs.InvalidParenthesisError));
parcelHelpers.export(exports, "CircularReferenceError", ()=>(0, _structJs.CircularReferenceError));
var _errorsJs = require("../errors.js");
var _narrowJs = require("../narrow.js");
var _formatAbiJs = require("../human-readable/formatAbi.js");
var _formatAbiItemJs = require("../human-readable/formatAbiItem.js");
var _formatAbiParameterJs = require("../human-readable/formatAbiParameter.js");
var _formatAbiParametersJs = require("../human-readable/formatAbiParameters.js");
var _parseAbiJs = require("../human-readable/parseAbi.js");
var _parseAbiItemJs = require("../human-readable/parseAbiItem.js");
var _parseAbiParameterJs = require("../human-readable/parseAbiParameter.js");
var _parseAbiParametersJs = require("../human-readable/parseAbiParameters.js");
var _abiItemJs = require("../human-readable/errors/abiItem.js");
var _abiParameterJs = require("../human-readable/errors/abiParameter.js");
var _signatureJs = require("../human-readable/errors/signature.js");
var _splitParametersJs = require("../human-readable/errors/splitParameters.js");
var _structJs = require("../human-readable/errors/struct.js");

},{"../errors.js":"91ZjA","../narrow.js":"eeZ6t","../human-readable/formatAbi.js":"33X8x","../human-readable/formatAbiItem.js":"7EAiN","../human-readable/formatAbiParameter.js":"33brF","../human-readable/formatAbiParameters.js":"8MhCq","../human-readable/parseAbi.js":"6KqUo","../human-readable/parseAbiItem.js":"04ScK","../human-readable/parseAbiParameter.js":"7ExiQ","../human-readable/parseAbiParameters.js":"2czdL","../human-readable/errors/abiItem.js":"hAazE","../human-readable/errors/abiParameter.js":"ahbTP","../human-readable/errors/signature.js":"e8F7Q","../human-readable/errors/splitParameters.js":"b0XfC","../human-readable/errors/struct.js":"kapZM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"91ZjA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseError", ()=>BaseError);
var _versionJs = require("./version.js");
class BaseError extends Error {
    constructor(shortMessage, args = {}){
        const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
        const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
        const message = [
            shortMessage || 'An error occurred.',
            '',
            ...args.metaMessages ? [
                ...args.metaMessages,
                ''
            ] : [],
            ...docsPath ? [
                `Docs: https://abitype.dev${docsPath}`
            ] : [],
            ...details ? [
                `Details: ${details}`
            ] : [],
            `Version: abitype@${(0, _versionJs.version)}`
        ].join('\n');
        super(message);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiTypeError'
        });
        if (args.cause) this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
    }
}

},{"./version.js":"c0ZRT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c0ZRT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = '1.0.8';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eeZ6t":[function(require,module,exports,__globalThis) {
/**
 * Infers embedded primitive type of any type
 * Same as `as const` but without setting the object as readonly and without needing the user to use it.
 *
 * @param value - Value to infer
 * @returns Value with embedded type inferred
 *
 * @example
 * const result = narrow(['foo', 'bar', 1])
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "narrow", ()=>narrow);
function narrow(value) {
    return value;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"33X8x":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parses JSON ABI into human-readable ABI
 *
 * @param abi - ABI
 * @returns Human-readable ABI
 */ parcelHelpers.export(exports, "formatAbi", ()=>formatAbi);
var _formatAbiItemJs = require("./formatAbiItem.js");
function formatAbi(abi) {
    const signatures = [];
    const length = abi.length;
    for(let i = 0; i < length; i++){
        const abiItem = abi[i];
        const signature = (0, _formatAbiItemJs.formatAbiItem)(abiItem);
        signatures.push(signature);
    }
    return signatures;
}

},{"./formatAbiItem.js":"7EAiN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7EAiN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Formats ABI item (e.g. error, event, function) into human-readable ABI item
 *
 * @param abiItem - ABI item
 * @returns Human-readable ABI item
 */ parcelHelpers.export(exports, "formatAbiItem", ()=>formatAbiItem);
var _formatAbiParametersJs = require("./formatAbiParameters.js");
function formatAbiItem(abiItem) {
    if (abiItem.type === 'function') return `function ${abiItem.name}(${(0, _formatAbiParametersJs.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable' ? ` ${abiItem.stateMutability}` : ''}${abiItem.outputs?.length ? ` returns (${(0, _formatAbiParametersJs.formatAbiParameters)(abiItem.outputs)})` : ''}`;
    if (abiItem.type === 'event') return `event ${abiItem.name}(${(0, _formatAbiParametersJs.formatAbiParameters)(abiItem.inputs)})`;
    if (abiItem.type === 'error') return `error ${abiItem.name}(${(0, _formatAbiParametersJs.formatAbiParameters)(abiItem.inputs)})`;
    if (abiItem.type === 'constructor') return `constructor(${(0, _formatAbiParametersJs.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
    if (abiItem.type === 'fallback') return `fallback() external${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
    return 'receive() external payable';
}

},{"./formatAbiParameters.js":"8MhCq","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8MhCq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Formats {@link AbiParameter}s to human-readable ABI parameters.
 *
 * @param abiParameters - ABI parameters
 * @returns Human-readable ABI parameters
 *
 * @example
 * const result = formatAbiParameters([
 *   //  ^? const result: 'address from, uint256 tokenId'
 *   { type: 'address', name: 'from' },
 *   { type: 'uint256', name: 'tokenId' },
 * ])
 */ parcelHelpers.export(exports, "formatAbiParameters", ()=>formatAbiParameters);
var _formatAbiParameterJs = require("./formatAbiParameter.js");
function formatAbiParameters(abiParameters) {
    let params = '';
    const length = abiParameters.length;
    for(let i = 0; i < length; i++){
        const abiParameter = abiParameters[i];
        params += (0, _formatAbiParameterJs.formatAbiParameter)(abiParameter);
        if (i !== length - 1) params += ', ';
    }
    return params;
}

},{"./formatAbiParameter.js":"33brF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"33brF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Formats {@link AbiParameter} to human-readable ABI parameter.
 *
 * @param abiParameter - ABI parameter
 * @returns Human-readable ABI parameter
 *
 * @example
 * const result = formatAbiParameter({ type: 'address', name: 'from' })
 * //    ^? const result: 'address from'
 */ parcelHelpers.export(exports, "formatAbiParameter", ()=>formatAbiParameter);
var _regexJs = require("../regex.js");
// https://regexr.com/7f7rv
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter) {
    let type = abiParameter.type;
    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {
        type = '(';
        const length = abiParameter.components.length;
        for(let i = 0; i < length; i++){
            const component = abiParameter.components[i];
            type += formatAbiParameter(component);
            if (i < length - 1) type += ', ';
        }
        const result = (0, _regexJs.execTyped)(tupleRegex, abiParameter.type);
        type += `)${result?.array ?? ''}`;
        return formatAbiParameter({
            ...abiParameter,
            type
        });
    }
    // Add `indexed` to type if in `abiParameter`
    if ('indexed' in abiParameter && abiParameter.indexed) type = `${type} indexed`;
    // Return human-readable ABI parameter
    if (abiParameter.name) return `${type} ${abiParameter.name}`;
    return type;
}

},{"../regex.js":"f23nz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f23nz":[function(require,module,exports,__globalThis) {
// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.
// https://twitter.com/GabrielVergnaud/status/1622906834343366657
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "execTyped", ()=>execTyped);
parcelHelpers.export(exports, "bytesRegex", ()=>bytesRegex);
parcelHelpers.export(exports, "integerRegex", ()=>integerRegex);
parcelHelpers.export(exports, "isTupleRegex", ()=>isTupleRegex);
function execTyped(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
}
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
const isTupleRegex = /^\(.+?\).*?$/;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6KqUo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parses human-readable ABI into JSON {@link Abi}
 *
 * @param signatures - Human-Readable ABI
 * @returns Parsed {@link Abi}
 *
 * @example
 * const abi = parseAbi([
 *   //  ^? const abi: readonly [{ name: "balanceOf"; type: "function"; stateMutability:...
 *   'function balanceOf(address owner) view returns (uint256)',
 *   'event Transfer(address indexed from, address indexed to, uint256 amount)',
 * ])
 */ parcelHelpers.export(exports, "parseAbi", ()=>parseAbi);
var _signaturesJs = require("./runtime/signatures.js");
var _structsJs = require("./runtime/structs.js");
var _utilsJs = require("./runtime/utils.js");
function parseAbi(signatures) {
    const structs = (0, _structsJs.parseStructs)(signatures);
    const abi = [];
    const length = signatures.length;
    for(let i = 0; i < length; i++){
        const signature = signatures[i];
        if ((0, _signaturesJs.isStructSignature)(signature)) continue;
        abi.push((0, _utilsJs.parseSignature)(signature, structs));
    }
    return abi;
}

},{"./runtime/signatures.js":"fxDjg","./runtime/structs.js":"8E8vy","./runtime/utils.js":"5pgja","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fxDjg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isErrorSignature", ()=>isErrorSignature);
parcelHelpers.export(exports, "execErrorSignature", ()=>execErrorSignature);
parcelHelpers.export(exports, "isEventSignature", ()=>isEventSignature);
parcelHelpers.export(exports, "execEventSignature", ()=>execEventSignature);
parcelHelpers.export(exports, "isFunctionSignature", ()=>isFunctionSignature);
parcelHelpers.export(exports, "execFunctionSignature", ()=>execFunctionSignature);
parcelHelpers.export(exports, "isStructSignature", ()=>isStructSignature);
parcelHelpers.export(exports, "execStructSignature", ()=>execStructSignature);
parcelHelpers.export(exports, "isConstructorSignature", ()=>isConstructorSignature);
parcelHelpers.export(exports, "execConstructorSignature", ()=>execConstructorSignature);
parcelHelpers.export(exports, "isFallbackSignature", ()=>isFallbackSignature);
parcelHelpers.export(exports, "execFallbackSignature", ()=>execFallbackSignature);
parcelHelpers.export(exports, "isReceiveSignature", ()=>isReceiveSignature);
parcelHelpers.export(exports, "modifiers", ()=>modifiers);
parcelHelpers.export(exports, "eventModifiers", ()=>eventModifiers);
parcelHelpers.export(exports, "functionModifiers", ()=>functionModifiers);
var _regexJs = require("../../regex.js");
// https://regexr.com/7gmok
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(signature) {
    return errorSignatureRegex.test(signature);
}
function execErrorSignature(signature) {
    return (0, _regexJs.execTyped)(errorSignatureRegex, signature);
}
// https://regexr.com/7gmoq
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(signature) {
    return eventSignatureRegex.test(signature);
}
function execEventSignature(signature) {
    return (0, _regexJs.execTyped)(eventSignatureRegex, signature);
}
// https://regexr.com/7gmot
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(signature) {
    return functionSignatureRegex.test(signature);
}
function execFunctionSignature(signature) {
    return (0, _regexJs.execTyped)(functionSignatureRegex, signature);
}
// https://regexr.com/7gmp3
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(signature) {
    return structSignatureRegex.test(signature);
}
function execStructSignature(signature) {
    return (0, _regexJs.execTyped)(structSignatureRegex, signature);
}
// https://regexr.com/78u01
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(signature) {
    return constructorSignatureRegex.test(signature);
}
function execConstructorSignature(signature) {
    return (0, _regexJs.execTyped)(constructorSignatureRegex, signature);
}
// https://regexr.com/7srtn
const fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function isFallbackSignature(signature) {
    return fallbackSignatureRegex.test(signature);
}
function execFallbackSignature(signature) {
    return (0, _regexJs.execTyped)(fallbackSignatureRegex, signature);
}
// https://regexr.com/78u1k
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(signature) {
    return receiveSignatureRegex.test(signature);
}
const modifiers = new Set([
    'memory',
    'indexed',
    'storage',
    'calldata'
]);
const eventModifiers = new Set([
    'indexed'
]);
const functionModifiers = new Set([
    'calldata',
    'memory',
    'storage'
]);

},{"../../regex.js":"f23nz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8E8vy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseStructs", ()=>parseStructs);
var _regexJs = require("../../regex.js");
var _abiItemJs = require("../errors/abiItem.js");
var _abiParameterJs = require("../errors/abiParameter.js");
var _signatureJs = require("../errors/signature.js");
var _structJs = require("../errors/struct.js");
var _signaturesJs = require("./signatures.js");
var _utilsJs = require("./utils.js");
function parseStructs(signatures) {
    // Create "shallow" version of each struct (and filter out non-structs or invalid structs)
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for(let i = 0; i < signaturesLength; i++){
        const signature = signatures[i];
        if (!(0, _signaturesJs.isStructSignature)(signature)) continue;
        const match = (0, _signaturesJs.execStructSignature)(signature);
        if (!match) throw new (0, _signatureJs.InvalidSignatureError)({
            signature,
            type: 'struct'
        });
        const properties = match.properties.split(';');
        const components = [];
        const propertiesLength = properties.length;
        for(let k = 0; k < propertiesLength; k++){
            const property = properties[k];
            const trimmed = property.trim();
            if (!trimmed) continue;
            const abiParameter = (0, _utilsJs.parseAbiParameter)(trimmed, {
                type: 'struct'
            });
            components.push(abiParameter);
        }
        if (!components.length) throw new (0, _signatureJs.InvalidStructSignatureError)({
            signature
        });
        shallowStructs[match.name] = components;
    }
    // Resolve nested structs inside each parameter
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for(let i = 0; i < entriesLength; i++){
        const [name, parameters] = entries[i];
        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
}
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(abiParameters, structs, ancestors = new Set()) {
    const components = [];
    const length = abiParameters.length;
    for(let i = 0; i < length; i++){
        const abiParameter = abiParameters[i];
        const isTuple = (0, _regexJs.isTupleRegex).test(abiParameter.type);
        if (isTuple) components.push(abiParameter);
        else {
            const match = (0, _regexJs.execTyped)(typeWithoutTupleRegex, abiParameter.type);
            if (!match?.type) throw new (0, _abiParameterJs.InvalidAbiTypeParameterError)({
                abiParameter
            });
            const { array, type } = match;
            if (type in structs) {
                if (ancestors.has(type)) throw new (0, _structJs.CircularReferenceError)({
                    type
                });
                components.push({
                    ...abiParameter,
                    type: `tuple${array ?? ''}`,
                    components: resolveStructs(structs[type] ?? [], structs, new Set([
                        ...ancestors,
                        type
                    ]))
                });
            } else {
                if ((0, _utilsJs.isSolidityType)(type)) components.push(abiParameter);
                else throw new (0, _abiItemJs.UnknownTypeError)({
                    type
                });
            }
        }
    }
    return components;
}

},{"../../regex.js":"f23nz","../errors/abiItem.js":"hAazE","../errors/abiParameter.js":"ahbTP","../errors/signature.js":"e8F7Q","../errors/struct.js":"kapZM","./signatures.js":"fxDjg","./utils.js":"5pgja","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hAazE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InvalidAbiItemError", ()=>InvalidAbiItemError);
parcelHelpers.export(exports, "UnknownTypeError", ()=>UnknownTypeError);
parcelHelpers.export(exports, "UnknownSolidityTypeError", ()=>UnknownSolidityTypeError);
var _errorsJs = require("../../errors.js");
class InvalidAbiItemError extends (0, _errorsJs.BaseError) {
    constructor({ signature }){
        super('Failed to parse ABI item.', {
            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
            docsPath: '/api/human#parseabiitem-1'
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiItemError'
        });
    }
}
class UnknownTypeError extends (0, _errorsJs.BaseError) {
    constructor({ type }){
        super('Unknown type.', {
            metaMessages: [
                `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownTypeError'
        });
    }
}
class UnknownSolidityTypeError extends (0, _errorsJs.BaseError) {
    constructor({ type }){
        super('Unknown type.', {
            metaMessages: [
                `Type "${type}" is not a valid ABI type.`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownSolidityTypeError'
        });
    }
}

},{"../../errors.js":"91ZjA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ahbTP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InvalidAbiParameterError", ()=>InvalidAbiParameterError);
parcelHelpers.export(exports, "InvalidAbiParametersError", ()=>InvalidAbiParametersError);
parcelHelpers.export(exports, "InvalidParameterError", ()=>InvalidParameterError);
parcelHelpers.export(exports, "SolidityProtectedKeywordError", ()=>SolidityProtectedKeywordError);
parcelHelpers.export(exports, "InvalidModifierError", ()=>InvalidModifierError);
parcelHelpers.export(exports, "InvalidFunctionModifierError", ()=>InvalidFunctionModifierError);
parcelHelpers.export(exports, "InvalidAbiTypeParameterError", ()=>InvalidAbiTypeParameterError);
var _errorsJs = require("../../errors.js");
class InvalidAbiParameterError extends (0, _errorsJs.BaseError) {
    constructor({ param }){
        super('Failed to parse ABI parameter.', {
            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
            docsPath: '/api/human#parseabiparameter-1'
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiParameterError'
        });
    }
}
class InvalidAbiParametersError extends (0, _errorsJs.BaseError) {
    constructor({ params }){
        super('Failed to parse ABI parameters.', {
            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
            docsPath: '/api/human#parseabiparameters-1'
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiParametersError'
        });
    }
}
class InvalidParameterError extends (0, _errorsJs.BaseError) {
    constructor({ param }){
        super('Invalid ABI parameter.', {
            details: param
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidParameterError'
        });
    }
}
class SolidityProtectedKeywordError extends (0, _errorsJs.BaseError) {
    constructor({ param, name }){
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'SolidityProtectedKeywordError'
        });
    }
}
class InvalidModifierError extends (0, _errorsJs.BaseError) {
    constructor({ param, type, modifier }){
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidModifierError'
        });
    }
}
class InvalidFunctionModifierError extends (0, _errorsJs.BaseError) {
    constructor({ param, type, modifier }){
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`,
                `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidFunctionModifierError'
        });
    }
}
class InvalidAbiTypeParameterError extends (0, _errorsJs.BaseError) {
    constructor({ abiParameter }){
        super('Invalid ABI parameter.', {
            details: JSON.stringify(abiParameter, null, 2),
            metaMessages: [
                'ABI parameter type is invalid.'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiTypeParameterError'
        });
    }
}

},{"../../errors.js":"91ZjA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e8F7Q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InvalidSignatureError", ()=>InvalidSignatureError);
parcelHelpers.export(exports, "UnknownSignatureError", ()=>UnknownSignatureError);
parcelHelpers.export(exports, "InvalidStructSignatureError", ()=>InvalidStructSignatureError);
var _errorsJs = require("../../errors.js");
class InvalidSignatureError extends (0, _errorsJs.BaseError) {
    constructor({ signature, type }){
        super(`Invalid ${type} signature.`, {
            details: signature
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidSignatureError'
        });
    }
}
class UnknownSignatureError extends (0, _errorsJs.BaseError) {
    constructor({ signature }){
        super('Unknown signature.', {
            details: signature
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownSignatureError'
        });
    }
}
class InvalidStructSignatureError extends (0, _errorsJs.BaseError) {
    constructor({ signature }){
        super('Invalid struct signature.', {
            details: signature,
            metaMessages: [
                'No properties exist.'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidStructSignatureError'
        });
    }
}

},{"../../errors.js":"91ZjA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kapZM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CircularReferenceError", ()=>CircularReferenceError);
var _errorsJs = require("../../errors.js");
class CircularReferenceError extends (0, _errorsJs.BaseError) {
    constructor({ type }){
        super('Circular reference detected.', {
            metaMessages: [
                `Struct "${type}" is a circular reference.`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'CircularReferenceError'
        });
    }
}

},{"../../errors.js":"91ZjA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5pgja":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseSignature", ()=>parseSignature);
parcelHelpers.export(exports, "parseFunctionSignature", ()=>parseFunctionSignature);
parcelHelpers.export(exports, "parseEventSignature", ()=>parseEventSignature);
parcelHelpers.export(exports, "parseErrorSignature", ()=>parseErrorSignature);
parcelHelpers.export(exports, "parseConstructorSignature", ()=>parseConstructorSignature);
parcelHelpers.export(exports, "parseFallbackSignature", ()=>parseFallbackSignature);
parcelHelpers.export(exports, "parseAbiParameter", ()=>parseAbiParameter);
// s/o latika for this
parcelHelpers.export(exports, "splitParameters", ()=>splitParameters);
parcelHelpers.export(exports, "isSolidityType", ()=>isSolidityType);
/** @internal */ parcelHelpers.export(exports, "isSolidityKeyword", ()=>isSolidityKeyword);
/** @internal */ parcelHelpers.export(exports, "isValidDataLocation", ()=>isValidDataLocation);
var _regexJs = require("../../regex.js");
var _abiItemJs = require("../errors/abiItem.js");
var _abiParameterJs = require("../errors/abiParameter.js");
var _signatureJs = require("../errors/signature.js");
var _splitParametersJs = require("../errors/splitParameters.js");
var _cacheJs = require("./cache.js");
var _signaturesJs = require("./signatures.js");
function parseSignature(signature, structs = {}) {
    if ((0, _signaturesJs.isFunctionSignature)(signature)) return parseFunctionSignature(signature, structs);
    if ((0, _signaturesJs.isEventSignature)(signature)) return parseEventSignature(signature, structs);
    if ((0, _signaturesJs.isErrorSignature)(signature)) return parseErrorSignature(signature, structs);
    if ((0, _signaturesJs.isConstructorSignature)(signature)) return parseConstructorSignature(signature, structs);
    if ((0, _signaturesJs.isFallbackSignature)(signature)) return parseFallbackSignature(signature);
    if ((0, _signaturesJs.isReceiveSignature)(signature)) return {
        type: 'receive',
        stateMutability: 'payable'
    };
    throw new (0, _signatureJs.UnknownSignatureError)({
        signature
    });
}
function parseFunctionSignature(signature, structs = {}) {
    const match = (0, _signaturesJs.execFunctionSignature)(signature);
    if (!match) throw new (0, _signatureJs.InvalidSignatureError)({
        signature,
        type: 'function'
    });
    const inputParams = splitParameters(match.parameters);
    const inputs = [];
    const inputLength = inputParams.length;
    for(let i = 0; i < inputLength; i++)inputs.push(parseAbiParameter(inputParams[i], {
        modifiers: (0, _signaturesJs.functionModifiers),
        structs,
        type: 'function'
    }));
    const outputs = [];
    if (match.returns) {
        const outputParams = splitParameters(match.returns);
        const outputLength = outputParams.length;
        for(let i = 0; i < outputLength; i++)outputs.push(parseAbiParameter(outputParams[i], {
            modifiers: (0, _signaturesJs.functionModifiers),
            structs,
            type: 'function'
        }));
    }
    return {
        name: match.name,
        type: 'function',
        stateMutability: match.stateMutability ?? 'nonpayable',
        inputs,
        outputs
    };
}
function parseEventSignature(signature, structs = {}) {
    const match = (0, _signaturesJs.execEventSignature)(signature);
    if (!match) throw new (0, _signatureJs.InvalidSignatureError)({
        signature,
        type: 'event'
    });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for(let i = 0; i < length; i++)abiParameters.push(parseAbiParameter(params[i], {
        modifiers: (0, _signaturesJs.eventModifiers),
        structs,
        type: 'event'
    }));
    return {
        name: match.name,
        type: 'event',
        inputs: abiParameters
    };
}
function parseErrorSignature(signature, structs = {}) {
    const match = (0, _signaturesJs.execErrorSignature)(signature);
    if (!match) throw new (0, _signatureJs.InvalidSignatureError)({
        signature,
        type: 'error'
    });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for(let i = 0; i < length; i++)abiParameters.push(parseAbiParameter(params[i], {
        structs,
        type: 'error'
    }));
    return {
        name: match.name,
        type: 'error',
        inputs: abiParameters
    };
}
function parseConstructorSignature(signature, structs = {}) {
    const match = (0, _signaturesJs.execConstructorSignature)(signature);
    if (!match) throw new (0, _signatureJs.InvalidSignatureError)({
        signature,
        type: 'constructor'
    });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for(let i = 0; i < length; i++)abiParameters.push(parseAbiParameter(params[i], {
        structs,
        type: 'constructor'
    }));
    return {
        type: 'constructor',
        stateMutability: match.stateMutability ?? 'nonpayable',
        inputs: abiParameters
    };
}
function parseFallbackSignature(signature) {
    const match = (0, _signaturesJs.execFallbackSignature)(signature);
    if (!match) throw new (0, _signatureJs.InvalidSignatureError)({
        signature,
        type: 'fallback'
    });
    return {
        type: 'fallback',
        stateMutability: match.stateMutability ?? 'nonpayable'
    };
}
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(param, options) {
    // optional namespace cache by `type`
    const parameterCacheKey = (0, _cacheJs.getParameterCacheKey)(param, options?.type, options?.structs);
    if ((0, _cacheJs.parameterCache).has(parameterCacheKey)) return (0, _cacheJs.parameterCache).get(parameterCacheKey);
    const isTuple = (0, _regexJs.isTupleRegex).test(param);
    const match = (0, _regexJs.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match) throw new (0, _abiParameterJs.InvalidParameterError)({
        param
    });
    if (match.name && isSolidityKeyword(match.name)) throw new (0, _abiParameterJs.SolidityProtectedKeywordError)({
        param,
        name: match.name
    });
    const name = match.name ? {
        name: match.name
    } : {};
    const indexed = match.modifier === 'indexed' ? {
        indexed: true
    } : {};
    const structs = options?.structs ?? {};
    let type;
    let components = {};
    if (isTuple) {
        type = 'tuple';
        const params = splitParameters(match.type);
        const components_ = [];
        const length = params.length;
        for(let i = 0; i < length; i++)// remove `modifiers` from `options` to prevent from being added to tuple components
        components_.push(parseAbiParameter(params[i], {
            structs
        }));
        components = {
            components: components_
        };
    } else if (match.type in structs) {
        type = 'tuple';
        components = {
            components: structs[match.type]
        };
    } else if (dynamicIntegerRegex.test(match.type)) type = `${match.type}256`;
    else {
        type = match.type;
        if (!(options?.type === 'struct') && !isSolidityType(type)) throw new (0, _abiItemJs.UnknownSolidityTypeError)({
            type
        });
    }
    if (match.modifier) {
        // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)
        if (!options?.modifiers?.has?.(match.modifier)) throw new (0, _abiParameterJs.InvalidModifierError)({
            param,
            type: options?.type,
            modifier: match.modifier
        });
        // Check if resolved `type` is valid if there is a function modifier
        if ((0, _signaturesJs.functionModifiers).has(match.modifier) && !isValidDataLocation(type, !!match.array)) throw new (0, _abiParameterJs.InvalidFunctionModifierError)({
            param,
            type: options?.type,
            modifier: match.modifier
        });
    }
    const abiParameter = {
        type: `${type}${match.array ?? ''}`,
        ...name,
        ...indexed,
        ...components
    };
    (0, _cacheJs.parameterCache).set(parameterCacheKey, abiParameter);
    return abiParameter;
}
function splitParameters(params, result = [], current = '', depth = 0) {
    const length = params.trim().length;
    // biome-ignore lint/correctness/noUnreachable: recursive
    for(let i = 0; i < length; i++){
        const char = params[i];
        const tail = params.slice(i + 1);
        switch(char){
            case ',':
                return depth === 0 ? splitParameters(tail, [
                    ...result,
                    current.trim()
                ]) : splitParameters(tail, result, `${current}${char}`, depth);
            case '(':
                return splitParameters(tail, result, `${current}${char}`, depth + 1);
            case ')':
                return splitParameters(tail, result, `${current}${char}`, depth - 1);
            default:
                return splitParameters(tail, result, `${current}${char}`, depth);
        }
    }
    if (current === '') return result;
    if (depth !== 0) throw new (0, _splitParametersJs.InvalidParenthesisError)({
        current,
        depth
    });
    result.push(current.trim());
    return result;
}
function isSolidityType(type) {
    return type === 'address' || type === 'bool' || type === 'function' || type === 'string' || (0, _regexJs.bytesRegex).test(type) || (0, _regexJs.integerRegex).test(type);
}
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(name) {
    return name === 'address' || name === 'bool' || name === 'function' || name === 'string' || name === 'tuple' || (0, _regexJs.bytesRegex).test(name) || (0, _regexJs.integerRegex).test(name) || protectedKeywordsRegex.test(name);
}
function isValidDataLocation(type, isArray) {
    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';
}

},{"../../regex.js":"f23nz","../errors/abiItem.js":"hAazE","../errors/abiParameter.js":"ahbTP","../errors/signature.js":"e8F7Q","../errors/splitParameters.js":"b0XfC","./cache.js":"lxdIy","./signatures.js":"fxDjg","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b0XfC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InvalidParenthesisError", ()=>InvalidParenthesisError);
var _errorsJs = require("../../errors.js");
class InvalidParenthesisError extends (0, _errorsJs.BaseError) {
    constructor({ current, depth }){
        super('Unbalanced parentheses.', {
            metaMessages: [
                `"${current.trim()}" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`
            ],
            details: `Depth "${depth}"`
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidParenthesisError'
        });
    }
}

},{"../../errors.js":"91ZjA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lxdIy":[function(require,module,exports,__globalThis) {
/**
 * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).
 * @param param ABI parameter string
 * @param type ABI parameter type
 * @returns Cache key for {@link parameterCache}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getParameterCacheKey", ()=>getParameterCacheKey);
parcelHelpers.export(exports, "parameterCache", ()=>parameterCache);
function getParameterCacheKey(param, type, structs) {
    let structKey = '';
    if (structs) for (const struct of Object.entries(structs)){
        if (!struct) continue;
        let propertyKey = '';
        for (const property of struct[1])propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`;
        structKey += `(${struct[0]}{${propertyKey}})`;
    }
    if (type) return `${type}:${param}${structKey}`;
    return param;
}
const parameterCache = new Map([
    // Unnamed
    [
        'address',
        {
            type: 'address'
        }
    ],
    [
        'bool',
        {
            type: 'bool'
        }
    ],
    [
        'bytes',
        {
            type: 'bytes'
        }
    ],
    [
        'bytes32',
        {
            type: 'bytes32'
        }
    ],
    [
        'int',
        {
            type: 'int256'
        }
    ],
    [
        'int256',
        {
            type: 'int256'
        }
    ],
    [
        'string',
        {
            type: 'string'
        }
    ],
    [
        'uint',
        {
            type: 'uint256'
        }
    ],
    [
        'uint8',
        {
            type: 'uint8'
        }
    ],
    [
        'uint16',
        {
            type: 'uint16'
        }
    ],
    [
        'uint24',
        {
            type: 'uint24'
        }
    ],
    [
        'uint32',
        {
            type: 'uint32'
        }
    ],
    [
        'uint64',
        {
            type: 'uint64'
        }
    ],
    [
        'uint96',
        {
            type: 'uint96'
        }
    ],
    [
        'uint112',
        {
            type: 'uint112'
        }
    ],
    [
        'uint160',
        {
            type: 'uint160'
        }
    ],
    [
        'uint192',
        {
            type: 'uint192'
        }
    ],
    [
        'uint256',
        {
            type: 'uint256'
        }
    ],
    // Named
    [
        'address owner',
        {
            type: 'address',
            name: 'owner'
        }
    ],
    [
        'address to',
        {
            type: 'address',
            name: 'to'
        }
    ],
    [
        'bool approved',
        {
            type: 'bool',
            name: 'approved'
        }
    ],
    [
        'bytes _data',
        {
            type: 'bytes',
            name: '_data'
        }
    ],
    [
        'bytes data',
        {
            type: 'bytes',
            name: 'data'
        }
    ],
    [
        'bytes signature',
        {
            type: 'bytes',
            name: 'signature'
        }
    ],
    [
        'bytes32 hash',
        {
            type: 'bytes32',
            name: 'hash'
        }
    ],
    [
        'bytes32 r',
        {
            type: 'bytes32',
            name: 'r'
        }
    ],
    [
        'bytes32 root',
        {
            type: 'bytes32',
            name: 'root'
        }
    ],
    [
        'bytes32 s',
        {
            type: 'bytes32',
            name: 's'
        }
    ],
    [
        'string name',
        {
            type: 'string',
            name: 'name'
        }
    ],
    [
        'string symbol',
        {
            type: 'string',
            name: 'symbol'
        }
    ],
    [
        'string tokenURI',
        {
            type: 'string',
            name: 'tokenURI'
        }
    ],
    [
        'uint tokenId',
        {
            type: 'uint256',
            name: 'tokenId'
        }
    ],
    [
        'uint8 v',
        {
            type: 'uint8',
            name: 'v'
        }
    ],
    [
        'uint256 balance',
        {
            type: 'uint256',
            name: 'balance'
        }
    ],
    [
        'uint256 tokenId',
        {
            type: 'uint256',
            name: 'tokenId'
        }
    ],
    [
        'uint256 value',
        {
            type: 'uint256',
            name: 'value'
        }
    ],
    // Indexed
    [
        'event:address indexed from',
        {
            type: 'address',
            name: 'from',
            indexed: true
        }
    ],
    [
        'event:address indexed to',
        {
            type: 'address',
            name: 'to',
            indexed: true
        }
    ],
    [
        'event:uint indexed tokenId',
        {
            type: 'uint256',
            name: 'tokenId',
            indexed: true
        }
    ],
    [
        'event:uint256 indexed tokenId',
        {
            type: 'uint256',
            name: 'tokenId',
            indexed: true
        }
    ]
]);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"04ScK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item
 *
 * @param signature - Human-readable ABI item
 * @returns Parsed {@link Abi} item
 *
 * @example
 * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')
 * //    ^? const abiItem: { name: "balanceOf"; type: "function"; stateMutability: "view";...
 *
 * @example
 * const abiItem = parseAbiItem([
 *   //  ^? const abiItem: { name: "foo"; type: "function"; stateMutability: "view"; inputs:...
 *   'function foo(Baz bar) view returns (string)',
 *   'struct Baz { string name; }',
 * ])
 */ parcelHelpers.export(exports, "parseAbiItem", ()=>parseAbiItem);
var _abiItemJs = require("./errors/abiItem.js");
var _signaturesJs = require("./runtime/signatures.js");
var _structsJs = require("./runtime/structs.js");
var _utilsJs = require("./runtime/utils.js");
function parseAbiItem(signature) {
    let abiItem;
    if (typeof signature === 'string') abiItem = (0, _utilsJs.parseSignature)(signature);
    else {
        const structs = (0, _structsJs.parseStructs)(signature);
        const length = signature.length;
        for(let i = 0; i < length; i++){
            const signature_ = signature[i];
            if ((0, _signaturesJs.isStructSignature)(signature_)) continue;
            abiItem = (0, _utilsJs.parseSignature)(signature_, structs);
            break;
        }
    }
    if (!abiItem) throw new (0, _abiItemJs.InvalidAbiItemError)({
        signature
    });
    return abiItem;
}

},{"./errors/abiItem.js":"hAazE","./runtime/signatures.js":"fxDjg","./runtime/structs.js":"8E8vy","./runtime/utils.js":"5pgja","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7ExiQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parses human-readable ABI parameter into {@link AbiParameter}
 *
 * @param param - Human-readable ABI parameter
 * @returns Parsed {@link AbiParameter}
 *
 * @example
 * const abiParameter = parseAbiParameter('address from')
 * //    ^? const abiParameter: { type: "address"; name: "from"; }
 *
 * @example
 * const abiParameter = parseAbiParameter([
 *   //  ^? const abiParameter: { type: "tuple"; components: [{ type: "string"; name:...
 *   'Baz bar',
 *   'struct Baz { string name; }',
 * ])
 */ parcelHelpers.export(exports, "parseAbiParameter", ()=>parseAbiParameter);
var _abiParameterJs = require("./errors/abiParameter.js");
var _signaturesJs = require("./runtime/signatures.js");
var _structsJs = require("./runtime/structs.js");
var _utilsJs = require("./runtime/utils.js");
function parseAbiParameter(param) {
    let abiParameter;
    if (typeof param === 'string') abiParameter = (0, _utilsJs.parseAbiParameter)(param, {
        modifiers: (0, _signaturesJs.modifiers)
    });
    else {
        const structs = (0, _structsJs.parseStructs)(param);
        const length = param.length;
        for(let i = 0; i < length; i++){
            const signature = param[i];
            if ((0, _signaturesJs.isStructSignature)(signature)) continue;
            abiParameter = (0, _utilsJs.parseAbiParameter)(signature, {
                modifiers: (0, _signaturesJs.modifiers),
                structs
            });
            break;
        }
    }
    if (!abiParameter) throw new (0, _abiParameterJs.InvalidAbiParameterError)({
        param
    });
    return abiParameter;
}

},{"./errors/abiParameter.js":"ahbTP","./runtime/signatures.js":"fxDjg","./runtime/structs.js":"8E8vy","./runtime/utils.js":"5pgja","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2czdL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parses human-readable ABI parameters into {@link AbiParameter}s
 *
 * @param params - Human-readable ABI parameters
 * @returns Parsed {@link AbiParameter}s
 *
 * @example
 * const abiParameters = parseAbiParameters('address from, address to, uint256 amount')
 * //    ^? const abiParameters: [{ type: "address"; name: "from"; }, { type: "address";...
 *
 * @example
 * const abiParameters = parseAbiParameters([
 *   //  ^? const abiParameters: [{ type: "tuple"; components: [{ type: "string"; name:...
 *   'Baz bar',
 *   'struct Baz { string name; }',
 * ])
 */ parcelHelpers.export(exports, "parseAbiParameters", ()=>parseAbiParameters);
var _abiParameterJs = require("./errors/abiParameter.js");
var _signaturesJs = require("./runtime/signatures.js");
var _structsJs = require("./runtime/structs.js");
var _utilsJs = require("./runtime/utils.js");
function parseAbiParameters(params) {
    const abiParameters = [];
    if (typeof params === 'string') {
        const parameters = (0, _utilsJs.splitParameters)(params);
        const length = parameters.length;
        for(let i = 0; i < length; i++)abiParameters.push((0, _utilsJs.parseAbiParameter)(parameters[i], {
            modifiers: (0, _signaturesJs.modifiers)
        }));
    } else {
        const structs = (0, _structsJs.parseStructs)(params);
        const length = params.length;
        for(let i = 0; i < length; i++){
            const signature = params[i];
            if ((0, _signaturesJs.isStructSignature)(signature)) continue;
            const parameters = (0, _utilsJs.splitParameters)(signature);
            const length = parameters.length;
            for(let k = 0; k < length; k++)abiParameters.push((0, _utilsJs.parseAbiParameter)(parameters[k], {
                modifiers: (0, _signaturesJs.modifiers),
                structs
            }));
        }
    }
    if (abiParameters.length === 0) throw new (0, _abiParameterJs.InvalidAbiParametersError)({
        params
    });
    return abiParameters;
}

},{"./errors/abiParameter.js":"ahbTP","./runtime/signatures.js":"fxDjg","./runtime/structs.js":"8E8vy","./runtime/utils.js":"5pgja","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ah6Mx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets type-safe interface for performing contract-related actions with a specific `abi` and `address`.
 *
 * - Docs https://viem.sh/docs/contract/getContract
 *
 * Using Contract Instances can make it easier to work with contracts if you don't want to pass the `abi` and `address` properties every time you perform contract actions, e.g. [`readContract`](https://viem.sh/docs/contract/readContract), [`writeContract`](https://viem.sh/docs/contract/writeContract), [`estimateContractGas`](https://viem.sh/docs/contract/estimateContractGas), etc.
 *
 * @example
 * import { createPublicClient, getContract, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const publicClient = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const contract = getContract({
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi([
 *     'function balanceOf(address owner) view returns (uint256)',
 *     'function ownerOf(uint256 tokenId) view returns (address)',
 *     'function totalSupply() view returns (uint256)',
 *   ]),
 *   client: publicClient,
 * })
 */ parcelHelpers.export(exports, "getContract", ()=>getContract);
/**
 * @internal exporting for testing only
 */ parcelHelpers.export(exports, "getFunctionParameters", ()=>getFunctionParameters);
/**
 * @internal exporting for testing only
 */ parcelHelpers.export(exports, "getEventParameters", ()=>getEventParameters);
var _getActionJs = require("../utils/getAction.js");
var _createContractEventFilterJs = require("./public/createContractEventFilter.js");
var _estimateContractGasJs = require("./public/estimateContractGas.js");
var _getContractEventsJs = require("./public/getContractEvents.js");
var _readContractJs = require("./public/readContract.js");
var _simulateContractJs = require("./public/simulateContract.js");
var _watchContractEventJs = require("./public/watchContractEvent.js");
var _writeContractJs = require("./wallet/writeContract.js");
function getContract({ abi, address, client: client_ }) {
    const client = client_;
    const [publicClient, walletClient] = (()=>{
        if (!client) return [
            undefined,
            undefined
        ];
        if ('public' in client && 'wallet' in client) return [
            client.public,
            client.wallet
        ];
        if ('public' in client) return [
            client.public,
            undefined
        ];
        if ('wallet' in client) return [
            undefined,
            client.wallet
        ];
        return [
            client,
            client
        ];
    })();
    const hasPublicClient = publicClient !== undefined && publicClient !== null;
    const hasWalletClient = walletClient !== undefined && walletClient !== null;
    const contract = {};
    let hasReadFunction = false;
    let hasWriteFunction = false;
    let hasEvent = false;
    for (const item of abi){
        if (item.type === 'function') {
            if (item.stateMutability === 'view' || item.stateMutability === 'pure') hasReadFunction = true;
            else hasWriteFunction = true;
        } else if (item.type === 'event') hasEvent = true;
        // Exit early if all flags are `true`
        if (hasReadFunction && hasWriteFunction && hasEvent) break;
    }
    if (hasPublicClient) {
        if (hasReadFunction) contract.read = new Proxy({}, {
            get (_, functionName) {
                return (...parameters)=>{
                    const { args, options } = getFunctionParameters(parameters);
                    return (0, _getActionJs.getAction)(publicClient, (0, _readContractJs.readContract), 'readContract')({
                        abi,
                        address,
                        functionName,
                        args,
                        ...options
                    });
                };
            }
        });
        if (hasWriteFunction) contract.simulate = new Proxy({}, {
            get (_, functionName) {
                return (...parameters)=>{
                    const { args, options } = getFunctionParameters(parameters);
                    return (0, _getActionJs.getAction)(publicClient, (0, _simulateContractJs.simulateContract), 'simulateContract')({
                        abi,
                        address,
                        functionName,
                        args,
                        ...options
                    });
                };
            }
        });
        if (hasEvent) {
            contract.createEventFilter = new Proxy({}, {
                get (_, eventName) {
                    return (...parameters)=>{
                        const abiEvent = abi.find((x)=>x.type === 'event' && x.name === eventName);
                        const { args, options } = getEventParameters(parameters, abiEvent);
                        return (0, _getActionJs.getAction)(publicClient, (0, _createContractEventFilterJs.createContractEventFilter), 'createContractEventFilter')({
                            abi,
                            address,
                            eventName,
                            args,
                            ...options
                        });
                    };
                }
            });
            contract.getEvents = new Proxy({}, {
                get (_, eventName) {
                    return (...parameters)=>{
                        const abiEvent = abi.find((x)=>x.type === 'event' && x.name === eventName);
                        const { args, options } = getEventParameters(parameters, abiEvent);
                        return (0, _getActionJs.getAction)(publicClient, (0, _getContractEventsJs.getContractEvents), 'getContractEvents')({
                            abi,
                            address,
                            eventName,
                            args,
                            ...options
                        });
                    };
                }
            });
            contract.watchEvent = new Proxy({}, {
                get (_, eventName) {
                    return (...parameters)=>{
                        const abiEvent = abi.find((x)=>x.type === 'event' && x.name === eventName);
                        const { args, options } = getEventParameters(parameters, abiEvent);
                        return (0, _getActionJs.getAction)(publicClient, (0, _watchContractEventJs.watchContractEvent), 'watchContractEvent')({
                            abi,
                            address,
                            eventName,
                            args,
                            ...options
                        });
                    };
                }
            });
        }
    }
    if (hasWalletClient) {
        if (hasWriteFunction) contract.write = new Proxy({}, {
            get (_, functionName) {
                return (...parameters)=>{
                    const { args, options } = getFunctionParameters(parameters);
                    return (0, _getActionJs.getAction)(walletClient, (0, _writeContractJs.writeContract), 'writeContract')({
                        abi,
                        address,
                        functionName,
                        args,
                        ...options
                    });
                };
            }
        });
    }
    if (hasPublicClient || hasWalletClient) {
        if (hasWriteFunction) contract.estimateGas = new Proxy({}, {
            get (_, functionName) {
                return (...parameters)=>{
                    const { args, options } = getFunctionParameters(parameters);
                    const client = publicClient ?? walletClient;
                    return (0, _getActionJs.getAction)(client, (0, _estimateContractGasJs.estimateContractGas), 'estimateContractGas')({
                        abi,
                        address,
                        functionName,
                        args,
                        ...options,
                        account: options.account ?? walletClient.account
                    });
                };
            }
        });
    }
    contract.address = address;
    contract.abi = abi;
    return contract;
}
function getFunctionParameters(values) {
    const hasArgs = values.length && Array.isArray(values[0]);
    const args = hasArgs ? values[0] : [];
    const options = (hasArgs ? values[1] : values[0]) ?? {};
    return {
        args,
        options
    };
}
function getEventParameters(values, abiEvent) {
    let hasArgs = false;
    // If first item is array, must be `args`
    if (Array.isArray(values[0])) hasArgs = true;
    else if (values.length === 1) // if event has indexed inputs, must have `args`
    hasArgs = abiEvent.inputs.some((x)=>x.indexed);
    else if (values.length === 2) hasArgs = true;
    const args = hasArgs ? values[0] : undefined;
    const options = (hasArgs ? values[1] : values[0]) ?? {};
    return {
        args,
        options
    };
}

},{"../utils/getAction.js":"d1Bvd","./public/createContractEventFilter.js":"aZFsp","./public/estimateContractGas.js":"26qE1","./public/getContractEvents.js":"8aoKV","./public/readContract.js":"fusIl","./public/simulateContract.js":"3yzsB","./public/watchContractEvent.js":"jxMap","./wallet/writeContract.js":"FOZdN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d1Bvd":[function(require,module,exports,__globalThis) {
/**
 * Retrieves and returns an action from the client (if exists), and falls
 * back to the tree-shakable action.
 *
 * Useful for extracting overridden actions from a client (ie. if a consumer
 * wants to override the `sendTransaction` implementation).
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAction", ()=>getAction);
function getAction(client, actionFn, // Some minifiers drop `Function.prototype.name`, or replace it with short letters,
// meaning that `actionFn.name` will not always work. For that case, the consumer
// needs to pass the name explicitly.
name) {
    const action_implicit = client[actionFn.name];
    if (typeof action_implicit === 'function') return action_implicit;
    const action_explicit = client[name];
    if (typeof action_explicit === 'function') return action_explicit;
    return (params)=>actionFn(client, params);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aZFsp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a Filter to retrieve event logs that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges) or [`getFilterLogs`](https://viem.sh/docs/actions/public/getFilterLogs).
 *
 * - Docs: https://viem.sh/docs/contract/createContractEventFilter
 *
 * @param client - Client to use
 * @param parameters - {@link CreateContractEventFilterParameters}
 * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateContractEventFilterReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createContractEventFilter } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createContractEventFilter(client, {
 *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),
 * })
 */ parcelHelpers.export(exports, "createContractEventFilter", ()=>createContractEventFilter);
var _encodeEventTopicsJs = require("../../utils/abi/encodeEventTopics.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _createFilterRequestScopeJs = require("../../utils/filters/createFilterRequestScope.js");
async function createContractEventFilter(client, parameters) {
    const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;
    const getRequest = (0, _createFilterRequestScopeJs.createFilterRequestScope)(client, {
        method: 'eth_newFilter'
    });
    const topics = eventName ? (0, _encodeEventTopicsJs.encodeEventTopics)({
        abi,
        args,
        eventName
    }) : undefined;
    const id = await client.request({
        method: 'eth_newFilter',
        params: [
            {
                address,
                fromBlock: typeof fromBlock === 'bigint' ? (0, _toHexJs.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === 'bigint' ? (0, _toHexJs.numberToHex)(toBlock) : toBlock,
                topics
            }
        ]
    });
    return {
        abi,
        args,
        eventName,
        id,
        request: getRequest(id),
        strict: Boolean(strict),
        type: 'event'
    };
}

},{"../../utils/abi/encodeEventTopics.js":"7zHy3","../../utils/encoding/toHex.js":"9GFC6","../../utils/filters/createFilterRequestScope.js":"lUucN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7zHy3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeEventTopics", ()=>encodeEventTopics);
var _abiJs = require("../../errors/abi.js");
var _logJs = require("../../errors/log.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _keccak256Js = require("../hash/keccak256.js");
var _toEventSelectorJs = require("../hash/toEventSelector.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
var _getAbiItemJs = require("./getAbiItem.js");
const docsPath = '/docs/contract/encodeEventTopics';
function encodeEventTopics(parameters) {
    const { abi, eventName, args } = parameters;
    let abiItem = abi[0];
    if (eventName) {
        const item = (0, _getAbiItemJs.getAbiItem)({
            abi,
            name: eventName
        });
        if (!item) throw new (0, _abiJs.AbiEventNotFoundError)(eventName, {
            docsPath
        });
        abiItem = item;
    }
    if (abiItem.type !== 'event') throw new (0, _abiJs.AbiEventNotFoundError)(undefined, {
        docsPath
    });
    const definition = (0, _formatAbiItemJs.formatAbiItem)(abiItem);
    const signature = (0, _toEventSelectorJs.toEventSelector)(definition);
    let topics = [];
    if (args && 'inputs' in abiItem) {
        const indexedInputs = abiItem.inputs?.filter((param)=>'indexed' in param && param.indexed);
        const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x)=>args[x.name]) ?? [] : [];
        if (args_.length > 0) topics = indexedInputs?.map((param, i)=>{
            if (Array.isArray(args_[i])) return args_[i].map((_, j)=>encodeArg({
                    param,
                    value: args_[i][j]
                }));
            return typeof args_[i] !== 'undefined' && args_[i] !== null ? encodeArg({
                param,
                value: args_[i]
            }) : null;
        }) ?? [];
    }
    return [
        signature,
        ...topics
    ];
}
function encodeArg({ param, value }) {
    if (param.type === 'string' || param.type === 'bytes') return (0, _keccak256Js.keccak256)((0, _toBytesJs.toBytes)(value));
    if (param.type === 'tuple' || param.type.match(/^(.*)\[(\d+)?\]$/)) throw new (0, _logJs.FilterTypeNotSupportedError)(param.type);
    return (0, _encodeAbiParametersJs.encodeAbiParameters)([
        param
    ], [
        value
    ]);
}

},{"../../errors/abi.js":"7l8j7","../../errors/log.js":"8NWDn","../encoding/toBytes.js":"8cx1T","../hash/keccak256.js":"k4CmV","../hash/toEventSelector.js":"4FcAp","./encodeAbiParameters.js":"8kHRc","./formatAbiItem.js":"khxDG","./getAbiItem.js":"k6BVB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7l8j7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbiConstructorNotFoundError", ()=>AbiConstructorNotFoundError);
parcelHelpers.export(exports, "AbiConstructorParamsNotFoundError", ()=>AbiConstructorParamsNotFoundError);
parcelHelpers.export(exports, "AbiDecodingDataSizeInvalidError", ()=>AbiDecodingDataSizeInvalidError);
parcelHelpers.export(exports, "AbiDecodingDataSizeTooSmallError", ()=>AbiDecodingDataSizeTooSmallError);
parcelHelpers.export(exports, "AbiDecodingZeroDataError", ()=>AbiDecodingZeroDataError);
parcelHelpers.export(exports, "AbiEncodingArrayLengthMismatchError", ()=>AbiEncodingArrayLengthMismatchError);
parcelHelpers.export(exports, "AbiEncodingBytesSizeMismatchError", ()=>AbiEncodingBytesSizeMismatchError);
parcelHelpers.export(exports, "AbiEncodingLengthMismatchError", ()=>AbiEncodingLengthMismatchError);
parcelHelpers.export(exports, "AbiErrorInputsNotFoundError", ()=>AbiErrorInputsNotFoundError);
parcelHelpers.export(exports, "AbiErrorNotFoundError", ()=>AbiErrorNotFoundError);
parcelHelpers.export(exports, "AbiErrorSignatureNotFoundError", ()=>AbiErrorSignatureNotFoundError);
parcelHelpers.export(exports, "AbiEventSignatureEmptyTopicsError", ()=>AbiEventSignatureEmptyTopicsError);
parcelHelpers.export(exports, "AbiEventSignatureNotFoundError", ()=>AbiEventSignatureNotFoundError);
parcelHelpers.export(exports, "AbiEventNotFoundError", ()=>AbiEventNotFoundError);
parcelHelpers.export(exports, "AbiFunctionNotFoundError", ()=>AbiFunctionNotFoundError);
parcelHelpers.export(exports, "AbiFunctionOutputsNotFoundError", ()=>AbiFunctionOutputsNotFoundError);
parcelHelpers.export(exports, "AbiFunctionSignatureNotFoundError", ()=>AbiFunctionSignatureNotFoundError);
parcelHelpers.export(exports, "AbiItemAmbiguityError", ()=>AbiItemAmbiguityError);
parcelHelpers.export(exports, "BytesSizeMismatchError", ()=>BytesSizeMismatchError);
parcelHelpers.export(exports, "DecodeLogDataMismatch", ()=>DecodeLogDataMismatch);
parcelHelpers.export(exports, "DecodeLogTopicsMismatch", ()=>DecodeLogTopicsMismatch);
parcelHelpers.export(exports, "InvalidAbiEncodingTypeError", ()=>InvalidAbiEncodingTypeError);
parcelHelpers.export(exports, "InvalidAbiDecodingTypeError", ()=>InvalidAbiDecodingTypeError);
parcelHelpers.export(exports, "InvalidArrayError", ()=>InvalidArrayError);
parcelHelpers.export(exports, "InvalidDefinitionTypeError", ()=>InvalidDefinitionTypeError);
parcelHelpers.export(exports, "UnsupportedPackedAbiType", ()=>UnsupportedPackedAbiType);
var _formatAbiItemJs = require("../utils/abi/formatAbiItem.js");
var _sizeJs = require("../utils/data/size.js");
var _baseJs = require("./base.js");
class AbiConstructorNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ docsPath }){
        super([
            'A constructor was not found on the ABI.',
            'Make sure you are using the correct ABI and that the constructor exists on it.'
        ].join('\n'), {
            docsPath,
            name: 'AbiConstructorNotFoundError'
        });
    }
}
class AbiConstructorParamsNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ docsPath }){
        super([
            'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',
            'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.'
        ].join('\n'), {
            docsPath,
            name: 'AbiConstructorParamsNotFoundError'
        });
    }
}
class AbiDecodingDataSizeInvalidError extends (0, _baseJs.BaseError) {
    constructor({ data, size }){
        super([
            `Data size of ${size} bytes is invalid.`,
            'Size must be in increments of 32 bytes (size % 32 === 0).'
        ].join('\n'), {
            metaMessages: [
                `Data: ${data} (${size} bytes)`
            ],
            name: 'AbiDecodingDataSizeInvalidError'
        });
    }
}
class AbiDecodingDataSizeTooSmallError extends (0, _baseJs.BaseError) {
    constructor({ data, params, size }){
        super([
            `Data size of ${size} bytes is too small for given parameters.`
        ].join('\n'), {
            metaMessages: [
                `Params: (${(0, _formatAbiItemJs.formatAbiParams)(params, {
                    includeName: true
                })})`,
                `Data:   ${data} (${size} bytes)`
            ],
            name: 'AbiDecodingDataSizeTooSmallError'
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = data;
        this.params = params;
        this.size = size;
    }
}
class AbiDecodingZeroDataError extends (0, _baseJs.BaseError) {
    constructor(){
        super('Cannot decode zero data ("0x") with ABI parameters.', {
            name: 'AbiDecodingZeroDataError'
        });
    }
}
class AbiEncodingArrayLengthMismatchError extends (0, _baseJs.BaseError) {
    constructor({ expectedLength, givenLength, type }){
        super([
            `ABI encoding array length mismatch for type ${type}.`,
            `Expected length: ${expectedLength}`,
            `Given length: ${givenLength}`
        ].join('\n'), {
            name: 'AbiEncodingArrayLengthMismatchError'
        });
    }
}
class AbiEncodingBytesSizeMismatchError extends (0, _baseJs.BaseError) {
    constructor({ expectedSize, value }){
        super(`Size of bytes "${value}" (bytes${(0, _sizeJs.size)(value)}) does not match expected size (bytes${expectedSize}).`, {
            name: 'AbiEncodingBytesSizeMismatchError'
        });
    }
}
class AbiEncodingLengthMismatchError extends (0, _baseJs.BaseError) {
    constructor({ expectedLength, givenLength }){
        super([
            'ABI encoding params/values length mismatch.',
            `Expected length (params): ${expectedLength}`,
            `Given length (values): ${givenLength}`
        ].join('\n'), {
            name: 'AbiEncodingLengthMismatchError'
        });
    }
}
class AbiErrorInputsNotFoundError extends (0, _baseJs.BaseError) {
    constructor(errorName, { docsPath }){
        super([
            `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
            'Cannot encode error result without knowing what the parameter types are.',
            'Make sure you are using the correct ABI and that the inputs exist on it.'
        ].join('\n'), {
            docsPath,
            name: 'AbiErrorInputsNotFoundError'
        });
    }
}
class AbiErrorNotFoundError extends (0, _baseJs.BaseError) {
    constructor(errorName, { docsPath } = {}){
        super([
            `Error ${errorName ? `"${errorName}" ` : ''}not found on ABI.`,
            'Make sure you are using the correct ABI and that the error exists on it.'
        ].join('\n'), {
            docsPath,
            name: 'AbiErrorNotFoundError'
        });
    }
}
class AbiErrorSignatureNotFoundError extends (0, _baseJs.BaseError) {
    constructor(signature, { docsPath }){
        super([
            `Encoded error signature "${signature}" not found on ABI.`,
            'Make sure you are using the correct ABI and that the error exists on it.',
            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join('\n'), {
            docsPath,
            name: 'AbiErrorSignatureNotFoundError'
        });
        Object.defineProperty(this, "signature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.signature = signature;
    }
}
class AbiEventSignatureEmptyTopicsError extends (0, _baseJs.BaseError) {
    constructor({ docsPath }){
        super('Cannot extract event signature from empty topics.', {
            docsPath,
            name: 'AbiEventSignatureEmptyTopicsError'
        });
    }
}
class AbiEventSignatureNotFoundError extends (0, _baseJs.BaseError) {
    constructor(signature, { docsPath }){
        super([
            `Encoded event signature "${signature}" not found on ABI.`,
            'Make sure you are using the correct ABI and that the event exists on it.',
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join('\n'), {
            docsPath,
            name: 'AbiEventSignatureNotFoundError'
        });
    }
}
class AbiEventNotFoundError extends (0, _baseJs.BaseError) {
    constructor(eventName, { docsPath } = {}){
        super([
            `Event ${eventName ? `"${eventName}" ` : ''}not found on ABI.`,
            'Make sure you are using the correct ABI and that the event exists on it.'
        ].join('\n'), {
            docsPath,
            name: 'AbiEventNotFoundError'
        });
    }
}
class AbiFunctionNotFoundError extends (0, _baseJs.BaseError) {
    constructor(functionName, { docsPath } = {}){
        super([
            `Function ${functionName ? `"${functionName}" ` : ''}not found on ABI.`,
            'Make sure you are using the correct ABI and that the function exists on it.'
        ].join('\n'), {
            docsPath,
            name: 'AbiFunctionNotFoundError'
        });
    }
}
class AbiFunctionOutputsNotFoundError extends (0, _baseJs.BaseError) {
    constructor(functionName, { docsPath }){
        super([
            `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
            'Cannot decode function result without knowing what the parameter types are.',
            'Make sure you are using the correct ABI and that the function exists on it.'
        ].join('\n'), {
            docsPath,
            name: 'AbiFunctionOutputsNotFoundError'
        });
    }
}
class AbiFunctionSignatureNotFoundError extends (0, _baseJs.BaseError) {
    constructor(signature, { docsPath }){
        super([
            `Encoded function signature "${signature}" not found on ABI.`,
            'Make sure you are using the correct ABI and that the function exists on it.',
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`
        ].join('\n'), {
            docsPath,
            name: 'AbiFunctionSignatureNotFoundError'
        });
    }
}
class AbiItemAmbiguityError extends (0, _baseJs.BaseError) {
    constructor(x, y){
        super('Found ambiguous types in overloaded ABI items.', {
            metaMessages: [
                `\`${x.type}\` in \`${(0, _formatAbiItemJs.formatAbiItem)(x.abiItem)}\`, and`,
                `\`${y.type}\` in \`${(0, _formatAbiItemJs.formatAbiItem)(y.abiItem)}\``,
                '',
                'These types encode differently and cannot be distinguished at runtime.',
                'Remove one of the ambiguous items in the ABI.'
            ],
            name: 'AbiItemAmbiguityError'
        });
    }
}
class BytesSizeMismatchError extends (0, _baseJs.BaseError) {
    constructor({ expectedSize, givenSize }){
        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
            name: 'BytesSizeMismatchError'
        });
    }
}
class DecodeLogDataMismatch extends (0, _baseJs.BaseError) {
    constructor({ abiItem, data, params, size }){
        super([
            `Data size of ${size} bytes is too small for non-indexed event parameters.`
        ].join('\n'), {
            metaMessages: [
                `Params: (${(0, _formatAbiItemJs.formatAbiParams)(params, {
                    includeName: true
                })})`,
                `Data:   ${data} (${size} bytes)`
            ],
            name: 'DecodeLogDataMismatch'
        });
        Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abiItem = abiItem;
        this.data = data;
        this.params = params;
        this.size = size;
    }
}
class DecodeLogTopicsMismatch extends (0, _baseJs.BaseError) {
    constructor({ abiItem, param }){
        super([
            `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ''} on event "${(0, _formatAbiItemJs.formatAbiItem)(abiItem, {
                includeName: true
            })}".`
        ].join('\n'), {
            name: 'DecodeLogTopicsMismatch'
        });
        Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abiItem = abiItem;
    }
}
class InvalidAbiEncodingTypeError extends (0, _baseJs.BaseError) {
    constructor(type, { docsPath }){
        super([
            `Type "${type}" is not a valid encoding type.`,
            'Please provide a valid ABI type.'
        ].join('\n'), {
            docsPath,
            name: 'InvalidAbiEncodingType'
        });
    }
}
class InvalidAbiDecodingTypeError extends (0, _baseJs.BaseError) {
    constructor(type, { docsPath }){
        super([
            `Type "${type}" is not a valid decoding type.`,
            'Please provide a valid ABI type.'
        ].join('\n'), {
            docsPath,
            name: 'InvalidAbiDecodingType'
        });
    }
}
class InvalidArrayError extends (0, _baseJs.BaseError) {
    constructor(value){
        super([
            `Value "${value}" is not a valid array.`
        ].join('\n'), {
            name: 'InvalidArrayError'
        });
    }
}
class InvalidDefinitionTypeError extends (0, _baseJs.BaseError) {
    constructor(type){
        super([
            `"${type}" is not a valid definition type.`,
            'Valid types: "function", "event", "error"'
        ].join('\n'), {
            name: 'InvalidDefinitionTypeError'
        });
    }
}
class UnsupportedPackedAbiType extends (0, _baseJs.BaseError) {
    constructor(type){
        super(`Type "${type}" is not supported for packed encoding.`, {
            name: 'UnsupportedPackedAbiType'
        });
    }
}

},{"../utils/abi/formatAbiItem.js":"khxDG","../utils/data/size.js":"exELm","./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"khxDG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatAbiItem", ()=>formatAbiItem);
parcelHelpers.export(exports, "formatAbiParams", ()=>formatAbiParams);
var _abiJs = require("../../errors/abi.js");
function formatAbiItem(abiItem, { includeName = false } = {}) {
    if (abiItem.type !== 'function' && abiItem.type !== 'event' && abiItem.type !== 'error') throw new (0, _abiJs.InvalidDefinitionTypeError)(abiItem.type);
    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, {
        includeName
    })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
    if (!params) return '';
    return params.map((param)=>formatAbiParam(param, {
            includeName
        })).join(includeName ? ', ' : ',');
}
function formatAbiParam(param, { includeName }) {
    if (param.type.startsWith('tuple')) return `(${formatAbiParams(param.components, {
        includeName
    })})${param.type.slice(5)}`;
    return param.type + (includeName && param.name ? ` ${param.name}` : '');
}

},{"../../errors/abi.js":"7l8j7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"exELm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Retrieves the size of the value (in bytes).
 *
 * @param value The value (hex or byte array) to retrieve the size of.
 * @returns The size of the value (in bytes).
 */ parcelHelpers.export(exports, "size", ()=>size);
var _isHexJs = require("./isHex.js");
function size(value) {
    if ((0, _isHexJs.isHex)(value, {
        strict: false
    })) return Math.ceil((value.length - 2) / 2);
    return value.length;
}

},{"./isHex.js":"evOcm","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"evOcm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isHex", ()=>isHex);
function isHex(value, { strict = true } = {}) {
    if (!value) return false;
    if (typeof value !== 'string') return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3SEPF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setErrorConfig", ()=>setErrorConfig);
parcelHelpers.export(exports, "BaseError", ()=>BaseError);
var _versionJs = require("./version.js");
let errorConfig = {
    getDocsUrl: ({ docsBaseUrl, docsPath = '', docsSlug })=>docsPath ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${docsSlug ? `#${docsSlug}` : ''}` : undefined,
    version: `viem@${(0, _versionJs.version)}`
};
function setErrorConfig(config) {
    errorConfig = config;
}
class BaseError extends Error {
    constructor(shortMessage, args = {}){
        const details = (()=>{
            if (args.cause instanceof BaseError) return args.cause.details;
            if (args.cause?.message) return args.cause.message;
            return args.details;
        })();
        const docsPath = (()=>{
            if (args.cause instanceof BaseError) return args.cause.docsPath || args.docsPath;
            return args.docsPath;
        })();
        const docsUrl = errorConfig.getDocsUrl?.({
            ...args,
            docsPath
        });
        const message = [
            shortMessage || 'An error occurred.',
            '',
            ...args.metaMessages ? [
                ...args.metaMessages,
                ''
            ] : [],
            ...docsUrl ? [
                `Docs: ${docsUrl}`
            ] : [],
            ...details ? [
                `Details: ${details}`
            ] : [],
            ...errorConfig.version ? [
                `Version: ${errorConfig.version}`
            ] : []
        ].join('\n');
        super(message, args.cause ? {
            cause: args.cause
        } : undefined);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BaseError'
        });
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.name = args.name ?? this.name;
        this.shortMessage = shortMessage;
        this.version = (0, _versionJs.version);
    }
    walk(fn) {
        return walk(this, fn);
    }
}
function walk(err, fn) {
    if (fn?.(err)) return err;
    if (err && typeof err === 'object' && 'cause' in err && err.cause !== undefined) return walk(err.cause, fn);
    return fn ? null : err;
}

},{"./version.js":"asHCT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"asHCT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = '2.30.5';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8NWDn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FilterTypeNotSupportedError", ()=>FilterTypeNotSupportedError);
var _baseJs = require("./base.js");
class FilterTypeNotSupportedError extends (0, _baseJs.BaseError) {
    constructor(type){
        super(`Filter type "${type}" is not supported.`, {
            name: 'FilterTypeNotSupportedError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8cx1T":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Encodes a UTF-8 string, hex value, bigint, number or boolean to a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes
 * - Example: https://viem.sh/docs/utilities/toBytes#usage
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes('Hello world')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes(420)
 * // Uint8Array([1, 164])
 *
 * @example
 * import { toBytes } from 'viem'
 * const data = toBytes(420, { size: 4 })
 * // Uint8Array([0, 0, 1, 164])
 */ parcelHelpers.export(exports, "toBytes", ()=>toBytes);
/**
 * Encodes a boolean into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#booltobytes
 *
 * @param value Boolean value to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { boolToBytes } from 'viem'
 * const data = boolToBytes(true)
 * // Uint8Array([1])
 *
 * @example
 * import { boolToBytes } from 'viem'
 * const data = boolToBytes(true, { size: 32 })
 * // Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
 */ parcelHelpers.export(exports, "boolToBytes", ()=>boolToBytes);
/**
 * Encodes a hex string into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#hextobytes
 *
 * @param hex Hex string to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { hexToBytes } from 'viem'
 * const data = hexToBytes('0x48656c6c6f20776f726c6421')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 *
 * @example
 * import { hexToBytes } from 'viem'
 * const data = hexToBytes('0x48656c6c6f20776f726c6421', { size: 32 })
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 */ parcelHelpers.export(exports, "hexToBytes", ()=>hexToBytes);
/**
 * Encodes a number into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#numbertobytes
 *
 * @param value Number to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { numberToBytes } from 'viem'
 * const data = numberToBytes(420)
 * // Uint8Array([1, 164])
 *
 * @example
 * import { numberToBytes } from 'viem'
 * const data = numberToBytes(420, { size: 4 })
 * // Uint8Array([0, 0, 1, 164])
 */ parcelHelpers.export(exports, "numberToBytes", ()=>numberToBytes);
/**
 * Encodes a UTF-8 string into a byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/toBytes#stringtobytes
 *
 * @param value String to encode.
 * @param opts Options.
 * @returns Byte array value.
 *
 * @example
 * import { stringToBytes } from 'viem'
 * const data = stringToBytes('Hello world!')
 * // Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])
 *
 * @example
 * import { stringToBytes } from 'viem'
 * const data = stringToBytes('Hello world!', { size: 32 })
 * // Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 */ parcelHelpers.export(exports, "stringToBytes", ()=>stringToBytes);
var _baseJs = require("../../errors/base.js");
var _isHexJs = require("../data/isHex.js");
var _padJs = require("../data/pad.js");
var _fromHexJs = require("./fromHex.js");
var _toHexJs = require("./toHex.js");
const encoder = /*#__PURE__*/ new TextEncoder();
function toBytes(value, opts = {}) {
    if (typeof value === 'number' || typeof value === 'bigint') return numberToBytes(value, opts);
    if (typeof value === 'boolean') return boolToBytes(value, opts);
    if ((0, _isHexJs.isHex)(value)) return hexToBytes(value, opts);
    return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
    const bytes = new Uint8Array(1);
    bytes[0] = Number(value);
    if (typeof opts.size === 'number') {
        (0, _fromHexJs.assertSize)(bytes, {
            size: opts.size
        });
        return (0, _padJs.pad)(bytes, {
            size: opts.size
        });
    }
    return bytes;
}
// We use very optimized technique to convert hex string to byte array
const charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);
    return undefined;
}
function hexToBytes(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        (0, _fromHexJs.assertSize)(hex, {
            size: opts.size
        });
        hex = (0, _padJs.pad)(hex, {
            dir: 'right',
            size: opts.size
        });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2) hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for(let index = 0, j = 0; index < length; index++){
        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
        if (nibbleLeft === undefined || nibbleRight === undefined) throw new (0, _baseJs.BaseError)(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
        bytes[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
}
function numberToBytes(value, opts) {
    const hex = (0, _toHexJs.numberToHex)(value, opts);
    return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
    const bytes = encoder.encode(value);
    if (typeof opts.size === 'number') {
        (0, _fromHexJs.assertSize)(bytes, {
            size: opts.size
        });
        return (0, _padJs.pad)(bytes, {
            dir: 'right',
            size: opts.size
        });
    }
    return bytes;
}

},{"../../errors/base.js":"3SEPF","../data/isHex.js":"evOcm","../data/pad.js":"aAjQN","./fromHex.js":"kLfW5","./toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aAjQN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pad", ()=>pad);
parcelHelpers.export(exports, "padHex", ()=>padHex);
parcelHelpers.export(exports, "padBytes", ()=>padBytes);
var _dataJs = require("../../errors/data.js");
function pad(hexOrBytes, { dir, size = 32 } = {}) {
    if (typeof hexOrBytes === 'string') return padHex(hexOrBytes, {
        dir,
        size
    });
    return padBytes(hexOrBytes, {
        dir,
        size
    });
}
function padHex(hex_, { dir, size = 32 } = {}) {
    if (size === null) return hex_;
    const hex = hex_.replace('0x', '');
    if (hex.length > size * 2) throw new (0, _dataJs.SizeExceedsPaddingSizeError)({
        size: Math.ceil(hex.length / 2),
        targetSize: size,
        type: 'hex'
    });
    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
}
function padBytes(bytes, { dir, size = 32 } = {}) {
    if (size === null) return bytes;
    if (bytes.length > size) throw new (0, _dataJs.SizeExceedsPaddingSizeError)({
        size: bytes.length,
        targetSize: size,
        type: 'bytes'
    });
    const paddedBytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        const padEnd = dir === 'right';
        paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
}

},{"../../errors/data.js":"kBfpj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kBfpj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SliceOffsetOutOfBoundsError", ()=>SliceOffsetOutOfBoundsError);
parcelHelpers.export(exports, "SizeExceedsPaddingSizeError", ()=>SizeExceedsPaddingSizeError);
parcelHelpers.export(exports, "InvalidBytesLengthError", ()=>InvalidBytesLengthError);
var _baseJs = require("./base.js");
class SliceOffsetOutOfBoundsError extends (0, _baseJs.BaseError) {
    constructor({ offset, position, size }){
        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset "${offset}" is out-of-bounds (size: ${size}).`, {
            name: 'SliceOffsetOutOfBoundsError'
        });
    }
}
class SizeExceedsPaddingSizeError extends (0, _baseJs.BaseError) {
    constructor({ size, targetSize, type }){
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`, {
            name: 'SizeExceedsPaddingSizeError'
        });
    }
}
class InvalidBytesLengthError extends (0, _baseJs.BaseError) {
    constructor({ size, targetSize, type }){
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`, {
            name: 'InvalidBytesLengthError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kLfW5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assertSize", ()=>assertSize);
/**
 * Decodes a hex string into a string, number, bigint, boolean, or byte array.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex
 * - Example: https://viem.sh/docs/utilities/fromHex#usage
 *
 * @param hex Hex string to decode.
 * @param toOrOpts Type to convert to or options.
 * @returns Decoded value.
 *
 * @example
 * import { fromHex } from 'viem'
 * const data = fromHex('0x1a4', 'number')
 * // 420
 *
 * @example
 * import { fromHex } from 'viem'
 * const data = fromHex('0x48656c6c6f20576f726c6421', 'string')
 * // 'Hello world'
 *
 * @example
 * import { fromHex } from 'viem'
 * const data = fromHex('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {
 *   size: 32,
 *   to: 'string'
 * })
 * // 'Hello world'
 */ parcelHelpers.export(exports, "fromHex", ()=>fromHex);
/**
 * Decodes a hex value into a bigint.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex#hextobigint
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns BigInt value.
 *
 * @example
 * import { hexToBigInt } from 'viem'
 * const data = hexToBigInt('0x1a4', { signed: true })
 * // 420n
 *
 * @example
 * import { hexToBigInt } from 'viem'
 * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
 * // 420n
 */ parcelHelpers.export(exports, "hexToBigInt", ()=>hexToBigInt);
/**
 * Decodes a hex value into a boolean.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex#hextobool
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns Boolean value.
 *
 * @example
 * import { hexToBool } from 'viem'
 * const data = hexToBool('0x01')
 * // true
 *
 * @example
 * import { hexToBool } from 'viem'
 * const data = hexToBool('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })
 * // true
 */ parcelHelpers.export(exports, "hexToBool", ()=>hexToBool);
/**
 * Decodes a hex string into a number.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex#hextonumber
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns Number value.
 *
 * @example
 * import { hexToNumber } from 'viem'
 * const data = hexToNumber('0x1a4')
 * // 420
 *
 * @example
 * import { hexToNumber } from 'viem'
 * const data = hexToBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
 * // 420
 */ parcelHelpers.export(exports, "hexToNumber", ()=>hexToNumber);
/**
 * Decodes a hex value into a UTF-8 string.
 *
 * - Docs: https://viem.sh/docs/utilities/fromHex#hextostring
 *
 * @param hex Hex value to decode.
 * @param opts Options.
 * @returns String value.
 *
 * @example
 * import { hexToString } from 'viem'
 * const data = hexToString('0x48656c6c6f20576f726c6421')
 * // 'Hello world!'
 *
 * @example
 * import { hexToString } from 'viem'
 * const data = hexToString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {
 *  size: 32,
 * })
 * // 'Hello world'
 */ parcelHelpers.export(exports, "hexToString", ()=>hexToString);
var _encodingJs = require("../../errors/encoding.js");
var _sizeJs = require("../data/size.js");
var _trimJs = require("../data/trim.js");
var _toBytesJs = require("./toBytes.js");
function assertSize(hexOrBytes, { size }) {
    if ((0, _sizeJs.size)(hexOrBytes) > size) throw new (0, _encodingJs.SizeOverflowError)({
        givenSize: (0, _sizeJs.size)(hexOrBytes),
        maxSize: size
    });
}
function fromHex(hex, toOrOpts) {
    const opts = typeof toOrOpts === 'string' ? {
        to: toOrOpts
    } : toOrOpts;
    const to = opts.to;
    if (to === 'number') return hexToNumber(hex, opts);
    if (to === 'bigint') return hexToBigInt(hex, opts);
    if (to === 'string') return hexToString(hex, opts);
    if (to === 'boolean') return hexToBool(hex, opts);
    return (0, _toBytesJs.hexToBytes)(hex, opts);
}
function hexToBigInt(hex, opts = {}) {
    const { signed } = opts;
    if (opts.size) assertSize(hex, {
        size: opts.size
    });
    const value = BigInt(hex);
    if (!signed) return value;
    const size = (hex.length - 2) / 2;
    const max = (1n << BigInt(size) * 8n - 1n) - 1n;
    if (value <= max) return value;
    return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;
}
function hexToBool(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        assertSize(hex, {
            size: opts.size
        });
        hex = (0, _trimJs.trim)(hex);
    }
    if ((0, _trimJs.trim)(hex) === '0x00') return false;
    if ((0, _trimJs.trim)(hex) === '0x01') return true;
    throw new (0, _encodingJs.InvalidHexBooleanError)(hex);
}
function hexToNumber(hex, opts = {}) {
    return Number(hexToBigInt(hex, opts));
}
function hexToString(hex, opts = {}) {
    let bytes = (0, _toBytesJs.hexToBytes)(hex);
    if (opts.size) {
        assertSize(bytes, {
            size: opts.size
        });
        bytes = (0, _trimJs.trim)(bytes, {
            dir: 'right'
        });
    }
    return new TextDecoder().decode(bytes);
}

},{"../../errors/encoding.js":"45Fmz","../data/size.js":"exELm","../data/trim.js":"3ZmMy","./toBytes.js":"8cx1T","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"45Fmz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IntegerOutOfRangeError", ()=>IntegerOutOfRangeError);
parcelHelpers.export(exports, "InvalidBytesBooleanError", ()=>InvalidBytesBooleanError);
parcelHelpers.export(exports, "InvalidHexBooleanError", ()=>InvalidHexBooleanError);
parcelHelpers.export(exports, "InvalidHexValueError", ()=>InvalidHexValueError);
parcelHelpers.export(exports, "SizeOverflowError", ()=>SizeOverflowError);
var _baseJs = require("./base.js");
class IntegerOutOfRangeError extends (0, _baseJs.BaseError) {
    constructor({ max, min, signed, size, value }){
        super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, {
            name: 'IntegerOutOfRangeError'
        });
    }
}
class InvalidBytesBooleanError extends (0, _baseJs.BaseError) {
    constructor(bytes){
        super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
            name: 'InvalidBytesBooleanError'
        });
    }
}
class InvalidHexBooleanError extends (0, _baseJs.BaseError) {
    constructor(hex){
        super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, {
            name: 'InvalidHexBooleanError'
        });
    }
}
class InvalidHexValueError extends (0, _baseJs.BaseError) {
    constructor(value){
        super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`, {
            name: 'InvalidHexValueError'
        });
    }
}
class SizeOverflowError extends (0, _baseJs.BaseError) {
    constructor({ givenSize, maxSize }){
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, {
            name: 'SizeOverflowError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3ZmMy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "trim", ()=>trim);
function trim(hexOrBytes, { dir = 'left' } = {}) {
    let data = typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes;
    let sliceLength = 0;
    for(let i = 0; i < data.length - 1; i++){
        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0') sliceLength++;
        else break;
    }
    data = dir === 'left' ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === 'string') {
        if (data.length === 1 && dir === 'right') data = `${data}0`;
        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
    }
    return data;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9GFC6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Encodes a string, number, bigint, or ByteArray into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex
 * - Example: https://viem.sh/docs/utilities/toHex#usage
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex('Hello world')
 * // '0x48656c6c6f20776f726c6421'
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex(420)
 * // '0x1a4'
 *
 * @example
 * import { toHex } from 'viem'
 * const data = toHex('Hello world', { size: 32 })
 * // '0x48656c6c6f20776f726c64210000000000000000000000000000000000000000'
 */ parcelHelpers.export(exports, "toHex", ()=>toHex);
/**
 * Encodes a boolean into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#booltohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(true)
 * // '0x1'
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(false)
 * // '0x0'
 *
 * @example
 * import { boolToHex } from 'viem'
 * const data = boolToHex(true, { size: 32 })
 * // '0x0000000000000000000000000000000000000000000000000000000000000001'
 */ parcelHelpers.export(exports, "boolToHex", ()=>boolToHex);
/**
 * Encodes a bytes array into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#bytestohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { bytesToHex } from 'viem'
 * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 * // '0x48656c6c6f20576f726c6421'
 *
 * @example
 * import { bytesToHex } from 'viem'
 * const data = bytesToHex(Uint8Array.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]), { size: 32 })
 * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
 */ parcelHelpers.export(exports, "bytesToHex", ()=>bytesToHex);
/**
 * Encodes a number or bigint into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#numbertohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420)
 * // '0x1a4'
 *
 * @example
 * import { numberToHex } from 'viem'
 * const data = numberToHex(420, { size: 32 })
 * // '0x00000000000000000000000000000000000000000000000000000000000001a4'
 */ parcelHelpers.export(exports, "numberToHex", ()=>numberToHex);
/**
 * Encodes a UTF-8 string into a hex string
 *
 * - Docs: https://viem.sh/docs/utilities/toHex#stringtohex
 *
 * @param value Value to encode.
 * @param opts Options.
 * @returns Hex value.
 *
 * @example
 * import { stringToHex } from 'viem'
 * const data = stringToHex('Hello World!')
 * // '0x48656c6c6f20576f726c6421'
 *
 * @example
 * import { stringToHex } from 'viem'
 * const data = stringToHex('Hello World!', { size: 32 })
 * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
 */ parcelHelpers.export(exports, "stringToHex", ()=>stringToHex);
var _encodingJs = require("../../errors/encoding.js");
var _padJs = require("../data/pad.js");
var _fromHexJs = require("./fromHex.js");
const hexes = /*#__PURE__*/ Array.from({
    length: 256
}, (_v, i)=>i.toString(16).padStart(2, '0'));
function toHex(value, opts = {}) {
    if (typeof value === 'number' || typeof value === 'bigint') return numberToHex(value, opts);
    if (typeof value === 'string') return stringToHex(value, opts);
    if (typeof value === 'boolean') return boolToHex(value, opts);
    return bytesToHex(value, opts);
}
function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === 'number') {
        (0, _fromHexJs.assertSize)(hex, {
            size: opts.size
        });
        return (0, _padJs.pad)(hex, {
            size: opts.size
        });
    }
    return hex;
}
function bytesToHex(value, opts = {}) {
    let string = '';
    for(let i = 0; i < value.length; i++)string += hexes[value[i]];
    const hex = `0x${string}`;
    if (typeof opts.size === 'number') {
        (0, _fromHexJs.assertSize)(hex, {
            size: opts.size
        });
        return (0, _padJs.pad)(hex, {
            dir: 'right',
            size: opts.size
        });
    }
    return hex;
}
function numberToHex(value_, opts = {}) {
    const { signed, size } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size) {
        if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;
        else maxValue = 2n ** (BigInt(size) * 8n) - 1n;
    } else if (typeof value_ === 'number') maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
    if (maxValue && value > maxValue || value < minValue) {
        const suffix = typeof value_ === 'bigint' ? 'n' : '';
        throw new (0, _encodingJs.IntegerOutOfRangeError)({
            max: maxValue ? `${maxValue}${suffix}` : undefined,
            min: `${minValue}${suffix}`,
            signed,
            size,
            value: `${value_}${suffix}`
        });
    }
    const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
    if (size) return (0, _padJs.pad)(hex, {
        size
    });
    return hex;
}
const encoder = /*#__PURE__*/ new TextEncoder();
function stringToHex(value_, opts = {}) {
    const value = encoder.encode(value_);
    return bytesToHex(value, opts);
}

},{"../../errors/encoding.js":"45Fmz","../data/pad.js":"aAjQN","./fromHex.js":"kLfW5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k4CmV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keccak256", ()=>keccak256);
var _sha3 = require("@noble/hashes/sha3");
var _isHexJs = require("../data/isHex.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
function keccak256(value, to_) {
    const to = to_ || 'hex';
    const bytes = (0, _sha3.keccak_256)((0, _isHexJs.isHex)(value, {
        strict: false
    }) ? (0, _toBytesJs.toBytes)(value) : value);
    if (to === 'bytes') return bytes;
    return (0, _toHexJs.toHex)(bytes);
}

},{"@noble/hashes/sha3":"by5a3","../data/isHex.js":"evOcm","../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"by5a3":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
exports.keccakP = keccakP;
/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */ const _u64_ts_1 = require("45e8a44e40fd6b7f");
// prettier-ignore
const utils_ts_1 = require("5a04751f3e786b49");
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for(let round = 0, R = _1n, x = 1, y = 0; round < 24; round++){
    // Pi
    [x, y] = [
        y,
        (2 * x + 3 * y) % 5
    ];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    // Iota
    let t = _0n;
    for(let j = 0; j < 7; j++){
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s);
const rotlL = (h, l, s)=>s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s);
/** `keccakf1600` internal function, additionally allows to adjust round count. */ function keccakP(s, rounds = 24) {
    const B = new Uint32Array(10);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for(let round = 24 - rounds; round < 24; round++){
        // Theta 
        for(let x = 0; x < 10; x++)B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for(let x = 0; x < 10; x += 2){
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for(let y = 0; y < 50; y += 10){
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for(let t = 0; t < 24; t++){
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for(let y = 0; y < 50; y += 10){
            for(let x = 0; x < 10; x++)B[x] = s[y + x];
            for(let x = 0; x < 10; x++)s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, utils_ts_1.clean)(B);
}
/** Keccak sponge function. */ class Keccak extends utils_ts_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24){
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, utils_ts_1.anumber)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200)) throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            for(let i = 0; i < take; i++)state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen) this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished) return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for(let pos = 0, len = out.length; pos < len;){
            if (this.posOut >= blockLen) this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished) throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createHasher)(()=>new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */ exports.sha3_224 = (()=>gen(0x06, 144, 28))();
/** SHA3-256 hash function. Different from keccak-256. */ exports.sha3_256 = (()=>gen(0x06, 136, 32))();
/** SHA3-384 hash function. */ exports.sha3_384 = (()=>gen(0x06, 104, 48))();
/** SHA3-512 hash function. */ exports.sha3_512 = (()=>gen(0x06, 72, 64))();
/** keccak-224 hash function. */ exports.keccak_224 = (()=>gen(0x01, 144, 28))();
/** keccak-256 hash function. Different from SHA3-256. */ exports.keccak_256 = (()=>gen(0x01, 136, 32))();
/** keccak-384 hash function. */ exports.keccak_384 = (()=>gen(0x01, 104, 48))();
/** keccak-512 hash function. */ exports.keccak_512 = (()=>gen(0x01, 72, 64))();
const genShake = (suffix, blockLen, outputLen)=>(0, utils_ts_1.createXOFer)((opts = {})=>new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */ exports.shake128 = (()=>genShake(0x1f, 168, 16))();
/** SHAKE256 XOF with 256-bit security. */ exports.shake256 = (()=>genShake(0x1f, 136, 32))();

},{"45e8a44e40fd6b7f":"gNDUI","5a04751f3e786b49":"fuxLy"}],"gNDUI":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */ const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for(let i = 0; i < len; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s)=>h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l)=>l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l)=>h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
exports.default = u64;

},{}],"fuxLy":[function(require,module,exports,__globalThis) {
"use strict";
/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = require("308a0f9b8753b4af");
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */ function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
/** Asserts something is positive integer. */ function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */ function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */ function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */ function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) throw new Error('digestInto() expects output buffer of length at least ' + min);
}
/** Cast u8 / u16 / u32 to u8. */ function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */ function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */ function clean(...arrays) {
    for(let i = 0; i < arrays.length; i++)arrays[i].fill(0);
}
/** Create DataView of an array for easy byte-level manipulation. */ function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */ function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
}
/** The rotate left (circular left shift) operation for uint32 */ function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */ exports.isLE = (()=>new Uint8Array(new Uint32Array([
        0x11223344
    ]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */ function byteSwap(word) {
    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
}
/** Conditionally byte swap if on a big-endian platform */ exports.swap8IfBE = exports.isLE ? (n)=>n : (n)=>byteSwap(n);
/** @deprecated */ exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */ function byteSwap32(arr) {
    for(let i = 0; i < arr.length; i++)arr[i] = byteSwap(arr[i]);
    return arr;
}
exports.swap32IfBE = exports.isLE ? (u)=>u : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore
    typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin) return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */ const nextTick = async ()=>{};
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */ async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */ function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */ function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */ function kdfInputToBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */ function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && ({}).toString.call(opts) !== '[object Object]') throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */ class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */ function createHasher(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */ function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    throw new Error('crypto.getRandomValues must be defined');
}

},{"308a0f9b8753b4af":"hCvWO"}],"hCvWO":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

},{}],"4FcAp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toEventSelector", ()=>toEventSelector);
var _toSignatureHashJs = require("./toSignatureHash.js");
const toEventSelector = (0, _toSignatureHashJs.toSignatureHash);

},{"./toSignatureHash.js":"7T2T5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7T2T5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the hash (of the function/event signature) for a given event or function definition.
 */ parcelHelpers.export(exports, "toSignatureHash", ()=>toSignatureHash);
var _hashSignatureJs = require("./hashSignature.js");
var _toSignatureJs = require("./toSignature.js");
function toSignatureHash(fn) {
    return (0, _hashSignatureJs.hashSignature)((0, _toSignatureJs.toSignature)(fn));
}

},{"./hashSignature.js":"l2wu1","./toSignature.js":"19eOv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l2wu1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hashSignature", ()=>hashSignature);
var _toBytesJs = require("../encoding/toBytes.js");
var _keccak256Js = require("./keccak256.js");
const hash = (value)=>(0, _keccak256Js.keccak256)((0, _toBytesJs.toBytes)(value));
function hashSignature(sig) {
    return hash(sig);
}

},{"../encoding/toBytes.js":"8cx1T","./keccak256.js":"k4CmV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"19eOv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toSignature", ()=>toSignature);
var _abitype = require("abitype");
var _normalizeSignatureJs = require("./normalizeSignature.js");
const toSignature = (def)=>{
    const def_ = (()=>{
        if (typeof def === 'string') return def;
        return (0, _abitype.formatAbiItem)(def);
    })();
    return (0, _normalizeSignatureJs.normalizeSignature)(def_);
};

},{"abitype":"6tgJn","./normalizeSignature.js":"cK40H","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cK40H":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "normalizeSignature", ()=>normalizeSignature);
var _baseJs = require("../../errors/base.js");
function normalizeSignature(signature) {
    let active = true;
    let current = '';
    let level = 0;
    let result = '';
    let valid = false;
    for(let i = 0; i < signature.length; i++){
        const char = signature[i];
        // If the character is a separator, we want to reactivate.
        if ([
            '(',
            ')',
            ','
        ].includes(char)) active = true;
        // If the character is a "level" token, we want to increment/decrement.
        if (char === '(') level++;
        if (char === ')') level--;
        // If we aren't active, we don't want to mutate the result.
        if (!active) continue;
        // If level === 0, we are at the definition level.
        if (level === 0) {
            if (char === ' ' && [
                'event',
                'function',
                ''
            ].includes(result)) result = '';
            else {
                result += char;
                // If we are at the end of the definition, we must be finished.
                if (char === ')') {
                    valid = true;
                    break;
                }
            }
            continue;
        }
        // Ignore spaces
        if (char === ' ') {
            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.
            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {
                current = '';
                active = false;
            }
            continue;
        }
        result += char;
        current += char;
    }
    if (!valid) throw new (0, _baseJs.BaseError)('Unable to normalize signature.');
    return result;
}

},{"../../errors/base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8kHRc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Encodes a list of primitive values into an ABI-encoded hex value.
 *
 * - Docs: https://viem.sh/docs/abi/encodeAbiParameters#encodeabiparameters
 *
 *   Generates ABI encoded data using the [ABI specification](https://docs.soliditylang.org/en/latest/abi-spec), given a set of ABI parameters (inputs/outputs) and their corresponding values.
 *
 * @param params - a set of ABI Parameters (params), that can be in the shape of the inputs or outputs attribute of an ABI Item.
 * @param values - a set of values (values) that correspond to the given params.
 * @example
 * ```typescript
 * import { encodeAbiParameters } from 'viem'
 *
 * const encodedData = encodeAbiParameters(
 *   [
 *     { name: 'x', type: 'string' },
 *     { name: 'y', type: 'uint' },
 *     { name: 'z', type: 'bool' }
 *   ],
 *   ['wagmi', 420n, true]
 * )
 * ```
 *
 * You can also pass in Human Readable parameters with the parseAbiParameters utility.
 *
 * @example
 * ```typescript
 * import { encodeAbiParameters, parseAbiParameters } from 'viem'
 *
 * const encodedData = encodeAbiParameters(
 *   parseAbiParameters('string x, uint y, bool z'),
 *   ['wagmi', 420n, true]
 * )
 * ```
 */ parcelHelpers.export(exports, "encodeAbiParameters", ()=>encodeAbiParameters);
parcelHelpers.export(exports, "getArrayComponents", ()=>getArrayComponents);
var _abiJs = require("../../errors/abi.js");
var _addressJs = require("../../errors/address.js");
var _baseJs = require("../../errors/base.js");
var _encodingJs = require("../../errors/encoding.js");
var _isAddressJs = require("../address/isAddress.js");
var _concatJs = require("../data/concat.js");
var _padJs = require("../data/pad.js");
var _sizeJs = require("../data/size.js");
var _sliceJs = require("../data/slice.js");
var _toHexJs = require("../encoding/toHex.js");
var _regexJs = require("../regex.js");
function encodeAbiParameters(params, values) {
    if (params.length !== values.length) throw new (0, _abiJs.AbiEncodingLengthMismatchError)({
        expectedLength: params.length,
        givenLength: values.length
    });
    // Prepare the parameters to determine dynamic types to encode.
    const preparedParams = prepareParams({
        params: params,
        values: values
    });
    const data = encodeParams(preparedParams);
    if (data.length === 0) return '0x';
    return data;
}
function prepareParams({ params, values }) {
    const preparedParams = [];
    for(let i = 0; i < params.length; i++)preparedParams.push(prepareParam({
        param: params[i],
        value: values[i]
    }));
    return preparedParams;
}
function prepareParam({ param, value }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return encodeArray(value, {
            length,
            param: {
                ...param,
                type
            }
        });
    }
    if (param.type === 'tuple') return encodeTuple(value, {
        param: param
    });
    if (param.type === 'address') return encodeAddress(value);
    if (param.type === 'bool') return encodeBool(value);
    if (param.type.startsWith('uint') || param.type.startsWith('int')) {
        const signed = param.type.startsWith('int');
        const [, , size = '256'] = (0, _regexJs.integerRegex).exec(param.type) ?? [];
        return encodeNumber(value, {
            signed,
            size: Number(size)
        });
    }
    if (param.type.startsWith('bytes')) return encodeBytes(value, {
        param
    });
    if (param.type === 'string') return encodeString(value);
    throw new (0, _abiJs.InvalidAbiEncodingTypeError)(param.type, {
        docsPath: '/docs/contract/encodeAbiParameters'
    });
}
function encodeParams(preparedParams) {
    // 1. Compute the size of the static part of the parameters.
    let staticSize = 0;
    for(let i = 0; i < preparedParams.length; i++){
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) staticSize += 32;
        else staticSize += (0, _sizeJs.size)(encoded);
    }
    // 2. Split the parameters into static and dynamic parts.
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for(let i = 0; i < preparedParams.length; i++){
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) {
            staticParams.push((0, _toHexJs.numberToHex)(staticSize + dynamicSize, {
                size: 32
            }));
            dynamicParams.push(encoded);
            dynamicSize += (0, _sizeJs.size)(encoded);
        } else staticParams.push(encoded);
    }
    // 3. Concatenate static and dynamic parts.
    return (0, _concatJs.concat)([
        ...staticParams,
        ...dynamicParams
    ]);
}
function encodeAddress(value) {
    if (!(0, _isAddressJs.isAddress)(value)) throw new (0, _addressJs.InvalidAddressError)({
        address: value
    });
    return {
        dynamic: false,
        encoded: (0, _padJs.padHex)(value.toLowerCase())
    };
}
function encodeArray(value, { length, param }) {
    const dynamic = length === null;
    if (!Array.isArray(value)) throw new (0, _abiJs.InvalidArrayError)(value);
    if (!dynamic && value.length !== length) throw new (0, _abiJs.AbiEncodingArrayLengthMismatchError)({
        expectedLength: length,
        givenLength: value.length,
        type: `${param.type}[${length}]`
    });
    let dynamicChild = false;
    const preparedParams = [];
    for(let i = 0; i < value.length; i++){
        const preparedParam = prepareParam({
            param,
            value: value[i]
        });
        if (preparedParam.dynamic) dynamicChild = true;
        preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
        const data = encodeParams(preparedParams);
        if (dynamic) {
            const length = (0, _toHexJs.numberToHex)(preparedParams.length, {
                size: 32
            });
            return {
                dynamic: true,
                encoded: preparedParams.length > 0 ? (0, _concatJs.concat)([
                    length,
                    data
                ]) : length
            };
        }
        if (dynamicChild) return {
            dynamic: true,
            encoded: data
        };
    }
    return {
        dynamic: false,
        encoded: (0, _concatJs.concat)(preparedParams.map(({ encoded })=>encoded))
    };
}
function encodeBytes(value, { param }) {
    const [, paramSize] = param.type.split('bytes');
    const bytesSize = (0, _sizeJs.size)(value);
    if (!paramSize) {
        let value_ = value;
        // If the size is not divisible by 32 bytes, pad the end
        // with empty bytes to the ceiling 32 bytes.
        if (bytesSize % 32 !== 0) value_ = (0, _padJs.padHex)(value_, {
            dir: 'right',
            size: Math.ceil((value.length - 2) / 2 / 32) * 32
        });
        return {
            dynamic: true,
            encoded: (0, _concatJs.concat)([
                (0, _padJs.padHex)((0, _toHexJs.numberToHex)(bytesSize, {
                    size: 32
                })),
                value_
            ])
        };
    }
    if (bytesSize !== Number.parseInt(paramSize)) throw new (0, _abiJs.AbiEncodingBytesSizeMismatchError)({
        expectedSize: Number.parseInt(paramSize),
        value
    });
    return {
        dynamic: false,
        encoded: (0, _padJs.padHex)(value, {
            dir: 'right'
        })
    };
}
function encodeBool(value) {
    if (typeof value !== 'boolean') throw new (0, _baseJs.BaseError)(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
    return {
        dynamic: false,
        encoded: (0, _padJs.padHex)((0, _toHexJs.boolToHex)(value))
    };
}
function encodeNumber(value, { signed, size = 256 }) {
    if (typeof size === 'number') {
        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;
        const min = signed ? -max - 1n : 0n;
        if (value > max || value < min) throw new (0, _encodingJs.IntegerOutOfRangeError)({
            max: max.toString(),
            min: min.toString(),
            signed,
            size: size / 8,
            value: value.toString()
        });
    }
    return {
        dynamic: false,
        encoded: (0, _toHexJs.numberToHex)(value, {
            size: 32,
            signed
        })
    };
}
function encodeString(value) {
    const hexValue = (0, _toHexJs.stringToHex)(value);
    const partsLength = Math.ceil((0, _sizeJs.size)(hexValue) / 32);
    const parts = [];
    for(let i = 0; i < partsLength; i++)parts.push((0, _padJs.padHex)((0, _sliceJs.slice)(hexValue, i * 32, (i + 1) * 32), {
        dir: 'right'
    }));
    return {
        dynamic: true,
        encoded: (0, _concatJs.concat)([
            (0, _padJs.padHex)((0, _toHexJs.numberToHex)((0, _sizeJs.size)(hexValue), {
                size: 32
            })),
            ...parts
        ])
    };
}
function encodeTuple(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for(let i = 0; i < param.components.length; i++){
        const param_ = param.components[i];
        const index = Array.isArray(value) ? i : param_.name;
        const preparedParam = prepareParam({
            param: param_,
            value: value[index]
        });
        preparedParams.push(preparedParam);
        if (preparedParam.dynamic) dynamic = true;
    }
    return {
        dynamic,
        encoded: dynamic ? encodeParams(preparedParams) : (0, _concatJs.concat)(preparedParams.map(({ encoded })=>encoded))
    };
}
function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? [
        matches[2] ? Number(matches[2]) : null,
        matches[1]
    ] : undefined;
}

},{"../../errors/abi.js":"7l8j7","../../errors/address.js":"17VWr","../../errors/base.js":"3SEPF","../../errors/encoding.js":"45Fmz","../address/isAddress.js":"kdAuv","../data/concat.js":"6FL5K","../data/pad.js":"aAjQN","../data/size.js":"exELm","../data/slice.js":"hh6kq","../encoding/toHex.js":"9GFC6","../regex.js":"cdnY6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"17VWr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InvalidAddressError", ()=>InvalidAddressError);
var _baseJs = require("./base.js");
class InvalidAddressError extends (0, _baseJs.BaseError) {
    constructor({ address }){
        super(`Address "${address}" is invalid.`, {
            metaMessages: [
                '- Address must be a hex value of 20 bytes (40 hex characters).',
                '- Address must match its checksum counterpart.'
            ],
            name: 'InvalidAddressError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kdAuv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isAddressCache", ()=>isAddressCache);
parcelHelpers.export(exports, "isAddress", ()=>isAddress);
var _lruJs = require("../lru.js");
var _getAddressJs = require("./getAddress.js");
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
const isAddressCache = /*#__PURE__*/ new (0, _lruJs.LruMap)(8192);
function isAddress(address, options) {
    const { strict = true } = options ?? {};
    const cacheKey = `${address}.${strict}`;
    if (isAddressCache.has(cacheKey)) return isAddressCache.get(cacheKey);
    const result = (()=>{
        if (!addressRegex.test(address)) return false;
        if (address.toLowerCase() === address) return true;
        if (strict) return (0, _getAddressJs.checksumAddress)(address) === address;
        return true;
    })();
    isAddressCache.set(cacheKey, result);
    return result;
}

},{"../lru.js":"ibK3x","./getAddress.js":"aGHEi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ibK3x":[function(require,module,exports,__globalThis) {
/**
 * Map with a LRU (Least recently used) policy.
 *
 * @link https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LruMap", ()=>LruMap);
class LruMap extends Map {
    constructor(size){
        super();
        Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.maxSize = size;
    }
    get(key) {
        const value = super.get(key);
        if (super.has(key) && value !== undefined) {
            this.delete(key);
            super.set(key, value);
        }
        return value;
    }
    set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize) {
            const firstKey = this.keys().next().value;
            if (firstKey) this.delete(firstKey);
        }
        return this;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aGHEi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checksumAddress", ()=>checksumAddress);
parcelHelpers.export(exports, "getAddress", ()=>getAddress);
var _addressJs = require("../../errors/address.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _keccak256Js = require("../hash/keccak256.js");
var _lruJs = require("../lru.js");
var _isAddressJs = require("./isAddress.js");
const checksumAddressCache = /*#__PURE__*/ new (0, _lruJs.LruMap)(8192);
function checksumAddress(address_, /**
 * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the
 * wider Ethereum ecosystem, meaning it will break when validated against an application/tool
 * that relies on EIP-55 checksum encoding (checksum without chainId).
 *
 * It is highly recommended to not use this feature unless you
 * know what you are doing.
 *
 * See more: https://github.com/ethereum/EIPs/issues/1121
 */ chainId) {
    if (checksumAddressCache.has(`${address_}.${chainId}`)) return checksumAddressCache.get(`${address_}.${chainId}`);
    const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
    const hash = (0, _keccak256Js.keccak256)((0, _toBytesJs.stringToBytes)(hexAddress), 'bytes');
    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');
    for(let i = 0; i < 40; i += 2){
        if (hash[i >> 1] >> 4 >= 8 && address[i]) address[i] = address[i].toUpperCase();
        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) address[i + 1] = address[i + 1].toUpperCase();
    }
    const result = `0x${address.join('')}`;
    checksumAddressCache.set(`${address_}.${chainId}`, result);
    return result;
}
function getAddress(address, /**
 * Warning: EIP-1191 checksum addresses are generally not backwards compatible with the
 * wider Ethereum ecosystem, meaning it will break when validated against an application/tool
 * that relies on EIP-55 checksum encoding (checksum without chainId).
 *
 * It is highly recommended to not use this feature unless you
 * know what you are doing.
 *
 * See more: https://github.com/ethereum/EIPs/issues/1121
 */ chainId) {
    if (!(0, _isAddressJs.isAddress)(address, {
        strict: false
    })) throw new (0, _addressJs.InvalidAddressError)({
        address
    });
    return checksumAddress(address, chainId);
}

},{"../../errors/address.js":"17VWr","../encoding/toBytes.js":"8cx1T","../hash/keccak256.js":"k4CmV","../lru.js":"ibK3x","./isAddress.js":"kdAuv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6FL5K":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "concat", ()=>concat);
parcelHelpers.export(exports, "concatBytes", ()=>concatBytes);
parcelHelpers.export(exports, "concatHex", ()=>concatHex);
function concat(values) {
    if (typeof values[0] === 'string') return concatHex(values);
    return concatBytes(values);
}
function concatBytes(values) {
    let length = 0;
    for (const arr of values)length += arr.length;
    const result = new Uint8Array(length);
    let offset = 0;
    for (const arr of values){
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}
function concatHex(values) {
    return `0x${values.reduce((acc, x)=>acc + x.replace('0x', ''), '')}`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hh6kq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Returns a section of the hex or byte array given a start/end bytes offset.
 *
 * @param value The hex or byte array to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */ parcelHelpers.export(exports, "slice", ()=>slice);
/**
 * @description Returns a section of the byte array given a start/end bytes offset.
 *
 * @param value The byte array to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */ parcelHelpers.export(exports, "sliceBytes", ()=>sliceBytes);
/**
 * @description Returns a section of the hex value given a start/end bytes offset.
 *
 * @param value The hex value to slice.
 * @param start The start offset (in bytes).
 * @param end The end offset (in bytes).
 */ parcelHelpers.export(exports, "sliceHex", ()=>sliceHex);
var _dataJs = require("../../errors/data.js");
var _isHexJs = require("./isHex.js");
var _sizeJs = require("./size.js");
function slice(value, start, end, { strict } = {}) {
    if ((0, _isHexJs.isHex)(value, {
        strict: false
    })) return sliceHex(value, start, end, {
        strict
    });
    return sliceBytes(value, start, end, {
        strict
    });
}
function assertStartOffset(value, start) {
    if (typeof start === 'number' && start > 0 && start > (0, _sizeJs.size)(value) - 1) throw new (0, _dataJs.SliceOffsetOutOfBoundsError)({
        offset: start,
        position: 'start',
        size: (0, _sizeJs.size)(value)
    });
}
function assertEndOffset(value, start, end) {
    if (typeof start === 'number' && typeof end === 'number' && (0, _sizeJs.size)(value) !== end - start) throw new (0, _dataJs.SliceOffsetOutOfBoundsError)({
        offset: end,
        position: 'end',
        size: (0, _sizeJs.size)(value)
    });
}
function sliceBytes(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = value_.slice(start, end);
    if (strict) assertEndOffset(value, start, end);
    return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = `0x${value_.replace('0x', '').slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
    if (strict) assertEndOffset(value, start, end);
    return value;
}

},{"../../errors/data.js":"kBfpj","./isHex.js":"evOcm","./size.js":"exELm","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cdnY6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrayRegex", ()=>arrayRegex);
parcelHelpers.export(exports, "bytesRegex", ()=>bytesRegex);
parcelHelpers.export(exports, "integerRegex", ()=>integerRegex);
const arrayRegex = /^(.*)\[([0-9]*)\]$/;
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k6BVB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAbiItem", ()=>getAbiItem);
/** @internal */ parcelHelpers.export(exports, "isArgOfType", ()=>isArgOfType);
/** @internal */ parcelHelpers.export(exports, "getAmbiguousTypes", ()=>getAmbiguousTypes);
var _abiJs = require("../../errors/abi.js");
var _isHexJs = require("../../utils/data/isHex.js");
var _isAddressJs = require("../address/isAddress.js");
var _toEventSelectorJs = require("../hash/toEventSelector.js");
var _toFunctionSelectorJs = require("../hash/toFunctionSelector.js");
function getAbiItem(parameters) {
    const { abi, args = [], name } = parameters;
    const isSelector = (0, _isHexJs.isHex)(name, {
        strict: false
    });
    const abiItems = abi.filter((abiItem)=>{
        if (isSelector) {
            if (abiItem.type === 'function') return (0, _toFunctionSelectorJs.toFunctionSelector)(abiItem) === name;
            if (abiItem.type === 'event') return (0, _toEventSelectorJs.toEventSelector)(abiItem) === name;
            return false;
        }
        return 'name' in abiItem && abiItem.name === name;
    });
    if (abiItems.length === 0) return undefined;
    if (abiItems.length === 1) return abiItems[0];
    let matchedAbiItem = undefined;
    for (const abiItem of abiItems){
        if (!('inputs' in abiItem)) continue;
        if (!args || args.length === 0) {
            if (!abiItem.inputs || abiItem.inputs.length === 0) return abiItem;
            continue;
        }
        if (!abiItem.inputs) continue;
        if (abiItem.inputs.length === 0) continue;
        if (abiItem.inputs.length !== args.length) continue;
        const matched = args.every((arg, index)=>{
            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];
            if (!abiParameter) return false;
            return isArgOfType(arg, abiParameter);
        });
        if (matched) {
            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).
            if (matchedAbiItem && 'inputs' in matchedAbiItem && matchedAbiItem.inputs) {
                const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
                if (ambiguousTypes) throw new (0, _abiJs.AbiItemAmbiguityError)({
                    abiItem,
                    type: ambiguousTypes[0]
                }, {
                    abiItem: matchedAbiItem,
                    type: ambiguousTypes[1]
                });
            }
            matchedAbiItem = abiItem;
        }
    }
    if (matchedAbiItem) return matchedAbiItem;
    return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch(abiParameterType){
        case 'address':
            return (0, _isAddressJs.isAddress)(arg, {
                strict: false
            });
        case 'bool':
            return argType === 'boolean';
        case 'function':
            return argType === 'string';
        case 'string':
            return argType === 'string';
        default:
            if (abiParameterType === 'tuple' && 'components' in abiParameter) return Object.values(abiParameter.components).every((component, index)=>{
                return isArgOfType(Object.values(arg)[index], component);
            });
            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`
            // https://regexr.com/6v8hp
            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === 'number' || argType === 'bigint';
            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`
            // https://regexr.com/6va55
            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === 'string' || arg instanceof Uint8Array;
            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays
            // https://regexr.com/6va6i
            if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) return Array.isArray(arg) && arg.every((x)=>isArgOfType(x, {
                    ...abiParameter,
                    // Pop off `[]` or `[M]` from end of type
                    type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, '')
                }));
            return false;
    }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
    for(const parameterIndex in sourceParameters){
        const sourceParameter = sourceParameters[parameterIndex];
        const targetParameter = targetParameters[parameterIndex];
        if (sourceParameter.type === 'tuple' && targetParameter.type === 'tuple' && 'components' in sourceParameter && 'components' in targetParameter) return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
        const types = [
            sourceParameter.type,
            targetParameter.type
        ];
        const ambiguous = (()=>{
            if (types.includes('address') && types.includes('bytes20')) return true;
            if (types.includes('address') && types.includes('string')) return (0, _isAddressJs.isAddress)(args[parameterIndex], {
                strict: false
            });
            if (types.includes('address') && types.includes('bytes')) return (0, _isAddressJs.isAddress)(args[parameterIndex], {
                strict: false
            });
            return false;
        })();
        if (ambiguous) return types;
    }
    return;
}

},{"../../errors/abi.js":"7l8j7","../../utils/data/isHex.js":"evOcm","../address/isAddress.js":"kdAuv","../hash/toEventSelector.js":"4FcAp","../hash/toFunctionSelector.js":"7CpcI","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7CpcI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toFunctionSelector", ()=>toFunctionSelector);
var _sliceJs = require("../data/slice.js");
var _toSignatureHashJs = require("./toSignatureHash.js");
const toFunctionSelector = (fn)=>(0, _sliceJs.slice)((0, _toSignatureHashJs.toSignatureHash)(fn), 0, 4);

},{"../data/slice.js":"hh6kq","./toSignatureHash.js":"7T2T5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lUucN":[function(require,module,exports,__globalThis) {
/**
 * Scopes `request` to the filter ID. If the client is a fallback, it will
 * listen for responses and scope the child transport `request` function
 * to the successful filter ID.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createFilterRequestScope", ()=>createFilterRequestScope);
function createFilterRequestScope(client, { method }) {
    const requestMap = {};
    if (client.transport.type === 'fallback') client.transport.onResponse?.(({ method: method_, response: id, status, transport })=>{
        if (status === 'success' && method === method_) requestMap[id] = transport.request;
    });
    return (id)=>requestMap[id] || client.request;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"26qE1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Estimates the gas required to successfully execute a contract write function call.
 *
 * - Docs: https://viem.sh/docs/contract/estimateContractGas
 *
 * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`estimateGas` action](https://viem.sh/docs/actions/public/estimateGas) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
 *
 * @param client - Client to use
 * @param parameters - {@link EstimateContractGasParameters}
 * @returns The gas estimate (in wei). {@link EstimateContractGasReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { estimateContractGas } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const gas = await estimateContractGas(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function mint() public']),
 *   functionName: 'mint',
 *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
 * })
 */ parcelHelpers.export(exports, "estimateContractGas", ()=>estimateContractGas);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getContractErrorJs = require("../../utils/errors/getContractError.js");
var _getActionJs = require("../../utils/getAction.js");
var _estimateGasJs = require("./estimateGas.js");
async function estimateContractGas(client, parameters) {
    const { abi, address, args, functionName, dataSuffix, ...request } = parameters;
    const data = (0, _encodeFunctionDataJs.encodeFunctionData)({
        abi,
        args,
        functionName
    });
    try {
        const gas = await (0, _getActionJs.getAction)(client, (0, _estimateGasJs.estimateGas), 'estimateGas')({
            data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
            to: address,
            ...request
        });
        return gas;
    } catch (error) {
        const account = request.account ? (0, _parseAccountJs.parseAccount)(request.account) : undefined;
        throw (0, _getContractErrorJs.getContractError)(error, {
            abi,
            address,
            args,
            docsPath: '/docs/contract/estimateContractGas',
            functionName,
            sender: account?.address
        });
    }
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../utils/abi/encodeFunctionData.js":"eQLEb","../../utils/errors/getContractError.js":"kESZV","../../utils/getAction.js":"d1Bvd","./estimateGas.js":"22Lcu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lGQkg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseAccount", ()=>parseAccount);
function parseAccount(account) {
    if (typeof account === 'string') return {
        address: account,
        type: 'json-rpc'
    };
    return account;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eQLEb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeFunctionData", ()=>encodeFunctionData);
var _concatJs = require("../data/concat.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
var _prepareEncodeFunctionDataJs = require("./prepareEncodeFunctionData.js");
function encodeFunctionData(parameters) {
    const { args } = parameters;
    const { abi, functionName } = (()=>{
        if (parameters.abi.length === 1 && parameters.functionName?.startsWith('0x')) return parameters;
        return (0, _prepareEncodeFunctionDataJs.prepareEncodeFunctionData)(parameters);
    })();
    const abiItem = abi[0];
    const signature = functionName;
    const data = 'inputs' in abiItem && abiItem.inputs ? (0, _encodeAbiParametersJs.encodeAbiParameters)(abiItem.inputs, args ?? []) : undefined;
    return (0, _concatJs.concatHex)([
        signature,
        data ?? '0x'
    ]);
}

},{"../data/concat.js":"6FL5K","./encodeAbiParameters.js":"8kHRc","./prepareEncodeFunctionData.js":"8U0DY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8U0DY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "prepareEncodeFunctionData", ()=>prepareEncodeFunctionData);
var _abiJs = require("../../errors/abi.js");
var _toFunctionSelectorJs = require("../hash/toFunctionSelector.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
var _getAbiItemJs = require("./getAbiItem.js");
const docsPath = '/docs/contract/encodeFunctionData';
function prepareEncodeFunctionData(parameters) {
    const { abi, args, functionName } = parameters;
    let abiItem = abi[0];
    if (functionName) {
        const item = (0, _getAbiItemJs.getAbiItem)({
            abi,
            args,
            name: functionName
        });
        if (!item) throw new (0, _abiJs.AbiFunctionNotFoundError)(functionName, {
            docsPath
        });
        abiItem = item;
    }
    if (abiItem.type !== 'function') throw new (0, _abiJs.AbiFunctionNotFoundError)(undefined, {
        docsPath
    });
    return {
        abi: [
            abiItem
        ],
        functionName: (0, _toFunctionSelectorJs.toFunctionSelector)((0, _formatAbiItemJs.formatAbiItem)(abiItem))
    };
}

},{"../../errors/abi.js":"7l8j7","../hash/toFunctionSelector.js":"7CpcI","./formatAbiItem.js":"khxDG","./getAbiItem.js":"k6BVB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kESZV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getContractError", ()=>getContractError);
var _abiJs = require("../../errors/abi.js");
var _baseJs = require("../../errors/base.js");
var _contractJs = require("../../errors/contract.js");
var _requestJs = require("../../errors/request.js");
var _rpcJs = require("../../errors/rpc.js");
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi, address, args, docsPath, functionName, sender }) {
    const error = err instanceof (0, _contractJs.RawContractError) ? err : err instanceof (0, _baseJs.BaseError) ? err.walk((err)=>'data' in err) || err.walk() : {};
    const { code, data, details, message, shortMessage } = error;
    const cause = (()=>{
        if (err instanceof (0, _abiJs.AbiDecodingZeroDataError)) return new (0, _contractJs.ContractFunctionZeroDataError)({
            functionName
        });
        if ([
            EXECUTION_REVERTED_ERROR_CODE,
            (0, _rpcJs.InternalRpcError).code
        ].includes(code) && (data || details || message || shortMessage)) return new (0, _contractJs.ContractFunctionRevertedError)({
            abi,
            data: typeof data === 'object' ? data.data : data,
            functionName,
            message: error instanceof (0, _requestJs.RpcRequestError) ? details : shortMessage ?? message
        });
        return err;
    })();
    return new (0, _contractJs.ContractFunctionExecutionError)(cause, {
        abi,
        args,
        contractAddress: address,
        docsPath,
        functionName,
        sender
    });
}

},{"../../errors/abi.js":"7l8j7","../../errors/base.js":"3SEPF","../../errors/contract.js":"1S92K","../../errors/request.js":"6LYvf","../../errors/rpc.js":"jYSPv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1S92K":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CallExecutionError", ()=>CallExecutionError);
parcelHelpers.export(exports, "ContractFunctionExecutionError", ()=>ContractFunctionExecutionError);
parcelHelpers.export(exports, "ContractFunctionRevertedError", ()=>ContractFunctionRevertedError);
parcelHelpers.export(exports, "ContractFunctionZeroDataError", ()=>ContractFunctionZeroDataError);
parcelHelpers.export(exports, "CounterfactualDeploymentFailedError", ()=>CounterfactualDeploymentFailedError);
parcelHelpers.export(exports, "RawContractError", ()=>RawContractError);
var _parseAccountJs = require("../accounts/utils/parseAccount.js");
var _solidityJs = require("../constants/solidity.js");
var _decodeErrorResultJs = require("../utils/abi/decodeErrorResult.js");
var _formatAbiItemJs = require("../utils/abi/formatAbiItem.js");
var _formatAbiItemWithArgsJs = require("../utils/abi/formatAbiItemWithArgs.js");
var _getAbiItemJs = require("../utils/abi/getAbiItem.js");
var _formatEtherJs = require("../utils/unit/formatEther.js");
var _formatGweiJs = require("../utils/unit/formatGwei.js");
var _abiJs = require("./abi.js");
var _baseJs = require("./base.js");
var _stateOverrideJs = require("./stateOverride.js");
var _transactionJs = require("./transaction.js");
var _utilsJs = require("./utils.js");
class CallExecutionError extends (0, _baseJs.BaseError) {
    constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride }){
        const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : undefined;
        let prettyArgs = (0, _transactionJs.prettyPrint)({
            from: account?.address,
            to,
            value: typeof value !== 'undefined' && `${(0, _formatEtherJs.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== 'undefined' && `${(0, _formatGweiJs.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== 'undefined' && `${(0, _formatGweiJs.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' && `${(0, _formatGweiJs.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce
        });
        if (stateOverride) prettyArgs += `\n${(0, _stateOverrideJs.prettyStateOverride)(stateOverride)}`;
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...cause.metaMessages ? [
                    ...cause.metaMessages,
                    ' '
                ] : [],
                'Raw Call Arguments:',
                prettyArgs
            ].filter(Boolean),
            name: 'CallExecutionError'
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.cause = cause;
    }
}
class ContractFunctionExecutionError extends (0, _baseJs.BaseError) {
    constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender }){
        const abiItem = (0, _getAbiItemJs.getAbiItem)({
            abi,
            args,
            name: functionName
        });
        const formattedArgs = abiItem ? (0, _formatAbiItemWithArgsJs.formatAbiItemWithArgs)({
            abiItem,
            args,
            includeFunctionName: false,
            includeName: false
        }) : undefined;
        const functionWithParams = abiItem ? (0, _formatAbiItemJs.formatAbiItem)(abiItem, {
            includeName: true
        }) : undefined;
        const prettyArgs = (0, _transactionJs.prettyPrint)({
            address: contractAddress && (0, _utilsJs.getContractAddress)(contractAddress),
            function: functionWithParams,
            args: formattedArgs && formattedArgs !== '()' && `${[
                ...Array(functionName?.length ?? 0).keys()
            ].map(()=>' ').join('')}${formattedArgs}`,
            sender
        });
        super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
            cause,
            docsPath,
            metaMessages: [
                ...cause.metaMessages ? [
                    ...cause.metaMessages,
                    ' '
                ] : [],
                prettyArgs && 'Contract Call:',
                prettyArgs
            ].filter(Boolean),
            name: 'ContractFunctionExecutionError'
        });
        Object.defineProperty(this, "abi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "contractAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "formattedArgs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abi = abi;
        this.args = args;
        this.cause = cause;
        this.contractAddress = contractAddress;
        this.functionName = functionName;
        this.sender = sender;
    }
}
class ContractFunctionRevertedError extends (0, _baseJs.BaseError) {
    constructor({ abi, data, functionName, message }){
        let cause;
        let decodedData = undefined;
        let metaMessages;
        let reason;
        if (data && data !== '0x') try {
            decodedData = (0, _decodeErrorResultJs.decodeErrorResult)({
                abi,
                data
            });
            const { abiItem, errorName, args: errorArgs } = decodedData;
            if (errorName === 'Error') reason = errorArgs[0];
            else if (errorName === 'Panic') {
                const [firstArg] = errorArgs;
                reason = (0, _solidityJs.panicReasons)[firstArg];
            } else {
                const errorWithParams = abiItem ? (0, _formatAbiItemJs.formatAbiItem)(abiItem, {
                    includeName: true
                }) : undefined;
                const formattedArgs = abiItem && errorArgs ? (0, _formatAbiItemWithArgsJs.formatAbiItemWithArgs)({
                    abiItem,
                    args: errorArgs,
                    includeFunctionName: false,
                    includeName: false
                }) : undefined;
                metaMessages = [
                    errorWithParams ? `Error: ${errorWithParams}` : '',
                    formattedArgs && formattedArgs !== '()' ? `       ${[
                        ...Array(errorName?.length ?? 0).keys()
                    ].map(()=>' ').join('')}${formattedArgs}` : ''
                ];
            }
        } catch (err) {
            cause = err;
        }
        else if (message) reason = message;
        let signature;
        if (cause instanceof (0, _abiJs.AbiErrorSignatureNotFoundError)) {
            signature = cause.signature;
            metaMessages = [
                `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
                'Make sure you are using the correct ABI and that the error exists on it.',
                `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`
            ];
        }
        super(reason && reason !== 'execution reverted' || signature ? [
            `The contract function "${functionName}" reverted with the following ${signature ? 'signature' : 'reason'}:`,
            reason || signature
        ].join('\n') : `The contract function "${functionName}" reverted.`, {
            cause,
            metaMessages,
            name: 'ContractFunctionRevertedError'
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "signature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = decodedData;
        this.raw = data;
        this.reason = reason;
        this.signature = signature;
    }
}
class ContractFunctionZeroDataError extends (0, _baseJs.BaseError) {
    constructor({ functionName }){
        super(`The contract function "${functionName}" returned no data ("0x").`, {
            metaMessages: [
                'This could be due to any of the following:',
                `  - The contract does not have the function "${functionName}",`,
                '  - The parameters passed to the contract function may be invalid, or',
                '  - The address is not a contract.'
            ],
            name: 'ContractFunctionZeroDataError'
        });
    }
}
class CounterfactualDeploymentFailedError extends (0, _baseJs.BaseError) {
    constructor({ factory }){
        super(`Deployment for counterfactual contract call failed${factory ? ` for factory "${factory}".` : ''}`, {
            metaMessages: [
                'Please ensure:',
                '- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).',
                '- The `factoryData` is a valid encoded function call for contract deployment function on the factory.'
            ],
            name: 'CounterfactualDeploymentFailedError'
        });
    }
}
class RawContractError extends (0, _baseJs.BaseError) {
    constructor({ data, message }){
        super(message || '', {
            name: 'RawContractError'
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 3
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = data;
    }
}

},{"../accounts/utils/parseAccount.js":"lGQkg","../constants/solidity.js":"bzCGA","../utils/abi/decodeErrorResult.js":"kFalj","../utils/abi/formatAbiItem.js":"khxDG","../utils/abi/formatAbiItemWithArgs.js":"6jPYC","../utils/abi/getAbiItem.js":"k6BVB","../utils/unit/formatEther.js":"d8qm6","../utils/unit/formatGwei.js":"2vNTy","./abi.js":"7l8j7","./base.js":"3SEPF","./stateOverride.js":"3GdPa","./transaction.js":"4gFzr","./utils.js":"3ALY3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bzCGA":[function(require,module,exports,__globalThis) {
// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "panicReasons", ()=>panicReasons);
parcelHelpers.export(exports, "solidityError", ()=>solidityError);
parcelHelpers.export(exports, "solidityPanic", ()=>solidityPanic);
const panicReasons = {
    1: 'An `assert` condition failed.',
    17: 'Arithmetic operation resulted in underflow or overflow.',
    18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',
    33: 'Attempted to convert to an invalid type.',
    34: 'Attempted to access a storage byte array that is incorrectly encoded.',
    49: 'Performed `.pop()` on an empty array',
    50: 'Array index is out of bounds.',
    65: 'Allocated too much memory or created an array which is too large.',
    81: 'Attempted to call a zero-initialized variable of internal function type.'
};
const solidityError = {
    inputs: [
        {
            name: 'message',
            type: 'string'
        }
    ],
    name: 'Error',
    type: 'error'
};
const solidityPanic = {
    inputs: [
        {
            name: 'reason',
            type: 'uint256'
        }
    ],
    name: 'Panic',
    type: 'error'
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kFalj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeErrorResult", ()=>decodeErrorResult);
var _solidityJs = require("../../constants/solidity.js");
var _abiJs = require("../../errors/abi.js");
var _sliceJs = require("../data/slice.js");
var _toFunctionSelectorJs = require("../hash/toFunctionSelector.js");
var _decodeAbiParametersJs = require("./decodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
function decodeErrorResult(parameters) {
    const { abi, data } = parameters;
    const signature = (0, _sliceJs.slice)(data, 0, 4);
    if (signature === '0x') throw new (0, _abiJs.AbiDecodingZeroDataError)();
    const abi_ = [
        ...abi || [],
        (0, _solidityJs.solidityError),
        (0, _solidityJs.solidityPanic)
    ];
    const abiItem = abi_.find((x)=>x.type === 'error' && signature === (0, _toFunctionSelectorJs.toFunctionSelector)((0, _formatAbiItemJs.formatAbiItem)(x)));
    if (!abiItem) throw new (0, _abiJs.AbiErrorSignatureNotFoundError)(signature, {
        docsPath: '/docs/contract/decodeErrorResult'
    });
    return {
        abiItem,
        args: 'inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? (0, _decodeAbiParametersJs.decodeAbiParameters)(abiItem.inputs, (0, _sliceJs.slice)(data, 4)) : undefined,
        errorName: abiItem.name
    };
}

},{"../../constants/solidity.js":"bzCGA","../../errors/abi.js":"7l8j7","../data/slice.js":"hh6kq","../hash/toFunctionSelector.js":"7CpcI","./decodeAbiParameters.js":"hR5FN","./formatAbiItem.js":"khxDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hR5FN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeAbiParameters", ()=>decodeAbiParameters);
var _abiJs = require("../../errors/abi.js");
var _getAddressJs = require("../address/getAddress.js");
var _cursorJs = require("../cursor.js");
var _sizeJs = require("../data/size.js");
var _sliceJs = require("../data/slice.js");
var _trimJs = require("../data/trim.js");
var _fromBytesJs = require("../encoding/fromBytes.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
function decodeAbiParameters(params, data) {
    const bytes = typeof data === 'string' ? (0, _toBytesJs.hexToBytes)(data) : data;
    const cursor = (0, _cursorJs.createCursor)(bytes);
    if ((0, _sizeJs.size)(bytes) === 0 && params.length > 0) throw new (0, _abiJs.AbiDecodingZeroDataError)();
    if ((0, _sizeJs.size)(data) && (0, _sizeJs.size)(data) < 32) throw new (0, _abiJs.AbiDecodingDataSizeTooSmallError)({
        data: typeof data === 'string' ? data : (0, _toHexJs.bytesToHex)(data),
        params: params,
        size: (0, _sizeJs.size)(data)
    });
    let consumed = 0;
    const values = [];
    for(let i = 0; i < params.length; ++i){
        const param = params[i];
        cursor.setPosition(consumed);
        const [data, consumed_] = decodeParameter(cursor, param, {
            staticPosition: 0
        });
        consumed += consumed_;
        values.push(data);
    }
    return values;
}
function decodeParameter(cursor, param, { staticPosition }) {
    const arrayComponents = (0, _encodeAbiParametersJs.getArrayComponents)(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return decodeArray(cursor, {
            ...param,
            type
        }, {
            length,
            staticPosition
        });
    }
    if (param.type === 'tuple') return decodeTuple(cursor, param, {
        staticPosition
    });
    if (param.type === 'address') return decodeAddress(cursor);
    if (param.type === 'bool') return decodeBool(cursor);
    if (param.type.startsWith('bytes')) return decodeBytes(cursor, param, {
        staticPosition
    });
    if (param.type.startsWith('uint') || param.type.startsWith('int')) return decodeNumber(cursor, param);
    if (param.type === 'string') return decodeString(cursor, {
        staticPosition
    });
    throw new (0, _abiJs.InvalidAbiDecodingTypeError)(param.type, {
        docsPath: '/docs/contract/decodeAbiParameters'
    });
}
////////////////////////////////////////////////////////////////////
// Type Decoders
const sizeOfLength = 32;
const sizeOfOffset = 32;
function decodeAddress(cursor) {
    const value = cursor.readBytes(32);
    return [
        (0, _getAddressJs.checksumAddress)((0, _toHexJs.bytesToHex)((0, _sliceJs.sliceBytes)(value, -20))),
        32
    ];
}
function decodeArray(cursor, param, { length, staticPosition }) {
    // If the length of the array is not known in advance (dynamic array),
    // this means we will need to wonder off to the pointer and decode.
    if (!length) {
        // Dealing with a dynamic type, so get the offset of the array data.
        const offset = (0, _fromBytesJs.bytesToNumber)(cursor.readBytes(sizeOfOffset));
        // Start is the static position of current slot + offset.
        const start = staticPosition + offset;
        const startOfData = start + sizeOfLength;
        // Get the length of the array from the offset.
        cursor.setPosition(start);
        const length = (0, _fromBytesJs.bytesToNumber)(cursor.readBytes(sizeOfLength));
        // Check if the array has any dynamic children.
        const dynamicChild = hasDynamicChild(param);
        let consumed = 0;
        const value = [];
        for(let i = 0; i < length; ++i){
            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).
            // Otherwise, elements will be the size of their encoding (consumed bytes).
            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));
            const [data, consumed_] = decodeParameter(cursor, param, {
                staticPosition: startOfData
            });
            consumed += consumed_;
            value.push(data);
        }
        // As we have gone wondering, restore to the original position + next slot.
        cursor.setPosition(staticPosition + 32);
        return [
            value,
            32
        ];
    }
    // If the length of the array is known in advance,
    // and the length of an element deeply nested in the array is not known,
    // we need to decode the offset of the array data.
    if (hasDynamicChild(param)) {
        // Dealing with dynamic types, so get the offset of the array data.
        const offset = (0, _fromBytesJs.bytesToNumber)(cursor.readBytes(sizeOfOffset));
        // Start is the static position of current slot + offset.
        const start = staticPosition + offset;
        const value = [];
        for(let i = 0; i < length; ++i){
            // Move cursor along to the next slot (next offset pointer).
            cursor.setPosition(start + i * 32);
            const [data] = decodeParameter(cursor, param, {
                staticPosition: start
            });
            value.push(data);
        }
        // As we have gone wondering, restore to the original position + next slot.
        cursor.setPosition(staticPosition + 32);
        return [
            value,
            32
        ];
    }
    // If the length of the array is known in advance and the array is deeply static,
    // then we can just decode each element in sequence.
    let consumed = 0;
    const value = [];
    for(let i = 0; i < length; ++i){
        const [data, consumed_] = decodeParameter(cursor, param, {
            staticPosition: staticPosition + consumed
        });
        consumed += consumed_;
        value.push(data);
    }
    return [
        value,
        consumed
    ];
}
function decodeBool(cursor) {
    return [
        (0, _fromBytesJs.bytesToBool)(cursor.readBytes(32), {
            size: 32
        }),
        32
    ];
}
function decodeBytes(cursor, param, { staticPosition }) {
    const [_, size] = param.type.split('bytes');
    if (!size) {
        // Dealing with dynamic types, so get the offset of the bytes data.
        const offset = (0, _fromBytesJs.bytesToNumber)(cursor.readBytes(32));
        // Set position of the cursor to start of bytes data.
        cursor.setPosition(staticPosition + offset);
        const length = (0, _fromBytesJs.bytesToNumber)(cursor.readBytes(32));
        // If there is no length, we have zero data.
        if (length === 0) {
            // As we have gone wondering, restore to the original position + next slot.
            cursor.setPosition(staticPosition + 32);
            return [
                '0x',
                32
            ];
        }
        const data = cursor.readBytes(length);
        // As we have gone wondering, restore to the original position + next slot.
        cursor.setPosition(staticPosition + 32);
        return [
            (0, _toHexJs.bytesToHex)(data),
            32
        ];
    }
    const value = (0, _toHexJs.bytesToHex)(cursor.readBytes(Number.parseInt(size), 32));
    return [
        value,
        32
    ];
}
function decodeNumber(cursor, param) {
    const signed = param.type.startsWith('int');
    const size = Number.parseInt(param.type.split('int')[1] || '256');
    const value = cursor.readBytes(32);
    return [
        size > 48 ? (0, _fromBytesJs.bytesToBigInt)(value, {
            signed
        }) : (0, _fromBytesJs.bytesToNumber)(value, {
            signed
        }),
        32
    ];
}
function decodeTuple(cursor, param, { staticPosition }) {
    // Tuples can have unnamed components (i.e. they are arrays), so we must
    // determine whether the tuple is named or unnamed. In the case of a named
    // tuple, the value will be an object where each property is the name of the
    // component. In the case of an unnamed tuple, the value will be an array.
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name })=>!name);
    // Initialize the value to an object or an array, depending on whether the
    // tuple is named or unnamed.
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    // If the tuple has a dynamic child, we must first decode the offset to the
    // tuple data.
    if (hasDynamicChild(param)) {
        // Dealing with dynamic types, so get the offset of the tuple data.
        const offset = (0, _fromBytesJs.bytesToNumber)(cursor.readBytes(sizeOfOffset));
        // Start is the static position of referencing slot + offset.
        const start = staticPosition + offset;
        for(let i = 0; i < param.components.length; ++i){
            const component = param.components[i];
            cursor.setPosition(start + consumed);
            const [data, consumed_] = decodeParameter(cursor, component, {
                staticPosition: start
            });
            consumed += consumed_;
            value[hasUnnamedChild ? i : component?.name] = data;
        }
        // As we have gone wondering, restore to the original position + next slot.
        cursor.setPosition(staticPosition + 32);
        return [
            value,
            32
        ];
    }
    // If the tuple has static children, we can just decode each component
    // in sequence.
    for(let i = 0; i < param.components.length; ++i){
        const component = param.components[i];
        const [data, consumed_] = decodeParameter(cursor, component, {
            staticPosition
        });
        value[hasUnnamedChild ? i : component?.name] = data;
        consumed += consumed_;
    }
    return [
        value,
        consumed
    ];
}
function decodeString(cursor, { staticPosition }) {
    // Get offset to start of string data.
    const offset = (0, _fromBytesJs.bytesToNumber)(cursor.readBytes(32));
    // Start is the static position of current slot + offset.
    const start = staticPosition + offset;
    cursor.setPosition(start);
    const length = (0, _fromBytesJs.bytesToNumber)(cursor.readBytes(32));
    // If there is no length, we have zero data (empty string).
    if (length === 0) {
        cursor.setPosition(staticPosition + 32);
        return [
            '',
            32
        ];
    }
    const data = cursor.readBytes(length, 32);
    const value = (0, _fromBytesJs.bytesToString)((0, _trimJs.trim)(data));
    // As we have gone wondering, restore to the original position + next slot.
    cursor.setPosition(staticPosition + 32);
    return [
        value,
        32
    ];
}
function hasDynamicChild(param) {
    const { type } = param;
    if (type === 'string') return true;
    if (type === 'bytes') return true;
    if (type.endsWith('[]')) return true;
    if (type === 'tuple') return param.components?.some(hasDynamicChild);
    const arrayComponents = (0, _encodeAbiParametersJs.getArrayComponents)(param.type);
    if (arrayComponents && hasDynamicChild({
        ...param,
        type: arrayComponents[1]
    })) return true;
    return false;
}

},{"../../errors/abi.js":"7l8j7","../address/getAddress.js":"aGHEi","../cursor.js":"pWJ3P","../data/size.js":"exELm","../data/slice.js":"hh6kq","../data/trim.js":"3ZmMy","../encoding/fromBytes.js":"dY2Xd","../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","./encodeAbiParameters.js":"8kHRc","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"pWJ3P":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createCursor", ()=>createCursor);
var _cursorJs = require("../errors/cursor.js");
const staticCursor = {
    bytes: new Uint8Array(),
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: new Map(),
    recursiveReadCount: 0,
    recursiveReadLimit: Number.POSITIVE_INFINITY,
    assertReadLimit () {
        if (this.recursiveReadCount >= this.recursiveReadLimit) throw new (0, _cursorJs.RecursiveReadLimitExceededError)({
            count: this.recursiveReadCount + 1,
            limit: this.recursiveReadLimit
        });
    },
    assertPosition (position) {
        if (position < 0 || position > this.bytes.length - 1) throw new (0, _cursorJs.PositionOutOfBoundsError)({
            length: this.bytes.length,
            position
        });
    },
    decrementPosition (offset) {
        if (offset < 0) throw new (0, _cursorJs.NegativeOffsetError)({
            offset
        });
        const position = this.position - offset;
        this.assertPosition(position);
        this.position = position;
    },
    getReadCount (position) {
        return this.positionReadCount.get(position || this.position) || 0;
    },
    incrementPosition (offset) {
        if (offset < 0) throw new (0, _cursorJs.NegativeOffsetError)({
            offset
        });
        const position = this.position + offset;
        this.assertPosition(position);
        this.position = position;
    },
    inspectByte (position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
    },
    inspectBytes (length, position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + length - 1);
        return this.bytes.subarray(position, position + length);
    },
    inspectUint8 (position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
    },
    inspectUint16 (position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 1);
        return this.dataView.getUint16(position);
    },
    inspectUint24 (position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 2);
        return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
    },
    inspectUint32 (position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 3);
        return this.dataView.getUint32(position);
    },
    pushByte (byte) {
        this.assertPosition(this.position);
        this.bytes[this.position] = byte;
        this.position++;
    },
    pushBytes (bytes) {
        this.assertPosition(this.position + bytes.length - 1);
        this.bytes.set(bytes, this.position);
        this.position += bytes.length;
    },
    pushUint8 (value) {
        this.assertPosition(this.position);
        this.bytes[this.position] = value;
        this.position++;
    },
    pushUint16 (value) {
        this.assertPosition(this.position + 1);
        this.dataView.setUint16(this.position, value);
        this.position += 2;
    },
    pushUint24 (value) {
        this.assertPosition(this.position + 2);
        this.dataView.setUint16(this.position, value >> 8);
        this.dataView.setUint8(this.position + 2, value & 255);
        this.position += 3;
    },
    pushUint32 (value) {
        this.assertPosition(this.position + 3);
        this.dataView.setUint32(this.position, value);
        this.position += 4;
    },
    readByte () {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectByte();
        this.position++;
        return value;
    },
    readBytes (length, size) {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectBytes(length);
        this.position += size ?? length;
        return value;
    },
    readUint8 () {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint8();
        this.position += 1;
        return value;
    },
    readUint16 () {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint16();
        this.position += 2;
        return value;
    },
    readUint24 () {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint24();
        this.position += 3;
        return value;
    },
    readUint32 () {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint32();
        this.position += 4;
        return value;
    },
    get remaining () {
        return this.bytes.length - this.position;
    },
    setPosition (position) {
        const oldPosition = this.position;
        this.assertPosition(position);
        this.position = position;
        return ()=>this.position = oldPosition;
    },
    _touch () {
        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
        const count = this.getReadCount();
        this.positionReadCount.set(this.position, count + 1);
        if (count > 0) this.recursiveReadCount++;
    }
};
function createCursor(bytes, { recursiveReadLimit = 8192 } = {}) {
    const cursor = Object.create(staticCursor);
    cursor.bytes = bytes;
    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    cursor.positionReadCount = new Map();
    cursor.recursiveReadLimit = recursiveReadLimit;
    return cursor;
}

},{"../errors/cursor.js":"3ZOkN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3ZOkN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NegativeOffsetError", ()=>NegativeOffsetError);
parcelHelpers.export(exports, "PositionOutOfBoundsError", ()=>PositionOutOfBoundsError);
parcelHelpers.export(exports, "RecursiveReadLimitExceededError", ()=>RecursiveReadLimitExceededError);
var _baseJs = require("./base.js");
class NegativeOffsetError extends (0, _baseJs.BaseError) {
    constructor({ offset }){
        super(`Offset \`${offset}\` cannot be negative.`, {
            name: 'NegativeOffsetError'
        });
    }
}
class PositionOutOfBoundsError extends (0, _baseJs.BaseError) {
    constructor({ length, position }){
        super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, {
            name: 'PositionOutOfBoundsError'
        });
    }
}
class RecursiveReadLimitExceededError extends (0, _baseJs.BaseError) {
    constructor({ count, limit }){
        super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, {
            name: 'RecursiveReadLimitExceededError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dY2Xd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Decodes a byte array into a UTF-8 string, hex value, number, bigint or boolean.
 *
 * - Docs: https://viem.sh/docs/utilities/fromBytes
 * - Example: https://viem.sh/docs/utilities/fromBytes#usage
 *
 * @param bytes Byte array to decode.
 * @param toOrOpts Type to convert to or options.
 * @returns Decoded value.
 *
 * @example
 * import { fromBytes } from 'viem'
 * const data = fromBytes(new Uint8Array([1, 164]), 'number')
 * // 420
 *
 * @example
 * import { fromBytes } from 'viem'
 * const data = fromBytes(
 *   new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]),
 *   'string'
 * )
 * // 'Hello world'
 */ parcelHelpers.export(exports, "fromBytes", ()=>fromBytes);
/**
 * Decodes a byte array into a bigint.
 *
 * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobigint
 *
 * @param bytes Byte array to decode.
 * @param opts Options.
 * @returns BigInt value.
 *
 * @example
 * import { bytesToBigInt } from 'viem'
 * const data = bytesToBigInt(new Uint8Array([1, 164]))
 * // 420n
 */ parcelHelpers.export(exports, "bytesToBigInt", ()=>bytesToBigInt);
/**
 * Decodes a byte array into a boolean.
 *
 * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestobool
 *
 * @param bytes Byte array to decode.
 * @param opts Options.
 * @returns Boolean value.
 *
 * @example
 * import { bytesToBool } from 'viem'
 * const data = bytesToBool(new Uint8Array([1]))
 * // true
 */ parcelHelpers.export(exports, "bytesToBool", ()=>bytesToBool);
/**
 * Decodes a byte array into a number.
 *
 * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestonumber
 *
 * @param bytes Byte array to decode.
 * @param opts Options.
 * @returns Number value.
 *
 * @example
 * import { bytesToNumber } from 'viem'
 * const data = bytesToNumber(new Uint8Array([1, 164]))
 * // 420
 */ parcelHelpers.export(exports, "bytesToNumber", ()=>bytesToNumber);
/**
 * Decodes a byte array into a UTF-8 string.
 *
 * - Docs: https://viem.sh/docs/utilities/fromBytes#bytestostring
 *
 * @param bytes Byte array to decode.
 * @param opts Options.
 * @returns String value.
 *
 * @example
 * import { bytesToString } from 'viem'
 * const data = bytesToString(new Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))
 * // 'Hello world'
 */ parcelHelpers.export(exports, "bytesToString", ()=>bytesToString);
var _encodingJs = require("../../errors/encoding.js");
var _trimJs = require("../data/trim.js");
var _fromHexJs = require("./fromHex.js");
var _toHexJs = require("./toHex.js");
function fromBytes(bytes, toOrOpts) {
    const opts = typeof toOrOpts === 'string' ? {
        to: toOrOpts
    } : toOrOpts;
    const to = opts.to;
    if (to === 'number') return bytesToNumber(bytes, opts);
    if (to === 'bigint') return bytesToBigInt(bytes, opts);
    if (to === 'boolean') return bytesToBool(bytes, opts);
    if (to === 'string') return bytesToString(bytes, opts);
    return (0, _toHexJs.bytesToHex)(bytes, opts);
}
function bytesToBigInt(bytes, opts = {}) {
    if (typeof opts.size !== 'undefined') (0, _fromHexJs.assertSize)(bytes, {
        size: opts.size
    });
    const hex = (0, _toHexJs.bytesToHex)(bytes, opts);
    return (0, _fromHexJs.hexToBigInt)(hex, opts);
}
function bytesToBool(bytes_, opts = {}) {
    let bytes = bytes_;
    if (typeof opts.size !== 'undefined') {
        (0, _fromHexJs.assertSize)(bytes, {
            size: opts.size
        });
        bytes = (0, _trimJs.trim)(bytes);
    }
    if (bytes.length > 1 || bytes[0] > 1) throw new (0, _encodingJs.InvalidBytesBooleanError)(bytes);
    return Boolean(bytes[0]);
}
function bytesToNumber(bytes, opts = {}) {
    if (typeof opts.size !== 'undefined') (0, _fromHexJs.assertSize)(bytes, {
        size: opts.size
    });
    const hex = (0, _toHexJs.bytesToHex)(bytes, opts);
    return (0, _fromHexJs.hexToNumber)(hex, opts);
}
function bytesToString(bytes_, opts = {}) {
    let bytes = bytes_;
    if (typeof opts.size !== 'undefined') {
        (0, _fromHexJs.assertSize)(bytes, {
            size: opts.size
        });
        bytes = (0, _trimJs.trim)(bytes, {
            dir: 'right'
        });
    }
    return new TextDecoder().decode(bytes);
}

},{"../../errors/encoding.js":"45Fmz","../data/trim.js":"3ZmMy","./fromHex.js":"kLfW5","./toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6jPYC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatAbiItemWithArgs", ()=>formatAbiItemWithArgs);
var _stringifyJs = require("../stringify.js");
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
    if (!('name' in abiItem)) return;
    if (!('inputs' in abiItem)) return;
    if (!abiItem.inputs) return;
    return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs.map((input, i)=>`${includeName && input.name ? `${input.name}: ` : ''}${typeof args[i] === 'object' ? (0, _stringifyJs.stringify)(args[i]) : args[i]}`).join(', ')})`;
}

},{"../stringify.js":"jKcjI","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jKcjI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stringify", ()=>stringify);
const stringify = (value, replacer, space)=>JSON.stringify(value, (key, value_)=>{
        const value = typeof value_ === 'bigint' ? value_.toString() : value_;
        return typeof replacer === 'function' ? replacer(key, value) : value;
    }, space);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d8qm6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts numerical wei to a string representation of ether.
 *
 * - Docs: https://viem.sh/docs/utilities/formatEther
 *
 * @example
 * import { formatEther } from 'viem'
 *
 * formatEther(1000000000000000000n)
 * // '1'
 */ parcelHelpers.export(exports, "formatEther", ()=>formatEther);
var _unitJs = require("../../constants/unit.js");
var _formatUnitsJs = require("./formatUnits.js");
function formatEther(wei, unit = 'wei') {
    return (0, _formatUnitsJs.formatUnits)(wei, (0, _unitJs.etherUnits)[unit]);
}

},{"../../constants/unit.js":"GgDwZ","./formatUnits.js":"jtBPD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"GgDwZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "etherUnits", ()=>etherUnits);
parcelHelpers.export(exports, "gweiUnits", ()=>gweiUnits);
parcelHelpers.export(exports, "weiUnits", ()=>weiUnits);
const etherUnits = {
    gwei: 9,
    wei: 18
};
const gweiUnits = {
    ether: -9,
    wei: 9
};
const weiUnits = {
    ether: -18,
    gwei: -9
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jtBPD":[function(require,module,exports,__globalThis) {
/**
 *  Divides a number by a given exponent of base 10 (10exponent), and formats it into a string representation of the number..
 *
 * - Docs: https://viem.sh/docs/utilities/formatUnits
 *
 * @example
 * import { formatUnits } from 'viem'
 *
 * formatUnits(420000000000n, 9)
 * // '420'
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatUnits", ()=>formatUnits);
function formatUnits(value, decimals) {
    let display = value.toString();
    const negative = display.startsWith('-');
    if (negative) display = display.slice(1);
    display = display.padStart(decimals, '0');
    let [integer, fraction] = [
        display.slice(0, display.length - decimals),
        display.slice(display.length - decimals)
    ];
    fraction = fraction.replace(/(0+)$/, '');
    return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2vNTy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts numerical wei to a string representation of gwei.
 *
 * - Docs: https://viem.sh/docs/utilities/formatGwei
 *
 * @example
 * import { formatGwei } from 'viem'
 *
 * formatGwei(1000000000n)
 * // '1'
 */ parcelHelpers.export(exports, "formatGwei", ()=>formatGwei);
var _unitJs = require("../../constants/unit.js");
var _formatUnitsJs = require("./formatUnits.js");
function formatGwei(wei, unit = 'wei') {
    return (0, _formatUnitsJs.formatUnits)(wei, (0, _unitJs.gweiUnits)[unit]);
}

},{"../../constants/unit.js":"GgDwZ","./formatUnits.js":"jtBPD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3GdPa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AccountStateConflictError", ()=>AccountStateConflictError);
parcelHelpers.export(exports, "StateAssignmentConflictError", ()=>StateAssignmentConflictError);
/** @internal */ parcelHelpers.export(exports, "prettyStateMapping", ()=>prettyStateMapping);
parcelHelpers.export(exports, "prettyStateOverride", ()=>prettyStateOverride);
var _baseJs = require("./base.js");
class AccountStateConflictError extends (0, _baseJs.BaseError) {
    constructor({ address }){
        super(`State for account "${address}" is set multiple times.`, {
            name: 'AccountStateConflictError'
        });
    }
}
class StateAssignmentConflictError extends (0, _baseJs.BaseError) {
    constructor(){
        super('state and stateDiff are set on the same account.', {
            name: 'StateAssignmentConflictError'
        });
    }
}
function prettyStateMapping(stateMapping) {
    return stateMapping.reduce((pretty, { slot, value })=>{
        return `${pretty}        ${slot}: ${value}\n`;
    }, '');
}
function prettyStateOverride(stateOverride) {
    return stateOverride.reduce((pretty, { address, ...state })=>{
        let val = `${pretty}    ${address}:\n`;
        if (state.nonce) val += `      nonce: ${state.nonce}\n`;
        if (state.balance) val += `      balance: ${state.balance}\n`;
        if (state.code) val += `      code: ${state.code}\n`;
        if (state.state) {
            val += '      state:\n';
            val += prettyStateMapping(state.state);
        }
        if (state.stateDiff) {
            val += '      stateDiff:\n';
            val += prettyStateMapping(state.stateDiff);
        }
        return val;
    }, '  State Override:\n').slice(0, -1);
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4gFzr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "prettyPrint", ()=>prettyPrint);
parcelHelpers.export(exports, "FeeConflictError", ()=>FeeConflictError);
parcelHelpers.export(exports, "InvalidLegacyVError", ()=>InvalidLegacyVError);
parcelHelpers.export(exports, "InvalidSerializableTransactionError", ()=>InvalidSerializableTransactionError);
parcelHelpers.export(exports, "InvalidSerializedTransactionTypeError", ()=>InvalidSerializedTransactionTypeError);
parcelHelpers.export(exports, "InvalidSerializedTransactionError", ()=>InvalidSerializedTransactionError);
parcelHelpers.export(exports, "InvalidStorageKeySizeError", ()=>InvalidStorageKeySizeError);
parcelHelpers.export(exports, "TransactionExecutionError", ()=>TransactionExecutionError);
parcelHelpers.export(exports, "TransactionNotFoundError", ()=>TransactionNotFoundError);
parcelHelpers.export(exports, "TransactionReceiptNotFoundError", ()=>TransactionReceiptNotFoundError);
parcelHelpers.export(exports, "WaitForTransactionReceiptTimeoutError", ()=>WaitForTransactionReceiptTimeoutError);
var _formatEtherJs = require("../utils/unit/formatEther.js");
var _formatGweiJs = require("../utils/unit/formatGwei.js");
var _baseJs = require("./base.js");
function prettyPrint(args) {
    const entries = Object.entries(args).map(([key, value])=>{
        if (value === undefined || value === false) return null;
        return [
            key,
            value
        ];
    }).filter(Boolean);
    const maxLength = entries.reduce((acc, [key])=>Math.max(acc, key.length), 0);
    return entries.map(([key, value])=>`  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join('\n');
}
class FeeConflictError extends (0, _baseJs.BaseError) {
    constructor(){
        super([
            'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',
            'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.'
        ].join('\n'), {
            name: 'FeeConflictError'
        });
    }
}
class InvalidLegacyVError extends (0, _baseJs.BaseError) {
    constructor({ v }){
        super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
            name: 'InvalidLegacyVError'
        });
    }
}
class InvalidSerializableTransactionError extends (0, _baseJs.BaseError) {
    constructor({ transaction }){
        super('Cannot infer a transaction type from provided transaction.', {
            metaMessages: [
                'Provided Transaction:',
                '{',
                prettyPrint(transaction),
                '}',
                '',
                'To infer the type, either provide:',
                '- a `type` to the Transaction, or',
                '- an EIP-1559 Transaction with `maxFeePerGas`, or',
                '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',
                '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',
                '- an EIP-7702 Transaction with `authorizationList`, or',
                '- a Legacy Transaction with `gasPrice`'
            ],
            name: 'InvalidSerializableTransactionError'
        });
    }
}
class InvalidSerializedTransactionTypeError extends (0, _baseJs.BaseError) {
    constructor({ serializedType }){
        super(`Serialized transaction type "${serializedType}" is invalid.`, {
            name: 'InvalidSerializedTransactionType'
        });
        Object.defineProperty(this, "serializedType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.serializedType = serializedType;
    }
}
class InvalidSerializedTransactionError extends (0, _baseJs.BaseError) {
    constructor({ attributes, serializedTransaction, type }){
        const missing = Object.entries(attributes).map(([key, value])=>typeof value === 'undefined' ? key : undefined).filter(Boolean);
        super(`Invalid serialized transaction of type "${type}" was provided.`, {
            metaMessages: [
                `Serialized Transaction: "${serializedTransaction}"`,
                missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : ''
            ].filter(Boolean),
            name: 'InvalidSerializedTransactionError'
        });
        Object.defineProperty(this, "serializedTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.serializedTransaction = serializedTransaction;
        this.type = type;
    }
}
class InvalidStorageKeySizeError extends (0, _baseJs.BaseError) {
    constructor({ storageKey }){
        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, {
            name: 'InvalidStorageKeySizeError'
        });
    }
}
class TransactionExecutionError extends (0, _baseJs.BaseError) {
    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }){
        const prettyArgs = prettyPrint({
            chain: chain && `${chain?.name} (id: ${chain?.id})`,
            from: account?.address,
            to,
            value: typeof value !== 'undefined' && `${(0, _formatEtherJs.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== 'undefined' && `${(0, _formatGweiJs.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== 'undefined' && `${(0, _formatGweiJs.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' && `${(0, _formatGweiJs.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...cause.metaMessages ? [
                    ...cause.metaMessages,
                    ' '
                ] : [],
                'Request Arguments:',
                prettyArgs
            ].filter(Boolean),
            name: 'TransactionExecutionError'
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.cause = cause;
    }
}
class TransactionNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ blockHash, blockNumber, blockTag, hash, index }){
        let identifier = 'Transaction';
        if (blockTag && index !== undefined) identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
        if (blockHash && index !== undefined) identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
        if (blockNumber && index !== undefined) identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
        if (hash) identifier = `Transaction with hash "${hash}"`;
        super(`${identifier} could not be found.`, {
            name: 'TransactionNotFoundError'
        });
    }
}
class TransactionReceiptNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ hash }){
        super(`Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`, {
            name: 'TransactionReceiptNotFoundError'
        });
    }
}
class WaitForTransactionReceiptTimeoutError extends (0, _baseJs.BaseError) {
    constructor({ hash }){
        super(`Timed out while waiting for transaction with hash "${hash}" to be confirmed.`, {
            name: 'WaitForTransactionReceiptTimeoutError'
        });
    }
}

},{"../utils/unit/formatEther.js":"d8qm6","../utils/unit/formatGwei.js":"2vNTy","./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3ALY3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getContractAddress", ()=>getContractAddress);
parcelHelpers.export(exports, "getUrl", ()=>getUrl);
const getContractAddress = (address)=>address;
const getUrl = (url)=>url;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6LYvf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HttpRequestError", ()=>HttpRequestError);
parcelHelpers.export(exports, "WebSocketRequestError", ()=>WebSocketRequestError);
parcelHelpers.export(exports, "RpcRequestError", ()=>RpcRequestError);
parcelHelpers.export(exports, "SocketClosedError", ()=>SocketClosedError);
parcelHelpers.export(exports, "TimeoutError", ()=>TimeoutError);
var _stringifyJs = require("../utils/stringify.js");
var _baseJs = require("./base.js");
var _utilsJs = require("./utils.js");
class HttpRequestError extends (0, _baseJs.BaseError) {
    constructor({ body, cause, details, headers, status, url }){
        super('HTTP request failed.', {
            cause,
            details,
            metaMessages: [
                status && `Status: ${status}`,
                `URL: ${(0, _utilsJs.getUrl)(url)}`,
                body && `Request body: ${(0, _stringifyJs.stringify)(body)}`
            ].filter(Boolean),
            name: 'HttpRequestError'
        });
        Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.body = body;
        this.headers = headers;
        this.status = status;
        this.url = url;
    }
}
class WebSocketRequestError extends (0, _baseJs.BaseError) {
    constructor({ body, cause, details, url }){
        super('WebSocket request failed.', {
            cause,
            details,
            metaMessages: [
                `URL: ${(0, _utilsJs.getUrl)(url)}`,
                body && `Request body: ${(0, _stringifyJs.stringify)(body)}`
            ].filter(Boolean),
            name: 'WebSocketRequestError'
        });
    }
}
class RpcRequestError extends (0, _baseJs.BaseError) {
    constructor({ body, error, url }){
        super('RPC Request failed.', {
            cause: error,
            details: error.message,
            metaMessages: [
                `URL: ${(0, _utilsJs.getUrl)(url)}`,
                `Request body: ${(0, _stringifyJs.stringify)(body)}`
            ],
            name: 'RpcRequestError'
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.code = error.code;
        this.data = error.data;
    }
}
class SocketClosedError extends (0, _baseJs.BaseError) {
    constructor({ url } = {}){
        super('The socket has been closed.', {
            metaMessages: [
                url && `URL: ${(0, _utilsJs.getUrl)(url)}`
            ].filter(Boolean),
            name: 'SocketClosedError'
        });
    }
}
class TimeoutError extends (0, _baseJs.BaseError) {
    constructor({ body, url }){
        super('The request took too long to respond.', {
            details: 'The request timed out.',
            metaMessages: [
                `URL: ${(0, _utilsJs.getUrl)(url)}`,
                `Request body: ${(0, _stringifyJs.stringify)(body)}`
            ],
            name: 'TimeoutError'
        });
    }
}

},{"../utils/stringify.js":"jKcjI","./base.js":"3SEPF","./utils.js":"3ALY3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jYSPv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RpcError", ()=>RpcError);
parcelHelpers.export(exports, "ProviderRpcError", ()=>ProviderRpcError);
parcelHelpers.export(exports, "ParseRpcError", ()=>ParseRpcError);
parcelHelpers.export(exports, "InvalidRequestRpcError", ()=>InvalidRequestRpcError);
parcelHelpers.export(exports, "MethodNotFoundRpcError", ()=>MethodNotFoundRpcError);
parcelHelpers.export(exports, "InvalidParamsRpcError", ()=>InvalidParamsRpcError);
parcelHelpers.export(exports, "InternalRpcError", ()=>InternalRpcError);
parcelHelpers.export(exports, "InvalidInputRpcError", ()=>InvalidInputRpcError);
parcelHelpers.export(exports, "ResourceNotFoundRpcError", ()=>ResourceNotFoundRpcError);
parcelHelpers.export(exports, "ResourceUnavailableRpcError", ()=>ResourceUnavailableRpcError);
parcelHelpers.export(exports, "TransactionRejectedRpcError", ()=>TransactionRejectedRpcError);
parcelHelpers.export(exports, "MethodNotSupportedRpcError", ()=>MethodNotSupportedRpcError);
parcelHelpers.export(exports, "LimitExceededRpcError", ()=>LimitExceededRpcError);
parcelHelpers.export(exports, "JsonRpcVersionUnsupportedError", ()=>JsonRpcVersionUnsupportedError);
parcelHelpers.export(exports, "UserRejectedRequestError", ()=>UserRejectedRequestError);
parcelHelpers.export(exports, "UnauthorizedProviderError", ()=>UnauthorizedProviderError);
parcelHelpers.export(exports, "UnsupportedProviderMethodError", ()=>UnsupportedProviderMethodError);
parcelHelpers.export(exports, "ProviderDisconnectedError", ()=>ProviderDisconnectedError);
parcelHelpers.export(exports, "ChainDisconnectedError", ()=>ChainDisconnectedError);
parcelHelpers.export(exports, "SwitchChainError", ()=>SwitchChainError);
parcelHelpers.export(exports, "UnsupportedNonOptionalCapabilityError", ()=>UnsupportedNonOptionalCapabilityError);
parcelHelpers.export(exports, "UnsupportedChainIdError", ()=>UnsupportedChainIdError);
parcelHelpers.export(exports, "DuplicateIdError", ()=>DuplicateIdError);
parcelHelpers.export(exports, "UnknownBundleIdError", ()=>UnknownBundleIdError);
parcelHelpers.export(exports, "BundleTooLargeError", ()=>BundleTooLargeError);
parcelHelpers.export(exports, "AtomicReadyWalletRejectedUpgradeError", ()=>AtomicReadyWalletRejectedUpgradeError);
parcelHelpers.export(exports, "AtomicityNotSupportedError", ()=>AtomicityNotSupportedError);
parcelHelpers.export(exports, "UnknownRpcError", ()=>UnknownRpcError);
var _baseJs = require("./base.js");
var _requestJs = require("./request.js");
const unknownErrorCode = -1;
class RpcError extends (0, _baseJs.BaseError) {
    constructor(cause, { code, docsPath, metaMessages, name, shortMessage }){
        super(shortMessage, {
            cause,
            docsPath,
            metaMessages: metaMessages || cause?.metaMessages,
            name: name || 'RpcError'
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = name || cause.name;
        this.code = cause instanceof (0, _requestJs.RpcRequestError) ? cause.code : code ?? unknownErrorCode;
    }
}
class ProviderRpcError extends RpcError {
    constructor(cause, options){
        super(cause, options);
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = options.data;
    }
}
class ParseRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: ParseRpcError.code,
            name: 'ParseRpcError',
            shortMessage: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.'
        });
    }
}
Object.defineProperty(ParseRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32700
});
class InvalidRequestRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: InvalidRequestRpcError.code,
            name: 'InvalidRequestRpcError',
            shortMessage: 'JSON is not a valid request object.'
        });
    }
}
Object.defineProperty(InvalidRequestRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32600
});
class MethodNotFoundRpcError extends RpcError {
    constructor(cause, { method } = {}){
        super(cause, {
            code: MethodNotFoundRpcError.code,
            name: 'MethodNotFoundRpcError',
            shortMessage: `The method${method ? ` "${method}"` : ''} does not exist / is not available.`
        });
    }
}
Object.defineProperty(MethodNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32601
});
class InvalidParamsRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: InvalidParamsRpcError.code,
            name: 'InvalidParamsRpcError',
            shortMessage: [
                'Invalid parameters were provided to the RPC method.',
                'Double check you have provided the correct parameters.'
            ].join('\n')
        });
    }
}
Object.defineProperty(InvalidParamsRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32602
});
class InternalRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: InternalRpcError.code,
            name: 'InternalRpcError',
            shortMessage: 'An internal error was received.'
        });
    }
}
Object.defineProperty(InternalRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32603
});
class InvalidInputRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: InvalidInputRpcError.code,
            name: 'InvalidInputRpcError',
            shortMessage: [
                'Missing or invalid parameters.',
                'Double check you have provided the correct parameters.'
            ].join('\n')
        });
    }
}
Object.defineProperty(InvalidInputRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32000
});
class ResourceNotFoundRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: ResourceNotFoundRpcError.code,
            name: 'ResourceNotFoundRpcError',
            shortMessage: 'Requested resource not found.'
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ResourceNotFoundRpcError'
        });
    }
}
Object.defineProperty(ResourceNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: ResourceUnavailableRpcError.code,
            name: 'ResourceUnavailableRpcError',
            shortMessage: 'Requested resource not available.'
        });
    }
}
Object.defineProperty(ResourceUnavailableRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32002
});
class TransactionRejectedRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: TransactionRejectedRpcError.code,
            name: 'TransactionRejectedRpcError',
            shortMessage: 'Transaction creation failed.'
        });
    }
}
Object.defineProperty(TransactionRejectedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
    constructor(cause, { method } = {}){
        super(cause, {
            code: MethodNotSupportedRpcError.code,
            name: 'MethodNotSupportedRpcError',
            shortMessage: `Method${method ? ` "${method}"` : ''} is not supported.`
        });
    }
}
Object.defineProperty(MethodNotSupportedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32004
});
class LimitExceededRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            code: LimitExceededRpcError.code,
            name: 'LimitExceededRpcError',
            shortMessage: 'Request exceeds defined limit.'
        });
    }
}
Object.defineProperty(LimitExceededRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
    constructor(cause){
        super(cause, {
            code: JsonRpcVersionUnsupportedError.code,
            name: 'JsonRpcVersionUnsupportedError',
            shortMessage: 'Version of JSON-RPC protocol is not supported.'
        });
    }
}
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: UserRejectedRequestError.code,
            name: 'UserRejectedRequestError',
            shortMessage: 'User rejected the request.'
        });
    }
}
Object.defineProperty(UserRejectedRequestError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: UnauthorizedProviderError.code,
            name: 'UnauthorizedProviderError',
            shortMessage: 'The requested method and/or account has not been authorized by the user.'
        });
    }
}
Object.defineProperty(UnauthorizedProviderError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
    constructor(cause, { method } = {}){
        super(cause, {
            code: UnsupportedProviderMethodError.code,
            name: 'UnsupportedProviderMethodError',
            shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ''}.`
        });
    }
}
Object.defineProperty(UnsupportedProviderMethodError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: ProviderDisconnectedError.code,
            name: 'ProviderDisconnectedError',
            shortMessage: 'The Provider is disconnected from all chains.'
        });
    }
}
Object.defineProperty(ProviderDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: ChainDisconnectedError.code,
            name: 'ChainDisconnectedError',
            shortMessage: 'The Provider is not connected to the requested chain.'
        });
    }
}
Object.defineProperty(ChainDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4901
});
class SwitchChainError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: SwitchChainError.code,
            name: 'SwitchChainError',
            shortMessage: 'An error occurred when attempting to switch chain.'
        });
    }
}
Object.defineProperty(SwitchChainError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4902
});
class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: UnsupportedNonOptionalCapabilityError.code,
            name: 'UnsupportedNonOptionalCapabilityError',
            shortMessage: 'This Wallet does not support a capability that was not marked as optional.'
        });
    }
}
Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5700
});
class UnsupportedChainIdError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: UnsupportedChainIdError.code,
            name: 'UnsupportedChainIdError',
            shortMessage: 'This Wallet does not support the requested chain ID.'
        });
    }
}
Object.defineProperty(UnsupportedChainIdError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5710
});
class DuplicateIdError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: DuplicateIdError.code,
            name: 'DuplicateIdError',
            shortMessage: 'There is already a bundle submitted with this ID.'
        });
    }
}
Object.defineProperty(DuplicateIdError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5720
});
class UnknownBundleIdError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: UnknownBundleIdError.code,
            name: 'UnknownBundleIdError',
            shortMessage: 'This bundle id is unknown / has not been submitted'
        });
    }
}
Object.defineProperty(UnknownBundleIdError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5730
});
class BundleTooLargeError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: BundleTooLargeError.code,
            name: 'BundleTooLargeError',
            shortMessage: 'The call bundle is too large for the Wallet to process.'
        });
    }
}
Object.defineProperty(BundleTooLargeError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5740
});
class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: AtomicReadyWalletRejectedUpgradeError.code,
            name: 'AtomicReadyWalletRejectedUpgradeError',
            shortMessage: 'The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.'
        });
    }
}
Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5750
});
class AtomicityNotSupportedError extends ProviderRpcError {
    constructor(cause){
        super(cause, {
            code: AtomicityNotSupportedError.code,
            name: 'AtomicityNotSupportedError',
            shortMessage: 'The wallet does not support atomic execution but the request requires it.'
        });
    }
}
Object.defineProperty(AtomicityNotSupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5760
});
class UnknownRpcError extends RpcError {
    constructor(cause){
        super(cause, {
            name: 'UnknownRpcError',
            shortMessage: 'An unknown RPC error occurred.'
        });
    }
}

},{"./base.js":"3SEPF","./request.js":"6LYvf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"22Lcu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Estimates the gas necessary to complete a transaction without submitting it to the network.
 *
 * - Docs: https://viem.sh/docs/actions/public/estimateGas
 * - JSON-RPC Methods: [`eth_estimateGas`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_estimategas)
 *
 * @param client - Client to use
 * @param parameters - {@link EstimateGasParameters}
 * @returns The gas estimate (in wei). {@link EstimateGasReturnType}
 *
 * @example
 * import { createPublicClient, http, parseEther } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { estimateGas } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const gasEstimate = await estimateGas(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *   value: parseEther('1'),
 * })
 */ parcelHelpers.export(exports, "estimateGas", ()=>estimateGas);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _baseJs = require("../../errors/base.js");
var _recoverAuthorizationAddressJs = require("../../utils/authorization/recoverAuthorizationAddress.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _getEstimateGasErrorJs = require("../../utils/errors/getEstimateGasError.js");
var _extractJs = require("../../utils/formatters/extract.js");
var _transactionRequestJs = require("../../utils/formatters/transactionRequest.js");
var _stateOverrideJs = require("../../utils/stateOverride.js");
var _assertRequestJs = require("../../utils/transaction/assertRequest.js");
var _prepareTransactionRequestJs = require("../wallet/prepareTransactionRequest.js");
var _getBalanceJs = require("./getBalance.js");
async function estimateGas(client, args) {
    const { account: account_ = client.account } = args;
    const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : undefined;
    try {
        const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = await (0, _prepareTransactionRequestJs.prepareTransactionRequest)(client, {
            ...args,
            parameters: // Some RPC Providers do not compute versioned hashes from blobs. We will need
            // to compute them.
            account?.type === 'local' ? undefined : [
                'blobVersionedHashes'
            ]
        });
        const blockNumberHex = typeof blockNumber === 'bigint' ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const rpcStateOverride = (0, _stateOverrideJs.serializeStateOverride)(stateOverride);
        const to = await (async ()=>{
            // If `to` exists on the parameters, use that.
            if (rest.to) return rest.to;
            // If no `to` exists, and we are sending a EIP-7702 transaction, use the
            // address of the first authorization in the list.
            if (authorizationList && authorizationList.length > 0) return await (0, _recoverAuthorizationAddressJs.recoverAuthorizationAddress)({
                authorization: authorizationList[0]
            }).catch(()=>{
                throw new (0, _baseJs.BaseError)('`to` is required. Could not infer from `authorizationList`');
            });
            // Otherwise, we are sending a deployment transaction.
            return undefined;
        })();
        (0, _assertRequestJs.assertRequest)(args);
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || (0, _transactionRequestJs.formatTransactionRequest);
        const request = format({
            // Pick out extra data that might exist on the chain's transaction request type.
            ...(0, _extractJs.extract)(rest, {
                format: chainFormat
            }),
            from: account?.address,
            accessList,
            authorizationList,
            blobs,
            blobVersionedHashes,
            data,
            gas,
            gasPrice,
            maxFeePerBlobGas,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value
        });
        function estimateGas_rpc(parameters) {
            const { block, request, rpcStateOverride } = parameters;
            return client.request({
                method: 'eth_estimateGas',
                params: rpcStateOverride ? [
                    request,
                    block ?? 'pending',
                    rpcStateOverride
                ] : block ? [
                    request,
                    block
                ] : [
                    request
                ]
            });
        }
        let estimate = BigInt(await estimateGas_rpc({
            block,
            request,
            rpcStateOverride
        }));
        // TODO(7702): Remove this once https://github.com/ethereum/execution-apis/issues/561 is resolved.
        //       Authorization list schema is not implemented on JSON-RPC spec yet, so we need to
        //       manually estimate the gas.
        if (authorizationList) {
            const value = await (0, _getBalanceJs.getBalance)(client, {
                address: request.from
            });
            const estimates = await Promise.all(authorizationList.map(async (authorization)=>{
                const { address } = authorization;
                const estimate = await estimateGas_rpc({
                    block,
                    request: {
                        authorizationList: undefined,
                        data,
                        from: account?.address,
                        to: address,
                        value: (0, _toHexJs.numberToHex)(value)
                    },
                    rpcStateOverride
                }).catch(()=>100000n);
                return 2n * BigInt(estimate);
            }));
            estimate += estimates.reduce((acc, curr)=>acc + curr, 0n);
        }
        return estimate;
    } catch (err) {
        throw (0, _getEstimateGasErrorJs.getEstimateGasError)(err, {
            ...args,
            account,
            chain: client.chain
        });
    }
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../errors/base.js":"3SEPF","../../utils/authorization/recoverAuthorizationAddress.js":"3ciAa","../../utils/encoding/toHex.js":"9GFC6","../../utils/errors/getEstimateGasError.js":"67Y68","../../utils/formatters/extract.js":"g9KS8","../../utils/formatters/transactionRequest.js":"dLljr","../../utils/stateOverride.js":"zqcJp","../../utils/transaction/assertRequest.js":"eSiKr","../wallet/prepareTransactionRequest.js":"53wjM","./getBalance.js":"1bzUH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3ciAa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "recoverAuthorizationAddress", ()=>recoverAuthorizationAddress);
var _recoverAddressJs = require("../signature/recoverAddress.js");
var _hashAuthorizationJs = require("./hashAuthorization.js");
async function recoverAuthorizationAddress(parameters) {
    const { authorization, signature } = parameters;
    return (0, _recoverAddressJs.recoverAddress)({
        hash: (0, _hashAuthorizationJs.hashAuthorization)(authorization),
        signature: signature ?? authorization
    });
}

},{"../signature/recoverAddress.js":"gBtnk","./hashAuthorization.js":"1nT4J","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gBtnk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "recoverAddress", ()=>recoverAddress);
var _publicKeyToAddressJs = require("../../accounts/utils/publicKeyToAddress.js");
var _recoverPublicKeyJs = require("./recoverPublicKey.js");
async function recoverAddress({ hash, signature }) {
    return (0, _publicKeyToAddressJs.publicKeyToAddress)(await (0, _recoverPublicKeyJs.recoverPublicKey)({
        hash,
        signature
    }));
}

},{"../../accounts/utils/publicKeyToAddress.js":"k4VB7","./recoverPublicKey.js":"lLPoN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k4VB7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Converts an ECDSA public key to an address.
 *
 * @param publicKey The public key to convert.
 *
 * @returns The address.
 */ parcelHelpers.export(exports, "publicKeyToAddress", ()=>publicKeyToAddress);
var _getAddressJs = require("../../utils/address/getAddress.js");
var _keccak256Js = require("../../utils/hash/keccak256.js");
function publicKeyToAddress(publicKey) {
    const address = (0, _keccak256Js.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
    return (0, _getAddressJs.checksumAddress)(`0x${address}`);
}

},{"../../utils/address/getAddress.js":"aGHEi","../../utils/hash/keccak256.js":"k4CmV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lLPoN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "recoverPublicKey", ()=>recoverPublicKey);
var _isHexJs = require("../data/isHex.js");
var _sizeJs = require("../data/size.js");
var _fromHexJs = require("../encoding/fromHex.js");
var _toHexJs = require("../encoding/toHex.js");
async function recoverPublicKey({ hash, signature }) {
    const hashHex = (0, _isHexJs.isHex)(hash) ? hash : (0, _toHexJs.toHex)(hash);
    const { secp256k1 } = await require("241bc89b98ad17cc");
    const signature_ = (()=>{
        // typeof signature: `Signature`
        if (typeof signature === 'object' && 'r' in signature && 's' in signature) {
            const { r, s, v, yParity } = signature;
            const yParityOrV = Number(yParity ?? v);
            const recoveryBit = toRecoveryBit(yParityOrV);
            return new secp256k1.Signature((0, _fromHexJs.hexToBigInt)(r), (0, _fromHexJs.hexToBigInt)(s)).addRecoveryBit(recoveryBit);
        }
        // typeof signature: `Hex | ByteArray`
        const signatureHex = (0, _isHexJs.isHex)(signature) ? signature : (0, _toHexJs.toHex)(signature);
        if ((0, _sizeJs.size)(signatureHex) !== 65) throw new Error('invalid signature length');
        const yParityOrV = (0, _fromHexJs.hexToNumber)(`0x${signatureHex.slice(130)}`);
        const recoveryBit = toRecoveryBit(yParityOrV);
        return secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
    })();
    const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
    return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
    if (yParityOrV === 0 || yParityOrV === 1) return yParityOrV;
    if (yParityOrV === 27) return 0;
    if (yParityOrV === 28) return 1;
    throw new Error('Invalid yParityOrV value');
}

},{"../data/isHex.js":"evOcm","../data/size.js":"exELm","../encoding/fromHex.js":"kLfW5","../encoding/toHex.js":"9GFC6","241bc89b98ad17cc":"4RuQf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4RuQf":[function(require,module,exports,__globalThis) {
module.exports = Promise.resolve(module.bundle.root("8NuVo"));

},{"8NuVo":"8NuVo"}],"1nT4J":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Computes an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.
 */ parcelHelpers.export(exports, "hashAuthorization", ()=>hashAuthorization);
var _concatJs = require("../data/concat.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
var _toRlpJs = require("../encoding/toRlp.js");
var _keccak256Js = require("../hash/keccak256.js");
function hashAuthorization(parameters) {
    const { chainId, nonce, to } = parameters;
    const address = parameters.contractAddress ?? parameters.address;
    const hash = (0, _keccak256Js.keccak256)((0, _concatJs.concatHex)([
        '0x05',
        (0, _toRlpJs.toRlp)([
            chainId ? (0, _toHexJs.numberToHex)(chainId) : '0x',
            address,
            nonce ? (0, _toHexJs.numberToHex)(nonce) : '0x'
        ])
    ]));
    if (to === 'bytes') return (0, _toBytesJs.hexToBytes)(hash);
    return hash;
}

},{"../data/concat.js":"6FL5K","../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","../encoding/toRlp.js":"7jPJy","../hash/keccak256.js":"k4CmV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7jPJy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toRlp", ()=>toRlp);
parcelHelpers.export(exports, "bytesToRlp", ()=>bytesToRlp);
parcelHelpers.export(exports, "hexToRlp", ()=>hexToRlp);
var _baseJs = require("../../errors/base.js");
var _cursorJs = require("../cursor.js");
var _toBytesJs = require("./toBytes.js");
var _toHexJs = require("./toHex.js");
function toRlp(bytes, to = 'hex') {
    const encodable = getEncodable(bytes);
    const cursor = (0, _cursorJs.createCursor)(new Uint8Array(encodable.length));
    encodable.encode(cursor);
    if (to === 'hex') return (0, _toHexJs.bytesToHex)(cursor.bytes);
    return cursor.bytes;
}
function bytesToRlp(bytes, to = 'bytes') {
    return toRlp(bytes, to);
}
function hexToRlp(hex, to = 'hex') {
    return toRlp(hex, to);
}
function getEncodable(bytes) {
    if (Array.isArray(bytes)) return getEncodableList(bytes.map((x)=>getEncodable(x)));
    return getEncodableBytes(bytes);
}
function getEncodableList(list) {
    const bodyLength = list.reduce((acc, x)=>acc + x.length, 0);
    const sizeOfBodyLength = getSizeOfLength(bodyLength);
    const length = (()=>{
        if (bodyLength <= 55) return 1 + bodyLength;
        return 1 + sizeOfBodyLength + bodyLength;
    })();
    return {
        length,
        encode (cursor) {
            if (bodyLength <= 55) cursor.pushByte(0xc0 + bodyLength);
            else {
                cursor.pushByte(247 + sizeOfBodyLength);
                if (sizeOfBodyLength === 1) cursor.pushUint8(bodyLength);
                else if (sizeOfBodyLength === 2) cursor.pushUint16(bodyLength);
                else if (sizeOfBodyLength === 3) cursor.pushUint24(bodyLength);
                else cursor.pushUint32(bodyLength);
            }
            for (const { encode } of list)encode(cursor);
        }
    };
}
function getEncodableBytes(bytesOrHex) {
    const bytes = typeof bytesOrHex === 'string' ? (0, _toBytesJs.hexToBytes)(bytesOrHex) : bytesOrHex;
    const sizeOfBytesLength = getSizeOfLength(bytes.length);
    const length = (()=>{
        if (bytes.length === 1 && bytes[0] < 0x80) return 1;
        if (bytes.length <= 55) return 1 + bytes.length;
        return 1 + sizeOfBytesLength + bytes.length;
    })();
    return {
        length,
        encode (cursor) {
            if (bytes.length === 1 && bytes[0] < 0x80) cursor.pushBytes(bytes);
            else if (bytes.length <= 55) {
                cursor.pushByte(0x80 + bytes.length);
                cursor.pushBytes(bytes);
            } else {
                cursor.pushByte(183 + sizeOfBytesLength);
                if (sizeOfBytesLength === 1) cursor.pushUint8(bytes.length);
                else if (sizeOfBytesLength === 2) cursor.pushUint16(bytes.length);
                else if (sizeOfBytesLength === 3) cursor.pushUint24(bytes.length);
                else cursor.pushUint32(bytes.length);
                cursor.pushBytes(bytes);
            }
        }
    };
}
function getSizeOfLength(length) {
    if (length < 256) return 1;
    if (length < 2 ** 16) return 2;
    if (length < 2 ** 24) return 3;
    if (length < 2 ** 32) return 4;
    throw new (0, _baseJs.BaseError)('Length is too large.');
}

},{"../../errors/base.js":"3SEPF","../cursor.js":"pWJ3P","./toBytes.js":"8cx1T","./toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"67Y68":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getEstimateGasError", ()=>getEstimateGasError);
var _estimateGasJs = require("../../errors/estimateGas.js");
var _nodeJs = require("../../errors/node.js");
var _getNodeErrorJs = require("./getNodeError.js");
function getEstimateGasError(err, { docsPath, ...args }) {
    const cause = (()=>{
        const cause = (0, _getNodeErrorJs.getNodeError)(err, args);
        if (cause instanceof (0, _nodeJs.UnknownNodeError)) return err;
        return cause;
    })();
    return new (0, _estimateGasJs.EstimateGasExecutionError)(cause, {
        docsPath,
        ...args
    });
}

},{"../../errors/estimateGas.js":"ae9wC","../../errors/node.js":"9Ytun","./getNodeError.js":"7Fxo9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ae9wC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EstimateGasExecutionError", ()=>EstimateGasExecutionError);
var _formatEtherJs = require("../utils/unit/formatEther.js");
var _formatGweiJs = require("../utils/unit/formatGwei.js");
var _baseJs = require("./base.js");
var _transactionJs = require("./transaction.js");
class EstimateGasExecutionError extends (0, _baseJs.BaseError) {
    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }){
        const prettyArgs = (0, _transactionJs.prettyPrint)({
            from: account?.address,
            to,
            value: typeof value !== 'undefined' && `${(0, _formatEtherJs.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== 'undefined' && `${(0, _formatGweiJs.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== 'undefined' && `${(0, _formatGweiJs.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' && `${(0, _formatGweiJs.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...cause.metaMessages ? [
                    ...cause.metaMessages,
                    ' '
                ] : [],
                'Estimate Gas Arguments:',
                prettyArgs
            ].filter(Boolean),
            name: 'EstimateGasExecutionError'
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.cause = cause;
    }
}

},{"../utils/unit/formatEther.js":"d8qm6","../utils/unit/formatGwei.js":"2vNTy","./base.js":"3SEPF","./transaction.js":"4gFzr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9Ytun":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ExecutionRevertedError", ()=>ExecutionRevertedError);
parcelHelpers.export(exports, "FeeCapTooHighError", ()=>FeeCapTooHighError);
parcelHelpers.export(exports, "FeeCapTooLowError", ()=>FeeCapTooLowError);
parcelHelpers.export(exports, "NonceTooHighError", ()=>NonceTooHighError);
parcelHelpers.export(exports, "NonceTooLowError", ()=>NonceTooLowError);
parcelHelpers.export(exports, "NonceMaxValueError", ()=>NonceMaxValueError);
parcelHelpers.export(exports, "InsufficientFundsError", ()=>InsufficientFundsError);
parcelHelpers.export(exports, "IntrinsicGasTooHighError", ()=>IntrinsicGasTooHighError);
parcelHelpers.export(exports, "IntrinsicGasTooLowError", ()=>IntrinsicGasTooLowError);
parcelHelpers.export(exports, "TransactionTypeNotSupportedError", ()=>TransactionTypeNotSupportedError);
parcelHelpers.export(exports, "TipAboveFeeCapError", ()=>TipAboveFeeCapError);
parcelHelpers.export(exports, "UnknownNodeError", ()=>UnknownNodeError);
var _formatGweiJs = require("../utils/unit/formatGwei.js");
var _baseJs = require("./base.js");
class ExecutionRevertedError extends (0, _baseJs.BaseError) {
    constructor({ cause, message } = {}){
        const reason = message?.replace('execution reverted: ', '')?.replace('execution reverted', '');
        super(`Execution reverted ${reason ? `with reason: ${reason}` : 'for an unknown reason'}.`, {
            cause,
            name: 'ExecutionRevertedError'
        });
    }
}
Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /execution reverted/
});
class FeeCapTooHighError extends (0, _baseJs.BaseError) {
    constructor({ cause, maxFeePerGas } = {}){
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, _formatGweiJs.formatGwei)(maxFeePerGas)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause,
            name: 'FeeCapTooHighError'
        });
    }
}
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends (0, _baseJs.BaseError) {
    constructor({ cause, maxFeePerGas } = {}){
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, _formatGweiJs.formatGwei)(maxFeePerGas)}` : ''} gwei) cannot be lower than the block base fee.`, {
            cause,
            name: 'FeeCapTooLowError'
        });
    }
}
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends (0, _baseJs.BaseError) {
    constructor({ cause, nonce } = {}){
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is higher than the next one expected.`, {
            cause,
            name: 'NonceTooHighError'
        });
    }
}
Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too high/
});
class NonceTooLowError extends (0, _baseJs.BaseError) {
    constructor({ cause, nonce } = {}){
        super([
            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is lower than the current nonce of the account.`,
            'Try increasing the nonce or find the latest nonce with `getTransactionCount`.'
        ].join('\n'), {
            cause,
            name: 'NonceTooLowError'
        });
    }
}
Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends (0, _baseJs.BaseError) {
    constructor({ cause, nonce } = {}){
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}exceeds the maximum allowed nonce.`, {
            cause,
            name: 'NonceMaxValueError'
        });
    }
}
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce has max value/
});
class InsufficientFundsError extends (0, _baseJs.BaseError) {
    constructor({ cause } = {}){
        super([
            'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.'
        ].join('\n'), {
            cause,
            metaMessages: [
                'This error could arise when the account does not have enough funds to:',
                ' - pay for the total gas fee,',
                ' - pay for the value to send.',
                ' ',
                'The cost of the transaction is calculated as `gas * gas fee + value`, where:',
                ' - `gas` is the amount of gas needed for transaction to execute,',
                ' - `gas fee` is the gas fee,',
                ' - `value` is the amount of ether to send to the recipient.'
            ],
            name: 'InsufficientFundsError'
        });
    }
}
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /insufficient funds|exceeds transaction sender account balance/
});
class IntrinsicGasTooHighError extends (0, _baseJs.BaseError) {
    constructor({ cause, gas } = {}){
        super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction exceeds the limit allowed for the block.`, {
            cause,
            name: 'IntrinsicGasTooHighError'
        });
    }
}
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends (0, _baseJs.BaseError) {
    constructor({ cause, gas } = {}){
        super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction is too low.`, {
            cause,
            name: 'IntrinsicGasTooLowError'
        });
    }
}
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends (0, _baseJs.BaseError) {
    constructor({ cause }){
        super('The transaction type is not supported for this chain.', {
            cause,
            name: 'TransactionTypeNotSupportedError'
        });
    }
}
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /transaction type not valid/
});
class TipAboveFeeCapError extends (0, _baseJs.BaseError) {
    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}){
        super([
            `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${(0, _formatGweiJs.formatGwei)(maxPriorityFeePerGas)} gwei` : ''}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, _formatGweiJs.formatGwei)(maxFeePerGas)} gwei` : ''}).`
        ].join('\n'), {
            cause,
            name: 'TipAboveFeeCapError'
        });
    }
}
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends (0, _baseJs.BaseError) {
    constructor({ cause }){
        super(`An error occurred while executing: ${cause?.shortMessage}`, {
            cause,
            name: 'UnknownNodeError'
        });
    }
}

},{"../utils/unit/formatGwei.js":"2vNTy","./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7Fxo9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "containsNodeError", ()=>containsNodeError);
parcelHelpers.export(exports, "getNodeError", ()=>getNodeError);
var _baseJs = require("../../errors/base.js");
var _nodeJs = require("../../errors/node.js");
var _requestJs = require("../../errors/request.js");
var _rpcJs = require("../../errors/rpc.js");
function containsNodeError(err) {
    return err instanceof (0, _rpcJs.TransactionRejectedRpcError) || err instanceof (0, _rpcJs.InvalidInputRpcError) || err instanceof (0, _requestJs.RpcRequestError) && err.code === (0, _nodeJs.ExecutionRevertedError).code;
}
function getNodeError(err, args) {
    const message = (err.details || '').toLowerCase();
    const executionRevertedError = err instanceof (0, _baseJs.BaseError) ? err.walk((e)=>e?.code === (0, _nodeJs.ExecutionRevertedError).code) : err;
    if (executionRevertedError instanceof (0, _baseJs.BaseError)) return new (0, _nodeJs.ExecutionRevertedError)({
        cause: err,
        message: executionRevertedError.details
    });
    if ((0, _nodeJs.ExecutionRevertedError).nodeMessage.test(message)) return new (0, _nodeJs.ExecutionRevertedError)({
        cause: err,
        message: err.details
    });
    if ((0, _nodeJs.FeeCapTooHighError).nodeMessage.test(message)) return new (0, _nodeJs.FeeCapTooHighError)({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
    });
    if ((0, _nodeJs.FeeCapTooLowError).nodeMessage.test(message)) return new (0, _nodeJs.FeeCapTooLowError)({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
    });
    if ((0, _nodeJs.NonceTooHighError).nodeMessage.test(message)) return new (0, _nodeJs.NonceTooHighError)({
        cause: err,
        nonce: args?.nonce
    });
    if ((0, _nodeJs.NonceTooLowError).nodeMessage.test(message)) return new (0, _nodeJs.NonceTooLowError)({
        cause: err,
        nonce: args?.nonce
    });
    if ((0, _nodeJs.NonceMaxValueError).nodeMessage.test(message)) return new (0, _nodeJs.NonceMaxValueError)({
        cause: err,
        nonce: args?.nonce
    });
    if ((0, _nodeJs.InsufficientFundsError).nodeMessage.test(message)) return new (0, _nodeJs.InsufficientFundsError)({
        cause: err
    });
    if ((0, _nodeJs.IntrinsicGasTooHighError).nodeMessage.test(message)) return new (0, _nodeJs.IntrinsicGasTooHighError)({
        cause: err,
        gas: args?.gas
    });
    if ((0, _nodeJs.IntrinsicGasTooLowError).nodeMessage.test(message)) return new (0, _nodeJs.IntrinsicGasTooLowError)({
        cause: err,
        gas: args?.gas
    });
    if ((0, _nodeJs.TransactionTypeNotSupportedError).nodeMessage.test(message)) return new (0, _nodeJs.TransactionTypeNotSupportedError)({
        cause: err
    });
    if ((0, _nodeJs.TipAboveFeeCapError).nodeMessage.test(message)) return new (0, _nodeJs.TipAboveFeeCapError)({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas,
        maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
    return new (0, _nodeJs.UnknownNodeError)({
        cause: err
    });
}

},{"../../errors/base.js":"3SEPF","../../errors/node.js":"9Ytun","../../errors/request.js":"6LYvf","../../errors/rpc.js":"jYSPv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g9KS8":[function(require,module,exports,__globalThis) {
/**
 * @description Picks out the keys from `value` that exist in the formatter..
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extract", ()=>extract);
function extract(value_, { format }) {
    if (!format) return {};
    const value = {};
    function extract_(formatted) {
        const keys = Object.keys(formatted);
        for (const key of keys){
            if (key in value_) value[key] = value_[key];
            if (formatted[key] && typeof formatted[key] === 'object' && !Array.isArray(formatted[key])) extract_(formatted[key]);
        }
    }
    const formatted = format(value_ || {});
    extract_(formatted);
    return value;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dLljr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpcTransactionType", ()=>rpcTransactionType);
parcelHelpers.export(exports, "formatTransactionRequest", ()=>formatTransactionRequest);
parcelHelpers.export(exports, "defineTransactionRequest", ()=>defineTransactionRequest);
var _toHexJs = require("../encoding/toHex.js");
var _formatterJs = require("./formatter.js");
const rpcTransactionType = {
    legacy: '0x0',
    eip2930: '0x1',
    eip1559: '0x2',
    eip4844: '0x3',
    eip7702: '0x4'
};
function formatTransactionRequest(request) {
    const rpcRequest = {};
    if (typeof request.authorizationList !== 'undefined') rpcRequest.authorizationList = formatAuthorizationList(request.authorizationList);
    if (typeof request.accessList !== 'undefined') rpcRequest.accessList = request.accessList;
    if (typeof request.blobVersionedHashes !== 'undefined') rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
    if (typeof request.blobs !== 'undefined') {
        if (typeof request.blobs[0] !== 'string') rpcRequest.blobs = request.blobs.map((x)=>(0, _toHexJs.bytesToHex)(x));
        else rpcRequest.blobs = request.blobs;
    }
    if (typeof request.data !== 'undefined') rpcRequest.data = request.data;
    if (typeof request.from !== 'undefined') rpcRequest.from = request.from;
    if (typeof request.gas !== 'undefined') rpcRequest.gas = (0, _toHexJs.numberToHex)(request.gas);
    if (typeof request.gasPrice !== 'undefined') rpcRequest.gasPrice = (0, _toHexJs.numberToHex)(request.gasPrice);
    if (typeof request.maxFeePerBlobGas !== 'undefined') rpcRequest.maxFeePerBlobGas = (0, _toHexJs.numberToHex)(request.maxFeePerBlobGas);
    if (typeof request.maxFeePerGas !== 'undefined') rpcRequest.maxFeePerGas = (0, _toHexJs.numberToHex)(request.maxFeePerGas);
    if (typeof request.maxPriorityFeePerGas !== 'undefined') rpcRequest.maxPriorityFeePerGas = (0, _toHexJs.numberToHex)(request.maxPriorityFeePerGas);
    if (typeof request.nonce !== 'undefined') rpcRequest.nonce = (0, _toHexJs.numberToHex)(request.nonce);
    if (typeof request.to !== 'undefined') rpcRequest.to = request.to;
    if (typeof request.type !== 'undefined') rpcRequest.type = rpcTransactionType[request.type];
    if (typeof request.value !== 'undefined') rpcRequest.value = (0, _toHexJs.numberToHex)(request.value);
    return rpcRequest;
}
const defineTransactionRequest = /*#__PURE__*/ (0, _formatterJs.defineFormatter)('transactionRequest', formatTransactionRequest);
//////////////////////////////////////////////////////////////////////////////
function formatAuthorizationList(authorizationList) {
    return authorizationList.map((authorization)=>({
            address: authorization.address,
            r: authorization.r ? (0, _toHexJs.numberToHex)(BigInt(authorization.r)) : authorization.r,
            s: authorization.s ? (0, _toHexJs.numberToHex)(BigInt(authorization.s)) : authorization.s,
            chainId: (0, _toHexJs.numberToHex)(authorization.chainId),
            nonce: (0, _toHexJs.numberToHex)(authorization.nonce),
            ...typeof authorization.yParity !== 'undefined' ? {
                yParity: (0, _toHexJs.numberToHex)(authorization.yParity)
            } : {},
            ...typeof authorization.v !== 'undefined' && typeof authorization.yParity === 'undefined' ? {
                v: (0, _toHexJs.numberToHex)(authorization.v)
            } : {}
        }));
}

},{"../encoding/toHex.js":"9GFC6","./formatter.js":"itqtW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"itqtW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defineFormatter", ()=>defineFormatter);
function defineFormatter(type, format) {
    return ({ exclude, format: overrides })=>{
        return {
            exclude,
            format: (args)=>{
                const formatted = format(args);
                if (exclude) for (const key of exclude)delete formatted[key];
                return {
                    ...formatted,
                    ...overrides(args)
                };
            },
            type
        };
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"zqcJp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "serializeStateMapping", ()=>serializeStateMapping);
/** @internal */ parcelHelpers.export(exports, "serializeAccountStateOverride", ()=>serializeAccountStateOverride);
/** @internal */ parcelHelpers.export(exports, "serializeStateOverride", ()=>serializeStateOverride);
var _addressJs = require("../errors/address.js");
var _dataJs = require("../errors/data.js");
var _stateOverrideJs = require("../errors/stateOverride.js");
var _isAddressJs = require("./address/isAddress.js");
var _toHexJs = require("./encoding/toHex.js");
function serializeStateMapping(stateMapping) {
    if (!stateMapping || stateMapping.length === 0) return undefined;
    return stateMapping.reduce((acc, { slot, value })=>{
        if (slot.length !== 66) throw new (0, _dataJs.InvalidBytesLengthError)({
            size: slot.length,
            targetSize: 66,
            type: 'hex'
        });
        if (value.length !== 66) throw new (0, _dataJs.InvalidBytesLengthError)({
            size: value.length,
            targetSize: 66,
            type: 'hex'
        });
        acc[slot] = value;
        return acc;
    }, {});
}
function serializeAccountStateOverride(parameters) {
    const { balance, nonce, state, stateDiff, code } = parameters;
    const rpcAccountStateOverride = {};
    if (code !== undefined) rpcAccountStateOverride.code = code;
    if (balance !== undefined) rpcAccountStateOverride.balance = (0, _toHexJs.numberToHex)(balance);
    if (nonce !== undefined) rpcAccountStateOverride.nonce = (0, _toHexJs.numberToHex)(nonce);
    if (state !== undefined) rpcAccountStateOverride.state = serializeStateMapping(state);
    if (stateDiff !== undefined) {
        if (rpcAccountStateOverride.state) throw new (0, _stateOverrideJs.StateAssignmentConflictError)();
        rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
    }
    return rpcAccountStateOverride;
}
function serializeStateOverride(parameters) {
    if (!parameters) return undefined;
    const rpcStateOverride = {};
    for (const { address, ...accountState } of parameters){
        if (!(0, _isAddressJs.isAddress)(address, {
            strict: false
        })) throw new (0, _addressJs.InvalidAddressError)({
            address
        });
        if (rpcStateOverride[address]) throw new (0, _stateOverrideJs.AccountStateConflictError)({
            address: address
        });
        rpcStateOverride[address] = serializeAccountStateOverride(accountState);
    }
    return rpcStateOverride;
}

},{"../errors/address.js":"17VWr","../errors/data.js":"kBfpj","../errors/stateOverride.js":"3GdPa","./address/isAddress.js":"kdAuv","./encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eSiKr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assertRequest", ()=>assertRequest);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _numberJs = require("../../constants/number.js");
var _addressJs = require("../../errors/address.js");
var _nodeJs = require("../../errors/node.js");
var _transactionJs = require("../../errors/transaction.js");
var _isAddressJs = require("../address/isAddress.js");
function assertRequest(args) {
    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to } = args;
    const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : undefined;
    if (account && !(0, _isAddressJs.isAddress)(account.address)) throw new (0, _addressJs.InvalidAddressError)({
        address: account.address
    });
    if (to && !(0, _isAddressJs.isAddress)(to)) throw new (0, _addressJs.InvalidAddressError)({
        address: to
    });
    if (typeof gasPrice !== 'undefined' && (typeof maxFeePerGas !== 'undefined' || typeof maxPriorityFeePerGas !== 'undefined')) throw new (0, _transactionJs.FeeConflictError)();
    if (maxFeePerGas && maxFeePerGas > (0, _numberJs.maxUint256)) throw new (0, _nodeJs.FeeCapTooHighError)({
        maxFeePerGas
    });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas) throw new (0, _nodeJs.TipAboveFeeCapError)({
        maxFeePerGas,
        maxPriorityFeePerGas
    });
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../constants/number.js":"4KokG","../../errors/address.js":"17VWr","../../errors/node.js":"9Ytun","../../errors/transaction.js":"4gFzr","../address/isAddress.js":"kdAuv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4KokG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maxInt8", ()=>maxInt8);
parcelHelpers.export(exports, "maxInt16", ()=>maxInt16);
parcelHelpers.export(exports, "maxInt24", ()=>maxInt24);
parcelHelpers.export(exports, "maxInt32", ()=>maxInt32);
parcelHelpers.export(exports, "maxInt40", ()=>maxInt40);
parcelHelpers.export(exports, "maxInt48", ()=>maxInt48);
parcelHelpers.export(exports, "maxInt56", ()=>maxInt56);
parcelHelpers.export(exports, "maxInt64", ()=>maxInt64);
parcelHelpers.export(exports, "maxInt72", ()=>maxInt72);
parcelHelpers.export(exports, "maxInt80", ()=>maxInt80);
parcelHelpers.export(exports, "maxInt88", ()=>maxInt88);
parcelHelpers.export(exports, "maxInt96", ()=>maxInt96);
parcelHelpers.export(exports, "maxInt104", ()=>maxInt104);
parcelHelpers.export(exports, "maxInt112", ()=>maxInt112);
parcelHelpers.export(exports, "maxInt120", ()=>maxInt120);
parcelHelpers.export(exports, "maxInt128", ()=>maxInt128);
parcelHelpers.export(exports, "maxInt136", ()=>maxInt136);
parcelHelpers.export(exports, "maxInt144", ()=>maxInt144);
parcelHelpers.export(exports, "maxInt152", ()=>maxInt152);
parcelHelpers.export(exports, "maxInt160", ()=>maxInt160);
parcelHelpers.export(exports, "maxInt168", ()=>maxInt168);
parcelHelpers.export(exports, "maxInt176", ()=>maxInt176);
parcelHelpers.export(exports, "maxInt184", ()=>maxInt184);
parcelHelpers.export(exports, "maxInt192", ()=>maxInt192);
parcelHelpers.export(exports, "maxInt200", ()=>maxInt200);
parcelHelpers.export(exports, "maxInt208", ()=>maxInt208);
parcelHelpers.export(exports, "maxInt216", ()=>maxInt216);
parcelHelpers.export(exports, "maxInt224", ()=>maxInt224);
parcelHelpers.export(exports, "maxInt232", ()=>maxInt232);
parcelHelpers.export(exports, "maxInt240", ()=>maxInt240);
parcelHelpers.export(exports, "maxInt248", ()=>maxInt248);
parcelHelpers.export(exports, "maxInt256", ()=>maxInt256);
parcelHelpers.export(exports, "minInt8", ()=>minInt8);
parcelHelpers.export(exports, "minInt16", ()=>minInt16);
parcelHelpers.export(exports, "minInt24", ()=>minInt24);
parcelHelpers.export(exports, "minInt32", ()=>minInt32);
parcelHelpers.export(exports, "minInt40", ()=>minInt40);
parcelHelpers.export(exports, "minInt48", ()=>minInt48);
parcelHelpers.export(exports, "minInt56", ()=>minInt56);
parcelHelpers.export(exports, "minInt64", ()=>minInt64);
parcelHelpers.export(exports, "minInt72", ()=>minInt72);
parcelHelpers.export(exports, "minInt80", ()=>minInt80);
parcelHelpers.export(exports, "minInt88", ()=>minInt88);
parcelHelpers.export(exports, "minInt96", ()=>minInt96);
parcelHelpers.export(exports, "minInt104", ()=>minInt104);
parcelHelpers.export(exports, "minInt112", ()=>minInt112);
parcelHelpers.export(exports, "minInt120", ()=>minInt120);
parcelHelpers.export(exports, "minInt128", ()=>minInt128);
parcelHelpers.export(exports, "minInt136", ()=>minInt136);
parcelHelpers.export(exports, "minInt144", ()=>minInt144);
parcelHelpers.export(exports, "minInt152", ()=>minInt152);
parcelHelpers.export(exports, "minInt160", ()=>minInt160);
parcelHelpers.export(exports, "minInt168", ()=>minInt168);
parcelHelpers.export(exports, "minInt176", ()=>minInt176);
parcelHelpers.export(exports, "minInt184", ()=>minInt184);
parcelHelpers.export(exports, "minInt192", ()=>minInt192);
parcelHelpers.export(exports, "minInt200", ()=>minInt200);
parcelHelpers.export(exports, "minInt208", ()=>minInt208);
parcelHelpers.export(exports, "minInt216", ()=>minInt216);
parcelHelpers.export(exports, "minInt224", ()=>minInt224);
parcelHelpers.export(exports, "minInt232", ()=>minInt232);
parcelHelpers.export(exports, "minInt240", ()=>minInt240);
parcelHelpers.export(exports, "minInt248", ()=>minInt248);
parcelHelpers.export(exports, "minInt256", ()=>minInt256);
parcelHelpers.export(exports, "maxUint8", ()=>maxUint8);
parcelHelpers.export(exports, "maxUint16", ()=>maxUint16);
parcelHelpers.export(exports, "maxUint24", ()=>maxUint24);
parcelHelpers.export(exports, "maxUint32", ()=>maxUint32);
parcelHelpers.export(exports, "maxUint40", ()=>maxUint40);
parcelHelpers.export(exports, "maxUint48", ()=>maxUint48);
parcelHelpers.export(exports, "maxUint56", ()=>maxUint56);
parcelHelpers.export(exports, "maxUint64", ()=>maxUint64);
parcelHelpers.export(exports, "maxUint72", ()=>maxUint72);
parcelHelpers.export(exports, "maxUint80", ()=>maxUint80);
parcelHelpers.export(exports, "maxUint88", ()=>maxUint88);
parcelHelpers.export(exports, "maxUint96", ()=>maxUint96);
parcelHelpers.export(exports, "maxUint104", ()=>maxUint104);
parcelHelpers.export(exports, "maxUint112", ()=>maxUint112);
parcelHelpers.export(exports, "maxUint120", ()=>maxUint120);
parcelHelpers.export(exports, "maxUint128", ()=>maxUint128);
parcelHelpers.export(exports, "maxUint136", ()=>maxUint136);
parcelHelpers.export(exports, "maxUint144", ()=>maxUint144);
parcelHelpers.export(exports, "maxUint152", ()=>maxUint152);
parcelHelpers.export(exports, "maxUint160", ()=>maxUint160);
parcelHelpers.export(exports, "maxUint168", ()=>maxUint168);
parcelHelpers.export(exports, "maxUint176", ()=>maxUint176);
parcelHelpers.export(exports, "maxUint184", ()=>maxUint184);
parcelHelpers.export(exports, "maxUint192", ()=>maxUint192);
parcelHelpers.export(exports, "maxUint200", ()=>maxUint200);
parcelHelpers.export(exports, "maxUint208", ()=>maxUint208);
parcelHelpers.export(exports, "maxUint216", ()=>maxUint216);
parcelHelpers.export(exports, "maxUint224", ()=>maxUint224);
parcelHelpers.export(exports, "maxUint232", ()=>maxUint232);
parcelHelpers.export(exports, "maxUint240", ()=>maxUint240);
parcelHelpers.export(exports, "maxUint248", ()=>maxUint248);
parcelHelpers.export(exports, "maxUint256", ()=>maxUint256);
const maxInt8 = 2n ** (8n - 1n) - 1n;
const maxInt16 = 2n ** (16n - 1n) - 1n;
const maxInt24 = 2n ** (24n - 1n) - 1n;
const maxInt32 = 2n ** (32n - 1n) - 1n;
const maxInt40 = 2n ** (40n - 1n) - 1n;
const maxInt48 = 2n ** (48n - 1n) - 1n;
const maxInt56 = 2n ** (56n - 1n) - 1n;
const maxInt64 = 2n ** (64n - 1n) - 1n;
const maxInt72 = 2n ** (72n - 1n) - 1n;
const maxInt80 = 2n ** (80n - 1n) - 1n;
const maxInt88 = 2n ** (88n - 1n) - 1n;
const maxInt96 = 2n ** (96n - 1n) - 1n;
const maxInt104 = 2n ** (104n - 1n) - 1n;
const maxInt112 = 2n ** (112n - 1n) - 1n;
const maxInt120 = 2n ** (120n - 1n) - 1n;
const maxInt128 = 2n ** (128n - 1n) - 1n;
const maxInt136 = 2n ** (136n - 1n) - 1n;
const maxInt144 = 2n ** (144n - 1n) - 1n;
const maxInt152 = 2n ** (152n - 1n) - 1n;
const maxInt160 = 2n ** (160n - 1n) - 1n;
const maxInt168 = 2n ** (168n - 1n) - 1n;
const maxInt176 = 2n ** (176n - 1n) - 1n;
const maxInt184 = 2n ** (184n - 1n) - 1n;
const maxInt192 = 2n ** (192n - 1n) - 1n;
const maxInt200 = 2n ** (200n - 1n) - 1n;
const maxInt208 = 2n ** (208n - 1n) - 1n;
const maxInt216 = 2n ** (216n - 1n) - 1n;
const maxInt224 = 2n ** (224n - 1n) - 1n;
const maxInt232 = 2n ** (232n - 1n) - 1n;
const maxInt240 = 2n ** (240n - 1n) - 1n;
const maxInt248 = 2n ** (248n - 1n) - 1n;
const maxInt256 = 2n ** (256n - 1n) - 1n;
const minInt8 = -(2n ** (8n - 1n));
const minInt16 = -(2n ** (16n - 1n));
const minInt24 = -(2n ** (24n - 1n));
const minInt32 = -(2n ** (32n - 1n));
const minInt40 = -(2n ** (40n - 1n));
const minInt48 = -(2n ** (48n - 1n));
const minInt56 = -(2n ** (56n - 1n));
const minInt64 = -(2n ** (64n - 1n));
const minInt72 = -(2n ** (72n - 1n));
const minInt80 = -(2n ** (80n - 1n));
const minInt88 = -(2n ** (88n - 1n));
const minInt96 = -(2n ** (96n - 1n));
const minInt104 = -(2n ** (104n - 1n));
const minInt112 = -(2n ** (112n - 1n));
const minInt120 = -(2n ** (120n - 1n));
const minInt128 = -(2n ** (128n - 1n));
const minInt136 = -(2n ** (136n - 1n));
const minInt144 = -(2n ** (144n - 1n));
const minInt152 = -(2n ** (152n - 1n));
const minInt160 = -(2n ** (160n - 1n));
const minInt168 = -(2n ** (168n - 1n));
const minInt176 = -(2n ** (176n - 1n));
const minInt184 = -(2n ** (184n - 1n));
const minInt192 = -(2n ** (192n - 1n));
const minInt200 = -(2n ** (200n - 1n));
const minInt208 = -(2n ** (208n - 1n));
const minInt216 = -(2n ** (216n - 1n));
const minInt224 = -(2n ** (224n - 1n));
const minInt232 = -(2n ** (232n - 1n));
const minInt240 = -(2n ** (240n - 1n));
const minInt248 = -(2n ** (248n - 1n));
const minInt256 = -(2n ** (256n - 1n));
const maxUint8 = 2n ** 8n - 1n;
const maxUint16 = 2n ** 16n - 1n;
const maxUint24 = 2n ** 24n - 1n;
const maxUint32 = 2n ** 32n - 1n;
const maxUint40 = 2n ** 40n - 1n;
const maxUint48 = 2n ** 48n - 1n;
const maxUint56 = 2n ** 56n - 1n;
const maxUint64 = 2n ** 64n - 1n;
const maxUint72 = 2n ** 72n - 1n;
const maxUint80 = 2n ** 80n - 1n;
const maxUint88 = 2n ** 88n - 1n;
const maxUint96 = 2n ** 96n - 1n;
const maxUint104 = 2n ** 104n - 1n;
const maxUint112 = 2n ** 112n - 1n;
const maxUint120 = 2n ** 120n - 1n;
const maxUint128 = 2n ** 128n - 1n;
const maxUint136 = 2n ** 136n - 1n;
const maxUint144 = 2n ** 144n - 1n;
const maxUint152 = 2n ** 152n - 1n;
const maxUint160 = 2n ** 160n - 1n;
const maxUint168 = 2n ** 168n - 1n;
const maxUint176 = 2n ** 176n - 1n;
const maxUint184 = 2n ** 184n - 1n;
const maxUint192 = 2n ** 192n - 1n;
const maxUint200 = 2n ** 200n - 1n;
const maxUint208 = 2n ** 208n - 1n;
const maxUint216 = 2n ** 216n - 1n;
const maxUint224 = 2n ** 224n - 1n;
const maxUint232 = 2n ** 232n - 1n;
const maxUint240 = 2n ** 240n - 1n;
const maxUint248 = 2n ** 248n - 1n;
const maxUint256 = 2n ** 256n - 1n;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"53wjM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultParameters", ()=>defaultParameters);
parcelHelpers.export(exports, "eip1559NetworkCache", ()=>eip1559NetworkCache);
/**
 * Prepares a transaction request for signing.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest
 *
 * @param args - {@link PrepareTransactionRequestParameters}
 * @returns The transaction request. {@link PrepareTransactionRequestReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { prepareTransactionRequest } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const request = await prepareTransactionRequest(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { prepareTransactionRequest } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const request = await prepareTransactionRequest(client, {
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 */ parcelHelpers.export(exports, "prepareTransactionRequest", ()=>prepareTransactionRequest);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _estimateFeesPerGasJs = require("../../actions/public/estimateFeesPerGas.js");
var _estimateGasJs = require("../../actions/public/estimateGas.js");
var _getBlockJs = require("../../actions/public/getBlock.js");
var _getTransactionCountJs = require("../../actions/public/getTransactionCount.js");
var _feeJs = require("../../errors/fee.js");
var _blobsToCommitmentsJs = require("../../utils/blob/blobsToCommitments.js");
var _blobsToProofsJs = require("../../utils/blob/blobsToProofs.js");
var _commitmentsToVersionedHashesJs = require("../../utils/blob/commitmentsToVersionedHashes.js");
var _toBlobSidecarsJs = require("../../utils/blob/toBlobSidecars.js");
var _getActionJs = require("../../utils/getAction.js");
var _assertRequestJs = require("../../utils/transaction/assertRequest.js");
var _getTransactionTypeJs = require("../../utils/transaction/getTransactionType.js");
var _getChainIdJs = require("../public/getChainId.js");
const defaultParameters = [
    'blobVersionedHashes',
    'chainId',
    'fees',
    'gas',
    'nonce',
    'type'
];
const eip1559NetworkCache = /*#__PURE__*/ new Map();
async function prepareTransactionRequest(client, args) {
    const { account: account_ = client.account, blobs, chain, gas, kzg, nonce, nonceManager, parameters = defaultParameters, type } = args;
    const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : account_;
    const request = {
        ...args,
        ...account ? {
            from: account?.address
        } : {}
    };
    let block;
    async function getBlock() {
        if (block) return block;
        block = await (0, _getActionJs.getAction)(client, (0, _getBlockJs.getBlock), 'getBlock')({
            blockTag: 'latest'
        });
        return block;
    }
    let chainId;
    async function getChainId() {
        if (chainId) return chainId;
        if (chain) return chain.id;
        if (typeof args.chainId !== 'undefined') return args.chainId;
        const chainId_ = await (0, _getActionJs.getAction)(client, (0, _getChainIdJs.getChainId), 'getChainId')({});
        chainId = chainId_;
        return chainId;
    }
    if (parameters.includes('nonce') && typeof nonce === 'undefined' && account) {
        if (nonceManager) {
            const chainId = await getChainId();
            request.nonce = await nonceManager.consume({
                address: account.address,
                chainId,
                client
            });
        } else request.nonce = await (0, _getActionJs.getAction)(client, (0, _getTransactionCountJs.getTransactionCount), 'getTransactionCount')({
            address: account.address,
            blockTag: 'pending'
        });
    }
    if ((parameters.includes('blobVersionedHashes') || parameters.includes('sidecars')) && blobs && kzg) {
        const commitments = (0, _blobsToCommitmentsJs.blobsToCommitments)({
            blobs,
            kzg
        });
        if (parameters.includes('blobVersionedHashes')) {
            const versionedHashes = (0, _commitmentsToVersionedHashesJs.commitmentsToVersionedHashes)({
                commitments,
                to: 'hex'
            });
            request.blobVersionedHashes = versionedHashes;
        }
        if (parameters.includes('sidecars')) {
            const proofs = (0, _blobsToProofsJs.blobsToProofs)({
                blobs,
                commitments,
                kzg
            });
            const sidecars = (0, _toBlobSidecarsJs.toBlobSidecars)({
                blobs,
                commitments,
                proofs,
                to: 'hex'
            });
            request.sidecars = sidecars;
        }
    }
    if (parameters.includes('chainId')) request.chainId = await getChainId();
    if ((parameters.includes('fees') || parameters.includes('type')) && typeof type === 'undefined') try {
        request.type = (0, _getTransactionTypeJs.getTransactionType)(request);
    } catch  {
        let isEip1559Network = eip1559NetworkCache.get(client.uid);
        if (typeof isEip1559Network === 'undefined') {
            const block = await getBlock();
            isEip1559Network = typeof block?.baseFeePerGas === 'bigint';
            eip1559NetworkCache.set(client.uid, isEip1559Network);
        }
        request.type = isEip1559Network ? 'eip1559' : 'legacy';
    }
    if (parameters.includes('fees')) {
        // TODO(4844): derive blob base fees once https://github.com/ethereum/execution-apis/pull/486 is merged.
        if (request.type !== 'legacy' && request.type !== 'eip2930') // EIP-1559 fees
        {
            if (typeof request.maxFeePerGas === 'undefined' || typeof request.maxPriorityFeePerGas === 'undefined') {
                const block = await getBlock();
                const { maxFeePerGas, maxPriorityFeePerGas } = await (0, _estimateFeesPerGasJs.internal_estimateFeesPerGas)(client, {
                    block: block,
                    chain,
                    request: request
                });
                if (typeof args.maxPriorityFeePerGas === 'undefined' && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas) throw new (0, _feeJs.MaxFeePerGasTooLowError)({
                    maxPriorityFeePerGas
                });
                request.maxPriorityFeePerGas = maxPriorityFeePerGas;
                request.maxFeePerGas = maxFeePerGas;
            }
        } else {
            // Legacy fees
            if (typeof args.maxFeePerGas !== 'undefined' || typeof args.maxPriorityFeePerGas !== 'undefined') throw new (0, _feeJs.Eip1559FeesNotSupportedError)();
            if (typeof args.gasPrice === 'undefined') {
                const block = await getBlock();
                const { gasPrice: gasPrice_ } = await (0, _estimateFeesPerGasJs.internal_estimateFeesPerGas)(client, {
                    block: block,
                    chain,
                    request: request,
                    type: 'legacy'
                });
                request.gasPrice = gasPrice_;
            }
        }
    }
    if (parameters.includes('gas') && typeof gas === 'undefined') request.gas = await (0, _getActionJs.getAction)(client, (0, _estimateGasJs.estimateGas), 'estimateGas')({
        ...request,
        account: account ? {
            address: account.address,
            type: 'json-rpc'
        } : account
    });
    (0, _assertRequestJs.assertRequest)(request);
    delete request.parameters;
    return request;
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../actions/public/estimateFeesPerGas.js":"duZBq","../../actions/public/estimateGas.js":"22Lcu","../../actions/public/getBlock.js":"1M4Cs","../../actions/public/getTransactionCount.js":"7o2N6","../../errors/fee.js":"2IQlm","../../utils/blob/blobsToCommitments.js":"lGkWy","../../utils/blob/blobsToProofs.js":"82xng","../../utils/blob/commitmentsToVersionedHashes.js":"hAdbt","../../utils/blob/toBlobSidecars.js":"iLFBZ","../../utils/getAction.js":"d1Bvd","../../utils/transaction/assertRequest.js":"eSiKr","../../utils/transaction/getTransactionType.js":"2MIAC","../public/getChainId.js":"lXOca","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"duZBq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns an estimate for the fees per gas (in wei) for a
 * transaction to be likely included in the next block.
 * Defaults to [`chain.fees.estimateFeesPerGas`](/docs/clients/chains#fees-estimatefeespergas) if set.
 *
 * - Docs: https://viem.sh/docs/actions/public/estimateFeesPerGas
 *
 * @param client - Client to use
 * @param parameters - {@link EstimateFeesPerGasParameters}
 * @returns An estimate (in wei) for the fees per gas. {@link EstimateFeesPerGasReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { estimateFeesPerGas } from 'viem/actions'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const maxPriorityFeePerGas = await estimateFeesPerGas(client)
 * // { maxFeePerGas: ..., maxPriorityFeePerGas: ... }
 */ parcelHelpers.export(exports, "estimateFeesPerGas", ()=>estimateFeesPerGas);
parcelHelpers.export(exports, "internal_estimateFeesPerGas", ()=>internal_estimateFeesPerGas);
var _feeJs = require("../../errors/fee.js");
var _getActionJs = require("../../utils/getAction.js");
var _estimateMaxPriorityFeePerGasJs = require("./estimateMaxPriorityFeePerGas.js");
var _getBlockJs = require("./getBlock.js");
var _getGasPriceJs = require("./getGasPrice.js");
async function estimateFeesPerGas(client, args) {
    return internal_estimateFeesPerGas(client, args);
}
async function internal_estimateFeesPerGas(client, args) {
    const { block: block_, chain = client.chain, request, type = 'eip1559' } = args || {};
    const baseFeeMultiplier = await (async ()=>{
        if (typeof chain?.fees?.baseFeeMultiplier === 'function') return chain.fees.baseFeeMultiplier({
            block: block_,
            client,
            request
        });
        return chain?.fees?.baseFeeMultiplier ?? 1.2;
    })();
    if (baseFeeMultiplier < 1) throw new (0, _feeJs.BaseFeeScalarError)();
    const decimals = baseFeeMultiplier.toString().split('.')[1]?.length ?? 0;
    const denominator = 10 ** decimals;
    const multiply = (base)=>base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
    const block = block_ ? block_ : await (0, _getActionJs.getAction)(client, (0, _getBlockJs.getBlock), 'getBlock')({});
    if (typeof chain?.fees?.estimateFeesPerGas === 'function') {
        const fees = await chain.fees.estimateFeesPerGas({
            block: block_,
            client,
            multiply,
            request,
            type
        });
        if (fees !== null) return fees;
    }
    if (type === 'eip1559') {
        if (typeof block.baseFeePerGas !== 'bigint') throw new (0, _feeJs.Eip1559FeesNotSupportedError)();
        const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === 'bigint' ? request.maxPriorityFeePerGas : await (0, _estimateMaxPriorityFeePerGasJs.internal_estimateMaxPriorityFeePerGas)(client, {
            block: block,
            chain,
            request
        });
        const baseFeePerGas = multiply(block.baseFeePerGas);
        const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
        return {
            maxFeePerGas,
            maxPriorityFeePerGas
        };
    }
    const gasPrice = request?.gasPrice ?? multiply(await (0, _getActionJs.getAction)(client, (0, _getGasPriceJs.getGasPrice), 'getGasPrice')({}));
    return {
        gasPrice
    };
}

},{"../../errors/fee.js":"2IQlm","../../utils/getAction.js":"d1Bvd","./estimateMaxPriorityFeePerGas.js":"hXKqr","./getBlock.js":"1M4Cs","./getGasPrice.js":"i7Vx8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2IQlm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseFeeScalarError", ()=>BaseFeeScalarError);
parcelHelpers.export(exports, "Eip1559FeesNotSupportedError", ()=>Eip1559FeesNotSupportedError);
parcelHelpers.export(exports, "MaxFeePerGasTooLowError", ()=>MaxFeePerGasTooLowError);
var _formatGweiJs = require("../utils/unit/formatGwei.js");
var _baseJs = require("./base.js");
class BaseFeeScalarError extends (0, _baseJs.BaseError) {
    constructor(){
        super('`baseFeeMultiplier` must be greater than 1.', {
            name: 'BaseFeeScalarError'
        });
    }
}
class Eip1559FeesNotSupportedError extends (0, _baseJs.BaseError) {
    constructor(){
        super('Chain does not support EIP-1559 fees.', {
            name: 'Eip1559FeesNotSupportedError'
        });
    }
}
class MaxFeePerGasTooLowError extends (0, _baseJs.BaseError) {
    constructor({ maxPriorityFeePerGas }){
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, _formatGweiJs.formatGwei)(maxPriorityFeePerGas)} gwei).`, {
            name: 'MaxFeePerGasTooLowError'
        });
    }
}

},{"../utils/unit/formatGwei.js":"2vNTy","./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hXKqr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns an estimate for the max priority fee per gas (in wei) for a
 * transaction to be likely included in the next block.
 * Defaults to [`chain.fees.defaultPriorityFee`](/docs/clients/chains#fees-defaultpriorityfee) if set.
 *
 * - Docs: https://viem.sh/docs/actions/public/estimateMaxPriorityFeePerGas
 *
 * @param client - Client to use
 * @returns An estimate (in wei) for the max priority fee per gas. {@link EstimateMaxPriorityFeePerGasReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { estimateMaxPriorityFeePerGas } from 'viem/actions'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const maxPriorityFeePerGas = await estimateMaxPriorityFeePerGas(client)
 * // 10000000n
 */ parcelHelpers.export(exports, "estimateMaxPriorityFeePerGas", ()=>estimateMaxPriorityFeePerGas);
parcelHelpers.export(exports, "internal_estimateMaxPriorityFeePerGas", ()=>internal_estimateMaxPriorityFeePerGas);
var _feeJs = require("../../errors/fee.js");
var _fromHexJs = require("../../utils/encoding/fromHex.js");
var _getActionJs = require("../../utils/getAction.js");
var _getBlockJs = require("./getBlock.js");
var _getGasPriceJs = require("./getGasPrice.js");
async function estimateMaxPriorityFeePerGas(client, args) {
    return internal_estimateMaxPriorityFeePerGas(client, args);
}
async function internal_estimateMaxPriorityFeePerGas(client, args) {
    const { block: block_, chain = client.chain, request } = args || {};
    try {
        const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;
        if (typeof maxPriorityFeePerGas === 'function') {
            const block = block_ || await (0, _getActionJs.getAction)(client, (0, _getBlockJs.getBlock), 'getBlock')({});
            const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
                block,
                client,
                request
            });
            if (maxPriorityFeePerGas_ === null) throw new Error();
            return maxPriorityFeePerGas_;
        }
        if (typeof maxPriorityFeePerGas !== 'undefined') return maxPriorityFeePerGas;
        const maxPriorityFeePerGasHex = await client.request({
            method: 'eth_maxPriorityFeePerGas'
        });
        return (0, _fromHexJs.hexToBigInt)(maxPriorityFeePerGasHex);
    } catch  {
        // If the RPC Provider does not support `eth_maxPriorityFeePerGas`
        // fall back to calculating it manually via `gasPrice - baseFeePerGas`.
        // See: https://github.com/ethereum/pm/issues/328#:~:text=eth_maxPriorityFeePerGas%20after%20London%20will%20effectively%20return%20eth_gasPrice%20%2D%20baseFee
        const [block, gasPrice] = await Promise.all([
            block_ ? Promise.resolve(block_) : (0, _getActionJs.getAction)(client, (0, _getBlockJs.getBlock), 'getBlock')({}),
            (0, _getActionJs.getAction)(client, (0, _getGasPriceJs.getGasPrice), 'getGasPrice')({})
        ]);
        if (typeof block.baseFeePerGas !== 'bigint') throw new (0, _feeJs.Eip1559FeesNotSupportedError)();
        const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
        if (maxPriorityFeePerGas < 0n) return 0n;
        return maxPriorityFeePerGas;
    }
}

},{"../../errors/fee.js":"2IQlm","../../utils/encoding/fromHex.js":"kLfW5","../../utils/getAction.js":"d1Bvd","./getBlock.js":"1M4Cs","./getGasPrice.js":"i7Vx8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1M4Cs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns information about a block at a block number, hash, or tag.
 *
 * - Docs: https://viem.sh/docs/actions/public/getBlock
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks
 * - JSON-RPC Methods:
 *   - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) for `blockNumber` & `blockTag`.
 *   - Calls [`eth_getBlockByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbyhash) for `blockHash`.
 *
 * @param client - Client to use
 * @param parameters - {@link GetBlockParameters}
 * @returns Information about the block. {@link GetBlockReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBlock } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const block = await getBlock(client)
 */ parcelHelpers.export(exports, "getBlock", ()=>getBlock);
var _blockJs = require("../../errors/block.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _blockJs1 = require("../../utils/formatters/block.js");
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
    const blockTag = blockTag_ ?? 'latest';
    const includeTransactions = includeTransactions_ ?? false;
    const blockNumberHex = blockNumber !== undefined ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    let block = null;
    if (blockHash) block = await client.request({
        method: 'eth_getBlockByHash',
        params: [
            blockHash,
            includeTransactions
        ]
    }, {
        dedupe: true
    });
    else block = await client.request({
        method: 'eth_getBlockByNumber',
        params: [
            blockNumberHex || blockTag,
            includeTransactions
        ]
    }, {
        dedupe: Boolean(blockNumberHex)
    });
    if (!block) throw new (0, _blockJs.BlockNotFoundError)({
        blockHash,
        blockNumber
    });
    const format = client.chain?.formatters?.block?.format || (0, _blockJs1.formatBlock);
    return format(block);
}

},{"../../errors/block.js":"iTpgp","../../utils/encoding/toHex.js":"9GFC6","../../utils/formatters/block.js":"kJKKG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iTpgp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BlockNotFoundError", ()=>BlockNotFoundError);
var _baseJs = require("./base.js");
class BlockNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ blockHash, blockNumber }){
        let identifier = 'Block';
        if (blockHash) identifier = `Block at hash "${blockHash}"`;
        if (blockNumber) identifier = `Block at number "${blockNumber}"`;
        super(`${identifier} could not be found.`, {
            name: 'BlockNotFoundError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kJKKG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatBlock", ()=>formatBlock);
parcelHelpers.export(exports, "defineBlock", ()=>defineBlock);
var _formatterJs = require("./formatter.js");
var _transactionJs = require("./transaction.js");
function formatBlock(block) {
    const transactions = (block.transactions ?? []).map((transaction)=>{
        if (typeof transaction === 'string') return transaction;
        return (0, _transactionJs.formatTransaction)(transaction);
    });
    return {
        ...block,
        baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
        blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,
        difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
        excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : undefined,
        gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
        gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
        hash: block.hash ? block.hash : null,
        logsBloom: block.logsBloom ? block.logsBloom : null,
        nonce: block.nonce ? block.nonce : null,
        number: block.number ? BigInt(block.number) : null,
        size: block.size ? BigInt(block.size) : undefined,
        timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
        transactions,
        totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
    };
}
const defineBlock = /*#__PURE__*/ (0, _formatterJs.defineFormatter)('block', formatBlock);

},{"./formatter.js":"itqtW","./transaction.js":"dhAxe","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dhAxe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transactionType", ()=>transactionType);
parcelHelpers.export(exports, "formatTransaction", ()=>formatTransaction);
parcelHelpers.export(exports, "defineTransaction", ()=>defineTransaction);
var _fromHexJs = require("../encoding/fromHex.js");
var _formatterJs = require("./formatter.js");
const transactionType = {
    '0x0': 'legacy',
    '0x1': 'eip2930',
    '0x2': 'eip1559',
    '0x3': 'eip4844',
    '0x4': 'eip7702'
};
function formatTransaction(transaction) {
    const transaction_ = {
        ...transaction,
        blockHash: transaction.blockHash ? transaction.blockHash : null,
        blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
        chainId: transaction.chainId ? (0, _fromHexJs.hexToNumber)(transaction.chainId) : undefined,
        gas: transaction.gas ? BigInt(transaction.gas) : undefined,
        gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
        maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : undefined,
        maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : undefined,
        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : undefined,
        nonce: transaction.nonce ? (0, _fromHexJs.hexToNumber)(transaction.nonce) : undefined,
        to: transaction.to ? transaction.to : null,
        transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
        type: transaction.type ? transactionType[transaction.type] : undefined,
        typeHex: transaction.type ? transaction.type : undefined,
        value: transaction.value ? BigInt(transaction.value) : undefined,
        v: transaction.v ? BigInt(transaction.v) : undefined
    };
    if (transaction.authorizationList) transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
    transaction_.yParity = (()=>{
        // If `yParity` is provided, we will use it.
        if (transaction.yParity) return Number(transaction.yParity);
        // If no `yParity` provided, try derive from `v`.
        if (typeof transaction_.v === 'bigint') {
            if (transaction_.v === 0n || transaction_.v === 27n) return 0;
            if (transaction_.v === 1n || transaction_.v === 28n) return 1;
            if (transaction_.v >= 35n) return transaction_.v % 2n === 0n ? 1 : 0;
        }
        return undefined;
    })();
    if (transaction_.type === 'legacy') {
        delete transaction_.accessList;
        delete transaction_.maxFeePerBlobGas;
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
        delete transaction_.yParity;
    }
    if (transaction_.type === 'eip2930') {
        delete transaction_.maxFeePerBlobGas;
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
    }
    if (transaction_.type === 'eip1559') delete transaction_.maxFeePerBlobGas;
    return transaction_;
}
const defineTransaction = /*#__PURE__*/ (0, _formatterJs.defineFormatter)('transaction', formatTransaction);
//////////////////////////////////////////////////////////////////////////////
function formatAuthorizationList(authorizationList) {
    return authorizationList.map((authorization)=>({
            address: authorization.address,
            chainId: Number(authorization.chainId),
            nonce: Number(authorization.nonce),
            r: authorization.r,
            s: authorization.s,
            yParity: Number(authorization.yParity)
        }));
}

},{"../encoding/fromHex.js":"kLfW5","./formatter.js":"itqtW","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i7Vx8":[function(require,module,exports,__globalThis) {
/**
 * Returns the current price of gas (in wei).
 *
 * - Docs: https://viem.sh/docs/actions/public/getGasPrice
 * - JSON-RPC Methods: [`eth_gasPrice`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gasprice)
 *
 * @param client - Client to use
 * @returns The gas price (in wei). {@link GetGasPriceReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getGasPrice } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const gasPrice = await getGasPrice(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getGasPrice", ()=>getGasPrice);
async function getGasPrice(client) {
    const gasPrice = await client.request({
        method: 'eth_gasPrice'
    });
    return BigInt(gasPrice);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7o2N6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the number of [Transactions](https://viem.sh/docs/glossary/terms#transaction) an Account has sent.
 *
 * - Docs: https://viem.sh/docs/actions/public/getTransactionCount
 * - JSON-RPC Methods: [`eth_getTransactionCount`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactioncount)
 *
 * @param client - Client to use
 * @param parameters - {@link GetTransactionCountParameters}
 * @returns The number of transactions an account has sent. {@link GetTransactionCountReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getTransactionCount } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const transactionCount = await getTransactionCount(client, {
 *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 */ parcelHelpers.export(exports, "getTransactionCount", ()=>getTransactionCount);
var _fromHexJs = require("../../utils/encoding/fromHex.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
async function getTransactionCount(client, { address, blockTag = 'latest', blockNumber }) {
    const count = await client.request({
        method: 'eth_getTransactionCount',
        params: [
            address,
            typeof blockNumber === 'bigint' ? (0, _toHexJs.numberToHex)(blockNumber) : blockTag
        ]
    }, {
        dedupe: Boolean(blockNumber)
    });
    return (0, _fromHexJs.hexToNumber)(count);
}

},{"../../utils/encoding/fromHex.js":"kLfW5","../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lGkWy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Compute commitments from a list of blobs.
 *
 * @example
 * ```ts
 * import { blobsToCommitments, toBlobs } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * ```
 */ parcelHelpers.export(exports, "blobsToCommitments", ()=>blobsToCommitments);
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
function blobsToCommitments(parameters) {
    const { kzg } = parameters;
    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
    const blobs = typeof parameters.blobs[0] === 'string' ? parameters.blobs.map((x)=>(0, _toBytesJs.hexToBytes)(x)) : parameters.blobs;
    const commitments = [];
    for (const blob of blobs)commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
    return to === 'bytes' ? commitments : commitments.map((x)=>(0, _toHexJs.bytesToHex)(x));
}

},{"../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"82xng":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Compute the proofs for a list of blobs and their commitments.
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   toBlobs
 * } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * const proofs = blobsToProofs({ blobs, commitments, kzg })
 * ```
 */ parcelHelpers.export(exports, "blobsToProofs", ()=>blobsToProofs);
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
function blobsToProofs(parameters) {
    const { kzg } = parameters;
    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
    const blobs = typeof parameters.blobs[0] === 'string' ? parameters.blobs.map((x)=>(0, _toBytesJs.hexToBytes)(x)) : parameters.blobs;
    const commitments = typeof parameters.commitments[0] === 'string' ? parameters.commitments.map((x)=>(0, _toBytesJs.hexToBytes)(x)) : parameters.commitments;
    const proofs = [];
    for(let i = 0; i < blobs.length; i++){
        const blob = blobs[i];
        const commitment = commitments[i];
        proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
    }
    return to === 'bytes' ? proofs : proofs.map((x)=>(0, _toHexJs.bytesToHex)(x));
}

},{"../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hAdbt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Transform a list of commitments to their versioned hashes.
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   commitmentsToVersionedHashes,
 *   toBlobs
 * } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * const versionedHashes = commitmentsToVersionedHashes({ commitments })
 * ```
 */ parcelHelpers.export(exports, "commitmentsToVersionedHashes", ()=>commitmentsToVersionedHashes);
var _commitmentToVersionedHashJs = require("./commitmentToVersionedHash.js");
function commitmentsToVersionedHashes(parameters) {
    const { commitments, version } = parameters;
    const to = parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes');
    const hashes = [];
    for (const commitment of commitments)hashes.push((0, _commitmentToVersionedHashJs.commitmentToVersionedHash)({
        commitment,
        to,
        version
    }));
    return hashes;
}

},{"./commitmentToVersionedHash.js":"cAPDC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cAPDC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Transform a commitment to it's versioned hash.
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   commitmentToVersionedHash,
 *   toBlobs
 * } from 'viem'
 * import { kzg } from './kzg'
 *
 * const blobs = toBlobs({ data: '0x1234' })
 * const [commitment] = blobsToCommitments({ blobs, kzg })
 * const versionedHash = commitmentToVersionedHash({ commitment })
 * ```
 */ parcelHelpers.export(exports, "commitmentToVersionedHash", ()=>commitmentToVersionedHash);
var _toHexJs = require("../encoding/toHex.js");
var _sha256Js = require("../hash/sha256.js");
function commitmentToVersionedHash(parameters) {
    const { commitment, version = 1 } = parameters;
    const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes');
    const versionedHash = (0, _sha256Js.sha256)(commitment, 'bytes');
    versionedHash.set([
        version
    ], 0);
    return to === 'bytes' ? versionedHash : (0, _toHexJs.bytesToHex)(versionedHash);
}

},{"../encoding/toHex.js":"9GFC6","../hash/sha256.js":"6D13u","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6D13u":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sha256", ()=>sha256);
var _sha256 = require("@noble/hashes/sha256");
var _isHexJs = require("../data/isHex.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
function sha256(value, to_) {
    const to = to_ || 'hex';
    const bytes = (0, _sha256.sha256)((0, _isHexJs.isHex)(value, {
        strict: false
    }) ? (0, _toBytesJs.toBytes)(value) : value);
    if (to === 'bytes') return bytes;
    return (0, _toHexJs.toHex)(bytes);
}

},{"@noble/hashes/sha256":"h9cuS","../data/isHex.js":"evOcm","../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h9cuS":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
/**
 * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.
 *
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 *
 * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 * @deprecated
 */ const sha2_ts_1 = require("b170fbbeecab08d7");
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA256 = sha2_ts_1.SHA256;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha256 = sha2_ts_1.sha256;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.SHA224 = sha2_ts_1.SHA224;
/** @deprecated Use import from `noble/hashes/sha2` module */ exports.sha224 = sha2_ts_1.sha224;

},{"b170fbbeecab08d7":"5Nc2s"}],"5Nc2s":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */ const _md_ts_1 = require("af0cede5cbbd2245");
const u64 = require("ae8242871b0e5f98");
const utils_ts_1 = require("6023160825f79395");
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */ // prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32){
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 64; i++){
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ W15 >>> 3;
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for(let i = 0; i < 64; i++){
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = sigma0 + (0, _md_ts_1.Maj)(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA256 = SHA256;
class SHA224 extends SHA256 {
    constructor(){
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
}
exports.SHA224 = SHA224;
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (()=>u64.split([
        '0x428a2f98d728ae22',
        '0x7137449123ef65cd',
        '0xb5c0fbcfec4d3b2f',
        '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538',
        '0x59f111f1b605d019',
        '0x923f82a4af194f9b',
        '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242',
        '0x12835b0145706fbe',
        '0x243185be4ee4b28c',
        '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f',
        '0x80deb1fe3b1696b1',
        '0x9bdc06a725c71235',
        '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2',
        '0xefbe4786384f25e3',
        '0x0fc19dc68b8cd5b5',
        '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275',
        '0x4a7484aa6ea6e483',
        '0x5cb0a9dcbd41fbd4',
        '0x76f988da831153b5',
        '0x983e5152ee66dfab',
        '0xa831c66d2db43210',
        '0xb00327c898fb213f',
        '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2',
        '0xd5a79147930aa725',
        '0x06ca6351e003826f',
        '0x142929670a0e6e70',
        '0x27b70a8546d22ffc',
        '0x2e1b21385c26c926',
        '0x4d2c6dfc5ac42aed',
        '0x53380d139d95b3df',
        '0x650a73548baf63de',
        '0x766a0abb3c77b2a8',
        '0x81c2c92e47edaee6',
        '0x92722c851482353b',
        '0xa2bfe8a14cf10364',
        '0xa81a664bbc423001',
        '0xc24b8b70d0f89791',
        '0xc76c51a30654be30',
        '0xd192e819d6ef5218',
        '0xd69906245565a910',
        '0xf40e35855771202a',
        '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8',
        '0x1e376c085141ab53',
        '0x2748774cdf8eeb99',
        '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63',
        '0x4ed8aa4ae3418acb',
        '0x5b9cca4f7763e373',
        '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc',
        '0x78a5636f43172f60',
        '0x84c87814a1f0ab72',
        '0x8cc702081a6439ec',
        '0x90befffa23631e28',
        '0xa4506cebde82bde9',
        '0xbef9a3f7b2c67915',
        '0xc67178f2e372532b',
        '0xca273eceea26619c',
        '0xd186b8c721c0c207',
        '0xeada7dd6cde0eb1e',
        '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba',
        '0x0a637dc5a2c898a6',
        '0x113f9804bef90dae',
        '0x1b710b35131c471b',
        '0x28db77f523047d84',
        '0x32caab7b40c72493',
        '0x3c9ebe0a15c9bebc',
        '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6',
        '0x597f299cfc657e2a',
        '0x5fcb6fab3ad6faec',
        '0x6c44198c4a475817'
    ].map((n)=>BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();
const SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64){
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4){
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for(let i = 16; i < 80; i++){
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for(let i = 0; i < 80; i++){
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA384 extends SHA512 {
    constructor(){
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
}
exports.SHA384 = SHA384;
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8,
    0x19544da2,
    0x73e19966,
    0x89dcd4d6,
    0x1dfab7ae,
    0x32ff9c82,
    0x679dd514,
    0x582f9fcf,
    0x0f6d2b69,
    0x7bd44da8,
    0x77e36f73,
    0x04c48942,
    0x3f9d85a8,
    0x6a1d36c8,
    0x1112e6ad,
    0x91d692a1
]);
/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194,
    0xfc2bf72c,
    0x9f555fa3,
    0xc84c64c2,
    0x2393b86b,
    0x6f53b151,
    0x96387719,
    0x5940eabd,
    0x96283ee2,
    0xa88effe3,
    0xbe5e1e25,
    0x53863992,
    0x2b0199fc,
    0x2c85b8aa,
    0x0eb72ddc,
    0x81c52ca2
]);
class SHA512_224 extends SHA512 {
    constructor(){
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor(){
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
exports.SHA512_256 = SHA512_256;
/**
 * SHA2-256 hash function from RFC 4634.
 *
 * It is the fastest JS hash, even faster than Blake3.
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 */ exports.sha256 = (0, utils_ts_1.createHasher)(()=>new SHA256());
/** SHA2-224 hash function from RFC 4634 */ exports.sha224 = (0, utils_ts_1.createHasher)(()=>new SHA224());
/** SHA2-512 hash function from RFC 4634. */ exports.sha512 = (0, utils_ts_1.createHasher)(()=>new SHA512());
/** SHA2-384 hash function from RFC 4634. */ exports.sha384 = (0, utils_ts_1.createHasher)(()=>new SHA384());
/**
 * SHA2-512/256 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */ exports.sha512_256 = (0, utils_ts_1.createHasher)(()=>new SHA512_256());
/**
 * SHA2-512/224 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */ exports.sha512_224 = (0, utils_ts_1.createHasher)(()=>new SHA512_224());

},{"af0cede5cbbd2245":"dkX9O","ae8242871b0e5f98":"gNDUI","6023160825f79395":"fuxLy"}],"dkX9O":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
exports.setBigUint64 = setBigUint64;
exports.Chi = Chi;
exports.Maj = Maj;
/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */ const utils_ts_1 = require("e667c0fa26fe74b7");
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */ function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */ function Chi(a, b, c) {
    return a & b ^ ~a & c;
}
/** Majority function, true if any two inputs is true. */ function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
}
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */ class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_ts_1.createView)(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 128;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.HashMD = HashMD;
/**
 * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
 * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
 */ /** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */ exports.SHA256_IV = Uint32Array.from([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */ exports.SHA224_IV = Uint32Array.from([
    0xc1059ed8,
    0x367cd507,
    0x3070dd17,
    0xf70e5939,
    0xffc00b31,
    0x68581511,
    0x64f98fa7,
    0xbefa4fa4
]);
/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */ exports.SHA384_IV = Uint32Array.from([
    0xcbbb9d5d,
    0xc1059ed8,
    0x629a292a,
    0x367cd507,
    0x9159015a,
    0x3070dd17,
    0x152fecd8,
    0xf70e5939,
    0x67332667,
    0xffc00b31,
    0x8eb44a87,
    0x68581511,
    0xdb0c2e0d,
    0x64f98fa7,
    0x47b5481d,
    0xbefa4fa4
]);
/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */ exports.SHA512_IV = Uint32Array.from([
    0x6a09e667,
    0xf3bcc908,
    0xbb67ae85,
    0x84caa73b,
    0x3c6ef372,
    0xfe94f82b,
    0xa54ff53a,
    0x5f1d36f1,
    0x510e527f,
    0xade682d1,
    0x9b05688c,
    0x2b3e6c1f,
    0x1f83d9ab,
    0xfb41bd6b,
    0x5be0cd19,
    0x137e2179
]);

},{"e667c0fa26fe74b7":"fuxLy"}],"iLFBZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Transforms arbitrary data (or blobs, commitments, & proofs) into a sidecar array.
 *
 * @example
 * ```ts
 * import { toBlobSidecars, stringToHex } from 'viem'
 *
 * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })
 * ```
 *
 * @example
 * ```ts
 * import {
 *   blobsToCommitments,
 *   toBlobs,
 *   blobsToProofs,
 *   toBlobSidecars,
 *   stringToHex
 * } from 'viem'
 *
 * const blobs = toBlobs({ data: stringToHex('hello world') })
 * const commitments = blobsToCommitments({ blobs, kzg })
 * const proofs = blobsToProofs({ blobs, commitments, kzg })
 *
 * const sidecars = toBlobSidecars({ blobs, commitments, proofs })
 * ```
 */ parcelHelpers.export(exports, "toBlobSidecars", ()=>toBlobSidecars);
var _blobsToCommitmentsJs = require("./blobsToCommitments.js");
var _blobsToProofsJs = require("./blobsToProofs.js");
var _toBlobsJs = require("./toBlobs.js");
function toBlobSidecars(parameters) {
    const { data, kzg, to } = parameters;
    const blobs = parameters.blobs ?? (0, _toBlobsJs.toBlobs)({
        data: data,
        to
    });
    const commitments = parameters.commitments ?? (0, _blobsToCommitmentsJs.blobsToCommitments)({
        blobs,
        kzg: kzg,
        to
    });
    const proofs = parameters.proofs ?? (0, _blobsToProofsJs.blobsToProofs)({
        blobs,
        commitments,
        kzg: kzg,
        to
    });
    const sidecars = [];
    for(let i = 0; i < blobs.length; i++)sidecars.push({
        blob: blobs[i],
        commitment: commitments[i],
        proof: proofs[i]
    });
    return sidecars;
}

},{"./blobsToCommitments.js":"lGkWy","./blobsToProofs.js":"82xng","./toBlobs.js":"f9lGV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f9lGV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Transforms arbitrary data to blobs.
 *
 * @example
 * ```ts
 * import { toBlobs, stringToHex } from 'viem'
 *
 * const blobs = toBlobs({ data: stringToHex('hello world') })
 * ```
 */ parcelHelpers.export(exports, "toBlobs", ()=>toBlobs);
var _blobJs = require("../../constants/blob.js");
var _blobJs1 = require("../../errors/blob.js");
var _cursorJs = require("../cursor.js");
var _sizeJs = require("../data/size.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
function toBlobs(parameters) {
    const to = parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes');
    const data = typeof parameters.data === 'string' ? (0, _toBytesJs.hexToBytes)(parameters.data) : parameters.data;
    const size_ = (0, _sizeJs.size)(data);
    if (!size_) throw new (0, _blobJs1.EmptyBlobError)();
    if (size_ > (0, _blobJs.maxBytesPerTransaction)) throw new (0, _blobJs1.BlobSizeTooLargeError)({
        maxSize: (0, _blobJs.maxBytesPerTransaction),
        size: size_
    });
    const blobs = [];
    let active = true;
    let position = 0;
    while(active){
        const blob = (0, _cursorJs.createCursor)(new Uint8Array((0, _blobJs.bytesPerBlob)));
        let size = 0;
        while(size < (0, _blobJs.fieldElementsPerBlob)){
            const bytes = data.slice(position, position + ((0, _blobJs.bytesPerFieldElement) - 1));
            // Push a zero byte so the field element doesn't overflow the BLS modulus.
            blob.pushByte(0x00);
            // Push the current segment of data bytes.
            blob.pushBytes(bytes);
            // If we detect that the current segment of data bytes is less than 31 bytes,
            // we can stop processing and push a terminator byte to indicate the end of the blob.
            if (bytes.length < 31) {
                blob.pushByte(0x80);
                active = false;
                break;
            }
            size++;
            position += 31;
        }
        blobs.push(blob);
    }
    return to === 'bytes' ? blobs.map((x)=>x.bytes) : blobs.map((x)=>(0, _toHexJs.bytesToHex)(x.bytes));
}

},{"../../constants/blob.js":"1JDzI","../../errors/blob.js":"76hB9","../cursor.js":"pWJ3P","../data/size.js":"exELm","../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1JDzI":[function(require,module,exports,__globalThis) {
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters
/** Blob limit per transaction. */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bytesPerFieldElement", ()=>bytesPerFieldElement);
parcelHelpers.export(exports, "fieldElementsPerBlob", ()=>fieldElementsPerBlob);
parcelHelpers.export(exports, "bytesPerBlob", ()=>bytesPerBlob);
parcelHelpers.export(exports, "maxBytesPerTransaction", ()=>maxBytesPerTransaction);
const blobsPerTransaction = 6;
const bytesPerFieldElement = 32;
const fieldElementsPerBlob = 4096;
const bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
const maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"76hB9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BlobSizeTooLargeError", ()=>BlobSizeTooLargeError);
parcelHelpers.export(exports, "EmptyBlobError", ()=>EmptyBlobError);
parcelHelpers.export(exports, "InvalidVersionedHashSizeError", ()=>InvalidVersionedHashSizeError);
parcelHelpers.export(exports, "InvalidVersionedHashVersionError", ()=>InvalidVersionedHashVersionError);
var _kzgJs = require("../constants/kzg.js");
var _baseJs = require("./base.js");
class BlobSizeTooLargeError extends (0, _baseJs.BaseError) {
    constructor({ maxSize, size }){
        super('Blob size is too large.', {
            metaMessages: [
                `Max: ${maxSize} bytes`,
                `Given: ${size} bytes`
            ],
            name: 'BlobSizeTooLargeError'
        });
    }
}
class EmptyBlobError extends (0, _baseJs.BaseError) {
    constructor(){
        super('Blob data must not be empty.', {
            name: 'EmptyBlobError'
        });
    }
}
class InvalidVersionedHashSizeError extends (0, _baseJs.BaseError) {
    constructor({ hash, size }){
        super(`Versioned hash "${hash}" size is invalid.`, {
            metaMessages: [
                'Expected: 32',
                `Received: ${size}`
            ],
            name: 'InvalidVersionedHashSizeError'
        });
    }
}
class InvalidVersionedHashVersionError extends (0, _baseJs.BaseError) {
    constructor({ hash, version }){
        super(`Versioned hash "${hash}" version is invalid.`, {
            metaMessages: [
                `Expected: ${(0, _kzgJs.versionedHashVersionKzg)}`,
                `Received: ${version}`
            ],
            name: 'InvalidVersionedHashVersionError'
        });
    }
}

},{"../constants/kzg.js":"6LtNd","./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6LtNd":[function(require,module,exports,__globalThis) {
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-4844.md#parameters
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "versionedHashVersionKzg", ()=>versionedHashVersionKzg);
const versionedHashVersionKzg = 1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2MIAC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getTransactionType", ()=>getTransactionType);
var _transactionJs = require("../../errors/transaction.js");
function getTransactionType(transaction) {
    if (transaction.type) return transaction.type;
    if (typeof transaction.authorizationList !== 'undefined') return 'eip7702';
    if (typeof transaction.blobs !== 'undefined' || typeof transaction.blobVersionedHashes !== 'undefined' || typeof transaction.maxFeePerBlobGas !== 'undefined' || typeof transaction.sidecars !== 'undefined') return 'eip4844';
    if (typeof transaction.maxFeePerGas !== 'undefined' || typeof transaction.maxPriorityFeePerGas !== 'undefined') return 'eip1559';
    if (typeof transaction.gasPrice !== 'undefined') {
        if (typeof transaction.accessList !== 'undefined') return 'eip2930';
        return 'legacy';
    }
    throw new (0, _transactionJs.InvalidSerializableTransactionError)({
        transaction
    });
}

},{"../../errors/transaction.js":"4gFzr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lXOca":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the chain ID associated with the current network.
 *
 * - Docs: https://viem.sh/docs/actions/public/getChainId
 * - JSON-RPC Methods: [`eth_chainId`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_chainid)
 *
 * @param client - Client to use
 * @returns The current chain ID. {@link GetChainIdReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getChainId } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const chainId = await getChainId(client)
 * // 1
 */ parcelHelpers.export(exports, "getChainId", ()=>getChainId);
var _fromHexJs = require("../../utils/encoding/fromHex.js");
async function getChainId(client) {
    const chainIdHex = await client.request({
        method: 'eth_chainId'
    }, {
        dedupe: true
    });
    return (0, _fromHexJs.hexToNumber)(chainIdHex);
}

},{"../../utils/encoding/fromHex.js":"kLfW5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1bzUH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the balance of an address in wei.
 *
 * - Docs: https://viem.sh/docs/actions/public/getBalance
 * - JSON-RPC Methods: [`eth_getBalance`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getbalance)
 *
 * You can convert the balance to ether units with [`formatEther`](https://viem.sh/docs/utilities/formatEther).
 *
 * ```ts
 * const balance = await getBalance(client, {
 *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   blockTag: 'safe'
 * })
 * const balanceAsEther = formatEther(balance)
 * // "6.942"
 * ```
 *
 * @param client - Client to use
 * @param parameters - {@link GetBalanceParameters}
 * @returns The balance of the address in wei. {@link GetBalanceReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBalance } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const balance = await getBalance(client, {
 *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 * // 10000000000000000000000n (wei)
 */ parcelHelpers.export(exports, "getBalance", ()=>getBalance);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function getBalance(client, { address, blockNumber, blockTag = 'latest' }) {
    const blockNumberHex = typeof blockNumber === 'bigint' ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    const balance = await client.request({
        method: 'eth_getBalance',
        params: [
            address,
            blockNumberHex || blockTag
        ]
    });
    return BigInt(balance);
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8aoKV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of event logs emitted by a contract.
 *
 * - Docs: https://viem.sh/docs/contract/getContractEvents#getcontractevents
 * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)
 *
 * @param client - Client to use
 * @param parameters - {@link GetContractEventsParameters}
 * @returns A list of event logs. {@link GetContractEventsReturnType}
 *
 * @example
 * import { createClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getContractEvents } from 'viem/public'
 * import { wagmiAbi } from './abi'
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const logs = await getContractEvents(client, {
 *  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *  abi: wagmiAbi,
 *  eventName: 'Transfer'
 * })
 */ parcelHelpers.export(exports, "getContractEvents", ()=>getContractEvents);
var _getAbiItemJs = require("../../utils/abi/getAbiItem.js");
var _getActionJs = require("../../utils/getAction.js");
var _getLogsJs = require("./getLogs.js");
async function getContractEvents(client, parameters) {
    const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
    const event = eventName ? (0, _getAbiItemJs.getAbiItem)({
        abi,
        name: eventName
    }) : undefined;
    const events = !event ? abi.filter((x)=>x.type === 'event') : undefined;
    return (0, _getActionJs.getAction)(client, (0, _getLogsJs.getLogs), 'getLogs')({
        address,
        args,
        blockHash,
        event,
        events,
        fromBlock,
        toBlock,
        strict
    });
}

},{"../../utils/abi/getAbiItem.js":"k6BVB","../../utils/getAction.js":"d1Bvd","./getLogs.js":"245SH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"245SH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of event logs matching the provided parameters.
 *
 * - Docs: https://viem.sh/docs/actions/public/getLogs
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/logs_event-logs
 * - JSON-RPC Methods: [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs)
 *
 * @param client - Client to use
 * @param parameters - {@link GetLogsParameters}
 * @returns A list of event logs. {@link GetLogsReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbiItem } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getLogs } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const logs = await getLogs(client)
 */ parcelHelpers.export(exports, "getLogs", ()=>getLogs);
var _encodeEventTopicsJs = require("../../utils/abi/encodeEventTopics.js");
var _parseEventLogsJs = require("../../utils/abi/parseEventLogs.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _logJs = require("../../utils/formatters/log.js");
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
    const strict = strict_ ?? false;
    const events = events_ ?? (event ? [
        event
    ] : undefined);
    let topics = [];
    if (events) {
        const encoded = events.flatMap((event)=>(0, _encodeEventTopicsJs.encodeEventTopics)({
                abi: [
                    event
                ],
                eventName: event.name,
                args: events_ ? undefined : args
            }));
        // TODO: Clean up type casting
        topics = [
            encoded
        ];
        if (event) topics = topics[0];
    }
    let logs;
    if (blockHash) logs = await client.request({
        method: 'eth_getLogs',
        params: [
            {
                address,
                topics,
                blockHash
            }
        ]
    });
    else logs = await client.request({
        method: 'eth_getLogs',
        params: [
            {
                address,
                topics,
                fromBlock: typeof fromBlock === 'bigint' ? (0, _toHexJs.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === 'bigint' ? (0, _toHexJs.numberToHex)(toBlock) : toBlock
            }
        ]
    });
    const formattedLogs = logs.map((log)=>(0, _logJs.formatLog)(log));
    if (!events) return formattedLogs;
    return (0, _parseEventLogsJs.parseEventLogs)({
        abi: events,
        args: args,
        logs: formattedLogs,
        strict
    });
}

},{"../../utils/abi/encodeEventTopics.js":"7zHy3","../../utils/abi/parseEventLogs.js":"3coRk","../../utils/encoding/toHex.js":"9GFC6","../../utils/formatters/log.js":"aaYKq","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3coRk":[function(require,module,exports,__globalThis) {
// TODO(v3): checksum address.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Extracts & decodes logs matching the provided signature(s) (`abi` + optional `eventName`)
 * from a set of opaque logs.
 *
 * @param parameters - {@link ParseEventLogsParameters}
 * @returns The logs. {@link ParseEventLogsReturnType}
 *
 * @example
 * import { createClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { parseEventLogs } from 'viem/op-stack'
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 *
 * const receipt = await getTransactionReceipt(client, {
 *   hash: '0xec23b2ba4bc59ba61554507c1b1bc91649e6586eb2dd00c728e8ed0db8bb37ea',
 * })
 *
 * const logs = parseEventLogs({ logs: receipt.logs })
 * // [{ args: { ... }, eventName: 'TransactionDeposited', ... }, ...]
 */ parcelHelpers.export(exports, "parseEventLogs", ()=>parseEventLogs);
var _abiJs = require("../../errors/abi.js");
var _isAddressEqualJs = require("../address/isAddressEqual.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _keccak256Js = require("../hash/keccak256.js");
var _toEventSelectorJs = require("../hash/toEventSelector.js");
var _decodeEventLogJs = require("./decodeEventLog.js");
function parseEventLogs(parameters) {
    const { abi, args, logs, strict = true } = parameters;
    const eventName = (()=>{
        if (!parameters.eventName) return undefined;
        if (Array.isArray(parameters.eventName)) return parameters.eventName;
        return [
            parameters.eventName
        ];
    })();
    return logs.map((log)=>{
        try {
            const abiItem = abi.find((abiItem)=>abiItem.type === 'event' && log.topics[0] === (0, _toEventSelectorJs.toEventSelector)(abiItem));
            if (!abiItem) return null;
            const event = (0, _decodeEventLogJs.decodeEventLog)({
                ...log,
                abi: [
                    abiItem
                ],
                strict
            });
            // Check that the decoded event name matches the provided event name.
            if (eventName && !eventName.includes(event.eventName)) return null;
            // Check that the decoded event args match the provided args.
            if (!includesArgs({
                args: event.args,
                inputs: abiItem.inputs,
                matchArgs: args
            })) return null;
            return {
                ...event,
                ...log
            };
        } catch (err) {
            let eventName;
            let isUnnamed;
            if (err instanceof (0, _abiJs.AbiEventSignatureNotFoundError)) return null;
            if (err instanceof (0, _abiJs.DecodeLogDataMismatch) || err instanceof (0, _abiJs.DecodeLogTopicsMismatch)) {
                // If strict mode is on, and log data/topics do not match event definition, skip.
                if (strict) return null;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x)=>!('name' in x && x.name));
            }
            // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).
            return {
                ...log,
                args: isUnnamed ? [] : {},
                eventName
            };
        }
    }).filter(Boolean);
}
function includesArgs(parameters) {
    const { args, inputs, matchArgs } = parameters;
    if (!matchArgs) return true;
    if (!args) return false;
    function isEqual(input, value, arg) {
        try {
            if (input.type === 'address') return (0, _isAddressEqualJs.isAddressEqual)(value, arg);
            if (input.type === 'string' || input.type === 'bytes') return (0, _keccak256Js.keccak256)((0, _toBytesJs.toBytes)(value)) === arg;
            return value === arg;
        } catch  {
            return false;
        }
    }
    if (Array.isArray(args) && Array.isArray(matchArgs)) return matchArgs.every((value, index)=>{
        if (value === null || value === undefined) return true;
        const input = inputs[index];
        if (!input) return false;
        const value_ = Array.isArray(value) ? value : [
            value
        ];
        return value_.some((value)=>isEqual(input, value, args[index]));
    });
    if (typeof args === 'object' && !Array.isArray(args) && typeof matchArgs === 'object' && !Array.isArray(matchArgs)) return Object.entries(matchArgs).every(([key, value])=>{
        if (value === null || value === undefined) return true;
        const input = inputs.find((input)=>input.name === key);
        if (!input) return false;
        const value_ = Array.isArray(value) ? value : [
            value
        ];
        return value_.some((value)=>isEqual(input, value, args[key]));
    });
    return false;
}

},{"../../errors/abi.js":"7l8j7","../address/isAddressEqual.js":"lW8Gp","../encoding/toBytes.js":"8cx1T","../hash/keccak256.js":"k4CmV","../hash/toEventSelector.js":"4FcAp","./decodeEventLog.js":"8uUoF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lW8Gp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isAddressEqual", ()=>isAddressEqual);
var _addressJs = require("../../errors/address.js");
var _isAddressJs = require("./isAddress.js");
function isAddressEqual(a, b) {
    if (!(0, _isAddressJs.isAddress)(a, {
        strict: false
    })) throw new (0, _addressJs.InvalidAddressError)({
        address: a
    });
    if (!(0, _isAddressJs.isAddress)(b, {
        strict: false
    })) throw new (0, _addressJs.InvalidAddressError)({
        address: b
    });
    return a.toLowerCase() === b.toLowerCase();
}

},{"../../errors/address.js":"17VWr","./isAddress.js":"kdAuv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8uUoF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeEventLog", ()=>decodeEventLog);
var _abiJs = require("../../errors/abi.js");
var _sizeJs = require("../data/size.js");
var _toEventSelectorJs = require("../hash/toEventSelector.js");
var _cursorJs = require("../../errors/cursor.js");
var _decodeAbiParametersJs = require("./decodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
const docsPath = '/docs/contract/decodeEventLog';
function decodeEventLog(parameters) {
    const { abi, data, strict: strict_, topics } = parameters;
    const strict = strict_ ?? true;
    const [signature, ...argTopics] = topics;
    if (!signature) throw new (0, _abiJs.AbiEventSignatureEmptyTopicsError)({
        docsPath
    });
    const abiItem = (()=>{
        if (abi.length === 1) return abi[0];
        return abi.find((x)=>x.type === 'event' && signature === (0, _toEventSelectorJs.toEventSelector)((0, _formatAbiItemJs.formatAbiItem)(x)));
    })();
    if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event') throw new (0, _abiJs.AbiEventSignatureNotFoundError)(signature, {
        docsPath
    });
    const { name, inputs } = abiItem;
    const isUnnamed = inputs?.some((x)=>!('name' in x && x.name));
    let args = isUnnamed ? [] : {};
    // Decode topics (indexed args).
    const indexedInputs = inputs.filter((x)=>'indexed' in x && x.indexed);
    for(let i = 0; i < indexedInputs.length; i++){
        const param = indexedInputs[i];
        const topic = argTopics[i];
        if (!topic) throw new (0, _abiJs.DecodeLogTopicsMismatch)({
            abiItem,
            param: param
        });
        args[isUnnamed ? i : param.name || i] = decodeTopic({
            param,
            value: topic
        });
    }
    // Decode data (non-indexed args).
    const nonIndexedInputs = inputs.filter((x)=>!('indexed' in x && x.indexed));
    if (nonIndexedInputs.length > 0) {
        if (data && data !== '0x') try {
            const decodedData = (0, _decodeAbiParametersJs.decodeAbiParameters)(nonIndexedInputs, data);
            if (decodedData) {
                if (isUnnamed) args = [
                    ...args,
                    ...decodedData
                ];
                else for(let i = 0; i < nonIndexedInputs.length; i++)args[nonIndexedInputs[i].name] = decodedData[i];
            }
        } catch (err) {
            if (strict) {
                if (err instanceof (0, _abiJs.AbiDecodingDataSizeTooSmallError) || err instanceof (0, _cursorJs.PositionOutOfBoundsError)) throw new (0, _abiJs.DecodeLogDataMismatch)({
                    abiItem,
                    data: data,
                    params: nonIndexedInputs,
                    size: (0, _sizeJs.size)(data)
                });
                throw err;
            }
        }
        else if (strict) throw new (0, _abiJs.DecodeLogDataMismatch)({
            abiItem,
            data: '0x',
            params: nonIndexedInputs,
            size: 0
        });
    }
    return {
        eventName: name,
        args: Object.values(args).length > 0 ? args : undefined
    };
}
function decodeTopic({ param, value }) {
    if (param.type === 'string' || param.type === 'bytes' || param.type === 'tuple' || param.type.match(/^(.*)\[(\d+)?\]$/)) return value;
    const decodedArg = (0, _decodeAbiParametersJs.decodeAbiParameters)([
        param
    ], value) || [];
    return decodedArg[0];
}

},{"../../errors/abi.js":"7l8j7","../data/size.js":"exELm","../hash/toEventSelector.js":"4FcAp","../../errors/cursor.js":"3ZOkN","./decodeAbiParameters.js":"hR5FN","./formatAbiItem.js":"khxDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aaYKq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatLog", ()=>formatLog);
function formatLog(log, { args, eventName } = {}) {
    return {
        ...log,
        blockHash: log.blockHash ? log.blockHash : null,
        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
        logIndex: log.logIndex ? Number(log.logIndex) : null,
        transactionHash: log.transactionHash ? log.transactionHash : null,
        transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
        ...eventName ? {
            args,
            eventName
        } : {}
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fusIl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calls a read-only function on a contract, and returns the response.
 *
 * - Docs: https://viem.sh/docs/contract/readContract
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_reading-contracts
 *
 * A "read-only" function (constant function) on a Solidity contract is denoted by a `view` or `pure` keyword. They can only read the state of the contract, and cannot make any changes to it. Since read-only methods do not change the state of the contract, they do not require any gas to be executed, and can be called by any user without the need to pay for gas.
 *
 * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
 *
 * @param client - Client to use
 * @param parameters - {@link ReadContractParameters}
 * @returns The response from the contract. Type is inferred. {@link ReadContractReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { readContract } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const result = await readContract(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function balanceOf(address) view returns (uint256)']),
 *   functionName: 'balanceOf',
 *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
 * })
 * // 424122n
 */ parcelHelpers.export(exports, "readContract", ()=>readContract);
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getContractErrorJs = require("../../utils/errors/getContractError.js");
var _getActionJs = require("../../utils/getAction.js");
var _callJs = require("./call.js");
async function readContract(client, parameters) {
    const { abi, address, args, functionName, ...rest } = parameters;
    const calldata = (0, _encodeFunctionDataJs.encodeFunctionData)({
        abi,
        args,
        functionName
    });
    try {
        const { data } = await (0, _getActionJs.getAction)(client, (0, _callJs.call), 'call')({
            ...rest,
            data: calldata,
            to: address
        });
        return (0, _decodeFunctionResultJs.decodeFunctionResult)({
            abi,
            args,
            functionName,
            data: data || '0x'
        });
    } catch (error) {
        throw (0, _getContractErrorJs.getContractError)(error, {
            abi,
            address,
            args,
            docsPath: '/docs/contract/readContract',
            functionName
        });
    }
}

},{"../../utils/abi/decodeFunctionResult.js":"j76hM","../../utils/abi/encodeFunctionData.js":"eQLEb","../../utils/errors/getContractError.js":"kESZV","../../utils/getAction.js":"d1Bvd","./call.js":"85xZD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j76hM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeFunctionResult", ()=>decodeFunctionResult);
var _abiJs = require("../../errors/abi.js");
var _decodeAbiParametersJs = require("./decodeAbiParameters.js");
var _getAbiItemJs = require("./getAbiItem.js");
const docsPath = '/docs/contract/decodeFunctionResult';
function decodeFunctionResult(parameters) {
    const { abi, args, functionName, data } = parameters;
    let abiItem = abi[0];
    if (functionName) {
        const item = (0, _getAbiItemJs.getAbiItem)({
            abi,
            args,
            name: functionName
        });
        if (!item) throw new (0, _abiJs.AbiFunctionNotFoundError)(functionName, {
            docsPath
        });
        abiItem = item;
    }
    if (abiItem.type !== 'function') throw new (0, _abiJs.AbiFunctionNotFoundError)(undefined, {
        docsPath
    });
    if (!abiItem.outputs) throw new (0, _abiJs.AbiFunctionOutputsNotFoundError)(abiItem.name, {
        docsPath
    });
    const values = (0, _decodeAbiParametersJs.decodeAbiParameters)(abiItem.outputs, data);
    if (values && values.length > 1) return values;
    if (values && values.length === 1) return values[0];
    return undefined;
}

},{"../../errors/abi.js":"7l8j7","./decodeAbiParameters.js":"hR5FN","./getAbiItem.js":"k6BVB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"85xZD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Executes a new message call immediately without submitting a transaction to the network.
 *
 * - Docs: https://viem.sh/docs/actions/public/call
 * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)
 *
 * @param client - Client to use
 * @param parameters - {@link CallParameters}
 * @returns The call data. {@link CallReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { call } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const data = await call(client, {
 *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
 *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 * })
 */ parcelHelpers.export(exports, "call", ()=>call);
/** @internal */ parcelHelpers.export(exports, "getRevertErrorData", ()=>getRevertErrorData);
var _abitype = require("abitype");
var _blockOverrides = require("ox/BlockOverrides");
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _abisJs = require("../../constants/abis.js");
var _contractJs = require("../../constants/contract.js");
var _contractsJs = require("../../constants/contracts.js");
var _baseJs = require("../../errors/base.js");
var _chainJs = require("../../errors/chain.js");
var _contractJs1 = require("../../errors/contract.js");
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeDeployDataJs = require("../../utils/abi/encodeDeployData.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getChainContractAddressJs = require("../../utils/chain/getChainContractAddress.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _getCallErrorJs = require("../../utils/errors/getCallError.js");
var _extractJs = require("../../utils/formatters/extract.js");
var _transactionRequestJs = require("../../utils/formatters/transactionRequest.js");
var _createBatchSchedulerJs = require("../../utils/promise/createBatchScheduler.js");
var _stateOverrideJs = require("../../utils/stateOverride.js");
var _assertRequestJs = require("../../utils/transaction/assertRequest.js");
async function call(client, args) {
    const { account: account_ = client.account, authorizationList, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = 'pending', accessList, blobs, blockOverrides, code, data: data_, factory, factoryData, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
    const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : undefined;
    if (code && (factory || factoryData)) throw new (0, _baseJs.BaseError)('Cannot provide both `code` & `factory`/`factoryData` as parameters.');
    if (code && to) throw new (0, _baseJs.BaseError)('Cannot provide both `code` & `to` as parameters.');
    // Check if the call is deployless via bytecode.
    const deploylessCallViaBytecode = code && data_;
    // Check if the call is deployless via a factory.
    const deploylessCallViaFactory = factory && factoryData && to && data_;
    const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;
    const data = (()=>{
        if (deploylessCallViaBytecode) return toDeploylessCallViaBytecodeData({
            code,
            data: data_
        });
        if (deploylessCallViaFactory) return toDeploylessCallViaFactoryData({
            data: data_,
            factory,
            factoryData,
            to
        });
        return data_;
    })();
    try {
        (0, _assertRequestJs.assertRequest)(args);
        const blockNumberHex = typeof blockNumber === 'bigint' ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const rpcBlockOverrides = blockOverrides ? _blockOverrides.toRpc(blockOverrides) : undefined;
        const rpcStateOverride = (0, _stateOverrideJs.serializeStateOverride)(stateOverride);
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || (0, _transactionRequestJs.formatTransactionRequest);
        const request = format({
            // Pick out extra data that might exist on the chain's transaction request type.
            ...(0, _extractJs.extract)(rest, {
                format: chainFormat
            }),
            from: account?.address,
            accessList,
            authorizationList,
            blobs,
            data,
            gas,
            gasPrice,
            maxFeePerBlobGas,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to: deploylessCall ? undefined : to,
            value
        });
        if (batch && shouldPerformMulticall({
            request
        }) && !rpcStateOverride && !rpcBlockOverrides) try {
            return await scheduleMulticall(client, {
                ...request,
                blockNumber,
                blockTag
            });
        } catch (err) {
            if (!(err instanceof (0, _chainJs.ClientChainNotConfiguredError)) && !(err instanceof (0, _chainJs.ChainDoesNotSupportContract))) throw err;
        }
        const params = (()=>{
            const base = [
                request,
                block
            ];
            if (rpcStateOverride && rpcBlockOverrides) return [
                ...base,
                rpcStateOverride,
                rpcBlockOverrides
            ];
            if (rpcStateOverride) return [
                ...base,
                rpcStateOverride
            ];
            if (rpcBlockOverrides) return [
                ...base,
                {},
                rpcBlockOverrides
            ];
            return base;
        })();
        const response = await client.request({
            method: 'eth_call',
            params
        });
        if (response === '0x') return {
            data: undefined
        };
        return {
            data: response
        };
    } catch (err) {
        const data = getRevertErrorData(err);
        // Check for CCIP-Read offchain lookup signature.
        const { offchainLookup, offchainLookupSignature } = await require("4ee58dd6de3b4d58");
        if (client.ccipRead !== false && data?.slice(0, 10) === offchainLookupSignature && to) return {
            data: await offchainLookup(client, {
                data,
                to
            })
        };
        // Check for counterfactual deployment error.
        if (deploylessCall && data?.slice(0, 10) === '0x101bb98d') throw new (0, _contractJs1.CounterfactualDeploymentFailedError)({
            factory
        });
        throw (0, _getCallErrorJs.getCallError)(err, {
            ...args,
            account,
            chain: client.chain
        });
    }
}
// We only want to perform a scheduled multicall if:
// - The request has calldata,
// - The request has a target address,
// - The target address is not already the aggregate3 signature,
// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).
function shouldPerformMulticall({ request }) {
    const { data, to, ...request_ } = request;
    if (!data) return false;
    if (data.startsWith((0, _contractJs.aggregate3Signature))) return false;
    if (!to) return false;
    if (Object.values(request_).filter((x)=>typeof x !== 'undefined').length > 0) return false;
    return true;
}
async function scheduleMulticall(client, args) {
    const { batchSize = 1024, wait = 0 } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {};
    const { blockNumber, blockTag = 'pending', data, multicallAddress: multicallAddress_, to } = args;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
        if (!client.chain) throw new (0, _chainJs.ClientChainNotConfiguredError)();
        multicallAddress = (0, _getChainContractAddressJs.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: 'multicall3'
        });
    }
    const blockNumberHex = typeof blockNumber === 'bigint' ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const { schedule } = (0, _createBatchSchedulerJs.createBatchScheduler)({
        id: `${client.uid}.${block}`,
        wait,
        shouldSplitBatch (args) {
            const size = args.reduce((size, { data })=>size + (data.length - 2), 0);
            return size > batchSize * 2;
        },
        fn: async (requests)=>{
            const calls = requests.map((request)=>({
                    allowFailure: true,
                    callData: request.data,
                    target: request.to
                }));
            const calldata = (0, _encodeFunctionDataJs.encodeFunctionData)({
                abi: (0, _abisJs.multicall3Abi),
                args: [
                    calls
                ],
                functionName: 'aggregate3'
            });
            const data = await client.request({
                method: 'eth_call',
                params: [
                    {
                        data: calldata,
                        to: multicallAddress
                    },
                    block
                ]
            });
            return (0, _decodeFunctionResultJs.decodeFunctionResult)({
                abi: (0, _abisJs.multicall3Abi),
                args: [
                    calls
                ],
                functionName: 'aggregate3',
                data: data || '0x'
            });
        }
    });
    const [{ returnData, success }] = await schedule({
        data,
        to
    });
    if (!success) throw new (0, _contractJs1.RawContractError)({
        data: returnData
    });
    if (returnData === '0x') return {
        data: undefined
    };
    return {
        data: returnData
    };
}
function toDeploylessCallViaBytecodeData(parameters) {
    const { code, data } = parameters;
    return (0, _encodeDeployDataJs.encodeDeployData)({
        abi: (0, _abitype.parseAbi)([
            'constructor(bytes, bytes)'
        ]),
        bytecode: (0, _contractsJs.deploylessCallViaBytecodeBytecode),
        args: [
            code,
            data
        ]
    });
}
function toDeploylessCallViaFactoryData(parameters) {
    const { data, factory, factoryData, to } = parameters;
    return (0, _encodeDeployDataJs.encodeDeployData)({
        abi: (0, _abitype.parseAbi)([
            'constructor(address, bytes, address, bytes)'
        ]),
        bytecode: (0, _contractsJs.deploylessCallViaFactoryBytecode),
        args: [
            to,
            data,
            factory,
            factoryData
        ]
    });
}
function getRevertErrorData(err) {
    if (!(err instanceof (0, _baseJs.BaseError))) return undefined;
    const error = err.walk();
    return typeof error?.data === 'object' ? error.data?.data : error.data;
}

},{"abitype":"6tgJn","ox/BlockOverrides":"3pha1","../../accounts/utils/parseAccount.js":"lGQkg","../../constants/abis.js":"ffwQK","../../constants/contract.js":"89z4d","../../constants/contracts.js":"3uCwC","../../errors/base.js":"3SEPF","../../errors/chain.js":"hiOFa","../../errors/contract.js":"1S92K","../../utils/abi/decodeFunctionResult.js":"j76hM","../../utils/abi/encodeDeployData.js":"55weO","../../utils/abi/encodeFunctionData.js":"eQLEb","../../utils/chain/getChainContractAddress.js":"cNh6w","../../utils/encoding/toHex.js":"9GFC6","../../utils/errors/getCallError.js":"14DML","../../utils/formatters/extract.js":"g9KS8","../../utils/formatters/transactionRequest.js":"dLljr","../../utils/promise/createBatchScheduler.js":"cXEx4","../../utils/stateOverride.js":"zqcJp","../../utils/transaction/assertRequest.js":"eSiKr","4ee58dd6de3b4d58":"8jhUy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3pha1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts an {@link ox#BlockOverrides.Rpc} to an {@link ox#BlockOverrides.BlockOverrides}.
 *
 * @example
 * ```ts twoslash
 * import { BlockOverrides } from 'ox'
 *
 * const blockOverrides = BlockOverrides.fromRpc({
 *   baseFeePerGas: '0x1',
 *   blobBaseFee: '0x2',
 *   feeRecipient: '0x0000000000000000000000000000000000000000',
 *   gasLimit: '0x4',
 *   number: '0x5',
 *   prevRandao: '0x6',
 *   time: '0x1234567890',
 *   withdrawals: [
 *     {
 *       address: '0x0000000000000000000000000000000000000000',
 *       amount: '0x1',
 *       index: '0x0',
 *       validatorIndex: '0x1',
 *     },
 *   ],
 * })
 * ```
 *
 * @param rpcBlockOverrides - The RPC block overrides to convert.
 * @returns An instantiated {@link ox#BlockOverrides.BlockOverrides}.
 */ parcelHelpers.export(exports, "fromRpc", ()=>fromRpc);
/**
 * Converts an {@link ox#BlockOverrides.BlockOverrides} to an {@link ox#BlockOverrides.Rpc}.
 *
 * @example
 * ```ts twoslash
 * import { BlockOverrides } from 'ox'
 *
 * const blockOverrides = BlockOverrides.toRpc({
 *   baseFeePerGas: 1n,
 *   blobBaseFee: 2n,
 *   feeRecipient: '0x0000000000000000000000000000000000000000',
 *   gasLimit: 4n,
 *   number: 5n,
 *   prevRandao: 6n,
 *   time: 78187493520n,
 *   withdrawals: [
 *     {
 *       address: '0x0000000000000000000000000000000000000000',
 *       amount: 1n,
 *       index: 0,
 *       validatorIndex: 1,
 *     },
 *   ],
 * })
 * ```
 *
 * @param blockOverrides - The block overrides to convert.
 * @returns An instantiated {@link ox#BlockOverrides.Rpc}.
 */ parcelHelpers.export(exports, "toRpc", ()=>toRpc);
var _hexJs = require("./Hex.js");
var _withdrawalJs = require("./Withdrawal.js");
function fromRpc(rpcBlockOverrides) {
    return {
        ...rpcBlockOverrides.baseFeePerGas && {
            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas)
        },
        ...rpcBlockOverrides.blobBaseFee && {
            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee)
        },
        ...rpcBlockOverrides.feeRecipient && {
            feeRecipient: rpcBlockOverrides.feeRecipient
        },
        ...rpcBlockOverrides.gasLimit && {
            gasLimit: BigInt(rpcBlockOverrides.gasLimit)
        },
        ...rpcBlockOverrides.number && {
            number: BigInt(rpcBlockOverrides.number)
        },
        ...rpcBlockOverrides.prevRandao && {
            prevRandao: BigInt(rpcBlockOverrides.prevRandao)
        },
        ...rpcBlockOverrides.time && {
            time: BigInt(rpcBlockOverrides.time)
        },
        ...rpcBlockOverrides.withdrawals && {
            withdrawals: rpcBlockOverrides.withdrawals.map(_withdrawalJs.fromRpc)
        }
    };
}
function toRpc(blockOverrides) {
    return {
        ...typeof blockOverrides.baseFeePerGas === 'bigint' && {
            baseFeePerGas: _hexJs.fromNumber(blockOverrides.baseFeePerGas)
        },
        ...typeof blockOverrides.blobBaseFee === 'bigint' && {
            blobBaseFee: _hexJs.fromNumber(blockOverrides.blobBaseFee)
        },
        ...typeof blockOverrides.feeRecipient === 'string' && {
            feeRecipient: blockOverrides.feeRecipient
        },
        ...typeof blockOverrides.gasLimit === 'bigint' && {
            gasLimit: _hexJs.fromNumber(blockOverrides.gasLimit)
        },
        ...typeof blockOverrides.number === 'bigint' && {
            number: _hexJs.fromNumber(blockOverrides.number)
        },
        ...typeof blockOverrides.prevRandao === 'bigint' && {
            prevRandao: _hexJs.fromNumber(blockOverrides.prevRandao)
        },
        ...typeof blockOverrides.time === 'bigint' && {
            time: _hexJs.fromNumber(blockOverrides.time)
        },
        ...blockOverrides.withdrawals && {
            withdrawals: blockOverrides.withdrawals.map(_withdrawalJs.toRpc)
        }
    };
}

},{"./Hex.js":"bkNyt","./Withdrawal.js":"jdl0M","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bkNyt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Asserts if the given value is {@link ox#Hex.Hex}.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.assert('abc')
 * // @error: InvalidHexValueTypeError:
 * // @error: Value `"abc"` of type `string` is an invalid hex type.
 * // @error: Hex types must be represented as `"0x\${string}"`.
 * ```
 *
 * @param value - The value to assert.
 * @param options - Options.
 */ parcelHelpers.export(exports, "assert", ()=>assert);
/**
 * Concatenates two or more {@link ox#Hex.Hex}.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.concat('0x123', '0x456')
 * // @log: '0x123456'
 * ```
 *
 * @param values - The {@link ox#Hex.Hex} values to concatenate.
 * @returns The concatenated {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "concat", ()=>concat);
/**
 * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.
 *
 * :::tip
 *
 * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:
 *
 * - `Hex.fromBoolean`
 *
 * - `Hex.fromString`
 *
 * - `Hex.fromNumber`
 *
 * :::
 *
 * @example
 * ```ts twoslash
 * import { Bytes, Hex } from 'ox'
 *
 * Hex.from('0x48656c6c6f20576f726c6421')
 * // @log: '0x48656c6c6f20576f726c6421'
 *
 * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))
 * // @log: '0x48656c6c6f20576f726c6421'
 * ```
 *
 * @param value - The {@link ox#Bytes.Bytes} value to encode.
 * @returns The encoded {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "from", ()=>from);
/**
 * Encodes a boolean into a {@link ox#Hex.Hex} value.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.fromBoolean(true)
 * // @log: '0x1'
 *
 * Hex.fromBoolean(false)
 * // @log: '0x0'
 *
 * Hex.fromBoolean(true, { size: 32 })
 * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'
 * ```
 *
 * @param value - The boolean value to encode.
 * @param options - Options.
 * @returns The encoded {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "fromBoolean", ()=>fromBoolean);
/**
 * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.
 *
 * @example
 * ```ts twoslash
 * import { Bytes, Hex } from 'ox'
 *
 * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))
 * // @log: '0x48656c6c6f20576f726c6421'
 * ```
 *
 * @param value - The {@link ox#Bytes.Bytes} value to encode.
 * @param options - Options.
 * @returns The encoded {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "fromBytes", ()=>fromBytes);
/**
 * Encodes a number or bigint into a {@link ox#Hex.Hex} value.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.fromNumber(420)
 * // @log: '0x1a4'
 *
 * Hex.fromNumber(420, { size: 32 })
 * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'
 * ```
 *
 * @param value - The number or bigint value to encode.
 * @param options - Options.
 * @returns The encoded {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "fromNumber", ()=>fromNumber);
/**
 * Encodes a string into a {@link ox#Hex.Hex} value.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 * Hex.fromString('Hello World!')
 * // '0x48656c6c6f20576f726c6421'
 *
 * Hex.fromString('Hello World!', { size: 32 })
 * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'
 * ```
 *
 * @param value - The string value to encode.
 * @param options - Options.
 * @returns The encoded {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "fromString", ()=>fromString);
/**
 * Checks if two {@link ox#Hex.Hex} values are equal.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.isEqual('0xdeadbeef', '0xdeadbeef')
 * // @log: true
 *
 * Hex.isEqual('0xda', '0xba')
 * // @log: false
 * ```
 *
 * @param hexA - The first {@link ox#Hex.Hex} value.
 * @param hexB - The second {@link ox#Hex.Hex} value.
 * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.
 */ parcelHelpers.export(exports, "isEqual", ()=>isEqual);
/**
 * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.padLeft('0x1234', 4)
 * // @log: '0x00001234'
 * ```
 *
 * @param value - The {@link ox#Hex.Hex} value to pad.
 * @param size - The size (in bytes) of the output hex value.
 * @returns The padded {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "padLeft", ()=>padLeft);
/**
 * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).
 *
 * @example
 * ```ts
 * import { Hex } from 'ox'
 *
 * Hex.padRight('0x1234', 4)
 * // @log: '0x12340000'
 * ```
 *
 * @param value - The {@link ox#Hex.Hex} value to pad.
 * @param size - The size (in bytes) of the output hex value.
 * @returns The padded {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "padRight", ()=>padRight);
/**
 * Generates a random {@link ox#Hex.Hex} value of the specified length.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * const hex = Hex.random(32)
 * // @log: '0x...'
 * ```
 *
 * @returns Random {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "random", ()=>random);
/**
 * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.slice('0x0123456789', 1, 4)
 * // @log: '0x234567'
 * ```
 *
 * @param value - The {@link ox#Hex.Hex} value to slice.
 * @param start - The start offset (in bytes).
 * @param end - The end offset (in bytes).
 * @param options - Options.
 * @returns The sliced {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "slice", ()=>slice);
/**
 * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.size('0xdeadbeef')
 * // @log: 4
 * ```
 *
 * @param value - The {@link ox#Hex.Hex} value to get the size of.
 * @returns The size of the {@link ox#Hex.Hex} value (in bytes).
 */ parcelHelpers.export(exports, "size", ()=>size);
/**
 * Trims leading zeros from a {@link ox#Hex.Hex} value.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.trimLeft('0x00000000deadbeef')
 * // @log: '0xdeadbeef'
 * ```
 *
 * @param value - The {@link ox#Hex.Hex} value to trim.
 * @returns The trimmed {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "trimLeft", ()=>trimLeft);
/**
 * Trims trailing zeros from a {@link ox#Hex.Hex} value.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.trimRight('0xdeadbeef00000000')
 * // @log: '0xdeadbeef'
 * ```
 *
 * @param value - The {@link ox#Hex.Hex} value to trim.
 * @returns The trimmed {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "trimRight", ()=>trimRight);
/**
 * Decodes a {@link ox#Hex.Hex} value into a BigInt.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.toBigInt('0x1a4')
 * // @log: 420n
 *
 * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
 * // @log: 420n
 * ```
 *
 * @param hex - The {@link ox#Hex.Hex} value to decode.
 * @param options - Options.
 * @returns The decoded BigInt.
 */ parcelHelpers.export(exports, "toBigInt", ()=>toBigInt);
/**
 * Decodes a {@link ox#Hex.Hex} value into a boolean.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.toBoolean('0x01')
 * // @log: true
 *
 * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })
 * // @log: true
 * ```
 *
 * @param hex - The {@link ox#Hex.Hex} value to decode.
 * @param options - Options.
 * @returns The decoded boolean.
 */ parcelHelpers.export(exports, "toBoolean", ()=>toBoolean);
/**
 * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')
 * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 * ```
 *
 * @param hex - The {@link ox#Hex.Hex} value to decode.
 * @param options - Options.
 * @returns The decoded {@link ox#Bytes.Bytes}.
 */ parcelHelpers.export(exports, "toBytes", ()=>toBytes);
/**
 * Decodes a {@link ox#Hex.Hex} value into a number.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.toNumber('0x1a4')
 * // @log: 420
 *
 * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })
 * // @log: 420
 * ```
 *
 * @param hex - The {@link ox#Hex.Hex} value to decode.
 * @param options - Options.
 * @returns The decoded number.
 */ parcelHelpers.export(exports, "toNumber", ()=>toNumber);
/**
 * Decodes a {@link ox#Hex.Hex} value into a string.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.toString('0x48656c6c6f20576f726c6421')
 * // @log: 'Hello world!'
 *
 * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {
 *  size: 32,
 * })
 * // @log: 'Hello world'
 * ```
 *
 * @param hex - The {@link ox#Hex.Hex} value to decode.
 * @param options - Options.
 * @returns The decoded string.
 */ parcelHelpers.export(exports, "toString", ()=>toString);
/**
 * Checks if the given value is {@link ox#Hex.Hex}.
 *
 * @example
 * ```ts twoslash
 * import { Bytes, Hex } from 'ox'
 *
 * Hex.validate('0xdeadbeef')
 * // @log: true
 *
 * Hex.validate(Bytes.from([1, 2, 3]))
 * // @log: false
 * ```
 *
 * @param value - The value to check.
 * @param options - Options.
 * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.
 */ parcelHelpers.export(exports, "validate", ()=>validate);
/**
 * Thrown when the provided integer is out of range, and cannot be represented as a hex value.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.fromNumber(420182738912731283712937129)
 * // @error: Hex.IntegerOutOfRangeError: Number \`4.2018273891273126e+26\` is not in safe unsigned integer range (`0` to `9007199254740991`)
 * ```
 */ parcelHelpers.export(exports, "IntegerOutOfRangeError", ()=>IntegerOutOfRangeError);
/**
 * Thrown when the provided hex value cannot be represented as a boolean.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.toBoolean('0xa')
 * // @error: Hex.InvalidHexBooleanError: Hex value `"0xa"` is not a valid boolean.
 * // @error: The hex value must be `"0x0"` (false) or `"0x1"` (true).
 * ```
 */ parcelHelpers.export(exports, "InvalidHexBooleanError", ()=>InvalidHexBooleanError);
/**
 * Thrown when the provided value is not a valid hex type.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.assert(1)
 * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.
 * ```
 */ parcelHelpers.export(exports, "InvalidHexTypeError", ()=>InvalidHexTypeError);
/**
 * Thrown when the provided hex value is invalid.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.assert('0x0123456789abcdefg')
 * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.
 * // @error: Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).
 * ```
 */ parcelHelpers.export(exports, "InvalidHexValueError", ()=>InvalidHexValueError);
/**
 * Thrown when the provided hex value is an odd length.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.fromHex('0xabcde')
 * // @error: Hex.InvalidLengthError: Hex value `"0xabcde"` is an odd length (5 nibbles).
 * ```
 */ parcelHelpers.export(exports, "InvalidLengthError", ()=>InvalidLengthError);
/**
 * Thrown when the size of the value exceeds the expected max size.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.fromString('Hello World!', { size: 8 })
 * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.
 * ```
 */ parcelHelpers.export(exports, "SizeOverflowError", ()=>SizeOverflowError);
/**
 * Thrown when the slice offset exceeds the bounds of the value.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.slice('0x0123456789', 6)
 * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).
 * ```
 */ parcelHelpers.export(exports, "SliceOffsetOutOfBoundsError", ()=>SliceOffsetOutOfBoundsError);
/**
 * Thrown when the size of the value exceeds the pad size.
 *
 * @example
 * ```ts twoslash
 * import { Hex } from 'ox'
 *
 * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)
 * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).
 * ```
 */ parcelHelpers.export(exports, "SizeExceedsPaddingSizeError", ()=>SizeExceedsPaddingSizeError);
var _utils = require("@noble/curves/abstract/utils");
var _bytesJs = require("./Bytes.js");
var _errorsJs = require("./Errors.js");
var _jsonJs = require("./Json.js");
var _bytesJs1 = require("./internal/bytes.js");
var _hexJs = require("./internal/hex.js");
const encoder = /*#__PURE__*/ new TextEncoder();
const hexes = /*#__PURE__*/ Array.from({
    length: 256
}, (_v, i)=>i.toString(16).padStart(2, '0'));
function assert(value, options = {}) {
    const { strict = false } = options;
    if (!value) throw new InvalidHexTypeError(value);
    if (typeof value !== 'string') throw new InvalidHexTypeError(value);
    if (strict) {
        if (!/^0x[0-9a-fA-F]*$/.test(value)) throw new InvalidHexValueError(value);
    }
    if (!value.startsWith('0x')) throw new InvalidHexValueError(value);
}
function concat(...values) {
    return `0x${values.reduce((acc, x)=>acc + x.replace('0x', ''), '')}`;
}
function from(value) {
    if (value instanceof Uint8Array) return fromBytes(value);
    if (Array.isArray(value)) return fromBytes(new Uint8Array(value));
    return value;
}
function fromBoolean(value, options = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof options.size === 'number') {
        _hexJs.assertSize(hex, options.size);
        return padLeft(hex, options.size);
    }
    return hex;
}
function fromBytes(value, options = {}) {
    let string = '';
    for(let i = 0; i < value.length; i++)string += hexes[value[i]];
    const hex = `0x${string}`;
    if (typeof options.size === 'number') {
        _hexJs.assertSize(hex, options.size);
        return padRight(hex, options.size);
    }
    return hex;
}
function fromNumber(value, options = {}) {
    const { signed, size } = options;
    const value_ = BigInt(value);
    let maxValue;
    if (size) {
        if (signed) maxValue = (1n << BigInt(size) * 8n - 1n) - 1n;
        else maxValue = 2n ** (BigInt(size) * 8n) - 1n;
    } else if (typeof value === 'number') maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
    if (maxValue && value_ > maxValue || value_ < minValue) {
        const suffix = typeof value === 'bigint' ? 'n' : '';
        throw new IntegerOutOfRangeError({
            max: maxValue ? `${maxValue}${suffix}` : undefined,
            min: `${minValue}${suffix}`,
            signed,
            size,
            value: `${value}${suffix}`
        });
    }
    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);
    const hex = `0x${stringValue}`;
    if (size) return padLeft(hex, size);
    return hex;
}
function fromString(value, options = {}) {
    return fromBytes(encoder.encode(value), options);
}
function isEqual(hexA, hexB) {
    return (0, _utils.equalBytes)(_bytesJs.fromHex(hexA), _bytesJs.fromHex(hexB));
}
function padLeft(value, size) {
    return _hexJs.pad(value, {
        dir: 'left',
        size
    });
}
function padRight(value, size) {
    return _hexJs.pad(value, {
        dir: 'right',
        size
    });
}
function random(length) {
    return fromBytes(_bytesJs.random(length));
}
function slice(value, start, end, options = {}) {
    const { strict } = options;
    _hexJs.assertStartOffset(value, start);
    const value_ = `0x${value.replace('0x', '').slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;
    if (strict) _hexJs.assertEndOffset(value_, start, end);
    return value_;
}
function size(value) {
    return Math.ceil((value.length - 2) / 2);
}
function trimLeft(value) {
    return _hexJs.trim(value, {
        dir: 'left'
    });
}
function trimRight(value) {
    return _hexJs.trim(value, {
        dir: 'right'
    });
}
function toBigInt(hex, options = {}) {
    const { signed } = options;
    if (options.size) _hexJs.assertSize(hex, options.size);
    const value = BigInt(hex);
    if (!signed) return value;
    const size = (hex.length - 2) / 2;
    const max_unsigned = (1n << BigInt(size) * 8n) - 1n;
    const max_signed = max_unsigned >> 1n;
    if (value <= max_signed) return value;
    return value - max_unsigned - 1n;
}
function toBoolean(hex, options = {}) {
    if (options.size) _hexJs.assertSize(hex, options.size);
    const hex_ = trimLeft(hex);
    if (hex_ === '0x') return false;
    if (hex_ === '0x1') return true;
    throw new InvalidHexBooleanError(hex);
}
function toBytes(hex, options = {}) {
    return _bytesJs.fromHex(hex, options);
}
function toNumber(hex, options = {}) {
    const { signed, size } = options;
    if (!signed && !size) return Number(hex);
    return Number(toBigInt(hex, options));
}
function toString(hex, options = {}) {
    const { size } = options;
    let bytes = _bytesJs.fromHex(hex);
    if (size) {
        _bytesJs1.assertSize(bytes, size);
        bytes = _bytesJs.trimRight(bytes);
    }
    return new TextDecoder().decode(bytes);
}
function validate(value, options = {}) {
    const { strict = false } = options;
    try {
        assert(value, {
            strict
        });
        return true;
    } catch  {
        return false;
    }
}
class IntegerOutOfRangeError extends _errorsJs.BaseError {
    constructor({ max, min, signed, size, value }){
        super(`Number \`${value}\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.IntegerOutOfRangeError'
        });
    }
}
class InvalidHexBooleanError extends _errorsJs.BaseError {
    constructor(hex){
        super(`Hex value \`"${hex}"\` is not a valid boolean.`, {
            metaMessages: [
                'The hex value must be `"0x0"` (false) or `"0x1"` (true).'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.InvalidHexBooleanError'
        });
    }
}
class InvalidHexTypeError extends _errorsJs.BaseError {
    constructor(value){
        super(`Value \`${typeof value === 'object' ? _jsonJs.stringify(value) : value}\` of type \`${typeof value}\` is an invalid hex type.`, {
            metaMessages: [
                'Hex types must be represented as `"0x${string}"`.'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.InvalidHexTypeError'
        });
    }
}
class InvalidHexValueError extends _errorsJs.BaseError {
    constructor(value){
        super(`Value \`${value}\` is an invalid hex value.`, {
            metaMessages: [
                'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.InvalidHexValueError'
        });
    }
}
class InvalidLengthError extends _errorsJs.BaseError {
    constructor(value){
        super(`Hex value \`"${value}"\` is an odd length (${value.length - 2} nibbles).`, {
            metaMessages: [
                'It must be an even length.'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.InvalidLengthError'
        });
    }
}
class SizeOverflowError extends _errorsJs.BaseError {
    constructor({ givenSize, maxSize }){
        super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.SizeOverflowError'
        });
    }
}
class SliceOffsetOutOfBoundsError extends _errorsJs.BaseError {
    constructor({ offset, position, size }){
        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \`${offset}\` is out-of-bounds (size: \`${size}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.SliceOffsetOutOfBoundsError'
        });
    }
}
class SizeExceedsPaddingSizeError extends _errorsJs.BaseError {
    constructor({ size, targetSize, type }){
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size}\`) exceeds padding size (\`${targetSize}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.SizeExceedsPaddingSizeError'
        });
    }
}

},{"@noble/curves/abstract/utils":"fc0Wi","./Bytes.js":"grkDP","./Errors.js":"d3pbB","./Json.js":"k5VJS","./internal/bytes.js":"yn0LJ","./internal/hex.js":"dKXXe","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fc0Wi":[function(require,module,exports,__globalThis) {
"use strict";
/**
 * Hex, bytes and number utilities.
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.notImplemented = exports.bitMask = void 0;
exports.isBytes = isBytes;
exports.abytes = abytes;
exports.abool = abool;
exports.numberToHexUnpadded = numberToHexUnpadded;
exports.hexToNumber = hexToNumber;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.bytesToNumberBE = bytesToNumberBE;
exports.bytesToNumberLE = bytesToNumberLE;
exports.numberToBytesBE = numberToBytesBE;
exports.numberToBytesLE = numberToBytesLE;
exports.numberToVarBytesBE = numberToVarBytesBE;
exports.ensureBytes = ensureBytes;
exports.concatBytes = concatBytes;
exports.equalBytes = equalBytes;
exports.utf8ToBytes = utf8ToBytes;
exports.inRange = inRange;
exports.aInRange = aInRange;
exports.bitLen = bitLen;
exports.bitGet = bitGet;
exports.bitSet = bitSet;
exports.createHmacDrbg = createHmacDrbg;
exports.validateObject = validateObject;
exports.memoized = memoized;
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
function abytes(item) {
    if (!isBytes(item)) throw new Error('Uint8Array expected');
}
function abool(title, value) {
    if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);
}
// Used in weierstrass, der
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? '0' + hex : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian
}
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = // @ts-ignore
typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */ function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin) return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++)hex += hexes[bytes[i]];
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */ function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function bytesToNumberLE(bytes) {
    abytes(bytes);
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */ function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') try {
        res = hexToBytes(hex);
    } catch (e) {
        throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);
    }
    else if (isBytes(hex)) // Uint8Array.from() instead of hash.slice() because node.js Buffer
    // is instance of Uint8Array, and its slice() creates **mutable** copy
    res = Uint8Array.from(hex);
    else throw new Error(title + ' must be hex string or Uint8Array');
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);
    return res;
}
/**
 * Copies several Uint8Arrays into one.
 */ function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length) return false;
    let diff = 0;
    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];
    return diff === 0;
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */ function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
// Is positive bigint
const isPosBig = (n)=>typeof n === 'bigint' && _0n <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */ function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max)) throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 * TODO: merge with nLength in modular
 */ function bitLen(n) {
    let len;
    for(len = 0; n > _0n; n >>= _1n, len += 1);
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */ function bitGet(n, pos) {
    return n >> BigInt(pos) & _1n;
}
/**
 * Sets single bit at position.
 */ function bitSet(n, pos, value) {
    return n | (value ? _1n : _0n) << BigInt(pos);
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */ const bitMask = (n)=>(_1n << BigInt(n)) - _1n;
exports.bitMask = bitMask;
// DRBG
const u8n = (len)=>new Uint8Array(len); // creates Uint8Array
const u8fr = (arr)=>Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = ()=>{
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n(0))=>{
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([
            0x00
        ]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0) return;
        k = h(u8fr([
            0x01
        ]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = ()=>{
        // HMAC-DRBG generate() function
        if (i++ >= 1000) throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while(len < qByteLen){
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred)=>{
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while(!(res = pred(gen())))reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val)=>typeof val === 'bigint',
    function: (val)=>typeof val === 'function',
    boolean: (val)=>typeof val === 'boolean',
    string: (val)=>typeof val === 'string',
    stringOrUint8Array: (val)=>typeof val === 'string' || isBytes(val),
    isSafeInteger: (val)=>Number.isSafeInteger(val),
    array: (val)=>Array.isArray(val),
    field: (val, object)=>object.Fp.isValid(val),
    hash: (val)=>typeof val === 'function' && Number.isSafeInteger(val.outputLen)
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional)=>{
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function') throw new Error('invalid validator function');
        const val = object[fieldName];
        if (isOptional && val === undefined) return;
        if (!checkVal(val, object)) throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);
    };
    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
/**
 * throws not implemented error
 */ const notImplemented = ()=>{
    throw new Error('not implemented');
};
exports.notImplemented = notImplemented;
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */ function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args)=>{
        const val = map.get(arg);
        if (val !== undefined) return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}

},{}],"grkDP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Asserts if the given value is {@link ox#Bytes.Bytes}.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.assert('abc')
 * // @error: Bytes.InvalidBytesTypeError:
 * // @error: Value `"abc"` of type `string` is an invalid Bytes value.
 * // @error: Bytes values must be of type `Uint8Array`.
 * ```
 *
 * @param value - Value to assert.
 */ parcelHelpers.export(exports, "assert", ()=>assert);
/**
 * Concatenates two or more {@link ox#Bytes.Bytes}.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const bytes = Bytes.concat(
 *   Bytes.from([1]),
 *   Bytes.from([69]),
 *   Bytes.from([420, 69]),
 * )
 * // @log: Uint8Array [ 1, 69, 420, 69 ]
 * ```
 *
 * @param values - Values to concatenate.
 * @returns Concatenated {@link ox#Bytes.Bytes}.
 */ parcelHelpers.export(exports, "concat", ()=>concat);
/**
 * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.
 *
 * :::tip
 *
 * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:
 *
 * - `Bytes.fromBoolean`
 *
 * - `Bytes.fromString`
 *
 * - `Bytes.fromNumber`
 *
 * :::
 *
 * @example
 * ```ts twoslash
 * // @noErrors
 * import { Bytes } from 'ox'
 *
 * const data = Bytes.from([255, 124, 5, 4])
 * // @log: Uint8Array([255, 124, 5, 4])
 *
 * const data = Bytes.from('0xdeadbeef')
 * // @log: Uint8Array([222, 173, 190, 239])
 * ```
 *
 * @param value - Value to convert.
 * @returns A {@link ox#Bytes.Bytes} instance.
 */ parcelHelpers.export(exports, "from", ()=>from);
/**
 * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const data = Bytes.fromArray([255, 124, 5, 4])
 * // @log: Uint8Array([255, 124, 5, 4])
 * ```
 *
 * @param value - Value to convert.
 * @returns A {@link ox#Bytes.Bytes} instance.
 */ parcelHelpers.export(exports, "fromArray", ()=>fromArray);
/**
 * Encodes a boolean value into {@link ox#Bytes.Bytes}.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const data = Bytes.fromBoolean(true)
 * // @log: Uint8Array([1])
 * ```
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const data = Bytes.fromBoolean(true, { size: 32 })
 * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
 * ```
 *
 * @param value - Boolean value to encode.
 * @param options - Encoding options.
 * @returns Encoded {@link ox#Bytes.Bytes}.
 */ parcelHelpers.export(exports, "fromBoolean", ()=>fromBoolean);
/**
 * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')
 * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])
 * ```
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })
 * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 * ```
 *
 * @param value - {@link ox#Hex.Hex} value to encode.
 * @param options - Encoding options.
 * @returns Encoded {@link ox#Bytes.Bytes}.
 */ parcelHelpers.export(exports, "fromHex", ()=>fromHex);
/**
 * Encodes a number value into {@link ox#Bytes.Bytes}.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const data = Bytes.fromNumber(420)
 * // @log: Uint8Array([1, 164])
 * ```
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const data = Bytes.fromNumber(420, { size: 4 })
 * // @log: Uint8Array([0, 0, 1, 164])
 * ```
 *
 * @param value - Number value to encode.
 * @param options - Encoding options.
 * @returns Encoded {@link ox#Bytes.Bytes}.
 */ parcelHelpers.export(exports, "fromNumber", ()=>fromNumber);
/**
 * Encodes a string into {@link ox#Bytes.Bytes}.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const data = Bytes.fromString('Hello world!')
 * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])
 * ```
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const data = Bytes.fromString('Hello world!', { size: 32 })
 * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
 * ```
 *
 * @param value - String to encode.
 * @param options - Encoding options.
 * @returns Encoded {@link ox#Bytes.Bytes}.
 */ parcelHelpers.export(exports, "fromString", ()=>fromString);
/**
 * Checks if two {@link ox#Bytes.Bytes} values are equal.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))
 * // @log: true
 *
 * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))
 * // @log: false
 * ```
 *
 * @param bytesA - First {@link ox#Bytes.Bytes} value.
 * @param bytesB - Second {@link ox#Bytes.Bytes} value.
 * @returns `true` if the two values are equal, otherwise `false`.
 */ parcelHelpers.export(exports, "isEqual", ()=>isEqual);
/**
 * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.padLeft(Bytes.from([1]), 4)
 * // @log: Uint8Array([0, 0, 0, 1])
 * ```
 *
 * @param value - {@link ox#Bytes.Bytes} value to pad.
 * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.
 * @returns Padded {@link ox#Bytes.Bytes} value.
 */ parcelHelpers.export(exports, "padLeft", ()=>padLeft);
/**
 * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.padRight(Bytes.from([1]), 4)
 * // @log: Uint8Array([1, 0, 0, 0])
 * ```
 *
 * @param value - {@link ox#Bytes.Bytes} value to pad.
 * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.
 * @returns Padded {@link ox#Bytes.Bytes} value.
 */ parcelHelpers.export(exports, "padRight", ()=>padRight);
/**
 * Generates random {@link ox#Bytes.Bytes} of the specified length.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const bytes = Bytes.random(32)
 * // @log: Uint8Array([... x32])
 * ```
 *
 * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.
 * @returns Random {@link ox#Bytes.Bytes} of the specified length.
 */ parcelHelpers.export(exports, "random", ()=>random);
/**
 * Retrieves the size of a {@link ox#Bytes.Bytes} value.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.size(Bytes.from([1, 2, 3, 4]))
 * // @log: 4
 * ```
 *
 * @param value - {@link ox#Bytes.Bytes} value.
 * @returns Size of the {@link ox#Bytes.Bytes} value.
 */ parcelHelpers.export(exports, "size", ()=>size);
/**
 * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.slice(
 *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),
 *   1,
 *   4,
 * )
 * // @log: Uint8Array([2, 3, 4])
 * ```
 *
 * @param value - The {@link ox#Bytes.Bytes} value.
 * @param start - Start offset.
 * @param end - End offset.
 * @param options - Slice options.
 * @returns Sliced {@link ox#Bytes.Bytes} value.
 */ parcelHelpers.export(exports, "slice", ()=>slice);
/**
 * Decodes a {@link ox#Bytes.Bytes} into a bigint.
 *
 * @example
 * ```ts
 * import { Bytes } from 'ox'
 *
 * Bytes.toBigInt(Bytes.from([1, 164]))
 * // @log: 420n
 * ```
 *
 * @param bytes - The {@link ox#Bytes.Bytes} to decode.
 * @param options - Decoding options.
 * @returns Decoded bigint.
 */ parcelHelpers.export(exports, "toBigInt", ()=>toBigInt);
/**
 * Decodes a {@link ox#Bytes.Bytes} into a boolean.
 *
 * @example
 * ```ts
 * import { Bytes } from 'ox'
 *
 * Bytes.toBoolean(Bytes.from([1]))
 * // @log: true
 * ```
 *
 * @param bytes - The {@link ox#Bytes.Bytes} to decode.
 * @param options - Decoding options.
 * @returns Decoded boolean.
 */ parcelHelpers.export(exports, "toBoolean", ()=>toBoolean);
/**
 * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))
 * // '0x48656c6c6f20576f726c6421'
 * ```
 *
 * @param value - The {@link ox#Bytes.Bytes} to decode.
 * @param options - Options.
 * @returns Decoded {@link ox#Hex.Hex} value.
 */ parcelHelpers.export(exports, "toHex", ()=>toHex);
/**
 * Decodes a {@link ox#Bytes.Bytes} into a number.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.toNumber(Bytes.from([1, 164]))
 * // @log: 420
 * ```
 */ parcelHelpers.export(exports, "toNumber", ()=>toNumber);
/**
 * Decodes a {@link ox#Bytes.Bytes} into a string.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))
 * // @log: 'Hello world'
 * ```
 *
 * @param bytes - The {@link ox#Bytes.Bytes} to decode.
 * @param options - Options.
 * @returns Decoded string.
 */ parcelHelpers.export(exports, "toString", ()=>toString);
/**
 * Trims leading zeros from a {@link ox#Bytes.Bytes} value.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))
 * // @log: Uint8Array([1, 2, 3])
 * ```
 *
 * @param value - {@link ox#Bytes.Bytes} value.
 * @returns Trimmed {@link ox#Bytes.Bytes} value.
 */ parcelHelpers.export(exports, "trimLeft", ()=>trimLeft);
/**
 * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))
 * // @log: Uint8Array([1, 2, 3])
 * ```
 *
 * @param value - {@link ox#Bytes.Bytes} value.
 * @returns Trimmed {@link ox#Bytes.Bytes} value.
 */ parcelHelpers.export(exports, "trimRight", ()=>trimRight);
/**
 * Checks if the given value is {@link ox#Bytes.Bytes}.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.validate('0x')
 * // @log: false
 *
 * Bytes.validate(Bytes.from([1, 2, 3]))
 * // @log: true
 * ```
 *
 * @param value - Value to check.
 * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.
 */ parcelHelpers.export(exports, "validate", ()=>validate);
/**
 * Thrown when the bytes value cannot be represented as a boolean.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.toBoolean(Bytes.from([5]))
 * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.
 * // @error: The bytes array must contain a single byte of either a `0` or `1` value.
 * ```
 */ parcelHelpers.export(exports, "InvalidBytesBooleanError", ()=>InvalidBytesBooleanError);
/**
 * Thrown when a value cannot be converted to bytes.
 *
 * @example
 * ```ts twoslash
 * // @noErrors
 * import { Bytes } from 'ox'
 *
 * Bytes.from('foo')
 * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.
 * ```
 */ parcelHelpers.export(exports, "InvalidBytesTypeError", ()=>InvalidBytesTypeError);
/**
 * Thrown when a size exceeds the maximum allowed size.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.fromString('Hello World!', { size: 8 })
 * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.
 * ```
 */ parcelHelpers.export(exports, "SizeOverflowError", ()=>SizeOverflowError);
/**
 * Thrown when a slice offset is out-of-bounds.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.slice(Bytes.from([1, 2, 3]), 4)
 * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).
 * ```
 */ parcelHelpers.export(exports, "SliceOffsetOutOfBoundsError", ()=>SliceOffsetOutOfBoundsError);
/**
 * Thrown when a the padding size exceeds the maximum allowed size.
 *
 * @example
 * ```ts twoslash
 * import { Bytes } from 'ox'
 *
 * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)
 * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).
 * ```
 */ parcelHelpers.export(exports, "SizeExceedsPaddingSizeError", ()=>SizeExceedsPaddingSizeError);
var _utils = require("@noble/curves/abstract/utils");
var _errorsJs = require("./Errors.js");
var _hexJs = require("./Hex.js");
var _jsonJs = require("./Json.js");
var _bytesJs = require("./internal/bytes.js");
var _hexJs1 = require("./internal/hex.js");
const decoder = /*#__PURE__*/ new TextDecoder();
const encoder = /*#__PURE__*/ new TextEncoder();
function assert(value) {
    if (value instanceof Uint8Array) return;
    if (!value) throw new InvalidBytesTypeError(value);
    if (typeof value !== 'object') throw new InvalidBytesTypeError(value);
    if (!('BYTES_PER_ELEMENT' in value)) throw new InvalidBytesTypeError(value);
    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array') throw new InvalidBytesTypeError(value);
}
function concat(...values) {
    let length = 0;
    for (const arr of values)length += arr.length;
    const result = new Uint8Array(length);
    for(let i = 0, index = 0; i < values.length; i++){
        const arr = values[i];
        result.set(arr, index);
        index += arr.length;
    }
    return result;
}
function from(value) {
    if (value instanceof Uint8Array) return value;
    if (typeof value === 'string') return fromHex(value);
    return fromArray(value);
}
function fromArray(value) {
    return value instanceof Uint8Array ? value : new Uint8Array(value);
}
function fromBoolean(value, options = {}) {
    const { size } = options;
    const bytes = new Uint8Array(1);
    bytes[0] = Number(value);
    if (typeof size === 'number') {
        _bytesJs.assertSize(bytes, size);
        return padLeft(bytes, size);
    }
    return bytes;
}
function fromHex(value, options = {}) {
    const { size } = options;
    let hex = value;
    if (size) {
        _hexJs1.assertSize(value, size);
        hex = _hexJs.padRight(value, size);
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2) hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for(let index = 0, j = 0; index < length; index++){
        const nibbleLeft = _bytesJs.charCodeToBase16(hexString.charCodeAt(j++));
        const nibbleRight = _bytesJs.charCodeToBase16(hexString.charCodeAt(j++));
        if (nibbleLeft === undefined || nibbleRight === undefined) throw new _errorsJs.BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
        bytes[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
}
function fromNumber(value, options) {
    const hex = _hexJs.fromNumber(value, options);
    return fromHex(hex);
}
function fromString(value, options = {}) {
    const { size } = options;
    const bytes = encoder.encode(value);
    if (typeof size === 'number') {
        _bytesJs.assertSize(bytes, size);
        return padRight(bytes, size);
    }
    return bytes;
}
function isEqual(bytesA, bytesB) {
    return (0, _utils.equalBytes)(bytesA, bytesB);
}
function padLeft(value, size) {
    return _bytesJs.pad(value, {
        dir: 'left',
        size
    });
}
function padRight(value, size) {
    return _bytesJs.pad(value, {
        dir: 'right',
        size
    });
}
function random(length) {
    return crypto.getRandomValues(new Uint8Array(length));
}
function size(value) {
    return value.length;
}
function slice(value, start, end, options = {}) {
    const { strict } = options;
    _bytesJs.assertStartOffset(value, start);
    const value_ = value.slice(start, end);
    if (strict) _bytesJs.assertEndOffset(value_, start, end);
    return value_;
}
function toBigInt(bytes, options = {}) {
    const { size } = options;
    if (typeof size !== 'undefined') _bytesJs.assertSize(bytes, size);
    const hex = _hexJs.fromBytes(bytes, options);
    return _hexJs.toBigInt(hex, options);
}
function toBoolean(bytes, options = {}) {
    const { size } = options;
    let bytes_ = bytes;
    if (typeof size !== 'undefined') {
        _bytesJs.assertSize(bytes_, size);
        bytes_ = trimLeft(bytes_);
    }
    if (bytes_.length > 1 || bytes_[0] > 1) throw new InvalidBytesBooleanError(bytes_);
    return Boolean(bytes_[0]);
}
function toHex(value, options = {}) {
    return _hexJs.fromBytes(value, options);
}
function toNumber(bytes, options = {}) {
    const { size } = options;
    if (typeof size !== 'undefined') _bytesJs.assertSize(bytes, size);
    const hex = _hexJs.fromBytes(bytes, options);
    return _hexJs.toNumber(hex, options);
}
function toString(bytes, options = {}) {
    const { size } = options;
    let bytes_ = bytes;
    if (typeof size !== 'undefined') {
        _bytesJs.assertSize(bytes_, size);
        bytes_ = trimRight(bytes_);
    }
    return decoder.decode(bytes_);
}
function trimLeft(value) {
    return _bytesJs.trim(value, {
        dir: 'left'
    });
}
function trimRight(value) {
    return _bytesJs.trim(value, {
        dir: 'right'
    });
}
function validate(value) {
    try {
        assert(value);
        return true;
    } catch  {
        return false;
    }
}
class InvalidBytesBooleanError extends _errorsJs.BaseError {
    constructor(bytes){
        super(`Bytes value \`${bytes}\` is not a valid boolean.`, {
            metaMessages: [
                'The bytes array must contain a single byte of either a `0` or `1` value.'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Bytes.InvalidBytesBooleanError'
        });
    }
}
class InvalidBytesTypeError extends _errorsJs.BaseError {
    constructor(value){
        super(`Value \`${typeof value === 'object' ? _jsonJs.stringify(value) : value}\` of type \`${typeof value}\` is an invalid Bytes value.`, {
            metaMessages: [
                'Bytes values must be of type `Bytes`.'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Bytes.InvalidBytesTypeError'
        });
    }
}
class SizeOverflowError extends _errorsJs.BaseError {
    constructor({ givenSize, maxSize }){
        super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Bytes.SizeOverflowError'
        });
    }
}
class SliceOffsetOutOfBoundsError extends _errorsJs.BaseError {
    constructor({ offset, position, size }){
        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \`${offset}\` is out-of-bounds (size: \`${size}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Bytes.SliceOffsetOutOfBoundsError'
        });
    }
}
class SizeExceedsPaddingSizeError extends _errorsJs.BaseError {
    constructor({ size, targetSize, type }){
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (\`${size}\`) exceeds padding size (\`${targetSize}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Bytes.SizeExceedsPaddingSizeError'
        });
    }
}

},{"@noble/curves/abstract/utils":"fc0Wi","./Errors.js":"d3pbB","./Hex.js":"bkNyt","./Json.js":"k5VJS","./internal/bytes.js":"yn0LJ","./internal/hex.js":"dKXXe","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d3pbB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Base error class inherited by all errors thrown by ox.
 *
 * @example
 * ```ts
 * import { Errors } from 'ox'
 * throw new Errors.BaseError('An error occurred')
 * ```
 */ parcelHelpers.export(exports, "BaseError", ()=>BaseError);
var _errorsJs = require("./internal/errors.js");
class BaseError extends Error {
    constructor(shortMessage, options = {}){
        const details = (()=>{
            if (options.cause instanceof BaseError) {
                if (options.cause.details) return options.cause.details;
                if (options.cause.shortMessage) return options.cause.shortMessage;
            }
            if (options.cause && 'details' in options.cause && typeof options.cause.details === 'string') return options.cause.details;
            if (options.cause?.message) return options.cause.message;
            return options.details;
        })();
        const docsPath = (()=>{
            if (options.cause instanceof BaseError) return options.cause.docsPath || options.docsPath;
            return options.docsPath;
        })();
        const docsBaseUrl = 'https://oxlib.sh';
        const docs = `${docsBaseUrl}${docsPath ?? ''}`;
        const message = [
            shortMessage || 'An error occurred.',
            ...options.metaMessages ? [
                '',
                ...options.metaMessages
            ] : [],
            ...details || docsPath ? [
                '',
                details ? `Details: ${details}` : undefined,
                docsPath ? `See: ${docs}` : undefined
            ] : []
        ].filter((x)=>typeof x === 'string').join('\n');
        super(message, options.cause ? {
            cause: options.cause
        } : undefined);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BaseError'
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: `ox@${(0, _errorsJs.getVersion)()}`
        });
        this.cause = options.cause;
        this.details = details;
        this.docs = docs;
        this.docsPath = docsPath;
        this.shortMessage = shortMessage;
    }
    walk(fn) {
        return walk(this, fn);
    }
}
/** @internal */ function walk(err, fn) {
    if (fn?.(err)) return err;
    if (err && typeof err === 'object' && 'cause' in err && err.cause) return walk(err.cause, fn);
    return fn ? null : err;
}

},{"./internal/errors.js":"6QIYV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6QIYV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "getUrl", ()=>getUrl);
/** @internal */ parcelHelpers.export(exports, "getVersion", ()=>getVersion);
/** @internal */ parcelHelpers.export(exports, "prettyPrint", ()=>prettyPrint);
var _versionJs = require("../version.js");
function getUrl(url) {
    return url;
}
function getVersion() {
    return 0, _versionJs.version;
}
function prettyPrint(args) {
    if (!args) return '';
    const entries = Object.entries(args).map(([key, value])=>{
        if (value === undefined || value === false) return null;
        return [
            key,
            value
        ];
    }).filter(Boolean);
    const maxLength = entries.reduce((acc, [key])=>Math.max(acc, key.length), 0);
    return entries.map(([key, value])=>`  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join('\n');
}

},{"../version.js":"02A2z","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"02A2z":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = '0.1.1';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k5VJS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parses a JSON string, with support for `bigint`.
 *
 * @example
 * ```ts twoslash
 * import { Json } from 'ox'
 *
 * const json = Json.parse('{"foo":"bar","baz":"69420694206942069420694206942069420694206942069420#__bigint"}')
 * // @log: {
 * // @log:   foo: 'bar',
 * // @log:   baz: 69420694206942069420694206942069420694206942069420n
 * // @log: }
 * ```
 *
 * @param string - The value to parse.
 * @param reviver - A function that transforms the results.
 * @returns The parsed value.
 */ parcelHelpers.export(exports, "parse", ()=>parse);
/**
 * Stringifies a value to its JSON representation, with support for `bigint`.
 *
 * @example
 * ```ts twoslash
 * import { Json } from 'ox'
 *
 * const json = Json.stringify({
 *   foo: 'bar',
 *   baz: 69420694206942069420694206942069420694206942069420n,
 * })
 * // @log: '{"foo":"bar","baz":"69420694206942069420694206942069420694206942069420#__bigint"}'
 * ```
 *
 * @param value - The value to stringify.
 * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.
 * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\t'`), it uses the string as the indentation character.
 * @returns The JSON string.
 */ parcelHelpers.export(exports, "stringify", ()=>stringify);
const bigIntSuffix = '#__bigint';
function parse(string, reviver) {
    return JSON.parse(string, (key, value_)=>{
        const value = value_;
        if (typeof value === 'string' && value.endsWith(bigIntSuffix)) return BigInt(value.slice(0, -bigIntSuffix.length));
        return typeof reviver === 'function' ? reviver(key, value) : value;
    });
}
function stringify(value, replacer, space) {
    return JSON.stringify(value, (key, value)=>{
        if (typeof replacer === 'function') return replacer(key, value);
        if (typeof value === 'bigint') return value.toString() + bigIntSuffix;
        return value;
    }, space);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"yn0LJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "assertSize", ()=>assertSize);
/** @internal */ parcelHelpers.export(exports, "assertStartOffset", ()=>assertStartOffset);
/** @internal */ parcelHelpers.export(exports, "assertEndOffset", ()=>assertEndOffset);
parcelHelpers.export(exports, "charCodeMap", ()=>charCodeMap);
/** @internal */ parcelHelpers.export(exports, "charCodeToBase16", ()=>charCodeToBase16);
/** @internal */ parcelHelpers.export(exports, "pad", ()=>pad);
/** @internal */ parcelHelpers.export(exports, "trim", ()=>trim);
var _bytesJs = require("../Bytes.js");
function assertSize(bytes, size_) {
    if (_bytesJs.size(bytes) > size_) throw new _bytesJs.SizeOverflowError({
        givenSize: _bytesJs.size(bytes),
        maxSize: size_
    });
}
function assertStartOffset(value, start) {
    if (typeof start === 'number' && start > 0 && start > _bytesJs.size(value) - 1) throw new _bytesJs.SliceOffsetOutOfBoundsError({
        offset: start,
        position: 'start',
        size: _bytesJs.size(value)
    });
}
function assertEndOffset(value, start, end) {
    if (typeof start === 'number' && typeof end === 'number' && _bytesJs.size(value) !== end - start) throw new _bytesJs.SliceOffsetOutOfBoundsError({
        offset: end,
        position: 'end',
        size: _bytesJs.size(value)
    });
}
const charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine) return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F) return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f) return char - (charCodeMap.a - 10);
    return undefined;
}
function pad(bytes, options = {}) {
    const { dir, size = 32 } = options;
    if (size === 0) return bytes;
    if (bytes.length > size) throw new _bytesJs.SizeExceedsPaddingSizeError({
        size: bytes.length,
        targetSize: size,
        type: 'Bytes'
    });
    const paddedBytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        const padEnd = dir === 'right';
        paddedBytes[padEnd ? i : size - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
}
function trim(value, options = {}) {
    const { dir = 'left' } = options;
    let data = value;
    let sliceLength = 0;
    for(let i = 0; i < data.length - 1; i++){
        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0') sliceLength++;
        else break;
    }
    data = dir === 'left' ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    return data;
}

},{"../Bytes.js":"grkDP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dKXXe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "assertSize", ()=>assertSize);
/** @internal */ parcelHelpers.export(exports, "assertStartOffset", ()=>assertStartOffset);
/** @internal */ parcelHelpers.export(exports, "assertEndOffset", ()=>assertEndOffset);
/** @internal */ parcelHelpers.export(exports, "pad", ()=>pad);
/** @internal */ parcelHelpers.export(exports, "trim", ()=>trim);
var _hexJs = require("../Hex.js");
function assertSize(hex, size_) {
    if (_hexJs.size(hex) > size_) throw new _hexJs.SizeOverflowError({
        givenSize: _hexJs.size(hex),
        maxSize: size_
    });
}
function assertStartOffset(value, start) {
    if (typeof start === 'number' && start > 0 && start > _hexJs.size(value) - 1) throw new _hexJs.SliceOffsetOutOfBoundsError({
        offset: start,
        position: 'start',
        size: _hexJs.size(value)
    });
}
function assertEndOffset(value, start, end) {
    if (typeof start === 'number' && typeof end === 'number' && _hexJs.size(value) !== end - start) throw new _hexJs.SliceOffsetOutOfBoundsError({
        offset: end,
        position: 'end',
        size: _hexJs.size(value)
    });
}
function pad(hex_, options = {}) {
    const { dir, size = 32 } = options;
    if (size === 0) return hex_;
    const hex = hex_.replace('0x', '');
    if (hex.length > size * 2) throw new _hexJs.SizeExceedsPaddingSizeError({
        size: Math.ceil(hex.length / 2),
        targetSize: size,
        type: 'Hex'
    });
    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
}
function trim(value, options = {}) {
    const { dir = 'left' } = options;
    let data = value.replace('0x', '');
    let sliceLength = 0;
    for(let i = 0; i < data.length - 1; i++){
        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0') sliceLength++;
        else break;
    }
    data = dir === 'left' ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
    if (data === '0') return '0x';
    if (dir === 'right' && data.length % 2 === 1) return `0x${data}0`;
    return `0x${data}`;
}

},{"../Hex.js":"bkNyt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jdl0M":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts a {@link ox#Withdrawal.Rpc} to an {@link ox#Withdrawal.Withdrawal}.
 *
 * @example
 * ```ts twoslash
 * import { Withdrawal } from 'ox'
 *
 * const withdrawal = Withdrawal.fromRpc({
 *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',
 *   amount: '0x620323',
 *   index: '0x0',
 *   validatorIndex: '0x1',
 * })
 * // @log: {
 * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',
 * // @log:   amount: 6423331n,
 * // @log:   index: 0,
 * // @log:   validatorIndex: 1
 * // @log: }
 * ```
 *
 * @param withdrawal - The RPC withdrawal to convert.
 * @returns An instantiated {@link ox#Withdrawal.Withdrawal}.
 */ parcelHelpers.export(exports, "fromRpc", ()=>fromRpc);
/**
 * Converts a {@link ox#Withdrawal.Withdrawal} to an {@link ox#Withdrawal.Rpc}.
 *
 * @example
 * ```ts twoslash
 * import { Withdrawal } from 'ox'
 *
 * const withdrawal = Withdrawal.toRpc({
 *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',
 *   amount: 6423331n,
 *   index: 0,
 *   validatorIndex: 1,
 * })
 * // @log: {
 * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',
 * // @log:   amount: '0x620323',
 * // @log:   index: '0x0',
 * // @log:   validatorIndex: '0x1',
 * // @log: }
 * ```
 *
 * @param withdrawal - The Withdrawal to convert.
 * @returns An RPC Withdrawal.
 */ parcelHelpers.export(exports, "toRpc", ()=>toRpc);
var _hexJs = require("./Hex.js");
function fromRpc(withdrawal) {
    return {
        ...withdrawal,
        amount: BigInt(withdrawal.amount),
        index: Number(withdrawal.index),
        validatorIndex: Number(withdrawal.validatorIndex)
    };
}
function toRpc(withdrawal) {
    return {
        address: withdrawal.address,
        amount: _hexJs.fromNumber(withdrawal.amount),
        index: _hexJs.fromNumber(withdrawal.index),
        validatorIndex: _hexJs.fromNumber(withdrawal.validatorIndex)
    };
}

},{"./Hex.js":"bkNyt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ffwQK":[function(require,module,exports,__globalThis) {
/* [Multicall3](https://github.com/mds1/multicall) */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "multicall3Abi", ()=>multicall3Abi);
parcelHelpers.export(exports, "batchGatewayAbi", ()=>batchGatewayAbi);
parcelHelpers.export(exports, "universalResolverResolveAbi", ()=>universalResolverResolveAbi);
parcelHelpers.export(exports, "universalResolverReverseAbi", ()=>universalResolverReverseAbi);
parcelHelpers.export(exports, "textResolverAbi", ()=>textResolverAbi);
parcelHelpers.export(exports, "addressResolverAbi", ()=>addressResolverAbi);
parcelHelpers.export(exports, "smartAccountAbi", ()=>smartAccountAbi);
parcelHelpers.export(exports, "universalSignatureValidatorAbi", ()=>universalSignatureValidatorAbi);
parcelHelpers.export(exports, "erc20Abi", ()=>erc20Abi);
parcelHelpers.export(exports, "erc20Abi_bytes32", ()=>erc20Abi_bytes32);
parcelHelpers.export(exports, "erc1155Abi", ()=>erc1155Abi);
parcelHelpers.export(exports, "erc721Abi", ()=>erc721Abi);
parcelHelpers.export(exports, "erc4626Abi", ()=>erc4626Abi);
const multicall3Abi = [
    {
        inputs: [
            {
                components: [
                    {
                        name: 'target',
                        type: 'address'
                    },
                    {
                        name: 'allowFailure',
                        type: 'bool'
                    },
                    {
                        name: 'callData',
                        type: 'bytes'
                    }
                ],
                name: 'calls',
                type: 'tuple[]'
            }
        ],
        name: 'aggregate3',
        outputs: [
            {
                components: [
                    {
                        name: 'success',
                        type: 'bool'
                    },
                    {
                        name: 'returnData',
                        type: 'bytes'
                    }
                ],
                name: 'returnData',
                type: 'tuple[]'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    }
];
const batchGatewayAbi = [
    {
        name: 'query',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            {
                type: 'tuple[]',
                name: 'queries',
                components: [
                    {
                        type: 'address',
                        name: 'sender'
                    },
                    {
                        type: 'string[]',
                        name: 'urls'
                    },
                    {
                        type: 'bytes',
                        name: 'data'
                    }
                ]
            }
        ],
        outputs: [
            {
                type: 'bool[]',
                name: 'failures'
            },
            {
                type: 'bytes[]',
                name: 'responses'
            }
        ]
    },
    {
        name: 'HttpError',
        type: 'error',
        inputs: [
            {
                type: 'uint16',
                name: 'status'
            },
            {
                type: 'string',
                name: 'message'
            }
        ]
    }
];
const universalResolverErrors = [
    {
        inputs: [],
        name: 'ResolverNotFound',
        type: 'error'
    },
    {
        inputs: [],
        name: 'ResolverWildcardNotSupported',
        type: 'error'
    },
    {
        inputs: [],
        name: 'ResolverNotContract',
        type: 'error'
    },
    {
        inputs: [
            {
                name: 'returnData',
                type: 'bytes'
            }
        ],
        name: 'ResolverError',
        type: 'error'
    },
    {
        inputs: [
            {
                components: [
                    {
                        name: 'status',
                        type: 'uint16'
                    },
                    {
                        name: 'message',
                        type: 'string'
                    }
                ],
                name: 'errors',
                type: 'tuple[]'
            }
        ],
        name: 'HttpError',
        type: 'error'
    }
];
const universalResolverResolveAbi = [
    ...universalResolverErrors,
    {
        name: 'resolve',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            {
                name: 'name',
                type: 'bytes'
            },
            {
                name: 'data',
                type: 'bytes'
            }
        ],
        outputs: [
            {
                name: '',
                type: 'bytes'
            },
            {
                name: 'address',
                type: 'address'
            }
        ]
    },
    {
        name: 'resolve',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            {
                name: 'name',
                type: 'bytes'
            },
            {
                name: 'data',
                type: 'bytes'
            },
            {
                name: 'gateways',
                type: 'string[]'
            }
        ],
        outputs: [
            {
                name: '',
                type: 'bytes'
            },
            {
                name: 'address',
                type: 'address'
            }
        ]
    }
];
const universalResolverReverseAbi = [
    ...universalResolverErrors,
    {
        name: 'reverse',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            {
                type: 'bytes',
                name: 'reverseName'
            }
        ],
        outputs: [
            {
                type: 'string',
                name: 'resolvedName'
            },
            {
                type: 'address',
                name: 'resolvedAddress'
            },
            {
                type: 'address',
                name: 'reverseResolver'
            },
            {
                type: 'address',
                name: 'resolver'
            }
        ]
    },
    {
        name: 'reverse',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            {
                type: 'bytes',
                name: 'reverseName'
            },
            {
                type: 'string[]',
                name: 'gateways'
            }
        ],
        outputs: [
            {
                type: 'string',
                name: 'resolvedName'
            },
            {
                type: 'address',
                name: 'resolvedAddress'
            },
            {
                type: 'address',
                name: 'reverseResolver'
            },
            {
                type: 'address',
                name: 'resolver'
            }
        ]
    }
];
const textResolverAbi = [
    {
        name: 'text',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            {
                name: 'name',
                type: 'bytes32'
            },
            {
                name: 'key',
                type: 'string'
            }
        ],
        outputs: [
            {
                name: '',
                type: 'string'
            }
        ]
    }
];
const addressResolverAbi = [
    {
        name: 'addr',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            {
                name: 'name',
                type: 'bytes32'
            }
        ],
        outputs: [
            {
                name: '',
                type: 'address'
            }
        ]
    },
    {
        name: 'addr',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            {
                name: 'name',
                type: 'bytes32'
            },
            {
                name: 'coinType',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                name: '',
                type: 'bytes'
            }
        ]
    }
];
const smartAccountAbi = [
    {
        name: 'isValidSignature',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            {
                name: 'hash',
                type: 'bytes32'
            },
            {
                name: 'signature',
                type: 'bytes'
            }
        ],
        outputs: [
            {
                name: '',
                type: 'bytes4'
            }
        ]
    }
];
const universalSignatureValidatorAbi = [
    {
        inputs: [
            {
                name: '_signer',
                type: 'address'
            },
            {
                name: '_hash',
                type: 'bytes32'
            },
            {
                name: '_signature',
                type: 'bytes'
            }
        ],
        stateMutability: 'nonpayable',
        type: 'constructor'
    },
    {
        inputs: [
            {
                name: '_signer',
                type: 'address'
            },
            {
                name: '_hash',
                type: 'bytes32'
            },
            {
                name: '_signature',
                type: 'bytes'
            }
        ],
        outputs: [
            {
                type: 'bool'
            }
        ],
        stateMutability: 'nonpayable',
        type: 'function',
        name: 'isValidSig'
    }
];
const erc20Abi = [
    {
        type: 'event',
        name: 'Approval',
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address'
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address'
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256'
            }
        ]
    },
    {
        type: 'event',
        name: 'Transfer',
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address'
            },
            {
                indexed: true,
                name: 'to',
                type: 'address'
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'allowance',
        stateMutability: 'view',
        inputs: [
            {
                name: 'owner',
                type: 'address'
            },
            {
                name: 'spender',
                type: 'address'
            }
        ],
        outputs: [
            {
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'spender',
                type: 'address'
            },
            {
                name: 'amount',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                type: 'bool'
            }
        ]
    },
    {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [
            {
                name: 'account',
                type: 'address'
            }
        ],
        outputs: [
            {
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'decimals',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint8'
            }
        ]
    },
    {
        type: 'function',
        name: 'name',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'string'
            }
        ]
    },
    {
        type: 'function',
        name: 'symbol',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'string'
            }
        ]
    },
    {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'transfer',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'recipient',
                type: 'address'
            },
            {
                name: 'amount',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                type: 'bool'
            }
        ]
    },
    {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'sender',
                type: 'address'
            },
            {
                name: 'recipient',
                type: 'address'
            },
            {
                name: 'amount',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                type: 'bool'
            }
        ]
    }
];
const erc20Abi_bytes32 = [
    {
        type: 'event',
        name: 'Approval',
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address'
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address'
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256'
            }
        ]
    },
    {
        type: 'event',
        name: 'Transfer',
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address'
            },
            {
                indexed: true,
                name: 'to',
                type: 'address'
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'allowance',
        stateMutability: 'view',
        inputs: [
            {
                name: 'owner',
                type: 'address'
            },
            {
                name: 'spender',
                type: 'address'
            }
        ],
        outputs: [
            {
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'spender',
                type: 'address'
            },
            {
                name: 'amount',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                type: 'bool'
            }
        ]
    },
    {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [
            {
                name: 'account',
                type: 'address'
            }
        ],
        outputs: [
            {
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'decimals',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint8'
            }
        ]
    },
    {
        type: 'function',
        name: 'name',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'bytes32'
            }
        ]
    },
    {
        type: 'function',
        name: 'symbol',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'bytes32'
            }
        ]
    },
    {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'transfer',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'recipient',
                type: 'address'
            },
            {
                name: 'amount',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                type: 'bool'
            }
        ]
    },
    {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'sender',
                type: 'address'
            },
            {
                name: 'recipient',
                type: 'address'
            },
            {
                name: 'amount',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                type: 'bool'
            }
        ]
    }
];
const erc1155Abi = [
    {
        inputs: [
            {
                internalType: 'address',
                name: 'sender',
                type: 'address'
            },
            {
                internalType: 'uint256',
                name: 'balance',
                type: 'uint256'
            },
            {
                internalType: 'uint256',
                name: 'needed',
                type: 'uint256'
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256'
            }
        ],
        name: 'ERC1155InsufficientBalance',
        type: 'error'
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'approver',
                type: 'address'
            }
        ],
        name: 'ERC1155InvalidApprover',
        type: 'error'
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'idsLength',
                type: 'uint256'
            },
            {
                internalType: 'uint256',
                name: 'valuesLength',
                type: 'uint256'
            }
        ],
        name: 'ERC1155InvalidArrayLength',
        type: 'error'
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'operator',
                type: 'address'
            }
        ],
        name: 'ERC1155InvalidOperator',
        type: 'error'
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address'
            }
        ],
        name: 'ERC1155InvalidReceiver',
        type: 'error'
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'sender',
                type: 'address'
            }
        ],
        name: 'ERC1155InvalidSender',
        type: 'error'
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'operator',
                type: 'address'
            },
            {
                internalType: 'address',
                name: 'owner',
                type: 'address'
            }
        ],
        name: 'ERC1155MissingApprovalForAll',
        type: 'error'
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'account',
                type: 'address'
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'operator',
                type: 'address'
            },
            {
                indexed: false,
                internalType: 'bool',
                name: 'approved',
                type: 'bool'
            }
        ],
        name: 'ApprovalForAll',
        type: 'event'
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'operator',
                type: 'address'
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'from',
                type: 'address'
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'to',
                type: 'address'
            },
            {
                indexed: false,
                internalType: 'uint256[]',
                name: 'ids',
                type: 'uint256[]'
            },
            {
                indexed: false,
                internalType: 'uint256[]',
                name: 'values',
                type: 'uint256[]'
            }
        ],
        name: 'TransferBatch',
        type: 'event'
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'operator',
                type: 'address'
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'from',
                type: 'address'
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'to',
                type: 'address'
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'id',
                type: 'uint256'
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'value',
                type: 'uint256'
            }
        ],
        name: 'TransferSingle',
        type: 'event'
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'string',
                name: 'value',
                type: 'string'
            },
            {
                indexed: true,
                internalType: 'uint256',
                name: 'id',
                type: 'uint256'
            }
        ],
        name: 'URI',
        type: 'event'
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'account',
                type: 'address'
            },
            {
                internalType: 'uint256',
                name: 'id',
                type: 'uint256'
            }
        ],
        name: 'balanceOf',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                internalType: 'address[]',
                name: 'accounts',
                type: 'address[]'
            },
            {
                internalType: 'uint256[]',
                name: 'ids',
                type: 'uint256[]'
            }
        ],
        name: 'balanceOfBatch',
        outputs: [
            {
                internalType: 'uint256[]',
                name: '',
                type: 'uint256[]'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'account',
                type: 'address'
            },
            {
                internalType: 'address',
                name: 'operator',
                type: 'address'
            }
        ],
        name: 'isApprovedForAll',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'from',
                type: 'address'
            },
            {
                internalType: 'address',
                name: 'to',
                type: 'address'
            },
            {
                internalType: 'uint256[]',
                name: 'ids',
                type: 'uint256[]'
            },
            {
                internalType: 'uint256[]',
                name: 'values',
                type: 'uint256[]'
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes'
            }
        ],
        name: 'safeBatchTransferFrom',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'from',
                type: 'address'
            },
            {
                internalType: 'address',
                name: 'to',
                type: 'address'
            },
            {
                internalType: 'uint256',
                name: 'id',
                type: 'uint256'
            },
            {
                internalType: 'uint256',
                name: 'value',
                type: 'uint256'
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes'
            }
        ],
        name: 'safeTransferFrom',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'operator',
                type: 'address'
            },
            {
                internalType: 'bool',
                name: 'approved',
                type: 'bool'
            }
        ],
        name: 'setApprovalForAll',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        inputs: [
            {
                internalType: 'bytes4',
                name: 'interfaceId',
                type: 'bytes4'
            }
        ],
        name: 'supportsInterface',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256'
            }
        ],
        name: 'uri',
        outputs: [
            {
                internalType: 'string',
                name: '',
                type: 'string'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    }
];
const erc721Abi = [
    {
        type: 'event',
        name: 'Approval',
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address'
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address'
            },
            {
                indexed: true,
                name: 'tokenId',
                type: 'uint256'
            }
        ]
    },
    {
        type: 'event',
        name: 'ApprovalForAll',
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address'
            },
            {
                indexed: true,
                name: 'operator',
                type: 'address'
            },
            {
                indexed: false,
                name: 'approved',
                type: 'bool'
            }
        ]
    },
    {
        type: 'event',
        name: 'Transfer',
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address'
            },
            {
                indexed: true,
                name: 'to',
                type: 'address'
            },
            {
                indexed: true,
                name: 'tokenId',
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'approve',
        stateMutability: 'payable',
        inputs: [
            {
                name: 'spender',
                type: 'address'
            },
            {
                name: 'tokenId',
                type: 'uint256'
            }
        ],
        outputs: []
    },
    {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [
            {
                name: 'account',
                type: 'address'
            }
        ],
        outputs: [
            {
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'getApproved',
        stateMutability: 'view',
        inputs: [
            {
                name: 'tokenId',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                type: 'address'
            }
        ]
    },
    {
        type: 'function',
        name: 'isApprovedForAll',
        stateMutability: 'view',
        inputs: [
            {
                name: 'owner',
                type: 'address'
            },
            {
                name: 'operator',
                type: 'address'
            }
        ],
        outputs: [
            {
                type: 'bool'
            }
        ]
    },
    {
        type: 'function',
        name: 'name',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'string'
            }
        ]
    },
    {
        type: 'function',
        name: 'ownerOf',
        stateMutability: 'view',
        inputs: [
            {
                name: 'tokenId',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                name: 'owner',
                type: 'address'
            }
        ]
    },
    {
        type: 'function',
        name: 'safeTransferFrom',
        stateMutability: 'payable',
        inputs: [
            {
                name: 'from',
                type: 'address'
            },
            {
                name: 'to',
                type: 'address'
            },
            {
                name: 'tokenId',
                type: 'uint256'
            }
        ],
        outputs: []
    },
    {
        type: 'function',
        name: 'safeTransferFrom',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'from',
                type: 'address'
            },
            {
                name: 'to',
                type: 'address'
            },
            {
                name: 'id',
                type: 'uint256'
            },
            {
                name: 'data',
                type: 'bytes'
            }
        ],
        outputs: []
    },
    {
        type: 'function',
        name: 'setApprovalForAll',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'operator',
                type: 'address'
            },
            {
                name: 'approved',
                type: 'bool'
            }
        ],
        outputs: []
    },
    {
        type: 'function',
        name: 'symbol',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'string'
            }
        ]
    },
    {
        type: 'function',
        name: 'tokenByIndex',
        stateMutability: 'view',
        inputs: [
            {
                name: 'index',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'tokenByIndex',
        stateMutability: 'view',
        inputs: [
            {
                name: 'owner',
                type: 'address'
            },
            {
                name: 'index',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                name: 'tokenId',
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'tokenURI',
        stateMutability: 'view',
        inputs: [
            {
                name: 'tokenId',
                type: 'uint256'
            }
        ],
        outputs: [
            {
                type: 'string'
            }
        ]
    },
    {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint256'
            }
        ]
    },
    {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'payable',
        inputs: [
            {
                name: 'sender',
                type: 'address'
            },
            {
                name: 'recipient',
                type: 'address'
            },
            {
                name: 'tokeId',
                type: 'uint256'
            }
        ],
        outputs: []
    }
];
const erc4626Abi = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address'
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address'
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256'
            }
        ],
        name: 'Approval',
        type: 'event'
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'sender',
                type: 'address'
            },
            {
                indexed: true,
                name: 'receiver',
                type: 'address'
            },
            {
                indexed: false,
                name: 'assets',
                type: 'uint256'
            },
            {
                indexed: false,
                name: 'shares',
                type: 'uint256'
            }
        ],
        name: 'Deposit',
        type: 'event'
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address'
            },
            {
                indexed: true,
                name: 'to',
                type: 'address'
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256'
            }
        ],
        name: 'Transfer',
        type: 'event'
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'sender',
                type: 'address'
            },
            {
                indexed: true,
                name: 'receiver',
                type: 'address'
            },
            {
                indexed: true,
                name: 'owner',
                type: 'address'
            },
            {
                indexed: false,
                name: 'assets',
                type: 'uint256'
            },
            {
                indexed: false,
                name: 'shares',
                type: 'uint256'
            }
        ],
        name: 'Withdraw',
        type: 'event'
    },
    {
        inputs: [
            {
                name: 'owner',
                type: 'address'
            },
            {
                name: 'spender',
                type: 'address'
            }
        ],
        name: 'allowance',
        outputs: [
            {
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'spender',
                type: 'address'
            },
            {
                name: 'amount',
                type: 'uint256'
            }
        ],
        name: 'approve',
        outputs: [
            {
                type: 'bool'
            }
        ],
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        inputs: [],
        name: 'asset',
        outputs: [
            {
                name: 'assetTokenAddress',
                type: 'address'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'account',
                type: 'address'
            }
        ],
        name: 'balanceOf',
        outputs: [
            {
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'shares',
                type: 'uint256'
            }
        ],
        name: 'convertToAssets',
        outputs: [
            {
                name: 'assets',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'assets',
                type: 'uint256'
            }
        ],
        name: 'convertToShares',
        outputs: [
            {
                name: 'shares',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'assets',
                type: 'uint256'
            },
            {
                name: 'receiver',
                type: 'address'
            }
        ],
        name: 'deposit',
        outputs: [
            {
                name: 'shares',
                type: 'uint256'
            }
        ],
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'caller',
                type: 'address'
            }
        ],
        name: 'maxDeposit',
        outputs: [
            {
                name: 'maxAssets',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'caller',
                type: 'address'
            }
        ],
        name: 'maxMint',
        outputs: [
            {
                name: 'maxShares',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'owner',
                type: 'address'
            }
        ],
        name: 'maxRedeem',
        outputs: [
            {
                name: 'maxShares',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'owner',
                type: 'address'
            }
        ],
        name: 'maxWithdraw',
        outputs: [
            {
                name: 'maxAssets',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'shares',
                type: 'uint256'
            },
            {
                name: 'receiver',
                type: 'address'
            }
        ],
        name: 'mint',
        outputs: [
            {
                name: 'assets',
                type: 'uint256'
            }
        ],
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'assets',
                type: 'uint256'
            }
        ],
        name: 'previewDeposit',
        outputs: [
            {
                name: 'shares',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'shares',
                type: 'uint256'
            }
        ],
        name: 'previewMint',
        outputs: [
            {
                name: 'assets',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'shares',
                type: 'uint256'
            }
        ],
        name: 'previewRedeem',
        outputs: [
            {
                name: 'assets',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'assets',
                type: 'uint256'
            }
        ],
        name: 'previewWithdraw',
        outputs: [
            {
                name: 'shares',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'shares',
                type: 'uint256'
            },
            {
                name: 'receiver',
                type: 'address'
            },
            {
                name: 'owner',
                type: 'address'
            }
        ],
        name: 'redeem',
        outputs: [
            {
                name: 'assets',
                type: 'uint256'
            }
        ],
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        inputs: [],
        name: 'totalAssets',
        outputs: [
            {
                name: 'totalManagedAssets',
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [],
        name: 'totalSupply',
        outputs: [
            {
                type: 'uint256'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'to',
                type: 'address'
            },
            {
                name: 'amount',
                type: 'uint256'
            }
        ],
        name: 'transfer',
        outputs: [
            {
                type: 'bool'
            }
        ],
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'from',
                type: 'address'
            },
            {
                name: 'to',
                type: 'address'
            },
            {
                name: 'amount',
                type: 'uint256'
            }
        ],
        name: 'transferFrom',
        outputs: [
            {
                type: 'bool'
            }
        ],
        stateMutability: 'nonpayable',
        type: 'function'
    },
    {
        inputs: [
            {
                name: 'assets',
                type: 'uint256'
            },
            {
                name: 'receiver',
                type: 'address'
            },
            {
                name: 'owner',
                type: 'address'
            }
        ],
        name: 'withdraw',
        outputs: [
            {
                name: 'shares',
                type: 'uint256'
            }
        ],
        stateMutability: 'nonpayable',
        type: 'function'
    }
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"89z4d":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "aggregate3Signature", ()=>aggregate3Signature);
const aggregate3Signature = '0x82ad56cb';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3uCwC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "deploylessCallViaBytecodeBytecode", ()=>deploylessCallViaBytecodeBytecode);
parcelHelpers.export(exports, "deploylessCallViaFactoryBytecode", ()=>deploylessCallViaFactoryBytecode);
parcelHelpers.export(exports, "universalSignatureValidatorByteCode", ()=>universalSignatureValidatorByteCode);
const deploylessCallViaBytecodeBytecode = '0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe';
const deploylessCallViaFactoryBytecode = '0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe';
const universalSignatureValidatorByteCode = '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hiOFa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChainDoesNotSupportContract", ()=>ChainDoesNotSupportContract);
parcelHelpers.export(exports, "ChainMismatchError", ()=>ChainMismatchError);
parcelHelpers.export(exports, "ChainNotFoundError", ()=>ChainNotFoundError);
parcelHelpers.export(exports, "ClientChainNotConfiguredError", ()=>ClientChainNotConfiguredError);
parcelHelpers.export(exports, "InvalidChainIdError", ()=>InvalidChainIdError);
var _baseJs = require("./base.js");
class ChainDoesNotSupportContract extends (0, _baseJs.BaseError) {
    constructor({ blockNumber, chain, contract }){
        super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
            metaMessages: [
                'This could be due to any of the following:',
                ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
                    `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
                ] : [
                    `- The chain does not have the contract "${contract.name}" configured.`
                ]
            ],
            name: 'ChainDoesNotSupportContract'
        });
    }
}
class ChainMismatchError extends (0, _baseJs.BaseError) {
    constructor({ chain, currentChainId }){
        super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u{2013} ${chain.name}).`, {
            metaMessages: [
                `Current Chain ID:  ${currentChainId}`,
                `Expected Chain ID: ${chain.id} \u{2013} ${chain.name}`
            ],
            name: 'ChainMismatchError'
        });
    }
}
class ChainNotFoundError extends (0, _baseJs.BaseError) {
    constructor(){
        super([
            'No chain was provided to the request.',
            'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.'
        ].join('\n'), {
            name: 'ChainNotFoundError'
        });
    }
}
class ClientChainNotConfiguredError extends (0, _baseJs.BaseError) {
    constructor(){
        super('No chain was provided to the Client.', {
            name: 'ClientChainNotConfiguredError'
        });
    }
}
class InvalidChainIdError extends (0, _baseJs.BaseError) {
    constructor({ chainId }){
        super(typeof chainId === 'number' ? `Chain ID "${chainId}" is invalid.` : 'Chain ID is invalid.', {
            name: 'InvalidChainIdError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"55weO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeDeployData", ()=>encodeDeployData);
var _abiJs = require("../../errors/abi.js");
var _concatJs = require("../data/concat.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
const docsPath = '/docs/contract/encodeDeployData';
function encodeDeployData(parameters) {
    const { abi, args, bytecode } = parameters;
    if (!args || args.length === 0) return bytecode;
    const description = abi.find((x)=>'type' in x && x.type === 'constructor');
    if (!description) throw new (0, _abiJs.AbiConstructorNotFoundError)({
        docsPath
    });
    if (!('inputs' in description)) throw new (0, _abiJs.AbiConstructorParamsNotFoundError)({
        docsPath
    });
    if (!description.inputs || description.inputs.length === 0) throw new (0, _abiJs.AbiConstructorParamsNotFoundError)({
        docsPath
    });
    const data = (0, _encodeAbiParametersJs.encodeAbiParameters)(description.inputs, args);
    return (0, _concatJs.concatHex)([
        bytecode,
        data
    ]);
}

},{"../../errors/abi.js":"7l8j7","../data/concat.js":"6FL5K","./encodeAbiParameters.js":"8kHRc","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cNh6w":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getChainContractAddress", ()=>getChainContractAddress);
var _chainJs = require("../../errors/chain.js");
function getChainContractAddress({ blockNumber, chain, contract: name }) {
    const contract = chain?.contracts?.[name];
    if (!contract) throw new (0, _chainJs.ChainDoesNotSupportContract)({
        chain,
        contract: {
            name
        }
    });
    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber) throw new (0, _chainJs.ChainDoesNotSupportContract)({
        blockNumber,
        chain,
        contract: {
            name,
            blockCreated: contract.blockCreated
        }
    });
    return contract.address;
}

},{"../../errors/chain.js":"hiOFa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"14DML":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getCallError", ()=>getCallError);
var _contractJs = require("../../errors/contract.js");
var _nodeJs = require("../../errors/node.js");
var _getNodeErrorJs = require("./getNodeError.js");
function getCallError(err, { docsPath, ...args }) {
    const cause = (()=>{
        const cause = (0, _getNodeErrorJs.getNodeError)(err, args);
        if (cause instanceof (0, _nodeJs.UnknownNodeError)) return err;
        return cause;
    })();
    return new (0, _contractJs.CallExecutionError)(cause, {
        docsPath,
        ...args
    });
}

},{"../../errors/contract.js":"1S92K","../../errors/node.js":"9Ytun","./getNodeError.js":"7Fxo9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cXEx4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "createBatchScheduler", ()=>createBatchScheduler);
var _withResolversJs = require("./withResolvers.js");
const schedulerCache = /*#__PURE__*/ new Map();
function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort }) {
    const exec = async ()=>{
        const scheduler = getScheduler();
        flush();
        const args = scheduler.map(({ args })=>args);
        if (args.length === 0) return;
        fn(args).then((data)=>{
            if (sort && Array.isArray(data)) data.sort(sort);
            for(let i = 0; i < scheduler.length; i++){
                const { resolve } = scheduler[i];
                resolve?.([
                    data[i],
                    data
                ]);
            }
        }).catch((err)=>{
            for(let i = 0; i < scheduler.length; i++){
                const { reject } = scheduler[i];
                reject?.(err);
            }
        });
    };
    const flush = ()=>schedulerCache.delete(id);
    const getBatchedArgs = ()=>getScheduler().map(({ args })=>args);
    const getScheduler = ()=>schedulerCache.get(id) || [];
    const setScheduler = (item)=>schedulerCache.set(id, [
            ...getScheduler(),
            item
        ]);
    return {
        flush,
        async schedule (args) {
            const { promise, resolve, reject } = (0, _withResolversJs.withResolvers)();
            const split = shouldSplitBatch?.([
                ...getBatchedArgs(),
                args
            ]);
            if (split) exec();
            const hasActiveScheduler = getScheduler().length > 0;
            if (hasActiveScheduler) {
                setScheduler({
                    args,
                    resolve,
                    reject
                });
                return promise;
            }
            setScheduler({
                args,
                resolve,
                reject
            });
            setTimeout(exec, wait);
            return promise;
        }
    };
}

},{"./withResolvers.js":"5yXnT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5yXnT":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "withResolvers", ()=>withResolvers);
function withResolvers() {
    let resolve = ()=>undefined;
    let reject = ()=>undefined;
    const promise = new Promise((resolve_, reject_)=>{
        resolve = resolve_;
        reject = reject_;
    });
    return {
        promise,
        resolve,
        reject
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8jhUy":[function(require,module,exports,__globalThis) {
module.exports = Promise.resolve(module.bundle.root("1rHaX"));

},{"1rHaX":"1rHaX"}],"3yzsB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Simulates/validates a contract interaction. This is useful for retrieving **return data** and **revert reasons** of contract write functions.
 *
 * - Docs: https://viem.sh/docs/contract/simulateContract
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts
 *
 * This function does not require gas to execute and _**does not**_ change the state of the blockchain. It is almost identical to [`readContract`](https://viem.sh/docs/contract/readContract), but also supports contract write functions.
 *
 * Internally, uses a [Public Client](https://viem.sh/docs/clients/public) to call the [`call` action](https://viem.sh/docs/actions/public/call) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
 *
 * @param client - Client to use
 * @param parameters - {@link SimulateContractParameters}
 * @returns The simulation result and write request. {@link SimulateContractReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { simulateContract } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const result = await simulateContract(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function mint(uint32) view returns (uint32)']),
 *   functionName: 'mint',
 *   args: ['69420'],
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 */ parcelHelpers.export(exports, "simulateContract", ()=>simulateContract);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getContractErrorJs = require("../../utils/errors/getContractError.js");
var _getActionJs = require("../../utils/getAction.js");
var _callJs = require("./call.js");
async function simulateContract(client, parameters) {
    const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;
    const account = callRequest.account ? (0, _parseAccountJs.parseAccount)(callRequest.account) : client.account;
    const calldata = (0, _encodeFunctionDataJs.encodeFunctionData)({
        abi,
        args,
        functionName
    });
    try {
        const { data } = await (0, _getActionJs.getAction)(client, (0, _callJs.call), 'call')({
            batch: false,
            data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
            to: address,
            ...callRequest,
            account
        });
        const result = (0, _decodeFunctionResultJs.decodeFunctionResult)({
            abi,
            args,
            functionName,
            data: data || '0x'
        });
        const minimizedAbi = abi.filter((abiItem)=>'name' in abiItem && abiItem.name === parameters.functionName);
        return {
            result,
            request: {
                abi: minimizedAbi,
                address,
                args,
                dataSuffix,
                functionName,
                ...callRequest,
                account
            }
        };
    } catch (error) {
        throw (0, _getContractErrorJs.getContractError)(error, {
            abi,
            address,
            args,
            docsPath: '/docs/contract/simulateContract',
            functionName,
            sender: account?.address
        });
    }
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../utils/abi/decodeFunctionResult.js":"j76hM","../../utils/abi/encodeFunctionData.js":"eQLEb","../../utils/errors/getContractError.js":"kESZV","../../utils/getAction.js":"d1Bvd","./call.js":"85xZD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jxMap":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Watches and returns emitted contract event logs.
 *
 * - Docs: https://viem.sh/docs/contract/watchContractEvent
 *
 * This Action will batch up all the event logs found within the [`pollingInterval`](https://viem.sh/docs/contract/watchContractEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/contract/watchContractEvent#onLogs).
 *
 * `watchContractEvent` will attempt to create an [Event Filter](https://viem.sh/docs/contract/createContractEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchContractEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.
 *
 * @param client - Client to use
 * @param parameters - {@link WatchContractEventParameters}
 * @returns A function that can be invoked to stop watching for new event logs. {@link WatchContractEventReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { watchContractEvent } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const unwatch = watchContractEvent(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['event Transfer(address indexed from, address indexed to, uint256 value)']),
 *   eventName: 'Transfer',
 *   args: { from: '0xc961145a54C96E3aE9bAA048c4F4D6b04C13916b' },
 *   onLogs: (logs) => console.log(logs),
 * })
 */ parcelHelpers.export(exports, "watchContractEvent", ()=>watchContractEvent);
var _abiJs = require("../../errors/abi.js");
var _rpcJs = require("../../errors/rpc.js");
var _decodeEventLogJs = require("../../utils/abi/decodeEventLog.js");
var _encodeEventTopicsJs = require("../../utils/abi/encodeEventTopics.js");
var _logJs = require("../../utils/formatters/log.js");
var _getActionJs = require("../../utils/getAction.js");
var _observeJs = require("../../utils/observe.js");
var _pollJs = require("../../utils/poll.js");
var _stringifyJs = require("../../utils/stringify.js");
var _createContractEventFilterJs = require("./createContractEventFilter.js");
var _getBlockNumberJs = require("./getBlockNumber.js");
var _getContractEventsJs = require("./getContractEvents.js");
var _getFilterChangesJs = require("./getFilterChanges.js");
var _uninstallFilterJs = require("./uninstallFilter.js");
function watchContractEvent(client, parameters) {
    const { abi, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
    const enablePolling = (()=>{
        if (typeof poll_ !== 'undefined') return poll_;
        if (typeof fromBlock === 'bigint') return true;
        if (client.transport.type === 'webSocket') return false;
        if (client.transport.type === 'fallback' && client.transport.transports[0].config.type === 'webSocket') return false;
        return true;
    })();
    const pollContractEvent = ()=>{
        const strict = strict_ ?? false;
        const observerId = (0, _stringifyJs.stringify)([
            'watchContractEvent',
            address,
            args,
            batch,
            client.uid,
            eventName,
            pollingInterval,
            strict,
            fromBlock
        ]);
        return (0, _observeJs.observe)(observerId, {
            onLogs,
            onError
        }, (emit)=>{
            let previousBlockNumber;
            if (fromBlock !== undefined) previousBlockNumber = fromBlock - 1n;
            let filter;
            let initialized = false;
            const unwatch = (0, _pollJs.poll)(async ()=>{
                if (!initialized) {
                    try {
                        filter = await (0, _getActionJs.getAction)(client, (0, _createContractEventFilterJs.createContractEventFilter), 'createContractEventFilter')({
                            abi,
                            address,
                            args: args,
                            eventName: eventName,
                            strict: strict,
                            fromBlock
                        });
                    } catch  {}
                    initialized = true;
                    return;
                }
                try {
                    let logs;
                    if (filter) logs = await (0, _getActionJs.getAction)(client, (0, _getFilterChangesJs.getFilterChanges), 'getFilterChanges')({
                        filter
                    });
                    else {
                        // If the filter doesn't exist, we will fall back to use `getLogs`.
                        // The fall back exists because some RPC Providers do not support filters.
                        // Fetch the block number to use for `getLogs`.
                        const blockNumber = await (0, _getActionJs.getAction)(client, (0, _getBlockNumberJs.getBlockNumber), 'getBlockNumber')({});
                        // If the block number has changed, we will need to fetch the logs.
                        // If the block number doesn't exist, we are yet to reach the first poll interval,
                        // so do not emit any logs.
                        if (previousBlockNumber && previousBlockNumber < blockNumber) logs = await (0, _getActionJs.getAction)(client, (0, _getContractEventsJs.getContractEvents), 'getContractEvents')({
                            abi,
                            address,
                            args,
                            eventName,
                            fromBlock: previousBlockNumber + 1n,
                            toBlock: blockNumber,
                            strict
                        });
                        else logs = [];
                        previousBlockNumber = blockNumber;
                    }
                    if (logs.length === 0) return;
                    if (batch) emit.onLogs(logs);
                    else for (const log of logs)emit.onLogs([
                        log
                    ]);
                } catch (err) {
                    // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.
                    // Reinitialize the filter when this occurs
                    if (filter && err instanceof (0, _rpcJs.InvalidInputRpcError)) initialized = false;
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval
            });
            return async ()=>{
                if (filter) await (0, _getActionJs.getAction)(client, (0, _uninstallFilterJs.uninstallFilter), 'uninstallFilter')({
                    filter
                });
                unwatch();
            };
        });
    };
    const subscribeContractEvent = ()=>{
        const strict = strict_ ?? false;
        const observerId = (0, _stringifyJs.stringify)([
            'watchContractEvent',
            address,
            args,
            batch,
            client.uid,
            eventName,
            pollingInterval,
            strict
        ]);
        let active = true;
        let unsubscribe = ()=>active = false;
        return (0, _observeJs.observe)(observerId, {
            onLogs,
            onError
        }, (emit)=>{
            (async ()=>{
                try {
                    const transport = (()=>{
                        if (client.transport.type === 'fallback') {
                            const transport = client.transport.transports.find((transport)=>transport.config.type === 'webSocket');
                            if (!transport) return client.transport;
                            return transport.value;
                        }
                        return client.transport;
                    })();
                    const topics = eventName ? (0, _encodeEventTopicsJs.encodeEventTopics)({
                        abi: abi,
                        eventName: eventName,
                        args
                    }) : [];
                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({
                        params: [
                            'logs',
                            {
                                address,
                                topics
                            }
                        ],
                        onData (data) {
                            if (!active) return;
                            const log = data.result;
                            try {
                                const { eventName, args } = (0, _decodeEventLogJs.decodeEventLog)({
                                    abi: abi,
                                    data: log.data,
                                    topics: log.topics,
                                    strict: strict_
                                });
                                const formatted = (0, _logJs.formatLog)(log, {
                                    args,
                                    eventName: eventName
                                });
                                emit.onLogs([
                                    formatted
                                ]);
                            } catch (err) {
                                let eventName;
                                let isUnnamed;
                                if (err instanceof (0, _abiJs.DecodeLogDataMismatch) || err instanceof (0, _abiJs.DecodeLogTopicsMismatch)) {
                                    // If strict mode is on, and log data/topics do not match event definition, skip.
                                    if (strict_) return;
                                    eventName = err.abiItem.name;
                                    isUnnamed = err.abiItem.inputs?.some((x)=>!('name' in x && x.name));
                                }
                                // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).
                                const formatted = (0, _logJs.formatLog)(log, {
                                    args: isUnnamed ? [] : {},
                                    eventName
                                });
                                emit.onLogs([
                                    formatted
                                ]);
                            }
                        },
                        onError (error) {
                            emit.onError?.(error);
                        }
                    });
                    unsubscribe = unsubscribe_;
                    if (!active) unsubscribe();
                } catch (err) {
                    onError?.(err);
                }
            })();
            return ()=>unsubscribe();
        });
    };
    return enablePolling ? pollContractEvent() : subscribeContractEvent();
}

},{"../../errors/abi.js":"7l8j7","../../errors/rpc.js":"jYSPv","../../utils/abi/decodeEventLog.js":"8uUoF","../../utils/abi/encodeEventTopics.js":"7zHy3","../../utils/formatters/log.js":"aaYKq","../../utils/getAction.js":"d1Bvd","../../utils/observe.js":"3BbFn","../../utils/poll.js":"6Dkrj","../../utils/stringify.js":"jKcjI","./createContractEventFilter.js":"aZFsp","./getBlockNumber.js":"hY1Hu","./getContractEvents.js":"8aoKV","./getFilterChanges.js":"6g1rZ","./uninstallFilter.js":"Yq58O","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3BbFn":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "listenersCache", ()=>listenersCache);
parcelHelpers.export(exports, "cleanupCache", ()=>cleanupCache);
/**
 * @description Sets up an observer for a given function. If another function
 * is set up under the same observer id, the function will only be called once
 * for both instances of the observer.
 */ parcelHelpers.export(exports, "observe", ()=>observe);
const listenersCache = /*#__PURE__*/ new Map();
const cleanupCache = /*#__PURE__*/ new Map();
let callbackCount = 0;
function observe(observerId, callbacks, fn) {
    const callbackId = ++callbackCount;
    const getListeners = ()=>listenersCache.get(observerId) || [];
    const unsubscribe = ()=>{
        const listeners = getListeners();
        listenersCache.set(observerId, listeners.filter((cb)=>cb.id !== callbackId));
    };
    const unwatch = ()=>{
        const listeners = getListeners();
        if (!listeners.some((cb)=>cb.id === callbackId)) return;
        const cleanup = cleanupCache.get(observerId);
        if (listeners.length === 1 && cleanup) cleanup();
        unsubscribe();
    };
    const listeners = getListeners();
    listenersCache.set(observerId, [
        ...listeners,
        {
            id: callbackId,
            fns: callbacks
        }
    ]);
    if (listeners && listeners.length > 0) return unwatch;
    const emit = {};
    for(const key in callbacks)emit[key] = (...args)=>{
        const listeners = getListeners();
        if (listeners.length === 0) return;
        for (const listener of listeners)listener.fns[key]?.(...args);
    };
    const cleanup = fn(emit);
    if (typeof cleanup === 'function') cleanupCache.set(observerId, cleanup);
    return unwatch;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6Dkrj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Polls a function at a specified interval.
 */ parcelHelpers.export(exports, "poll", ()=>poll);
var _waitJs = require("./wait.js");
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
    let active = true;
    const unwatch = ()=>active = false;
    const watch = async ()=>{
        let data = undefined;
        if (emitOnBegin) data = await fn({
            unpoll: unwatch
        });
        const initialWait = await initialWaitTime?.(data) ?? interval;
        await (0, _waitJs.wait)(initialWait);
        const poll = async ()=>{
            if (!active) return;
            await fn({
                unpoll: unwatch
            });
            await (0, _waitJs.wait)(interval);
            poll();
        };
        poll();
    };
    watch();
    return unwatch;
}

},{"./wait.js":"hnFJl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hnFJl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wait", ()=>wait);
async function wait(time) {
    return new Promise((res)=>setTimeout(res, time));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hY1Hu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "getBlockNumberCache", ()=>getBlockNumberCache);
/**
 * Returns the number of the most recent block seen.
 *
 * - Docs: https://viem.sh/docs/actions/public/getBlockNumber
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_fetching-blocks
 * - JSON-RPC Methods: [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber)
 *
 * @param client - Client to use
 * @param parameters - {@link GetBlockNumberParameters}
 * @returns The number of the block. {@link GetBlockNumberReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBlockNumber } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const blockNumber = await getBlockNumber(client)
 * // 69420n
 */ parcelHelpers.export(exports, "getBlockNumber", ()=>getBlockNumber);
var _withCacheJs = require("../../utils/promise/withCache.js");
const cacheKey = (id)=>`blockNumber.${id}`;
function getBlockNumberCache(id) {
    return (0, _withCacheJs.getCache)(cacheKey(id));
}
async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
    const blockNumberHex = await (0, _withCacheJs.withCache)(()=>client.request({
            method: 'eth_blockNumber'
        }), {
        cacheKey: cacheKey(client.uid),
        cacheTime
    });
    return BigInt(blockNumberHex);
}

},{"../../utils/promise/withCache.js":"7jin2","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7jin2":[function(require,module,exports,__globalThis) {
/** @internal */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "promiseCache", ()=>promiseCache);
parcelHelpers.export(exports, "responseCache", ()=>responseCache);
parcelHelpers.export(exports, "getCache", ()=>getCache);
/**
 * @description Returns the result of a given promise, and caches the result for
 * subsequent invocations against a provided cache key.
 */ parcelHelpers.export(exports, "withCache", ()=>withCache);
const promiseCache = /*#__PURE__*/ new Map();
const responseCache = /*#__PURE__*/ new Map();
function getCache(cacheKey) {
    const buildCache = (cacheKey, cache)=>({
            clear: ()=>cache.delete(cacheKey),
            get: ()=>cache.get(cacheKey),
            set: (data)=>cache.set(cacheKey, data)
        });
    const promise = buildCache(cacheKey, promiseCache);
    const response = buildCache(cacheKey, responseCache);
    return {
        clear: ()=>{
            promise.clear();
            response.clear();
        },
        promise,
        response
    };
}
async function withCache(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {
    const cache = getCache(cacheKey);
    // If a response exists in the cache, and it's not expired, return it
    // and do not invoke the promise.
    // If the max age is 0, the cache is disabled.
    const response = cache.response.get();
    if (response && cacheTime > 0) {
        const age = new Date().getTime() - response.created.getTime();
        if (age < cacheTime) return response.data;
    }
    let promise = cache.promise.get();
    if (!promise) {
        promise = fn();
        // Store the promise in the cache so that subsequent invocations
        // will wait for the same promise to resolve (deduping).
        cache.promise.set(promise);
    }
    try {
        const data = await promise;
        // Store the response in the cache so that subsequent invocations
        // will return the same response.
        cache.response.set({
            created: new Date(),
            data
        });
        return data;
    } finally{
        // Clear the promise cache so that subsequent invocations will
        // invoke the promise again.
        cache.promise.clear();
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6g1rZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of logs or hashes based on a [Filter](/docs/glossary/terms#filter) since the last time it was called.
 *
 * - Docs: https://viem.sh/docs/actions/public/getFilterChanges
 * - JSON-RPC Methods: [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges)
 *
 * A Filter can be created from the following actions:
 *
 * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter)
 * - [`createContractEventFilter`](https://viem.sh/docs/contract/createContractEventFilter)
 * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter)
 * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter)
 *
 * Depending on the type of filter, the return value will be different:
 *
 * - If the filter was created with `createContractEventFilter` or `createEventFilter`, it returns a list of logs.
 * - If the filter was created with `createPendingTransactionFilter`, it returns a list of transaction hashes.
 * - If the filter was created with `createBlockFilter`, it returns a list of block hashes.
 *
 * @param client - Client to use
 * @param parameters - {@link GetFilterChangesParameters}
 * @returns Logs or hashes. {@link GetFilterChangesReturnType}
 *
 * @example
 * // Blocks
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createBlockFilter, getFilterChanges } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createBlockFilter(client)
 * const hashes = await getFilterChanges(client, { filter })
 *
 * @example
 * // Contract Events
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createContractEventFilter, getFilterChanges } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createContractEventFilter(client, {
 *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
 *   abi: parseAbi(['event Transfer(address indexed, address indexed, uint256)']),
 *   eventName: 'Transfer',
 * })
 * const logs = await getFilterChanges(client, { filter })
 *
 * @example
 * // Raw Events
 * import { createPublicClient, http, parseAbiItem } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createEventFilter, getFilterChanges } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createEventFilter(client, {
 *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
 *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),
 * })
 * const logs = await getFilterChanges(client, { filter })
 *
 * @example
 * // Transactions
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createPendingTransactionFilter, getFilterChanges } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createPendingTransactionFilter(client)
 * const hashes = await getFilterChanges(client, { filter })
 */ parcelHelpers.export(exports, "getFilterChanges", ()=>getFilterChanges);
var _parseEventLogsJs = require("../../utils/abi/parseEventLogs.js");
var _logJs = require("../../utils/formatters/log.js");
async function getFilterChanges(_client, { filter }) {
    const strict = 'strict' in filter && filter.strict;
    const logs = await filter.request({
        method: 'eth_getFilterChanges',
        params: [
            filter.id
        ]
    });
    if (typeof logs[0] === 'string') return logs;
    const formattedLogs = logs.map((log)=>(0, _logJs.formatLog)(log));
    if (!('abi' in filter) || !filter.abi) return formattedLogs;
    return (0, _parseEventLogsJs.parseEventLogs)({
        abi: filter.abi,
        logs: formattedLogs,
        strict
    });
}

},{"../../utils/abi/parseEventLogs.js":"3coRk","../../utils/formatters/log.js":"aaYKq","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"Yq58O":[function(require,module,exports,__globalThis) {
/**
 * Destroys a [`Filter`](https://viem.sh/docs/glossary/types#filter).
 *
 * - Docs: https://viem.sh/docs/actions/public/uninstallFilter
 * - JSON-RPC Methods: [`eth_uninstallFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_uninstallFilter)
 *
 * Destroys a Filter that was created from one of the following Actions:
 * - [`createBlockFilter`](https://viem.sh/docs/actions/public/createBlockFilter)
 * - [`createEventFilter`](https://viem.sh/docs/actions/public/createEventFilter)
 * - [`createPendingTransactionFilter`](https://viem.sh/docs/actions/public/createPendingTransactionFilter)
 *
 * @param client - Client to use
 * @param parameters - {@link UninstallFilterParameters}
 * @returns A boolean indicating if the Filter was successfully uninstalled. {@link UninstallFilterReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createPendingTransactionFilter, uninstallFilter } from 'viem/public'
 *
 * const filter = await createPendingTransactionFilter(client)
 * const uninstalled = await uninstallFilter(client, { filter })
 * // true
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uninstallFilter", ()=>uninstallFilter);
async function uninstallFilter(_client, { filter }) {
    return filter.request({
        method: 'eth_uninstallFilter',
        params: [
            filter.id
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"FOZdN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Executes a write function on a contract.
 *
 * - Docs: https://viem.sh/docs/contract/writeContract
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_writing-to-contracts
 *
 * A "write" function on a Solidity contract modifies the state of the blockchain. These types of functions require gas to be executed, and hence a [Transaction](https://viem.sh/docs/glossary/terms) is needed to be broadcast in order to change the state.
 *
 * Internally, uses a [Wallet Client](https://viem.sh/docs/clients/wallet) to call the [`sendTransaction` action](https://viem.sh/docs/actions/wallet/sendTransaction) with [ABI-encoded `data`](https://viem.sh/docs/contract/encodeFunctionData).
 *
 * __Warning: The `write` internally sends a transaction  it does not validate if the contract write will succeed (the contract may throw an error). It is highly recommended to [simulate the contract write with `contract.simulate`](https://viem.sh/docs/contract/writeContract#usage) before you execute it.__
 *
 * @param client - Client to use
 * @param parameters - {@link WriteContractParameters}
 * @returns A [Transaction Hash](https://viem.sh/docs/glossary/terms#hash). {@link WriteContractReturnType}
 *
 * @example
 * import { createWalletClient, custom, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { writeContract } from 'viem/contract'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const hash = await writeContract(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),
 *   functionName: 'mint',
 *   args: [69420],
 * })
 *
 * @example
 * // With Validation
 * import { createWalletClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { simulateContract, writeContract } from 'viem/contract'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const { request } = await simulateContract(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   abi: parseAbi(['function mint(uint32 tokenId) nonpayable']),
 *   functionName: 'mint',
 *   args: [69420],
 * }
 * const hash = await writeContract(client, request)
 */ parcelHelpers.export(exports, "writeContract", ()=>writeContract);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getContractErrorJs = require("../../utils/errors/getContractError.js");
var _getActionJs = require("../../utils/getAction.js");
var _sendTransactionJs = require("./sendTransaction.js");
async function writeContract(client, parameters) {
    const { abi, account: account_ = client.account, address, args, dataSuffix, functionName, ...request } = parameters;
    if (typeof account_ === 'undefined') throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: '/docs/contract/writeContract'
    });
    const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : null;
    const data = (0, _encodeFunctionDataJs.encodeFunctionData)({
        abi,
        args,
        functionName
    });
    try {
        return await (0, _getActionJs.getAction)(client, (0, _sendTransactionJs.sendTransaction), 'sendTransaction')({
            data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
            to: address,
            account,
            ...request
        });
    } catch (error) {
        throw (0, _getContractErrorJs.getContractError)(error, {
            abi,
            address,
            args,
            docsPath: '/docs/contract/writeContract',
            functionName,
            sender: account?.address
        });
    }
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../errors/account.js":"39pf0","../../utils/abi/encodeFunctionData.js":"eQLEb","../../utils/errors/getContractError.js":"kESZV","../../utils/getAction.js":"d1Bvd","./sendTransaction.js":"910Bd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"39pf0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AccountNotFoundError", ()=>AccountNotFoundError);
parcelHelpers.export(exports, "AccountTypeNotSupportedError", ()=>AccountTypeNotSupportedError);
var _baseJs = require("./base.js");
class AccountNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ docsPath } = {}){
        super([
            'Could not find an Account to execute with this Action.',
            'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.'
        ].join('\n'), {
            docsPath,
            docsSlug: 'account',
            name: 'AccountNotFoundError'
        });
    }
}
class AccountTypeNotSupportedError extends (0, _baseJs.BaseError) {
    constructor({ docsPath, metaMessages, type }){
        super(`Account type "${type}" is not supported.`, {
            docsPath,
            metaMessages,
            name: 'AccountTypeNotSupportedError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"910Bd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates, signs, and sends a new transaction to the network.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/sendTransaction
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`eth_sendTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendtransaction)
 *   - Local Accounts: [`eth_sendRawTransaction`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_sendrawtransaction)
 *
 * @param client - Client to use
 * @param parameters - {@link SendTransactionParameters}
 * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link SendTransactionReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { sendTransaction } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const hash = await sendTransaction(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *   value: 1000000000000000000n,
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { sendTransaction } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const hash = await sendTransaction(client, {
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *   value: 1000000000000000000n,
 * })
 */ parcelHelpers.export(exports, "sendTransaction", ()=>sendTransaction);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _baseJs = require("../../errors/base.js");
var _recoverAuthorizationAddressJs = require("../../utils/authorization/recoverAuthorizationAddress.js");
var _assertCurrentChainJs = require("../../utils/chain/assertCurrentChain.js");
var _getTransactionErrorJs = require("../../utils/errors/getTransactionError.js");
var _extractJs = require("../../utils/formatters/extract.js");
var _transactionRequestJs = require("../../utils/formatters/transactionRequest.js");
var _getActionJs = require("../../utils/getAction.js");
var _lruJs = require("../../utils/lru.js");
var _assertRequestJs = require("../../utils/transaction/assertRequest.js");
var _getChainIdJs = require("../public/getChainId.js");
var _prepareTransactionRequestJs = require("./prepareTransactionRequest.js");
var _sendRawTransactionJs = require("./sendRawTransaction.js");
const supportsWalletNamespace = new (0, _lruJs.LruMap)(128);
async function sendTransaction(client, parameters) {
    const { account: account_ = client.account, chain = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, type, value, ...rest } = parameters;
    if (typeof account_ === 'undefined') throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: '/docs/actions/wallet/sendTransaction'
    });
    const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : null;
    try {
        (0, _assertRequestJs.assertRequest)(parameters);
        const to = await (async ()=>{
            // If `to` exists on the parameters, use that.
            if (parameters.to) return parameters.to;
            // If `to` is null, we are sending a deployment transaction.
            if (parameters.to === null) return undefined;
            // If no `to` exists, and we are sending a EIP-7702 transaction, use the
            // address of the first authorization in the list.
            if (authorizationList && authorizationList.length > 0) return await (0, _recoverAuthorizationAddressJs.recoverAuthorizationAddress)({
                authorization: authorizationList[0]
            }).catch(()=>{
                throw new (0, _baseJs.BaseError)('`to` is required. Could not infer from `authorizationList`.');
            });
            // Otherwise, we are sending a deployment transaction.
            return undefined;
        })();
        if (account?.type === 'json-rpc' || account === null) {
            let chainId;
            if (chain !== null) {
                chainId = await (0, _getActionJs.getAction)(client, (0, _getChainIdJs.getChainId), 'getChainId')({});
                (0, _assertCurrentChainJs.assertCurrentChain)({
                    currentChainId: chainId,
                    chain
                });
            }
            const chainFormat = client.chain?.formatters?.transactionRequest?.format;
            const format = chainFormat || (0, _transactionRequestJs.formatTransactionRequest);
            const request = format({
                // Pick out extra data that might exist on the chain's transaction request type.
                ...(0, _extractJs.extract)(rest, {
                    format: chainFormat
                }),
                accessList,
                authorizationList,
                blobs,
                chainId,
                data,
                from: account?.address,
                gas,
                gasPrice,
                maxFeePerBlobGas,
                maxFeePerGas,
                maxPriorityFeePerGas,
                nonce,
                to,
                type,
                value
            });
            const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);
            const method = isWalletNamespaceSupported ? 'wallet_sendTransaction' : 'eth_sendTransaction';
            try {
                return await client.request({
                    method,
                    params: [
                        request
                    ]
                }, {
                    retryCount: 0
                });
            } catch (e) {
                if (isWalletNamespaceSupported === false) throw e;
                const error = e;
                // If the transport does not support the method or input, attempt to use the
                // `wallet_sendTransaction` method.
                if (error.name === 'InvalidInputRpcError' || error.name === 'InvalidParamsRpcError' || error.name === 'MethodNotFoundRpcError' || error.name === 'MethodNotSupportedRpcError') return await client.request({
                    method: 'wallet_sendTransaction',
                    params: [
                        request
                    ]
                }, {
                    retryCount: 0
                }).then((hash)=>{
                    supportsWalletNamespace.set(client.uid, true);
                    return hash;
                }).catch((e)=>{
                    const walletNamespaceError = e;
                    if (walletNamespaceError.name === 'MethodNotFoundRpcError' || walletNamespaceError.name === 'MethodNotSupportedRpcError') {
                        supportsWalletNamespace.set(client.uid, false);
                        throw error;
                    }
                    throw walletNamespaceError;
                });
                throw error;
            }
        }
        if (account?.type === 'local') {
            // Prepare the request for signing (assign appropriate fees, etc.)
            const request = await (0, _getActionJs.getAction)(client, (0, _prepareTransactionRequestJs.prepareTransactionRequest), 'prepareTransactionRequest')({
                account,
                accessList,
                authorizationList,
                blobs,
                chain,
                data,
                gas,
                gasPrice,
                maxFeePerBlobGas,
                maxFeePerGas,
                maxPriorityFeePerGas,
                nonce,
                nonceManager: account.nonceManager,
                parameters: [
                    ...(0, _prepareTransactionRequestJs.defaultParameters),
                    'sidecars'
                ],
                type,
                value,
                ...rest,
                to
            });
            const serializer = chain?.serializers?.transaction;
            const serializedTransaction = await account.signTransaction(request, {
                serializer
            });
            return await (0, _getActionJs.getAction)(client, (0, _sendRawTransactionJs.sendRawTransaction), 'sendRawTransaction')({
                serializedTransaction
            });
        }
        if (account?.type === 'smart') throw new (0, _accountJs.AccountTypeNotSupportedError)({
            metaMessages: [
                'Consider using the `sendUserOperation` Action instead.'
            ],
            docsPath: '/docs/actions/bundler/sendUserOperation',
            type: 'smart'
        });
        throw new (0, _accountJs.AccountTypeNotSupportedError)({
            docsPath: '/docs/actions/wallet/sendTransaction',
            type: account?.type
        });
    } catch (err) {
        if (err instanceof (0, _accountJs.AccountTypeNotSupportedError)) throw err;
        throw (0, _getTransactionErrorJs.getTransactionError)(err, {
            ...parameters,
            account,
            chain: parameters.chain || undefined
        });
    }
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../errors/account.js":"39pf0","../../errors/base.js":"3SEPF","../../utils/authorization/recoverAuthorizationAddress.js":"3ciAa","../../utils/chain/assertCurrentChain.js":"g3OLr","../../utils/errors/getTransactionError.js":"9QQWW","../../utils/formatters/extract.js":"g9KS8","../../utils/formatters/transactionRequest.js":"dLljr","../../utils/getAction.js":"d1Bvd","../../utils/lru.js":"ibK3x","../../utils/transaction/assertRequest.js":"eSiKr","../public/getChainId.js":"lXOca","./prepareTransactionRequest.js":"53wjM","./sendRawTransaction.js":"6SNuf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g3OLr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assertCurrentChain", ()=>assertCurrentChain);
var _chainJs = require("../../errors/chain.js");
function assertCurrentChain({ chain, currentChainId }) {
    if (!chain) throw new (0, _chainJs.ChainNotFoundError)();
    if (currentChainId !== chain.id) throw new (0, _chainJs.ChainMismatchError)({
        chain,
        currentChainId
    });
}

},{"../../errors/chain.js":"hiOFa","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9QQWW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getTransactionError", ()=>getTransactionError);
var _nodeJs = require("../../errors/node.js");
var _transactionJs = require("../../errors/transaction.js");
var _getNodeErrorJs = require("./getNodeError.js");
function getTransactionError(err, { docsPath, ...args }) {
    const cause = (()=>{
        const cause = (0, _getNodeErrorJs.getNodeError)(err, args);
        if (cause instanceof (0, _nodeJs.UnknownNodeError)) return err;
        return cause;
    })();
    return new (0, _transactionJs.TransactionExecutionError)(cause, {
        docsPath,
        ...args
    });
}

},{"../../errors/node.js":"9Ytun","../../errors/transaction.js":"4gFzr","./getNodeError.js":"7Fxo9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6SNuf":[function(require,module,exports,__globalThis) {
/**
 * Sends a **signed** transaction to the network
 *
 * - Docs: https://viem.sh/docs/actions/wallet/sendRawTransaction
 * - JSON-RPC Method: [`eth_sendRawTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)
 *
 * @param client - Client to use
 * @param parameters - {@link SendRawTransactionParameters}
 * @returns The transaction hash. {@link SendRawTransactionReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { sendRawTransaction } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 *
 * const hash = await sendRawTransaction(client, {
 *   serializedTransaction: '0x02f850018203118080825208808080c080a04012522854168b27e5dc3d5839bab5e6b39e1a0ffd343901ce1622e3d64b48f1a04e00902ae0502c4728cbf12156290df99c3ed7de85b1dbfe20b5c36931733a33'
 * })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sendRawTransaction", ()=>sendRawTransaction);
async function sendRawTransaction(client, { serializedTransaction }) {
    return client.request({
        method: 'eth_sendRawTransaction',
        params: [
            serializedTransaction
        ]
    }, {
        retryCount: 0
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hSeJ1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Waits for the status & receipts of a call bundle that was sent via `sendCalls`.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/waitForCallsStatus
 * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)
 *
 * @param client - Client to use
 * @param parameters - {@link WaitForCallsStatusParameters}
 * @returns Status & receipts of the call bundle. {@link WaitForCallsStatusReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { waitForCallsStatus } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 *
 * const { receipts, status } = await waitForCallsStatus(client, { id: '0xdeadbeef' })
 */ parcelHelpers.export(exports, "waitForCallsStatus", ()=>waitForCallsStatus);
parcelHelpers.export(exports, "WaitForCallsStatusTimeoutError", ()=>WaitForCallsStatusTimeoutError);
var _baseJs = require("../../errors/base.js");
var _observeJs = require("../../utils/observe.js");
var _pollJs = require("../../utils/poll.js");
var _withResolversJs = require("../../utils/promise/withResolvers.js");
var _stringifyJs = require("../../utils/stringify.js");
var _getCallsStatusJs = require("./getCallsStatus.js");
async function waitForCallsStatus(client, parameters) {
    const { id, pollingInterval = client.pollingInterval, status = ({ statusCode })=>statusCode >= 200, timeout = 60000 } = parameters;
    const observerId = (0, _stringifyJs.stringify)([
        'waitForCallsStatus',
        client.uid,
        id
    ]);
    const { promise, resolve, reject } = (0, _withResolversJs.withResolvers)();
    let timer = undefined;
    const unobserve = (0, _observeJs.observe)(observerId, {
        resolve,
        reject
    }, (emit)=>{
        const unpoll = (0, _pollJs.poll)(async ()=>{
            const done = (fn)=>{
                clearTimeout(timer);
                unpoll();
                fn();
                unobserve();
            };
            try {
                const result = await (0, _getCallsStatusJs.getCallsStatus)(client, {
                    id
                });
                if (!status(result)) return;
                done(()=>emit.resolve(result));
            } catch (error) {
                done(()=>emit.reject(error));
            }
        }, {
            interval: pollingInterval,
            emitOnBegin: true
        });
        return unpoll;
    });
    timer = timeout ? setTimeout(()=>{
        unobserve();
        clearTimeout(timer);
        reject(new WaitForCallsStatusTimeoutError({
            id
        }));
    }, timeout) : undefined;
    return await promise;
}
class WaitForCallsStatusTimeoutError extends (0, _baseJs.BaseError) {
    constructor({ id }){
        super(`Timed out while waiting for call bundle with id "${id}" to be confirmed.`, {
            name: 'WaitForCallsStatusTimeoutError'
        });
    }
}

},{"../../errors/base.js":"3SEPF","../../utils/observe.js":"3BbFn","../../utils/poll.js":"6Dkrj","../../utils/promise/withResolvers.js":"5yXnT","../../utils/stringify.js":"jKcjI","./getCallsStatus.js":"90ztp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"90ztp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the status of a call batch that was sent via `sendCalls`.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/getCallsStatus
 * - JSON-RPC Methods: [`wallet_getCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)
 *
 * @param client - Client to use
 * @returns Status of the calls. {@link GetCallsStatusReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getCallsStatus } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const { receipts, status } = await getCallsStatus(client, { id: '0xdeadbeef' })
 */ parcelHelpers.export(exports, "getCallsStatus", ()=>getCallsStatus);
var _sliceJs = require("../../utils/data/slice.js");
var _trimJs = require("../../utils/data/trim.js");
var _fromHexJs = require("../../utils/encoding/fromHex.js");
var _transactionReceiptJs = require("../../utils/formatters/transactionReceipt.js");
var _sendCallsJs = require("./sendCalls.js");
async function getCallsStatus(client, parameters) {
    async function getStatus(id) {
        const isTransactions = id.endsWith((0, _sendCallsJs.fallbackMagicIdentifier).slice(2));
        if (isTransactions) {
            const chainId = (0, _trimJs.trim)((0, _sliceJs.sliceHex)(id, -64, -32));
            const hashes = (0, _sliceJs.sliceHex)(id, 0, -64).slice(2).match(/.{1,64}/g);
            const receipts = await Promise.all(hashes.map((hash)=>(0, _sendCallsJs.fallbackTransactionErrorMagicIdentifier).slice(2) !== hash ? client.request({
                    method: 'eth_getTransactionReceipt',
                    params: [
                        `0x${hash}`
                    ]
                }, {
                    dedupe: true
                }) : undefined));
            const status = (()=>{
                if (receipts.some((r)=>r === null)) return 100; // pending
                if (receipts.every((r)=>r?.status === '0x1')) return 200; // success
                if (receipts.every((r)=>r?.status === '0x0')) return 500; // complete failure
                return 600; // partial failure
            })();
            return {
                atomic: false,
                chainId: (0, _fromHexJs.hexToNumber)(chainId),
                receipts: receipts.filter(Boolean),
                status,
                version: '2.0.0'
            };
        }
        return client.request({
            method: 'wallet_getCallsStatus',
            params: [
                id
            ]
        });
    }
    const { atomic = false, chainId, receipts, version = '2.0.0', ...response } = await getStatus(parameters.id);
    const [status, statusCode] = (()=>{
        const statusCode = response.status;
        if (statusCode >= 100 && statusCode < 200) return [
            'pending',
            statusCode
        ];
        if (statusCode >= 200 && statusCode < 300) return [
            'success',
            statusCode
        ];
        if (statusCode >= 300 && statusCode < 700) return [
            'failure',
            statusCode
        ];
        // @ts-expect-error: for backwards compatibility
        if (statusCode === 'CONFIRMED') return [
            'success',
            200
        ];
        // @ts-expect-error: for backwards compatibility
        if (statusCode === 'PENDING') return [
            'pending',
            100
        ];
        return [
            undefined,
            statusCode
        ];
    })();
    return {
        ...response,
        atomic,
        // @ts-expect-error: for backwards compatibility
        chainId: chainId ? (0, _fromHexJs.hexToNumber)(chainId) : undefined,
        receipts: receipts?.map((receipt)=>({
                ...receipt,
                blockNumber: (0, _fromHexJs.hexToBigInt)(receipt.blockNumber),
                gasUsed: (0, _fromHexJs.hexToBigInt)(receipt.gasUsed),
                status: (0, _transactionReceiptJs.receiptStatuses)[receipt.status]
            })) ?? [],
        statusCode,
        status,
        version
    };
}

},{"../../utils/data/slice.js":"hh6kq","../../utils/data/trim.js":"3ZmMy","../../utils/encoding/fromHex.js":"kLfW5","../../utils/formatters/transactionReceipt.js":"1XqTn","./sendCalls.js":"8063v","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1XqTn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "receiptStatuses", ()=>receiptStatuses);
parcelHelpers.export(exports, "formatTransactionReceipt", ()=>formatTransactionReceipt);
parcelHelpers.export(exports, "defineTransactionReceipt", ()=>defineTransactionReceipt);
var _fromHexJs = require("../encoding/fromHex.js");
var _formatterJs = require("./formatter.js");
var _logJs = require("./log.js");
var _transactionJs = require("./transaction.js");
const receiptStatuses = {
    '0x0': 'reverted',
    '0x1': 'success'
};
function formatTransactionReceipt(transactionReceipt) {
    const receipt = {
        ...transactionReceipt,
        blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
        contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
        effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
        gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
        logs: transactionReceipt.logs ? transactionReceipt.logs.map((log)=>(0, _logJs.formatLog)(log)) : null,
        to: transactionReceipt.to ? transactionReceipt.to : null,
        transactionIndex: transactionReceipt.transactionIndex ? (0, _fromHexJs.hexToNumber)(transactionReceipt.transactionIndex) : null,
        status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
        type: transactionReceipt.type ? (0, _transactionJs.transactionType)[transactionReceipt.type] || transactionReceipt.type : null
    };
    if (transactionReceipt.blobGasPrice) receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
    if (transactionReceipt.blobGasUsed) receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
    return receipt;
}
const defineTransactionReceipt = /*#__PURE__*/ (0, _formatterJs.defineFormatter)('transactionReceipt', formatTransactionReceipt);

},{"../encoding/fromHex.js":"kLfW5","./formatter.js":"itqtW","./log.js":"aaYKq","./transaction.js":"dhAxe","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8063v":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fallbackMagicIdentifier", ()=>fallbackMagicIdentifier);
parcelHelpers.export(exports, "fallbackTransactionErrorMagicIdentifier", ()=>fallbackTransactionErrorMagicIdentifier);
/**
 * Requests the connected wallet to send a batch of calls.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/sendCalls
 * - JSON-RPC Methods: [`wallet_sendCalls`](https://eips.ethereum.org/EIPS/eip-5792)
 *
 * @param client - Client to use
 * @returns Transaction identifier. {@link SendCallsReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { sendCalls } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const id = await sendCalls(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   calls: [
 *     {
 *       data: '0xdeadbeef',
 *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *     },
 *     {
 *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *       value: 69420n,
 *     },
 *   ],
 * })
 */ parcelHelpers.export(exports, "sendCalls", ()=>sendCalls);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _baseJs = require("../../errors/base.js");
var _rpcJs = require("../../errors/rpc.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _concatJs = require("../../utils/data/concat.js");
var _fromHexJs = require("../../utils/encoding/fromHex.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _getTransactionErrorJs = require("../../utils/errors/getTransactionError.js");
var _sendTransactionJs = require("./sendTransaction.js");
const fallbackMagicIdentifier = '0x5792579257925792579257925792579257925792579257925792579257925792';
const fallbackTransactionErrorMagicIdentifier = (0, _toHexJs.numberToHex)(0, {
    size: 32
});
async function sendCalls(client, parameters) {
    const { account: account_ = client.account, capabilities, chain = client.chain, experimental_fallback, experimental_fallbackDelay = 32, forceAtomic = false, id, version = '2.0.0' } = parameters;
    if (typeof account_ === 'undefined') throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: '/docs/actions/wallet/sendCalls'
    });
    const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : null;
    const calls = parameters.calls.map((call_)=>{
        const call = call_;
        const data = call.abi ? (0, _encodeFunctionDataJs.encodeFunctionData)({
            abi: call.abi,
            functionName: call.functionName,
            args: call.args
        }) : call.data;
        return {
            data,
            to: call.to,
            value: call.value ? (0, _toHexJs.numberToHex)(call.value) : undefined
        };
    });
    try {
        const response = await client.request({
            method: 'wallet_sendCalls',
            params: [
                {
                    atomicRequired: forceAtomic,
                    calls,
                    capabilities,
                    chainId: (0, _toHexJs.numberToHex)(chain.id),
                    from: account?.address,
                    id,
                    version
                }
            ]
        }, {
            retryCount: 0
        });
        if (typeof response === 'string') return {
            id: response
        };
        return response;
    } catch (err) {
        const error = err;
        // If the transport does not support EIP-5792, fall back to
        // `eth_sendTransaction`.
        if (experimental_fallback && (error.name === 'MethodNotFoundRpcError' || error.name === 'MethodNotSupportedRpcError' || error.details.toLowerCase().includes('does not exist / is not available') || error.details.toLowerCase().includes('missing or invalid. request()') || error.details.toLowerCase().includes('did not match any variant of untagged enum'))) {
            if (capabilities) {
                const hasNonOptionalCapability = Object.values(capabilities).some((capability)=>!capability.optional);
                if (hasNonOptionalCapability) {
                    const message = 'non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.';
                    throw new (0, _rpcJs.UnsupportedNonOptionalCapabilityError)(new (0, _baseJs.BaseError)(message, {
                        details: message
                    }));
                }
            }
            if (forceAtomic && calls.length > 1) {
                const message = '`forceAtomic` is not supported on fallback to `eth_sendTransaction`.';
                throw new (0, _rpcJs.AtomicityNotSupportedError)(new (0, _baseJs.BaseError)(message, {
                    details: message
                }));
            }
            const promises = [];
            for (const call of calls){
                const promise = (0, _sendTransactionJs.sendTransaction)(client, {
                    account,
                    chain,
                    data: call.data,
                    to: call.to,
                    value: call.value ? (0, _fromHexJs.hexToBigInt)(call.value) : undefined
                });
                promises.push(promise);
                // Note: some browser wallets require a small delay between transactions
                // to prevent duplicate JSON-RPC requests.
                if (experimental_fallbackDelay > 0) await new Promise((resolve)=>setTimeout(resolve, experimental_fallbackDelay));
            }
            const results = await Promise.allSettled(promises);
            if (results.every((r)=>r.status === 'rejected')) throw results[0].reason;
            const hashes = results.map((result)=>{
                if (result.status === 'fulfilled') return result.value;
                return fallbackTransactionErrorMagicIdentifier;
            });
            return {
                id: (0, _concatJs.concat)([
                    ...hashes,
                    (0, _toHexJs.numberToHex)(chain.id, {
                        size: 32
                    }),
                    fallbackMagicIdentifier
                ])
            };
        }
        throw (0, _getTransactionErrorJs.getTransactionError)(err, {
            ...parameters,
            account,
            chain: parameters.chain
        });
    }
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../errors/account.js":"39pf0","../../errors/base.js":"3SEPF","../../errors/rpc.js":"jYSPv","../../utils/abi/encodeFunctionData.js":"eQLEb","../../utils/data/concat.js":"6FL5K","../../utils/encoding/fromHex.js":"kLfW5","../../utils/encoding/toHex.js":"9GFC6","../../utils/errors/getTransactionError.js":"9QQWW","./sendTransaction.js":"910Bd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7sQFR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createClient", ()=>createClient);
/**
 * Defines a typed JSON-RPC schema for the client.
 * Note: This is a runtime noop function.
 */ parcelHelpers.export(exports, "rpcSchema", ()=>rpcSchema);
var _parseAccountJs = require("../accounts/utils/parseAccount.js");
var _uidJs = require("../utils/uid.js");
function createClient(parameters) {
    const { batch, cacheTime = parameters.pollingInterval ?? 4000, ccipRead, key = 'base', name = 'Base Client', pollingInterval = 4000, type = 'base' } = parameters;
    const chain = parameters.chain;
    const account = parameters.account ? (0, _parseAccountJs.parseAccount)(parameters.account) : undefined;
    const { config, request, value } = parameters.transport({
        chain,
        pollingInterval
    });
    const transport = {
        ...config,
        ...value
    };
    const client = {
        account,
        batch,
        cacheTime,
        ccipRead,
        chain,
        key,
        name,
        pollingInterval,
        request,
        transport,
        type,
        uid: (0, _uidJs.uid)()
    };
    function extend(base) {
        return (extendFn)=>{
            const extended = extendFn(base);
            for(const key in client)delete extended[key];
            const combined = {
                ...base,
                ...extended
            };
            return Object.assign(combined, {
                extend: extend(combined)
            });
        };
    }
    return Object.assign(client, {
        extend: extend(client)
    });
}
function rpcSchema() {
    return null;
}

},{"../accounts/utils/parseAccount.js":"lGQkg","../utils/uid.js":"iu8jP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iu8jP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "uid", ()=>uid);
const size = 256;
let index = size;
let buffer;
function uid(length = 11) {
    if (!buffer || index + length > size * 2) {
        buffer = '';
        index = 0;
        for(let i = 0; i < size; i++)buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
    return buffer.substring(index, index++ + length);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fYXkb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Creates a custom transport given an EIP-1193 compliant `request` attribute.
 */ parcelHelpers.export(exports, "custom", ()=>custom);
var _createTransportJs = require("./createTransport.js");
function custom(provider, config = {}) {
    const { key = 'custom', methods, name = 'Custom Provider', retryDelay } = config;
    return ({ retryCount: defaultRetryCount })=>(0, _createTransportJs.createTransport)({
            key,
            methods,
            name,
            request: provider.request.bind(provider),
            retryCount: config.retryCount ?? defaultRetryCount,
            retryDelay,
            type: 'custom'
        });
}

},{"./createTransport.js":"cK0QC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cK0QC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Creates an transport intended to be used with a client.
 */ parcelHelpers.export(exports, "createTransport", ()=>createTransport);
var _buildRequestJs = require("../../utils/buildRequest.js");
var _uidJs = require("../../utils/uid.js");
function createTransport({ key, methods, name, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
    const uid = (0, _uidJs.uid)();
    return {
        config: {
            key,
            methods,
            name,
            request,
            retryCount,
            retryDelay,
            timeout,
            type
        },
        request: (0, _buildRequestJs.buildRequest)(request, {
            methods,
            retryCount,
            retryDelay,
            uid
        }),
        value
    };
}

},{"../../utils/buildRequest.js":"iYGfm","../../utils/uid.js":"iu8jP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iYGfm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildRequest", ()=>buildRequest);
/** @internal */ parcelHelpers.export(exports, "shouldRetry", ()=>shouldRetry);
var _baseJs = require("../errors/base.js");
var _requestJs = require("../errors/request.js");
var _rpcJs = require("../errors/rpc.js");
var _toHexJs = require("./encoding/toHex.js");
var _withDedupeJs = require("./promise/withDedupe.js");
var _withRetryJs = require("./promise/withRetry.js");
var _stringifyJs = require("./stringify.js");
function buildRequest(request, options = {}) {
    return async (args, overrideOptions = {})=>{
        const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid } = {
            ...options,
            ...overrideOptions
        };
        const { method } = args;
        if (methods?.exclude?.includes(method)) throw new (0, _rpcJs.MethodNotSupportedRpcError)(new Error('method not supported'), {
            method
        });
        if (methods?.include && !methods.include.includes(method)) throw new (0, _rpcJs.MethodNotSupportedRpcError)(new Error('method not supported'), {
            method
        });
        const requestId = dedupe ? (0, _toHexJs.stringToHex)(`${uid}.${(0, _stringifyJs.stringify)(args)}`) : undefined;
        return (0, _withDedupeJs.withDedupe)(()=>(0, _withRetryJs.withRetry)(async ()=>{
                try {
                    return await request(args);
                } catch (err_) {
                    const err = err_;
                    switch(err.code){
                        // -32700
                        case (0, _rpcJs.ParseRpcError).code:
                            throw new (0, _rpcJs.ParseRpcError)(err);
                        // -32600
                        case (0, _rpcJs.InvalidRequestRpcError).code:
                            throw new (0, _rpcJs.InvalidRequestRpcError)(err);
                        // -32601
                        case (0, _rpcJs.MethodNotFoundRpcError).code:
                            throw new (0, _rpcJs.MethodNotFoundRpcError)(err, {
                                method: args.method
                            });
                        // -32602
                        case (0, _rpcJs.InvalidParamsRpcError).code:
                            throw new (0, _rpcJs.InvalidParamsRpcError)(err);
                        // -32603
                        case (0, _rpcJs.InternalRpcError).code:
                            throw new (0, _rpcJs.InternalRpcError)(err);
                        // -32000
                        case (0, _rpcJs.InvalidInputRpcError).code:
                            throw new (0, _rpcJs.InvalidInputRpcError)(err);
                        // -32001
                        case (0, _rpcJs.ResourceNotFoundRpcError).code:
                            throw new (0, _rpcJs.ResourceNotFoundRpcError)(err);
                        // -32002
                        case (0, _rpcJs.ResourceUnavailableRpcError).code:
                            throw new (0, _rpcJs.ResourceUnavailableRpcError)(err);
                        // -32003
                        case (0, _rpcJs.TransactionRejectedRpcError).code:
                            throw new (0, _rpcJs.TransactionRejectedRpcError)(err);
                        // -32004
                        case (0, _rpcJs.MethodNotSupportedRpcError).code:
                            throw new (0, _rpcJs.MethodNotSupportedRpcError)(err, {
                                method: args.method
                            });
                        // -32005
                        case (0, _rpcJs.LimitExceededRpcError).code:
                            throw new (0, _rpcJs.LimitExceededRpcError)(err);
                        // -32006
                        case (0, _rpcJs.JsonRpcVersionUnsupportedError).code:
                            throw new (0, _rpcJs.JsonRpcVersionUnsupportedError)(err);
                        // 4001
                        case (0, _rpcJs.UserRejectedRequestError).code:
                            throw new (0, _rpcJs.UserRejectedRequestError)(err);
                        // 4100
                        case (0, _rpcJs.UnauthorizedProviderError).code:
                            throw new (0, _rpcJs.UnauthorizedProviderError)(err);
                        // 4200
                        case (0, _rpcJs.UnsupportedProviderMethodError).code:
                            throw new (0, _rpcJs.UnsupportedProviderMethodError)(err);
                        // 4900
                        case (0, _rpcJs.ProviderDisconnectedError).code:
                            throw new (0, _rpcJs.ProviderDisconnectedError)(err);
                        // 4901
                        case (0, _rpcJs.ChainDisconnectedError).code:
                            throw new (0, _rpcJs.ChainDisconnectedError)(err);
                        // 4902
                        case (0, _rpcJs.SwitchChainError).code:
                            throw new (0, _rpcJs.SwitchChainError)(err);
                        // 5700
                        case (0, _rpcJs.UnsupportedNonOptionalCapabilityError).code:
                            throw new (0, _rpcJs.UnsupportedNonOptionalCapabilityError)(err);
                        // 5710
                        case (0, _rpcJs.UnsupportedChainIdError).code:
                            throw new (0, _rpcJs.UnsupportedChainIdError)(err);
                        // 5720
                        case (0, _rpcJs.DuplicateIdError).code:
                            throw new (0, _rpcJs.DuplicateIdError)(err);
                        // 5730
                        case (0, _rpcJs.UnknownBundleIdError).code:
                            throw new (0, _rpcJs.UnknownBundleIdError)(err);
                        // 5740
                        case (0, _rpcJs.BundleTooLargeError).code:
                            throw new (0, _rpcJs.BundleTooLargeError)(err);
                        // 5750
                        case (0, _rpcJs.AtomicReadyWalletRejectedUpgradeError).code:
                            throw new (0, _rpcJs.AtomicReadyWalletRejectedUpgradeError)(err);
                        // 5760
                        case (0, _rpcJs.AtomicityNotSupportedError).code:
                            throw new (0, _rpcJs.AtomicityNotSupportedError)(err);
                        // CAIP-25: User Rejected Error
                        // https://docs.walletconnect.com/2.0/specs/clients/sign/error-codes#rejected-caip-25
                        case 5000:
                            throw new (0, _rpcJs.UserRejectedRequestError)(err);
                        default:
                            if (err_ instanceof (0, _baseJs.BaseError)) throw err_;
                            throw new (0, _rpcJs.UnknownRpcError)(err);
                    }
                }
            }, {
                delay: ({ count, error })=>{
                    // If we find a Retry-After header, let's retry after the given time.
                    if (error && error instanceof (0, _requestJs.HttpRequestError)) {
                        const retryAfter = error?.headers?.get('Retry-After');
                        if (retryAfter?.match(/\d/)) return Number.parseInt(retryAfter) * 1000;
                    }
                    // Otherwise, let's retry with an exponential backoff.
                    return ~~(1 << count) * retryDelay;
                },
                retryCount,
                shouldRetry: ({ error })=>shouldRetry(error)
            }), {
            enabled: dedupe,
            id: requestId
        });
    };
}
function shouldRetry(error) {
    if ('code' in error && typeof error.code === 'number') {
        if (error.code === -1) return true; // Unknown error
        if (error.code === (0, _rpcJs.LimitExceededRpcError).code) return true;
        if (error.code === (0, _rpcJs.InternalRpcError).code) return true;
        return false;
    }
    if (error instanceof (0, _requestJs.HttpRequestError) && error.status) {
        // Forbidden
        if (error.status === 403) return true;
        // Request Timeout
        if (error.status === 408) return true;
        // Request Entity Too Large
        if (error.status === 413) return true;
        // Too Many Requests
        if (error.status === 429) return true;
        // Internal Server Error
        if (error.status === 500) return true;
        // Bad Gateway
        if (error.status === 502) return true;
        // Service Unavailable
        if (error.status === 503) return true;
        // Gateway Timeout
        if (error.status === 504) return true;
        return false;
    }
    return true;
}

},{"../errors/base.js":"3SEPF","../errors/request.js":"6LYvf","../errors/rpc.js":"jYSPv","./encoding/toHex.js":"9GFC6","./promise/withDedupe.js":"4fO0F","./promise/withRetry.js":"3qWqJ","./stringify.js":"jKcjI","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4fO0F":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "promiseCache", ()=>promiseCache);
/** Deduplicates in-flight promises. */ parcelHelpers.export(exports, "withDedupe", ()=>withDedupe);
var _lruJs = require("../lru.js");
const promiseCache = /*#__PURE__*/ new (0, _lruJs.LruMap)(8192);
function withDedupe(fn, { enabled = true, id }) {
    if (!enabled || !id) return fn();
    if (promiseCache.get(id)) return promiseCache.get(id);
    const promise = fn().finally(()=>promiseCache.delete(id));
    promiseCache.set(id, promise);
    return promise;
}

},{"../lru.js":"ibK3x","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3qWqJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "withRetry", ()=>withRetry);
var _waitJs = require("../wait.js");
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = ()=>true } = {}) {
    return new Promise((resolve, reject)=>{
        const attemptRetry = async ({ count = 0 } = {})=>{
            const retry = async ({ error })=>{
                const delay = typeof delay_ === 'function' ? delay_({
                    count,
                    error
                }) : delay_;
                if (delay) await (0, _waitJs.wait)(delay);
                attemptRetry({
                    count: count + 1
                });
            };
            try {
                const data = await fn();
                resolve(data);
            } catch (err) {
                if (count < retryCount && await shouldRetry({
                    count,
                    error: err
                })) return retry({
                    error: err
                });
                reject(err);
            }
        };
        attemptRetry();
    });
}

},{"../wait.js":"hnFJl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f3fvY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fallback", ()=>fallback);
parcelHelpers.export(exports, "shouldThrow", ()=>shouldThrow);
/** @internal */ parcelHelpers.export(exports, "rankTransports", ()=>rankTransports);
var _nodeJs = require("../../errors/node.js");
var _rpcJs = require("../../errors/rpc.js");
var _waitJs = require("../../utils/wait.js");
var _createTransportJs = require("./createTransport.js");
function fallback(transports_, config = {}) {
    const { key = 'fallback', name = 'Fallback', rank = false, shouldThrow: shouldThrow_ = shouldThrow, retryCount, retryDelay } = config;
    return ({ chain, pollingInterval = 4000, timeout, ...rest })=>{
        let transports = transports_;
        let onResponse = ()=>{};
        const transport = (0, _createTransportJs.createTransport)({
            key,
            name,
            async request ({ method, params }) {
                let includes;
                const fetch = async (i = 0)=>{
                    const transport = transports[i]({
                        ...rest,
                        chain,
                        retryCount: 0,
                        timeout
                    });
                    try {
                        const response = await transport.request({
                            method,
                            params
                        });
                        onResponse({
                            method,
                            params: params,
                            response,
                            transport,
                            status: 'success'
                        });
                        return response;
                    } catch (err) {
                        onResponse({
                            error: err,
                            method,
                            params: params,
                            transport,
                            status: 'error'
                        });
                        if (shouldThrow_(err)) throw err;
                        // If we've reached the end of the fallbacks, throw the error.
                        if (i === transports.length - 1) throw err;
                        // Check if at least one other transport includes the method
                        includes ??= transports.slice(i + 1).some((transport)=>{
                            const { include, exclude } = transport({
                                chain
                            }).config.methods || {};
                            if (include) return include.includes(method);
                            if (exclude) return !exclude.includes(method);
                            return true;
                        });
                        if (!includes) throw err;
                        // Otherwise, try the next fallback.
                        return fetch(i + 1);
                    }
                };
                return fetch();
            },
            retryCount,
            retryDelay,
            type: 'fallback'
        }, {
            onResponse: (fn)=>onResponse = fn,
            transports: transports.map((fn)=>fn({
                    chain,
                    retryCount: 0
                }))
        });
        if (rank) {
            const rankOptions = typeof rank === 'object' ? rank : {};
            rankTransports({
                chain,
                interval: rankOptions.interval ?? pollingInterval,
                onTransports: (transports_)=>transports = transports_,
                ping: rankOptions.ping,
                sampleCount: rankOptions.sampleCount,
                timeout: rankOptions.timeout,
                transports,
                weights: rankOptions.weights
            });
        }
        return transport;
    };
}
function shouldThrow(error) {
    if ('code' in error && typeof error.code === 'number') {
        if (error.code === (0, _rpcJs.TransactionRejectedRpcError).code || error.code === (0, _rpcJs.UserRejectedRequestError).code || (0, _nodeJs.ExecutionRevertedError).nodeMessage.test(error.message) || error.code === 5000 // CAIP UserRejectedRequestError
        ) return true;
    }
    return false;
}
function rankTransports({ chain, interval = 4000, onTransports, ping, sampleCount = 10, timeout = 1000, transports, weights = {} }) {
    const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
    const samples = [];
    const rankTransports_ = async ()=>{
        // 1. Take a sample from each Transport.
        const sample = await Promise.all(transports.map(async (transport)=>{
            const transport_ = transport({
                chain,
                retryCount: 0,
                timeout
            });
            const start = Date.now();
            let end;
            let success;
            try {
                await (ping ? ping({
                    transport: transport_
                }) : transport_.request({
                    method: 'net_listening'
                }));
                success = 1;
            } catch  {
                success = 0;
            } finally{
                end = Date.now();
            }
            const latency = end - start;
            return {
                latency,
                success
            };
        }));
        // 2. Store the sample. If we have more than `sampleCount` samples, remove
        // the oldest sample.
        samples.push(sample);
        if (samples.length > sampleCount) samples.shift();
        // 3. Calculate the max latency from samples.
        const maxLatency = Math.max(...samples.map((sample)=>Math.max(...sample.map(({ latency })=>latency))));
        // 4. Calculate the score for each Transport.
        const scores = transports.map((_, i)=>{
            const latencies = samples.map((sample)=>sample[i].latency);
            const meanLatency = latencies.reduce((acc, latency)=>acc + latency, 0) / latencies.length;
            const latencyScore = 1 - meanLatency / maxLatency;
            const successes = samples.map((sample)=>sample[i].success);
            const stabilityScore = successes.reduce((acc, success)=>acc + success, 0) / successes.length;
            if (stabilityScore === 0) return [
                0,
                i
            ];
            return [
                latencyWeight * latencyScore + stabilityWeight * stabilityScore,
                i
            ];
        }).sort((a, b)=>b[0] - a[0]);
        // 5. Sort the Transports by score.
        onTransports(scores.map(([, i])=>transports[i]));
        // 6. Wait, and then rank again.
        await (0, _waitJs.wait)(interval);
        rankTransports_();
    };
    rankTransports_();
}

},{"../../errors/node.js":"9Ytun","../../errors/rpc.js":"jYSPv","../../utils/wait.js":"hnFJl","./createTransport.js":"cK0QC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hTPjl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Creates a HTTP transport that connects to a JSON-RPC API.
 */ parcelHelpers.export(exports, "http", ()=>http);
var _requestJs = require("../../errors/request.js");
var _transportJs = require("../../errors/transport.js");
var _createBatchSchedulerJs = require("../../utils/promise/createBatchScheduler.js");
var _httpJs = require("../../utils/rpc/http.js");
var _createTransportJs = require("./createTransport.js");
function http(/** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */ url, config = {}) {
    const { batch, fetchOptions, key = 'http', methods, name = 'HTTP JSON-RPC', onFetchRequest, onFetchResponse, retryDelay, raw } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ })=>{
        const { batchSize = 1000, wait = 0 } = typeof batch === 'object' ? batch : {};
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 10000;
        const url_ = url || chain?.rpcUrls.default.http[0];
        if (!url_) throw new (0, _transportJs.UrlRequiredError)();
        const rpcClient = (0, _httpJs.getHttpRpcClient)(url_, {
            fetchOptions,
            onRequest: onFetchRequest,
            onResponse: onFetchResponse,
            timeout
        });
        return (0, _createTransportJs.createTransport)({
            key,
            methods,
            name,
            async request ({ method, params }) {
                const body = {
                    method,
                    params
                };
                const { schedule } = (0, _createBatchSchedulerJs.createBatchScheduler)({
                    id: url_,
                    wait,
                    shouldSplitBatch (requests) {
                        return requests.length > batchSize;
                    },
                    fn: (body)=>rpcClient.request({
                            body
                        }),
                    sort: (a, b)=>a.id - b.id
                });
                const fn = async (body)=>batch ? schedule(body) : [
                        await rpcClient.request({
                            body
                        })
                    ];
                const [{ error, result }] = await fn(body);
                if (raw) return {
                    error,
                    result
                };
                if (error) throw new (0, _requestJs.RpcRequestError)({
                    body,
                    error,
                    url: url_
                });
                return result;
            },
            retryCount,
            retryDelay,
            timeout,
            type: 'http'
        }, {
            fetchOptions,
            url: url_
        });
    };
}

},{"../../errors/request.js":"6LYvf","../../errors/transport.js":"gIsZQ","../../utils/promise/createBatchScheduler.js":"cXEx4","../../utils/rpc/http.js":"hbLiA","./createTransport.js":"cK0QC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gIsZQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UrlRequiredError", ()=>UrlRequiredError);
var _baseJs = require("./base.js");
class UrlRequiredError extends (0, _baseJs.BaseError) {
    constructor(){
        super('No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.', {
            docsPath: '/docs/clients/intro',
            name: 'UrlRequiredError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hbLiA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getHttpRpcClient", ()=>getHttpRpcClient);
var _requestJs = require("../../errors/request.js");
var _withTimeoutJs = require("../promise/withTimeout.js");
var _stringifyJs = require("../stringify.js");
var _idJs = require("./id.js");
function getHttpRpcClient(url, options = {}) {
    return {
        async request (params) {
            const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 10000 } = params;
            const fetchOptions = {
                ...options.fetchOptions ?? {},
                ...params.fetchOptions ?? {}
            };
            const { headers, method, signal: signal_ } = fetchOptions;
            try {
                const response = await (0, _withTimeoutJs.withTimeout)(async ({ signal })=>{
                    const init = {
                        ...fetchOptions,
                        body: Array.isArray(body) ? (0, _stringifyJs.stringify)(body.map((body)=>({
                                jsonrpc: '2.0',
                                id: body.id ?? (0, _idJs.idCache).take(),
                                ...body
                            }))) : (0, _stringifyJs.stringify)({
                            jsonrpc: '2.0',
                            id: body.id ?? (0, _idJs.idCache).take(),
                            ...body
                        }),
                        headers: {
                            'Content-Type': 'application/json',
                            ...headers
                        },
                        method: method || 'POST',
                        signal: signal_ || (timeout > 0 ? signal : null)
                    };
                    const request = new Request(url, init);
                    const args = await onRequest?.(request, init) ?? {
                        ...init,
                        url
                    };
                    const response = await fetch(args.url ?? url, args);
                    return response;
                }, {
                    errorInstance: new (0, _requestJs.TimeoutError)({
                        body,
                        url
                    }),
                    timeout,
                    signal: true
                });
                if (onResponse) await onResponse(response);
                let data;
                if (response.headers.get('Content-Type')?.startsWith('application/json')) data = await response.json();
                else {
                    data = await response.text();
                    try {
                        data = JSON.parse(data || '{}');
                    } catch (err) {
                        if (response.ok) throw err;
                        data = {
                            error: data
                        };
                    }
                }
                if (!response.ok) throw new (0, _requestJs.HttpRequestError)({
                    body,
                    details: (0, _stringifyJs.stringify)(data.error) || response.statusText,
                    headers: response.headers,
                    status: response.status,
                    url
                });
                return data;
            } catch (err) {
                if (err instanceof (0, _requestJs.HttpRequestError)) throw err;
                if (err instanceof (0, _requestJs.TimeoutError)) throw err;
                throw new (0, _requestJs.HttpRequestError)({
                    body,
                    cause: err,
                    url
                });
            }
        }
    };
}

},{"../../errors/request.js":"6LYvf","../promise/withTimeout.js":"cETnG","../stringify.js":"jKcjI","./id.js":"l1EzB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cETnG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "withTimeout", ()=>withTimeout);
function withTimeout(fn, { errorInstance = new Error('timed out'), timeout, signal }) {
    return new Promise((resolve, reject)=>{
        (async ()=>{
            let timeoutId;
            try {
                const controller = new AbortController();
                if (timeout > 0) timeoutId = setTimeout(()=>{
                    if (signal) controller.abort();
                    else reject(errorInstance);
                }, timeout); // need to cast because bun globals.d.ts overrides @types/node
                resolve(await fn({
                    signal: controller?.signal || null
                }));
            } catch (err) {
                if (err?.name === 'AbortError') reject(errorInstance);
                reject(err);
            } finally{
                clearTimeout(timeoutId);
            }
        })();
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l1EzB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "idCache", ()=>idCache);
function createIdStore() {
    return {
        current: 0,
        take () {
            return this.current++;
        },
        reset () {
            this.current = 0;
        }
    };
}
const idCache = /*#__PURE__*/ createIdStore();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b5Nfq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a Public Client with a given [Transport](https://viem.sh/docs/clients/intro) configured for a [Chain](https://viem.sh/docs/clients/chains).
 *
 * - Docs: https://viem.sh/docs/clients/public
 *
 * A Public Client is an interface to "public" [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/) methods such as retrieving block numbers, transactions, reading from smart contracts, etc through [Public Actions](/docs/actions/public/introduction).
 *
 * @param config - {@link PublicClientConfig}
 * @returns A Public Client. {@link PublicClient}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 */ parcelHelpers.export(exports, "createPublicClient", ()=>createPublicClient);
var _createClientJs = require("./createClient.js");
var _publicJs = require("./decorators/public.js");
function createPublicClient(parameters) {
    const { key = 'public', name = 'Public Client' } = parameters;
    const client = (0, _createClientJs.createClient)({
        ...parameters,
        key,
        name,
        type: 'publicClient'
    });
    return client.extend((0, _publicJs.publicActions));
}

},{"./createClient.js":"7sQFR","./decorators/public.js":"tXTJF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"tXTJF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "publicActions", ()=>publicActions);
var _getEnsAddressJs = require("../../actions/ens/getEnsAddress.js");
var _getEnsAvatarJs = require("../../actions/ens/getEnsAvatar.js");
var _getEnsNameJs = require("../../actions/ens/getEnsName.js");
var _getEnsResolverJs = require("../../actions/ens/getEnsResolver.js");
var _getEnsTextJs = require("../../actions/ens/getEnsText.js");
var _callJs = require("../../actions/public/call.js");
var _createAccessListJs = require("../../actions/public/createAccessList.js");
var _createBlockFilterJs = require("../../actions/public/createBlockFilter.js");
var _createContractEventFilterJs = require("../../actions/public/createContractEventFilter.js");
var _createEventFilterJs = require("../../actions/public/createEventFilter.js");
var _createPendingTransactionFilterJs = require("../../actions/public/createPendingTransactionFilter.js");
var _estimateContractGasJs = require("../../actions/public/estimateContractGas.js");
var _estimateFeesPerGasJs = require("../../actions/public/estimateFeesPerGas.js");
var _estimateGasJs = require("../../actions/public/estimateGas.js");
var _estimateMaxPriorityFeePerGasJs = require("../../actions/public/estimateMaxPriorityFeePerGas.js");
var _getBalanceJs = require("../../actions/public/getBalance.js");
var _getBlobBaseFeeJs = require("../../actions/public/getBlobBaseFee.js");
var _getBlockJs = require("../../actions/public/getBlock.js");
var _getBlockNumberJs = require("../../actions/public/getBlockNumber.js");
var _getBlockTransactionCountJs = require("../../actions/public/getBlockTransactionCount.js");
var _getChainIdJs = require("../../actions/public/getChainId.js");
var _getCodeJs = require("../../actions/public/getCode.js");
var _getContractEventsJs = require("../../actions/public/getContractEvents.js");
var _getEip712DomainJs = require("../../actions/public/getEip712Domain.js");
var _getFeeHistoryJs = require("../../actions/public/getFeeHistory.js");
var _getFilterChangesJs = require("../../actions/public/getFilterChanges.js");
var _getFilterLogsJs = require("../../actions/public/getFilterLogs.js");
var _getGasPriceJs = require("../../actions/public/getGasPrice.js");
var _getLogsJs = require("../../actions/public/getLogs.js");
var _getProofJs = require("../../actions/public/getProof.js");
var _getStorageAtJs = require("../../actions/public/getStorageAt.js");
var _getTransactionJs = require("../../actions/public/getTransaction.js");
var _getTransactionConfirmationsJs = require("../../actions/public/getTransactionConfirmations.js");
var _getTransactionCountJs = require("../../actions/public/getTransactionCount.js");
var _getTransactionReceiptJs = require("../../actions/public/getTransactionReceipt.js");
var _multicallJs = require("../../actions/public/multicall.js");
var _readContractJs = require("../../actions/public/readContract.js");
var _simulateBlocksJs = require("../../actions/public/simulateBlocks.js");
var _simulateCallsJs = require("../../actions/public/simulateCalls.js");
var _simulateContractJs = require("../../actions/public/simulateContract.js");
var _uninstallFilterJs = require("../../actions/public/uninstallFilter.js");
var _verifyMessageJs = require("../../actions/public/verifyMessage.js");
var _verifyTypedDataJs = require("../../actions/public/verifyTypedData.js");
var _waitForTransactionReceiptJs = require("../../actions/public/waitForTransactionReceipt.js");
var _watchBlockNumberJs = require("../../actions/public/watchBlockNumber.js");
var _watchBlocksJs = require("../../actions/public/watchBlocks.js");
var _watchContractEventJs = require("../../actions/public/watchContractEvent.js");
var _watchEventJs = require("../../actions/public/watchEvent.js");
var _watchPendingTransactionsJs = require("../../actions/public/watchPendingTransactions.js");
var _verifySiweMessageJs = require("../../actions/siwe/verifySiweMessage.js");
var _prepareTransactionRequestJs = require("../../actions/wallet/prepareTransactionRequest.js");
var _sendRawTransactionJs = require("../../actions/wallet/sendRawTransaction.js");
function publicActions(client) {
    return {
        call: (args)=>(0, _callJs.call)(client, args),
        createAccessList: (args)=>(0, _createAccessListJs.createAccessList)(client, args),
        createBlockFilter: ()=>(0, _createBlockFilterJs.createBlockFilter)(client),
        createContractEventFilter: (args)=>(0, _createContractEventFilterJs.createContractEventFilter)(client, args),
        createEventFilter: (args)=>(0, _createEventFilterJs.createEventFilter)(client, args),
        createPendingTransactionFilter: ()=>(0, _createPendingTransactionFilterJs.createPendingTransactionFilter)(client),
        estimateContractGas: (args)=>(0, _estimateContractGasJs.estimateContractGas)(client, args),
        estimateGas: (args)=>(0, _estimateGasJs.estimateGas)(client, args),
        getBalance: (args)=>(0, _getBalanceJs.getBalance)(client, args),
        getBlobBaseFee: ()=>(0, _getBlobBaseFeeJs.getBlobBaseFee)(client),
        getBlock: (args)=>(0, _getBlockJs.getBlock)(client, args),
        getBlockNumber: (args)=>(0, _getBlockNumberJs.getBlockNumber)(client, args),
        getBlockTransactionCount: (args)=>(0, _getBlockTransactionCountJs.getBlockTransactionCount)(client, args),
        getBytecode: (args)=>(0, _getCodeJs.getCode)(client, args),
        getChainId: ()=>(0, _getChainIdJs.getChainId)(client),
        getCode: (args)=>(0, _getCodeJs.getCode)(client, args),
        getContractEvents: (args)=>(0, _getContractEventsJs.getContractEvents)(client, args),
        getEip712Domain: (args)=>(0, _getEip712DomainJs.getEip712Domain)(client, args),
        getEnsAddress: (args)=>(0, _getEnsAddressJs.getEnsAddress)(client, args),
        getEnsAvatar: (args)=>(0, _getEnsAvatarJs.getEnsAvatar)(client, args),
        getEnsName: (args)=>(0, _getEnsNameJs.getEnsName)(client, args),
        getEnsResolver: (args)=>(0, _getEnsResolverJs.getEnsResolver)(client, args),
        getEnsText: (args)=>(0, _getEnsTextJs.getEnsText)(client, args),
        getFeeHistory: (args)=>(0, _getFeeHistoryJs.getFeeHistory)(client, args),
        estimateFeesPerGas: (args)=>(0, _estimateFeesPerGasJs.estimateFeesPerGas)(client, args),
        getFilterChanges: (args)=>(0, _getFilterChangesJs.getFilterChanges)(client, args),
        getFilterLogs: (args)=>(0, _getFilterLogsJs.getFilterLogs)(client, args),
        getGasPrice: ()=>(0, _getGasPriceJs.getGasPrice)(client),
        getLogs: (args)=>(0, _getLogsJs.getLogs)(client, args),
        getProof: (args)=>(0, _getProofJs.getProof)(client, args),
        estimateMaxPriorityFeePerGas: (args)=>(0, _estimateMaxPriorityFeePerGasJs.estimateMaxPriorityFeePerGas)(client, args),
        getStorageAt: (args)=>(0, _getStorageAtJs.getStorageAt)(client, args),
        getTransaction: (args)=>(0, _getTransactionJs.getTransaction)(client, args),
        getTransactionConfirmations: (args)=>(0, _getTransactionConfirmationsJs.getTransactionConfirmations)(client, args),
        getTransactionCount: (args)=>(0, _getTransactionCountJs.getTransactionCount)(client, args),
        getTransactionReceipt: (args)=>(0, _getTransactionReceiptJs.getTransactionReceipt)(client, args),
        multicall: (args)=>(0, _multicallJs.multicall)(client, args),
        prepareTransactionRequest: (args)=>(0, _prepareTransactionRequestJs.prepareTransactionRequest)(client, args),
        readContract: (args)=>(0, _readContractJs.readContract)(client, args),
        sendRawTransaction: (args)=>(0, _sendRawTransactionJs.sendRawTransaction)(client, args),
        simulate: (args)=>(0, _simulateBlocksJs.simulateBlocks)(client, args),
        simulateBlocks: (args)=>(0, _simulateBlocksJs.simulateBlocks)(client, args),
        simulateCalls: (args)=>(0, _simulateCallsJs.simulateCalls)(client, args),
        simulateContract: (args)=>(0, _simulateContractJs.simulateContract)(client, args),
        verifyMessage: (args)=>(0, _verifyMessageJs.verifyMessage)(client, args),
        verifySiweMessage: (args)=>(0, _verifySiweMessageJs.verifySiweMessage)(client, args),
        verifyTypedData: (args)=>(0, _verifyTypedDataJs.verifyTypedData)(client, args),
        uninstallFilter: (args)=>(0, _uninstallFilterJs.uninstallFilter)(client, args),
        waitForTransactionReceipt: (args)=>(0, _waitForTransactionReceiptJs.waitForTransactionReceipt)(client, args),
        watchBlocks: (args)=>(0, _watchBlocksJs.watchBlocks)(client, args),
        watchBlockNumber: (args)=>(0, _watchBlockNumberJs.watchBlockNumber)(client, args),
        watchContractEvent: (args)=>(0, _watchContractEventJs.watchContractEvent)(client, args),
        watchEvent: (args)=>(0, _watchEventJs.watchEvent)(client, args),
        watchPendingTransactions: (args)=>(0, _watchPendingTransactionsJs.watchPendingTransactions)(client, args)
    };
}

},{"../../actions/ens/getEnsAddress.js":"buGur","../../actions/ens/getEnsAvatar.js":"1p6F1","../../actions/ens/getEnsName.js":"7kAMa","../../actions/ens/getEnsResolver.js":"i1DVp","../../actions/ens/getEnsText.js":"cgLfK","../../actions/public/call.js":"85xZD","../../actions/public/createAccessList.js":"gaOy9","../../actions/public/createBlockFilter.js":"eUMUC","../../actions/public/createContractEventFilter.js":"aZFsp","../../actions/public/createEventFilter.js":"4xY9E","../../actions/public/createPendingTransactionFilter.js":"4xwLI","../../actions/public/estimateContractGas.js":"26qE1","../../actions/public/estimateFeesPerGas.js":"duZBq","../../actions/public/estimateGas.js":"22Lcu","../../actions/public/estimateMaxPriorityFeePerGas.js":"hXKqr","../../actions/public/getBalance.js":"1bzUH","../../actions/public/getBlobBaseFee.js":"5r8SD","../../actions/public/getBlock.js":"1M4Cs","../../actions/public/getBlockNumber.js":"hY1Hu","../../actions/public/getBlockTransactionCount.js":"fHNqe","../../actions/public/getChainId.js":"lXOca","../../actions/public/getCode.js":"g3EeR","../../actions/public/getContractEvents.js":"8aoKV","../../actions/public/getEip712Domain.js":"2iQjU","../../actions/public/getFeeHistory.js":"4l4cq","../../actions/public/getFilterChanges.js":"6g1rZ","../../actions/public/getFilterLogs.js":"lgs4M","../../actions/public/getGasPrice.js":"i7Vx8","../../actions/public/getLogs.js":"245SH","../../actions/public/getProof.js":"j69FV","../../actions/public/getStorageAt.js":"i5HZM","../../actions/public/getTransaction.js":"lrruA","../../actions/public/getTransactionConfirmations.js":"lgIAF","../../actions/public/getTransactionCount.js":"7o2N6","../../actions/public/getTransactionReceipt.js":"aEzFk","../../actions/public/multicall.js":"7H0k4","../../actions/public/readContract.js":"fusIl","../../actions/public/simulateBlocks.js":"hwAPJ","../../actions/public/simulateCalls.js":"gX7cN","../../actions/public/simulateContract.js":"3yzsB","../../actions/public/uninstallFilter.js":"Yq58O","../../actions/public/verifyMessage.js":"41IZo","../../actions/public/verifyTypedData.js":"geW4Q","../../actions/public/waitForTransactionReceipt.js":"gBaOA","../../actions/public/watchBlockNumber.js":"fq9gv","../../actions/public/watchBlocks.js":"gM5SM","../../actions/public/watchContractEvent.js":"jxMap","../../actions/public/watchEvent.js":"byghu","../../actions/public/watchPendingTransactions.js":"7FFnI","../../actions/siwe/verifySiweMessage.js":"6Xlmr","../../actions/wallet/prepareTransactionRequest.js":"53wjM","../../actions/wallet/sendRawTransaction.js":"6SNuf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"buGur":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets address for ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsAddress
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
 *
 * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsAddressParameters}
 * @returns Address for ENS name or `null` if not found. {@link GetEnsAddressReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsAddress, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const ensAddress = await getEnsAddress(client, {
 *   name: normalize('wevm.eth'),
 * })
 * // '0xd2135CfB216b74109775236E36d4b433F1DF507B'
 */ parcelHelpers.export(exports, "getEnsAddress", ()=>getEnsAddress);
var _abisJs = require("../../constants/abis.js");
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getChainContractAddressJs = require("../../utils/chain/getChainContractAddress.js");
var _trimJs = require("../../utils/data/trim.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _errorsJs = require("../../utils/ens/errors.js");
var _localBatchGatewayRequestJs = require("../../utils/ens/localBatchGatewayRequest.js");
var _namehashJs = require("../../utils/ens/namehash.js");
var _packetToBytesJs = require("../../utils/ens/packetToBytes.js");
var _getActionJs = require("../../utils/getAction.js");
var _readContractJs = require("../public/readContract.js");
async function getEnsAddress(client, parameters) {
    const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } = parameters;
    const { chain } = client;
    const universalResolverAddress = (()=>{
        if (parameters.universalResolverAddress) return parameters.universalResolverAddress;
        if (!chain) throw new Error('client chain not configured. universalResolverAddress is required.');
        return (0, _getChainContractAddressJs.getChainContractAddress)({
            blockNumber,
            chain,
            contract: 'ensUniversalResolver'
        });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld)=>name.endsWith(tld))) return null;
    try {
        const functionData = (0, _encodeFunctionDataJs.encodeFunctionData)({
            abi: (0, _abisJs.addressResolverAbi),
            functionName: 'addr',
            ...coinType != null ? {
                args: [
                    (0, _namehashJs.namehash)(name),
                    BigInt(coinType)
                ]
            } : {
                args: [
                    (0, _namehashJs.namehash)(name)
                ]
            }
        });
        const readContractParameters = {
            address: universalResolverAddress,
            abi: (0, _abisJs.universalResolverResolveAbi),
            functionName: 'resolve',
            args: [
                (0, _toHexJs.toHex)((0, _packetToBytesJs.packetToBytes)(name)),
                functionData,
                gatewayUrls ?? [
                    (0, _localBatchGatewayRequestJs.localBatchGatewayUrl)
                ]
            ],
            blockNumber,
            blockTag
        };
        const readContractAction = (0, _getActionJs.getAction)(client, (0, _readContractJs.readContract), 'readContract');
        const res = await readContractAction(readContractParameters);
        if (res[0] === '0x') return null;
        const address = (0, _decodeFunctionResultJs.decodeFunctionResult)({
            abi: (0, _abisJs.addressResolverAbi),
            args: coinType != null ? [
                (0, _namehashJs.namehash)(name),
                BigInt(coinType)
            ] : undefined,
            functionName: 'addr',
            data: res[0]
        });
        if (address === '0x') return null;
        if ((0, _trimJs.trim)(address) === '0x00') return null;
        return address;
    } catch (err) {
        if (strict) throw err;
        if ((0, _errorsJs.isNullUniversalResolverError)(err, 'resolve')) return null;
        throw err;
    }
}

},{"../../constants/abis.js":"ffwQK","../../utils/abi/decodeFunctionResult.js":"j76hM","../../utils/abi/encodeFunctionData.js":"eQLEb","../../utils/chain/getChainContractAddress.js":"cNh6w","../../utils/data/trim.js":"3ZmMy","../../utils/encoding/toHex.js":"9GFC6","../../utils/ens/errors.js":"4b1mw","../../utils/ens/localBatchGatewayRequest.js":"iuGj1","../../utils/ens/namehash.js":"exJTH","../../utils/ens/packetToBytes.js":"2LDSR","../../utils/getAction.js":"d1Bvd","../public/readContract.js":"fusIl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4b1mw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
 * @description Checks if error is a valid null result UniversalResolver error
 */ parcelHelpers.export(exports, "isNullUniversalResolverError", ()=>isNullUniversalResolverError);
var _solidityJs = require("../../constants/solidity.js");
var _baseJs = require("../../errors/base.js");
var _contractJs = require("../../errors/contract.js");
function isNullUniversalResolverError(err, callType) {
    if (!(err instanceof (0, _baseJs.BaseError))) return false;
    const cause = err.walk((e)=>e instanceof (0, _contractJs.ContractFunctionRevertedError));
    if (!(cause instanceof (0, _contractJs.ContractFunctionRevertedError))) return false;
    if (cause.data?.errorName === 'ResolverNotFound') return true;
    if (cause.data?.errorName === 'ResolverWildcardNotSupported') return true;
    if (cause.data?.errorName === 'ResolverNotContract') return true;
    if (cause.data?.errorName === 'ResolverError') return true;
    if (cause.data?.errorName === 'HttpError') return true;
    // Backwards compatibility for older UniversalResolver contracts
    if (cause.reason?.includes('Wildcard on non-extended resolvers is not supported')) return true;
    // No primary name set for address.
    if (callType === 'reverse' && cause.reason === (0, _solidityJs.panicReasons)[50]) return true;
    return false;
}

},{"../../constants/solidity.js":"bzCGA","../../errors/base.js":"3SEPF","../../errors/contract.js":"1S92K","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iuGj1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "localBatchGatewayUrl", ()=>localBatchGatewayUrl);
parcelHelpers.export(exports, "localBatchGatewayRequest", ()=>localBatchGatewayRequest);
var _abisJs = require("../../constants/abis.js");
var _solidityJs = require("../../constants/solidity.js");
var _decodeFunctionDataJs = require("../abi/decodeFunctionData.js");
var _encodeErrorResultJs = require("../abi/encodeErrorResult.js");
var _encodeFunctionResultJs = require("../abi/encodeFunctionResult.js");
const localBatchGatewayUrl = 'x-batch-gateway:true';
async function localBatchGatewayRequest(parameters) {
    const { data, ccipRequest } = parameters;
    const { args: [queries] } = (0, _decodeFunctionDataJs.decodeFunctionData)({
        abi: (0, _abisJs.batchGatewayAbi),
        data
    });
    const failures = [];
    const responses = [];
    await Promise.all(queries.map(async (query, i)=>{
        try {
            responses[i] = await ccipRequest(query);
            failures[i] = false;
        } catch (err) {
            failures[i] = true;
            responses[i] = encodeError(err);
        }
    }));
    return (0, _encodeFunctionResultJs.encodeFunctionResult)({
        abi: (0, _abisJs.batchGatewayAbi),
        functionName: 'query',
        result: [
            failures,
            responses
        ]
    });
}
function encodeError(error) {
    if (error.name === 'HttpRequestError' && error.status) return (0, _encodeErrorResultJs.encodeErrorResult)({
        abi: (0, _abisJs.batchGatewayAbi),
        errorName: 'HttpError',
        args: [
            error.status,
            error.shortMessage
        ]
    });
    return (0, _encodeErrorResultJs.encodeErrorResult)({
        abi: [
            (0, _solidityJs.solidityError)
        ],
        errorName: 'Error',
        args: [
            'shortMessage' in error ? error.shortMessage : error.message
        ]
    });
}

},{"../../constants/abis.js":"ffwQK","../../constants/solidity.js":"bzCGA","../abi/decodeFunctionData.js":"lrq8I","../abi/encodeErrorResult.js":"6ieIf","../abi/encodeFunctionResult.js":"fKV1m","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lrq8I":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeFunctionData", ()=>decodeFunctionData);
var _abiJs = require("../../errors/abi.js");
var _sliceJs = require("../data/slice.js");
var _toFunctionSelectorJs = require("../hash/toFunctionSelector.js");
var _decodeAbiParametersJs = require("./decodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
function decodeFunctionData(parameters) {
    const { abi, data } = parameters;
    const signature = (0, _sliceJs.slice)(data, 0, 4);
    const description = abi.find((x)=>x.type === 'function' && signature === (0, _toFunctionSelectorJs.toFunctionSelector)((0, _formatAbiItemJs.formatAbiItem)(x)));
    if (!description) throw new (0, _abiJs.AbiFunctionSignatureNotFoundError)(signature, {
        docsPath: '/docs/contract/decodeFunctionData'
    });
    return {
        functionName: description.name,
        args: 'inputs' in description && description.inputs && description.inputs.length > 0 ? (0, _decodeAbiParametersJs.decodeAbiParameters)(description.inputs, (0, _sliceJs.slice)(data, 4)) : undefined
    };
}

},{"../../errors/abi.js":"7l8j7","../data/slice.js":"hh6kq","../hash/toFunctionSelector.js":"7CpcI","./decodeAbiParameters.js":"hR5FN","./formatAbiItem.js":"khxDG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6ieIf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeErrorResult", ()=>encodeErrorResult);
var _abiJs = require("../../errors/abi.js");
var _concatJs = require("../data/concat.js");
var _toFunctionSelectorJs = require("../hash/toFunctionSelector.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
var _formatAbiItemJs = require("./formatAbiItem.js");
var _getAbiItemJs = require("./getAbiItem.js");
const docsPath = '/docs/contract/encodeErrorResult';
function encodeErrorResult(parameters) {
    const { abi, errorName, args } = parameters;
    let abiItem = abi[0];
    if (errorName) {
        const item = (0, _getAbiItemJs.getAbiItem)({
            abi,
            args,
            name: errorName
        });
        if (!item) throw new (0, _abiJs.AbiErrorNotFoundError)(errorName, {
            docsPath
        });
        abiItem = item;
    }
    if (abiItem.type !== 'error') throw new (0, _abiJs.AbiErrorNotFoundError)(undefined, {
        docsPath
    });
    const definition = (0, _formatAbiItemJs.formatAbiItem)(abiItem);
    const signature = (0, _toFunctionSelectorJs.toFunctionSelector)(definition);
    let data = '0x';
    if (args && args.length > 0) {
        if (!abiItem.inputs) throw new (0, _abiJs.AbiErrorInputsNotFoundError)(abiItem.name, {
            docsPath
        });
        data = (0, _encodeAbiParametersJs.encodeAbiParameters)(abiItem.inputs, args);
    }
    return (0, _concatJs.concatHex)([
        signature,
        data
    ]);
}

},{"../../errors/abi.js":"7l8j7","../data/concat.js":"6FL5K","../hash/toFunctionSelector.js":"7CpcI","./encodeAbiParameters.js":"8kHRc","./formatAbiItem.js":"khxDG","./getAbiItem.js":"k6BVB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fKV1m":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeFunctionResult", ()=>encodeFunctionResult);
var _abiJs = require("../../errors/abi.js");
var _encodeAbiParametersJs = require("./encodeAbiParameters.js");
var _getAbiItemJs = require("./getAbiItem.js");
const docsPath = '/docs/contract/encodeFunctionResult';
function encodeFunctionResult(parameters) {
    const { abi, functionName, result } = parameters;
    let abiItem = abi[0];
    if (functionName) {
        const item = (0, _getAbiItemJs.getAbiItem)({
            abi,
            name: functionName
        });
        if (!item) throw new (0, _abiJs.AbiFunctionNotFoundError)(functionName, {
            docsPath
        });
        abiItem = item;
    }
    if (abiItem.type !== 'function') throw new (0, _abiJs.AbiFunctionNotFoundError)(undefined, {
        docsPath
    });
    if (!abiItem.outputs) throw new (0, _abiJs.AbiFunctionOutputsNotFoundError)(abiItem.name, {
        docsPath
    });
    const values = (()=>{
        if (abiItem.outputs.length === 0) return [];
        if (abiItem.outputs.length === 1) return [
            result
        ];
        if (Array.isArray(result)) return result;
        throw new (0, _abiJs.InvalidArrayError)(result);
    })();
    return (0, _encodeAbiParametersJs.encodeAbiParameters)(abiItem.outputs, values);
}

},{"../../errors/abi.js":"7l8j7","./encodeAbiParameters.js":"8kHRc","./getAbiItem.js":"k6BVB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"exJTH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Hashes ENS name
 *
 * - Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @example
 * namehash('wevm.eth')
 * '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'
 *
 * @link https://eips.ethereum.org/EIPS/eip-137
 */ parcelHelpers.export(exports, "namehash", ()=>namehash);
var _concatJs = require("../data/concat.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
var _keccak256Js = require("../hash/keccak256.js");
var _encodedLabelToLabelhashJs = require("./encodedLabelToLabelhash.js");
function namehash(name) {
    let result = new Uint8Array(32).fill(0);
    if (!name) return (0, _toHexJs.bytesToHex)(result);
    const labels = name.split('.');
    // Iterate in reverse order building up hash
    for(let i = labels.length - 1; i >= 0; i -= 1){
        const hashFromEncodedLabel = (0, _encodedLabelToLabelhashJs.encodedLabelToLabelhash)(labels[i]);
        const hashed = hashFromEncodedLabel ? (0, _toBytesJs.toBytes)(hashFromEncodedLabel) : (0, _keccak256Js.keccak256)((0, _toBytesJs.stringToBytes)(labels[i]), 'bytes');
        result = (0, _keccak256Js.keccak256)((0, _concatJs.concat)([
            result,
            hashed
        ]), 'bytes');
    }
    return (0, _toHexJs.bytesToHex)(result);
}

},{"../data/concat.js":"6FL5K","../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","../hash/keccak256.js":"k4CmV","./encodedLabelToLabelhash.js":"4DgRF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4DgRF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodedLabelToLabelhash", ()=>encodedLabelToLabelhash);
var _isHexJs = require("../data/isHex.js");
function encodedLabelToLabelhash(label) {
    if (label.length !== 66) return null;
    if (label.indexOf('[') !== 0) return null;
    if (label.indexOf(']') !== 65) return null;
    const hash = `0x${label.slice(1, 65)}`;
    if (!(0, _isHexJs.isHex)(hash)) return null;
    return hash;
}

},{"../data/isHex.js":"evOcm","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2LDSR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
 * @description Encodes a DNS packet into a ByteArray containing a UDP payload.
 *
 * @example
 * packetToBytes('awkweb.eth')
 * '0x0661776b7765620365746800'
 *
 * @see https://docs.ens.domains/resolution/names#dns
 *
 */ parcelHelpers.export(exports, "packetToBytes", ()=>packetToBytes);
var _toBytesJs = require("../encoding/toBytes.js");
var _encodeLabelhashJs = require("./encodeLabelhash.js");
var _labelhashJs = require("./labelhash.js");
function packetToBytes(packet) {
    // strip leading and trailing `.`
    const value = packet.replace(/^\.|\.$/gm, '');
    if (value.length === 0) return new Uint8Array(1);
    const bytes = new Uint8Array((0, _toBytesJs.stringToBytes)(value).byteLength + 2);
    let offset = 0;
    const list = value.split('.');
    for(let i = 0; i < list.length; i++){
        let encoded = (0, _toBytesJs.stringToBytes)(list[i]);
        // if the length is > 255, make the encoded label value a labelhash
        // this is compatible with the universal resolver
        if (encoded.byteLength > 255) encoded = (0, _toBytesJs.stringToBytes)((0, _encodeLabelhashJs.encodeLabelhash)((0, _labelhashJs.labelhash)(list[i])));
        bytes[offset] = encoded.length;
        bytes.set(encoded, offset + 1);
        offset += encoded.length + 1;
    }
    if (bytes.byteLength !== offset + 1) return bytes.slice(0, offset + 1);
    return bytes;
}

},{"../encoding/toBytes.js":"8cx1T","./encodeLabelhash.js":"35cQJ","./labelhash.js":"ebwrf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"35cQJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeLabelhash", ()=>encodeLabelhash);
function encodeLabelhash(hash) {
    return `[${hash.slice(2)}]`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ebwrf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Hashes ENS label
 *
 * - Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @example
 * labelhash('eth')
 * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'
 */ parcelHelpers.export(exports, "labelhash", ()=>labelhash);
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
var _keccak256Js = require("../hash/keccak256.js");
var _encodedLabelToLabelhashJs = require("./encodedLabelToLabelhash.js");
function labelhash(label) {
    const result = new Uint8Array(32).fill(0);
    if (!label) return (0, _toHexJs.bytesToHex)(result);
    return (0, _encodedLabelToLabelhashJs.encodedLabelToLabelhash)(label) || (0, _keccak256Js.keccak256)((0, _toBytesJs.stringToBytes)(label));
}

},{"../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","../hash/keccak256.js":"k4CmV","./encodedLabelToLabelhash.js":"4DgRF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1p6F1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets the avatar of an ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsAvatar
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
 *
 * Calls [`getEnsText`](https://viem.sh/docs/ens/actions/getEnsText) with `key` set to `'avatar'`.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsAvatarParameters}
 * @returns Avatar URI or `null` if not found. {@link GetEnsAvatarReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsAvatar, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const ensAvatar = await getEnsAvatar(client, {
 *   name: normalize('wevm.eth'),
 * })
 * // 'https://ipfs.io/ipfs/Qma8mnp6xV3J2cRNf3mTth5C8nV11CAnceVinc3y8jSbio'
 */ parcelHelpers.export(exports, "getEnsAvatar", ()=>getEnsAvatar);
var _parseAvatarRecordJs = require("../../utils/ens/avatar/parseAvatarRecord.js");
var _getActionJs = require("../../utils/getAction.js");
var _getEnsTextJs = require("./getEnsText.js");
async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress }) {
    const record = await (0, _getActionJs.getAction)(client, (0, _getEnsTextJs.getEnsText), 'getEnsText')({
        blockNumber,
        blockTag,
        key: 'avatar',
        name,
        universalResolverAddress,
        gatewayUrls,
        strict
    });
    if (!record) return null;
    try {
        return await (0, _parseAvatarRecordJs.parseAvatarRecord)(client, {
            record,
            gatewayUrls: assetGatewayUrls
        });
    } catch  {
        return null;
    }
}

},{"../../utils/ens/avatar/parseAvatarRecord.js":"fpA79","../../utils/getAction.js":"d1Bvd","./getEnsText.js":"cgLfK","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fpA79":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
 * @description Parses an ENS avatar record.
 *
 * @example
 * parseAvatarRecord('eip155:1/erc1155:0xb32979486938aa9694bfc898f35dbed459f44424/10063')
 * 'https://ipfs.io/ipfs/QmSP4nq9fnN9dAiCj42ug9Wa79rqmQerZXZch82VqpiH7U/image.gif'
 *
 * @see https://docs.ens.domains/web/avatars
 *
 */ parcelHelpers.export(exports, "parseAvatarRecord", ()=>parseAvatarRecord);
var _utilsJs = require("./utils.js");
async function parseAvatarRecord(client, { gatewayUrls, record }) {
    if (/eip155:/i.test(record)) return parseNftAvatarUri(client, {
        gatewayUrls,
        record
    });
    return (0, _utilsJs.parseAvatarUri)({
        uri: record,
        gatewayUrls
    });
}
async function parseNftAvatarUri(client, { gatewayUrls, record }) {
    // parse NFT URI into properties
    const nft = (0, _utilsJs.parseNftUri)(record);
    // fetch tokenURI from the NFT contract
    const nftUri = await (0, _utilsJs.getNftTokenUri)(client, {
        nft
    });
    // resolve the URI from the fetched tokenURI
    const { uri: resolvedNftUri, isOnChain, isEncoded } = (0, _utilsJs.resolveAvatarUri)({
        uri: nftUri,
        gatewayUrls
    });
    // if the resolved URI is on chain, return the data
    if (isOnChain && (resolvedNftUri.includes('data:application/json;base64,') || resolvedNftUri.startsWith('{'))) {
        const encodedJson = isEncoded ? atob(resolvedNftUri.replace('data:application/json;base64,', '')) : resolvedNftUri;
        const decoded = JSON.parse(encodedJson);
        return (0, _utilsJs.parseAvatarUri)({
            uri: (0, _utilsJs.getJsonImage)(decoded),
            gatewayUrls
        });
    }
    let uriTokenId = nft.tokenID;
    if (nft.namespace === 'erc1155') uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0');
    return (0, _utilsJs.getMetadataAvatarUri)({
        gatewayUrls,
        uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
    });
}

},{"./utils.js":"f587Q","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f587Q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "isImageUri", ()=>isImageUri);
/** @internal */ parcelHelpers.export(exports, "getGateway", ()=>getGateway);
parcelHelpers.export(exports, "resolveAvatarUri", ()=>resolveAvatarUri);
parcelHelpers.export(exports, "getJsonImage", ()=>getJsonImage);
parcelHelpers.export(exports, "getMetadataAvatarUri", ()=>getMetadataAvatarUri);
parcelHelpers.export(exports, "parseAvatarUri", ()=>parseAvatarUri);
parcelHelpers.export(exports, "parseNftUri", ()=>parseNftUri);
parcelHelpers.export(exports, "getNftTokenUri", ()=>getNftTokenUri);
var _readContractJs = require("../../../actions/public/readContract.js");
var _ensJs = require("../../../errors/ens.js");
const networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
    try {
        const res = await fetch(uri, {
            method: 'HEAD'
        });
        // retrieve content type header to check if content is image
        if (res.status === 200) {
            const contentType = res.headers.get('content-type');
            return contentType?.startsWith('image/');
        }
        return false;
    } catch (error) {
        // if error is not cors related then fail
        if (typeof error === 'object' && typeof error.response !== 'undefined') return false;
        // fail in NodeJS, since the error is not cors but any other network issue
        // biome-ignore lint/suspicious/noPrototypeBuiltins:
        if (!globalThis.hasOwnProperty('Image')) return false;
        // in case of cors, use image api to validate if given url is an actual image
        return new Promise((resolve)=>{
            const img = new Image();
            img.onload = ()=>{
                resolve(true);
            };
            img.onerror = ()=>{
                resolve(false);
            };
            img.src = uri;
        });
    }
}
function getGateway(custom, defaultGateway) {
    if (!custom) return defaultGateway;
    if (custom.endsWith('/')) return custom.slice(0, -1);
    return custom;
}
function resolveAvatarUri({ uri, gatewayUrls }) {
    const isEncoded = base64Regex.test(uri);
    if (isEncoded) return {
        uri,
        isOnChain: true,
        isEncoded
    };
    const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io');
    const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net');
    const networkRegexMatch = uri.match(networkRegex);
    const { protocol, subpath, target, subtarget = '' } = networkRegexMatch?.groups || {};
    const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';
    const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);
    if (uri.startsWith('http') && !isIPNS && !isIPFS) {
        let replacedUri = uri;
        if (gatewayUrls?.arweave) replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
        return {
            uri: replacedUri,
            isOnChain: false,
            isEncoded: false
        };
    }
    if ((isIPNS || isIPFS) && target) return {
        uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,
        isOnChain: false,
        isEncoded: false
    };
    if (protocol === 'ar:/' && target) return {
        uri: `${arweaveGateway}/${target}${subtarget || ''}`,
        isOnChain: false,
        isEncoded: false
    };
    let parsedUri = uri.replace(dataURIRegex, '');
    if (parsedUri.startsWith('<svg')) // if svg, base64 encode
    parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
    if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) return {
        uri: parsedUri,
        isOnChain: true,
        isEncoded: false
    };
    throw new (0, _ensJs.EnsAvatarUriResolutionError)({
        uri
    });
}
function getJsonImage(data) {
    // validation check for json data, must include one of theses properties
    if (typeof data !== 'object' || !('image' in data) && !('image_url' in data) && !('image_data' in data)) throw new (0, _ensJs.EnsAvatarInvalidMetadataError)({
        data
    });
    return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri }) {
    try {
        const res = await fetch(uri).then((res)=>res.json());
        const image = await parseAvatarUri({
            gatewayUrls,
            uri: getJsonImage(res)
        });
        return image;
    } catch  {
        throw new (0, _ensJs.EnsAvatarUriResolutionError)({
            uri
        });
    }
}
async function parseAvatarUri({ gatewayUrls, uri }) {
    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({
        uri,
        gatewayUrls
    });
    if (isOnChain) return resolvedURI;
    // check if resolvedURI is an image, if it is return the url
    const isImage = await isImageUri(resolvedURI);
    if (isImage) return resolvedURI;
    throw new (0, _ensJs.EnsAvatarUriResolutionError)({
        uri
    });
}
function parseNftUri(uri_) {
    let uri = uri_;
    // parse valid nft spec (CAIP-22/CAIP-29)
    // @see: https://github.com/ChainAgnostic/CAIPs/tree/master/CAIPs
    if (uri.startsWith('did:nft:')) // convert DID to CAIP
    uri = uri.replace('did:nft:', '').replace(/_/g, '/');
    const [reference, asset_namespace, tokenID] = uri.split('/');
    const [eip_namespace, chainID] = reference.split(':');
    const [erc_namespace, contractAddress] = asset_namespace.split(':');
    if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155') throw new (0, _ensJs.EnsAvatarInvalidNftUriError)({
        reason: 'Only EIP-155 supported'
    });
    if (!chainID) throw new (0, _ensJs.EnsAvatarInvalidNftUriError)({
        reason: 'Chain ID not found'
    });
    if (!contractAddress) throw new (0, _ensJs.EnsAvatarInvalidNftUriError)({
        reason: 'Contract address not found'
    });
    if (!tokenID) throw new (0, _ensJs.EnsAvatarInvalidNftUriError)({
        reason: 'Token ID not found'
    });
    if (!erc_namespace) throw new (0, _ensJs.EnsAvatarInvalidNftUriError)({
        reason: 'ERC namespace not found'
    });
    return {
        chainID: Number.parseInt(chainID),
        namespace: erc_namespace.toLowerCase(),
        contractAddress: contractAddress,
        tokenID
    };
}
async function getNftTokenUri(client, { nft }) {
    if (nft.namespace === 'erc721') return (0, _readContractJs.readContract)(client, {
        address: nft.contractAddress,
        abi: [
            {
                name: 'tokenURI',
                type: 'function',
                stateMutability: 'view',
                inputs: [
                    {
                        name: 'tokenId',
                        type: 'uint256'
                    }
                ],
                outputs: [
                    {
                        name: '',
                        type: 'string'
                    }
                ]
            }
        ],
        functionName: 'tokenURI',
        args: [
            BigInt(nft.tokenID)
        ]
    });
    if (nft.namespace === 'erc1155') return (0, _readContractJs.readContract)(client, {
        address: nft.contractAddress,
        abi: [
            {
                name: 'uri',
                type: 'function',
                stateMutability: 'view',
                inputs: [
                    {
                        name: '_id',
                        type: 'uint256'
                    }
                ],
                outputs: [
                    {
                        name: '',
                        type: 'string'
                    }
                ]
            }
        ],
        functionName: 'uri',
        args: [
            BigInt(nft.tokenID)
        ]
    });
    throw new (0, _ensJs.EnsAvatarUnsupportedNamespaceError)({
        namespace: nft.namespace
    });
}

},{"../../../actions/public/readContract.js":"fusIl","../../../errors/ens.js":"7GanX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7GanX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EnsAvatarInvalidMetadataError", ()=>EnsAvatarInvalidMetadataError);
parcelHelpers.export(exports, "EnsAvatarInvalidNftUriError", ()=>EnsAvatarInvalidNftUriError);
parcelHelpers.export(exports, "EnsAvatarUriResolutionError", ()=>EnsAvatarUriResolutionError);
parcelHelpers.export(exports, "EnsAvatarUnsupportedNamespaceError", ()=>EnsAvatarUnsupportedNamespaceError);
var _baseJs = require("./base.js");
class EnsAvatarInvalidMetadataError extends (0, _baseJs.BaseError) {
    constructor({ data }){
        super('Unable to extract image from metadata. The metadata may be malformed or invalid.', {
            metaMessages: [
                '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',
                '',
                `Provided data: ${JSON.stringify(data)}`
            ],
            name: 'EnsAvatarInvalidMetadataError'
        });
    }
}
class EnsAvatarInvalidNftUriError extends (0, _baseJs.BaseError) {
    constructor({ reason }){
        super(`ENS NFT avatar URI is invalid. ${reason}`, {
            name: 'EnsAvatarInvalidNftUriError'
        });
    }
}
class EnsAvatarUriResolutionError extends (0, _baseJs.BaseError) {
    constructor({ uri }){
        super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, {
            name: 'EnsAvatarUriResolutionError'
        });
    }
}
class EnsAvatarUnsupportedNamespaceError extends (0, _baseJs.BaseError) {
    constructor({ namespace }){
        super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, {
            name: 'EnsAvatarUnsupportedNamespaceError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cgLfK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets a text record for specified ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
 *
 * Calls `resolve(bytes, bytes)` on ENS Universal Resolver Contract.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsTextParameters}
 * @returns Address for ENS resolver. {@link GetEnsTextReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsText, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const twitterRecord = await getEnsText(client, {
 *   name: normalize('wevm.eth'),
 *   key: 'com.twitter',
 * })
 * // 'wevm_dev'
 */ parcelHelpers.export(exports, "getEnsText", ()=>getEnsText);
var _abisJs = require("../../constants/abis.js");
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getChainContractAddressJs = require("../../utils/chain/getChainContractAddress.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _errorsJs = require("../../utils/ens/errors.js");
var _localBatchGatewayRequestJs = require("../../utils/ens/localBatchGatewayRequest.js");
var _namehashJs = require("../../utils/ens/namehash.js");
var _packetToBytesJs = require("../../utils/ens/packetToBytes.js");
var _getActionJs = require("../../utils/getAction.js");
var _readContractJs = require("../public/readContract.js");
async function getEnsText(client, parameters) {
    const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters;
    const { chain } = client;
    const universalResolverAddress = (()=>{
        if (parameters.universalResolverAddress) return parameters.universalResolverAddress;
        if (!chain) throw new Error('client chain not configured. universalResolverAddress is required.');
        return (0, _getChainContractAddressJs.getChainContractAddress)({
            blockNumber,
            chain,
            contract: 'ensUniversalResolver'
        });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld)=>name.endsWith(tld))) return null;
    try {
        const readContractParameters = {
            address: universalResolverAddress,
            abi: (0, _abisJs.universalResolverResolveAbi),
            functionName: 'resolve',
            args: [
                (0, _toHexJs.toHex)((0, _packetToBytesJs.packetToBytes)(name)),
                (0, _encodeFunctionDataJs.encodeFunctionData)({
                    abi: (0, _abisJs.textResolverAbi),
                    functionName: 'text',
                    args: [
                        (0, _namehashJs.namehash)(name),
                        key
                    ]
                }),
                gatewayUrls ?? [
                    (0, _localBatchGatewayRequestJs.localBatchGatewayUrl)
                ]
            ],
            blockNumber,
            blockTag
        };
        const readContractAction = (0, _getActionJs.getAction)(client, (0, _readContractJs.readContract), 'readContract');
        const res = await readContractAction(readContractParameters);
        if (res[0] === '0x') return null;
        const record = (0, _decodeFunctionResultJs.decodeFunctionResult)({
            abi: (0, _abisJs.textResolverAbi),
            functionName: 'text',
            data: res[0]
        });
        return record === '' ? null : record;
    } catch (err) {
        if (strict) throw err;
        if ((0, _errorsJs.isNullUniversalResolverError)(err, 'resolve')) return null;
        throw err;
    }
}

},{"../../constants/abis.js":"ffwQK","../../utils/abi/decodeFunctionResult.js":"j76hM","../../utils/abi/encodeFunctionData.js":"eQLEb","../../utils/chain/getChainContractAddress.js":"cNh6w","../../utils/encoding/toHex.js":"9GFC6","../../utils/ens/errors.js":"4b1mw","../../utils/ens/localBatchGatewayRequest.js":"iuGj1","../../utils/ens/namehash.js":"exJTH","../../utils/ens/packetToBytes.js":"2LDSR","../../utils/getAction.js":"d1Bvd","../public/readContract.js":"fusIl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7kAMa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets primary name for specified address.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsName
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
 *
 * Calls `reverse(bytes)` on ENS Universal Resolver Contract to "reverse resolve" the address to the primary ENS name.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsNameParameters}
 * @returns Name or `null` if not found. {@link GetEnsNameReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsName } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const ensName = await getEnsName(client, {
 *   address: '0xd2135CfB216b74109775236E36d4b433F1DF507B',
 * })
 * // 'wevm.eth'
 */ parcelHelpers.export(exports, "getEnsName", ()=>getEnsName);
var _abisJs = require("../../constants/abis.js");
var _getChainContractAddressJs = require("../../utils/chain/getChainContractAddress.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _errorsJs = require("../../utils/ens/errors.js");
var _packetToBytesJs = require("../../utils/ens/packetToBytes.js");
var _getActionJs = require("../../utils/getAction.js");
var _readContractJs = require("../public/readContract.js");
async function getEnsName(client, { address, blockNumber, blockTag, gatewayUrls, strict, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
        if (!client.chain) throw new Error('client chain not configured. universalResolverAddress is required.');
        universalResolverAddress = (0, _getChainContractAddressJs.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: 'ensUniversalResolver'
        });
    }
    const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
    try {
        const readContractParameters = {
            address: universalResolverAddress,
            abi: (0, _abisJs.universalResolverReverseAbi),
            functionName: 'reverse',
            args: [
                (0, _toHexJs.toHex)((0, _packetToBytesJs.packetToBytes)(reverseNode))
            ],
            blockNumber,
            blockTag
        };
        const readContractAction = (0, _getActionJs.getAction)(client, (0, _readContractJs.readContract), 'readContract');
        const [name, resolvedAddress] = gatewayUrls ? await readContractAction({
            ...readContractParameters,
            args: [
                ...readContractParameters.args,
                gatewayUrls
            ]
        }) : await readContractAction(readContractParameters);
        if (address.toLowerCase() !== resolvedAddress.toLowerCase()) return null;
        return name;
    } catch (err) {
        if (strict) throw err;
        if ((0, _errorsJs.isNullUniversalResolverError)(err, 'reverse')) return null;
        throw err;
    }
}

},{"../../constants/abis.js":"ffwQK","../../utils/chain/getChainContractAddress.js":"cNh6w","../../utils/encoding/toHex.js":"9GFC6","../../utils/ens/errors.js":"4b1mw","../../utils/ens/packetToBytes.js":"2LDSR","../../utils/getAction.js":"d1Bvd","../public/readContract.js":"fusIl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i1DVp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gets resolver for ENS name.
 *
 * - Docs: https://viem.sh/docs/ens/actions/getEnsResolver
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/ens
 *
 * Calls `findResolver(bytes)` on ENS Universal Resolver Contract to retrieve the resolver of an ENS name.
 *
 * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `getEnsAddress`. You can use the built-in [`normalize`](https://viem.sh/docs/ens/utilities/normalize) function for this.
 *
 * @param client - Client to use
 * @param parameters - {@link GetEnsResolverParameters}
 * @returns Address for ENS resolver. {@link GetEnsResolverReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getEnsResolver, normalize } from 'viem/ens'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const resolverAddress = await getEnsResolver(client, {
 *   name: normalize('wevm.eth'),
 * })
 * // '0x4976fb03C32e5B8cfe2b6cCB31c09Ba78EBaBa41'
 */ parcelHelpers.export(exports, "getEnsResolver", ()=>getEnsResolver);
var _getChainContractAddressJs = require("../../utils/chain/getChainContractAddress.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _packetToBytesJs = require("../../utils/ens/packetToBytes.js");
var _getActionJs = require("../../utils/getAction.js");
var _readContractJs = require("../public/readContract.js");
async function getEnsResolver(client, parameters) {
    const { blockNumber, blockTag, name } = parameters;
    const { chain } = client;
    const universalResolverAddress = (()=>{
        if (parameters.universalResolverAddress) return parameters.universalResolverAddress;
        if (!chain) throw new Error('client chain not configured. universalResolverAddress is required.');
        return (0, _getChainContractAddressJs.getChainContractAddress)({
            blockNumber,
            chain,
            contract: 'ensUniversalResolver'
        });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld)=>name.endsWith(tld))) throw new Error(`${name} is not a valid ENS TLD (${tlds?.join(', ')}) for chain "${chain.name}" (id: ${chain.id}).`);
    const [resolverAddress] = await (0, _getActionJs.getAction)(client, (0, _readContractJs.readContract), 'readContract')({
        address: universalResolverAddress,
        abi: [
            {
                inputs: [
                    {
                        type: 'bytes'
                    }
                ],
                name: 'findResolver',
                outputs: [
                    {
                        type: 'address'
                    },
                    {
                        type: 'bytes32'
                    }
                ],
                stateMutability: 'view',
                type: 'function'
            }
        ],
        functionName: 'findResolver',
        args: [
            (0, _toHexJs.toHex)((0, _packetToBytesJs.packetToBytes)(name))
        ],
        blockNumber,
        blockTag
    });
    return resolverAddress;
}

},{"../../utils/chain/getChainContractAddress.js":"cNh6w","../../utils/encoding/toHex.js":"9GFC6","../../utils/ens/packetToBytes.js":"2LDSR","../../utils/getAction.js":"d1Bvd","../public/readContract.js":"fusIl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gaOy9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates an EIP-2930 access list.
 *
 * - Docs: https://viem.sh/docs/actions/public/createAccessList
 * - JSON-RPC Methods: `eth_createAccessList`
 *
 * @param client - Client to use
 * @param parameters - {@link CreateAccessListParameters}
 * @returns The access list. {@link CreateAccessListReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createAccessList } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const data = await createAccessList(client, {
 *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
 *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 * })
 */ parcelHelpers.export(exports, "createAccessList", ()=>createAccessList);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _getCallErrorJs = require("../../utils/errors/getCallError.js");
var _extractJs = require("../../utils/formatters/extract.js");
var _transactionRequestJs = require("../../utils/formatters/transactionRequest.js");
var _assertRequestJs = require("../../utils/transaction/assertRequest.js");
async function createAccessList(client, args) {
    const { account: account_ = client.account, blockNumber, blockTag = 'latest', blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, to, value, ...rest } = args;
    const account = account_ ? (0, _parseAccountJs.parseAccount)(account_) : undefined;
    try {
        (0, _assertRequestJs.assertRequest)(args);
        const blockNumberHex = typeof blockNumber === 'bigint' ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || (0, _transactionRequestJs.formatTransactionRequest);
        const request = format({
            // Pick out extra data that might exist on the chain's transaction request type.
            ...(0, _extractJs.extract)(rest, {
                format: chainFormat
            }),
            from: account?.address,
            blobs,
            data,
            gas,
            gasPrice,
            maxFeePerBlobGas,
            maxFeePerGas,
            maxPriorityFeePerGas,
            to,
            value
        });
        const response = await client.request({
            method: 'eth_createAccessList',
            params: [
                request,
                block
            ]
        });
        return {
            accessList: response.accessList,
            gasUsed: BigInt(response.gasUsed)
        };
    } catch (err) {
        throw (0, _getCallErrorJs.getCallError)(err, {
            ...args,
            account,
            chain: client.chain
        });
    }
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../utils/encoding/toHex.js":"9GFC6","../../utils/errors/getCallError.js":"14DML","../../utils/formatters/extract.js":"g9KS8","../../utils/formatters/transactionRequest.js":"dLljr","../../utils/transaction/assertRequest.js":"eSiKr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eUMUC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new block hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).
 *
 * - Docs: https://viem.sh/docs/actions/public/createBlockFilter
 * - JSON-RPC Methods: [`eth_newBlockFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newBlockFilter)
 *
 * @param client - Client to use
 * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateBlockFilterReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createBlockFilter } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createBlockFilter(client)
 * // { id: "0x345a6572337856574a76364e457a4366", type: 'block' }
 */ parcelHelpers.export(exports, "createBlockFilter", ()=>createBlockFilter);
var _createFilterRequestScopeJs = require("../../utils/filters/createFilterRequestScope.js");
async function createBlockFilter(client) {
    const getRequest = (0, _createFilterRequestScopeJs.createFilterRequestScope)(client, {
        method: 'eth_newBlockFilter'
    });
    const id = await client.request({
        method: 'eth_newBlockFilter'
    });
    return {
        id,
        request: getRequest(id),
        type: 'block'
    };
}

},{"../../utils/filters/createFilterRequestScope.js":"lUucN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4xY9E":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a [`Filter`](https://viem.sh/docs/glossary/types#filter) to listen for new events that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).
 *
 * - Docs: https://viem.sh/docs/actions/public/createEventFilter
 * - JSON-RPC Methods: [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter)
 *
 * @param client - Client to use
 * @param parameters - {@link CreateEventFilterParameters}
 * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateEventFilterReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createEventFilter } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createEventFilter(client, {
 *   address: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
 * })
 */ parcelHelpers.export(exports, "createEventFilter", ()=>createEventFilter);
var _encodeEventTopicsJs = require("../../utils/abi/encodeEventTopics.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _createFilterRequestScopeJs = require("../../utils/filters/createFilterRequestScope.js");
async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock } = {}) {
    const events = events_ ?? (event ? [
        event
    ] : undefined);
    const getRequest = (0, _createFilterRequestScopeJs.createFilterRequestScope)(client, {
        method: 'eth_newFilter'
    });
    let topics = [];
    if (events) {
        const encoded = events.flatMap((event)=>(0, _encodeEventTopicsJs.encodeEventTopics)({
                abi: [
                    event
                ],
                eventName: event.name,
                args
            }));
        // TODO: Clean up type casting
        topics = [
            encoded
        ];
        if (event) topics = topics[0];
    }
    const id = await client.request({
        method: 'eth_newFilter',
        params: [
            {
                address,
                fromBlock: typeof fromBlock === 'bigint' ? (0, _toHexJs.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === 'bigint' ? (0, _toHexJs.numberToHex)(toBlock) : toBlock,
                ...topics.length ? {
                    topics
                } : {}
            }
        ]
    });
    return {
        abi: events,
        args,
        eventName: event ? event.name : undefined,
        fromBlock,
        id,
        request: getRequest(id),
        strict: Boolean(strict),
        toBlock,
        type: 'event'
    };
}

},{"../../utils/abi/encodeEventTopics.js":"7zHy3","../../utils/encoding/toHex.js":"9GFC6","../../utils/filters/createFilterRequestScope.js":"lUucN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4xwLI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a Filter to listen for new pending transaction hashes that can be used with [`getFilterChanges`](https://viem.sh/docs/actions/public/getFilterChanges).
 *
 * - Docs: https://viem.sh/docs/actions/public/createPendingTransactionFilter
 * - JSON-RPC Methods: [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter)
 *
 * @param client - Client to use
 * @returns [`Filter`](https://viem.sh/docs/glossary/types#filter). {@link CreateBlockFilterReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createPendingTransactionFilter } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createPendingTransactionFilter(client)
 * // { id: "0x345a6572337856574a76364e457a4366", type: 'transaction' }
 */ parcelHelpers.export(exports, "createPendingTransactionFilter", ()=>createPendingTransactionFilter);
var _createFilterRequestScopeJs = require("../../utils/filters/createFilterRequestScope.js");
async function createPendingTransactionFilter(client) {
    const getRequest = (0, _createFilterRequestScopeJs.createFilterRequestScope)(client, {
        method: 'eth_newPendingTransactionFilter'
    });
    const id = await client.request({
        method: 'eth_newPendingTransactionFilter'
    });
    return {
        id,
        request: getRequest(id),
        type: 'transaction'
    };
}

},{"../../utils/filters/createFilterRequestScope.js":"lUucN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5r8SD":[function(require,module,exports,__globalThis) {
/**
 * Returns the base fee per blob gas in wei.
 *
 * - Docs: https://viem.sh/docs/actions/public/getBlobBaseFee
 * - JSON-RPC Methods: [`eth_blobBaseFee`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blobBaseFee)
 *
 * @param client - Client to use
 * @returns The blob base fee (in wei). {@link GetBlobBaseFeeReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBlobBaseFee } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const blobBaseFee = await getBlobBaseFee(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getBlobBaseFee", ()=>getBlobBaseFee);
async function getBlobBaseFee(client) {
    const baseFee = await client.request({
        method: 'eth_blobBaseFee'
    });
    return BigInt(baseFee);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fHNqe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the number of Transactions at a block number, hash, or tag.
 *
 * - Docs: https://viem.sh/docs/actions/public/getBlockTransactionCount
 * - JSON-RPC Methods:
 *   - Calls [`eth_getBlockTransactionCountByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbynumber) for `blockNumber` & `blockTag`.
 *   - Calls [`eth_getBlockTransactionCountByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblocktransactioncountbyhash) for `blockHash`.
 *
 * @param client - Client to use
 * @param parameters - {@link GetBlockTransactionCountParameters}
 * @returns The block transaction count. {@link GetBlockTransactionCountReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getBlockTransactionCount } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const count = await getBlockTransactionCount(client)
 */ parcelHelpers.export(exports, "getBlockTransactionCount", ()=>getBlockTransactionCount);
var _fromHexJs = require("../../utils/encoding/fromHex.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = 'latest' } = {}) {
    const blockNumberHex = blockNumber !== undefined ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    let count;
    if (blockHash) count = await client.request({
        method: 'eth_getBlockTransactionCountByHash',
        params: [
            blockHash
        ]
    }, {
        dedupe: true
    });
    else count = await client.request({
        method: 'eth_getBlockTransactionCountByNumber',
        params: [
            blockNumberHex || blockTag
        ]
    }, {
        dedupe: Boolean(blockNumberHex)
    });
    return (0, _fromHexJs.hexToNumber)(count);
}

},{"../../utils/encoding/fromHex.js":"kLfW5","../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g3EeR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Retrieves the bytecode at an address.
 *
 * - Docs: https://viem.sh/docs/contract/getCode
 * - JSON-RPC Methods: [`eth_getCode`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getcode)
 *
 * @param client - Client to use
 * @param parameters - {@link GetCodeParameters}
 * @returns The contract's bytecode. {@link GetCodeReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getCode } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const code = await getCode(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 * })
 */ parcelHelpers.export(exports, "getCode", ()=>getCode);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function getCode(client, { address, blockNumber, blockTag = 'latest' }) {
    const blockNumberHex = blockNumber !== undefined ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    const hex = await client.request({
        method: 'eth_getCode',
        params: [
            address,
            blockNumberHex || blockTag
        ]
    }, {
        dedupe: Boolean(blockNumberHex)
    });
    if (hex === '0x') return undefined;
    return hex;
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2iQjU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Reads the EIP-712 domain from a contract, based on the ERC-5267 specification.
 *
 * @param client - A {@link Client} instance.
 * @param parameters - The parameters of the action. {@link GetEip712DomainParameters}
 * @returns The EIP-712 domain, fields, and extensions. {@link GetEip712DomainReturnType}
 *
 * @example
 * ```ts
 * import { createPublicClient, http, getEip712Domain } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 *
 * const domain = await getEip712Domain(client, {
 *   address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
 * })
 * // {
 * //   domain: {
 * //     name: 'ExampleContract',
 * //     version: '1',
 * //     chainId: 1,
 * //     verifyingContract: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
 * //   },
 * //   fields: '0x0f',
 * //   extensions: [],
 * // }
 * ```
 */ parcelHelpers.export(exports, "getEip712Domain", ()=>getEip712Domain);
var _eip712Js = require("../../errors/eip712.js");
var _getActionJs = require("../../utils/getAction.js");
var _readContractJs = require("./readContract.js");
async function getEip712Domain(client, parameters) {
    const { address, factory, factoryData } = parameters;
    try {
        const [fields, name, version, chainId, verifyingContract, salt, extensions] = await (0, _getActionJs.getAction)(client, (0, _readContractJs.readContract), 'readContract')({
            abi,
            address,
            functionName: 'eip712Domain',
            factory,
            factoryData
        });
        return {
            domain: {
                name,
                version,
                chainId: Number(chainId),
                verifyingContract,
                salt
            },
            extensions,
            fields
        };
    } catch (e) {
        const error = e;
        if (error.name === 'ContractFunctionExecutionError' && error.cause.name === 'ContractFunctionZeroDataError') throw new (0, _eip712Js.Eip712DomainNotFoundError)({
            address
        });
        throw error;
    }
}
const abi = [
    {
        inputs: [],
        name: 'eip712Domain',
        outputs: [
            {
                name: 'fields',
                type: 'bytes1'
            },
            {
                name: 'name',
                type: 'string'
            },
            {
                name: 'version',
                type: 'string'
            },
            {
                name: 'chainId',
                type: 'uint256'
            },
            {
                name: 'verifyingContract',
                type: 'address'
            },
            {
                name: 'salt',
                type: 'bytes32'
            },
            {
                name: 'extensions',
                type: 'uint256[]'
            }
        ],
        stateMutability: 'view',
        type: 'function'
    }
];

},{"../../errors/eip712.js":"gQ9c9","../../utils/getAction.js":"d1Bvd","./readContract.js":"fusIl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gQ9c9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Eip712DomainNotFoundError", ()=>Eip712DomainNotFoundError);
var _baseJs = require("./base.js");
class Eip712DomainNotFoundError extends (0, _baseJs.BaseError) {
    constructor({ address }){
        super(`No EIP-712 domain found on contract "${address}".`, {
            metaMessages: [
                'Ensure that:',
                `- The contract is deployed at the address "${address}".`,
                '- `eip712Domain()` function exists on the contract.',
                '- `eip712Domain()` function matches signature to ERC-5267 specification.'
            ],
            name: 'Eip712DomainNotFoundError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4l4cq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a collection of historical gas information.
 *
 * - Docs: https://viem.sh/docs/actions/public/getFeeHistory
 * - JSON-RPC Methods: [`eth_feeHistory`](https://docs.alchemy.com/reference/eth-feehistory)
 *
 * @param client - Client to use
 * @param parameters - {@link GetFeeHistoryParameters}
 * @returns The gas estimate (in wei). {@link GetFeeHistoryReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getFeeHistory } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const feeHistory = await getFeeHistory(client, {
 *   blockCount: 4,
 *   rewardPercentiles: [25, 75],
 * })
 */ parcelHelpers.export(exports, "getFeeHistory", ()=>getFeeHistory);
var _toHexJs = require("../../utils/encoding/toHex.js");
var _feeHistoryJs = require("../../utils/formatters/feeHistory.js");
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = 'latest', rewardPercentiles }) {
    const blockNumberHex = typeof blockNumber === 'bigint' ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    const feeHistory = await client.request({
        method: 'eth_feeHistory',
        params: [
            (0, _toHexJs.numberToHex)(blockCount),
            blockNumberHex || blockTag,
            rewardPercentiles
        ]
    }, {
        dedupe: Boolean(blockNumberHex)
    });
    return (0, _feeHistoryJs.formatFeeHistory)(feeHistory);
}

},{"../../utils/encoding/toHex.js":"9GFC6","../../utils/formatters/feeHistory.js":"6usX2","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6usX2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatFeeHistory", ()=>formatFeeHistory);
function formatFeeHistory(feeHistory) {
    return {
        baseFeePerGas: feeHistory.baseFeePerGas.map((value)=>BigInt(value)),
        gasUsedRatio: feeHistory.gasUsedRatio,
        oldestBlock: BigInt(feeHistory.oldestBlock),
        reward: feeHistory.reward?.map((reward)=>reward.map((value)=>BigInt(value)))
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lgs4M":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of event logs since the filter was created.
 *
 * - Docs: https://viem.sh/docs/actions/public/getFilterLogs
 * - JSON-RPC Methods: [`eth_getFilterLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterlogs)
 *
 * `getFilterLogs` is only compatible with **event filters**.
 *
 * @param client - Client to use
 * @param parameters - {@link GetFilterLogsParameters}
 * @returns A list of event logs. {@link GetFilterLogsReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbiItem } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { createEventFilter, getFilterLogs } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const filter = await createEventFilter(client, {
 *   address: '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',
 *   event: parseAbiItem('event Transfer(address indexed, address indexed, uint256)'),
 * })
 * const logs = await getFilterLogs(client, { filter })
 */ parcelHelpers.export(exports, "getFilterLogs", ()=>getFilterLogs);
var _parseEventLogsJs = require("../../utils/abi/parseEventLogs.js");
var _logJs = require("../../utils/formatters/log.js");
async function getFilterLogs(_client, { filter }) {
    const strict = filter.strict ?? false;
    const logs = await filter.request({
        method: 'eth_getFilterLogs',
        params: [
            filter.id
        ]
    });
    const formattedLogs = logs.map((log)=>(0, _logJs.formatLog)(log));
    if (!filter.abi) return formattedLogs;
    return (0, _parseEventLogsJs.parseEventLogs)({
        abi: filter.abi,
        logs: formattedLogs,
        strict
    });
}

},{"../../utils/abi/parseEventLogs.js":"3coRk","../../utils/formatters/log.js":"aaYKq","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j69FV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the account and storage values of the specified account including the Merkle-proof.
 *
 * - Docs: https://viem.sh/docs/actions/public/getProof
 * - JSON-RPC Methods:
 *   - Calls [`eth_getProof`](https://eips.ethereum.org/EIPS/eip-1186)
 *
 * @param client - Client to use
 * @param parameters - {@link GetProofParameters}
 * @returns Proof data. {@link GetProofReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getProof } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const block = await getProof(client, {
 *  address: '0x...',
 *  storageKeys: ['0x...'],
 * })
 */ parcelHelpers.export(exports, "getProof", ()=>getProof);
var _toHexJs = require("../../utils/encoding/toHex.js");
var _proofJs = require("../../utils/formatters/proof.js");
async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys }) {
    const blockTag = blockTag_ ?? 'latest';
    const blockNumberHex = blockNumber !== undefined ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    const proof = await client.request({
        method: 'eth_getProof',
        params: [
            address,
            storageKeys,
            blockNumberHex || blockTag
        ]
    });
    return (0, _proofJs.formatProof)(proof);
}

},{"../../utils/encoding/toHex.js":"9GFC6","../../utils/formatters/proof.js":"2FPx4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2FPx4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatProof", ()=>formatProof);
var _indexJs = require("../index.js");
function formatStorageProof(storageProof) {
    return storageProof.map((proof)=>({
            ...proof,
            value: BigInt(proof.value)
        }));
}
function formatProof(proof) {
    return {
        ...proof,
        balance: proof.balance ? BigInt(proof.balance) : undefined,
        nonce: proof.nonce ? (0, _indexJs.hexToNumber)(proof.nonce) : undefined,
        storageProof: proof.storageProof ? formatStorageProof(proof.storageProof) : undefined
    };
}

},{"../index.js":"ceNVN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ceNVN":[function(require,module,exports,__globalThis) {
// biome-ignore lint/performance/noBarrelFile: entrypoint module
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "buildRequest", ()=>(0, _buildRequestJs.buildRequest));
parcelHelpers.export(exports, "ccipRequest", ()=>(0, _ccipJs.ccipRequest));
parcelHelpers.export(exports, "ccipFetch", ()=>(0, _ccipJs.ccipRequest));
parcelHelpers.export(exports, "offchainLookup", ()=>(0, _ccipJs.offchainLookup));
parcelHelpers.export(exports, "offchainLookupAbiItem", ()=>(0, _ccipJs.offchainLookupAbiItem));
parcelHelpers.export(exports, "offchainLookupSignature", ()=>(0, _ccipJs.offchainLookupSignature));
parcelHelpers.export(exports, "assertCurrentChain", ()=>(0, _assertCurrentChainJs.assertCurrentChain));
parcelHelpers.export(exports, "defineChain", ()=>(0, _defineChainJs.defineChain));
parcelHelpers.export(exports, "extractChain", ()=>(0, _extractChainJs.extractChain));
parcelHelpers.export(exports, "getChainContractAddress", ()=>(0, _getChainContractAddressJs.getChainContractAddress));
parcelHelpers.export(exports, "arrayRegex", ()=>(0, _regexJs.arrayRegex));
parcelHelpers.export(exports, "bytesRegex", ()=>(0, _regexJs.bytesRegex));
parcelHelpers.export(exports, "integerRegex", ()=>(0, _regexJs.integerRegex));
parcelHelpers.export(exports, "getSocket", ()=>(0, _compatJs.getSocket));
parcelHelpers.export(exports, "rpc", ()=>(0, _compatJs.rpc));
parcelHelpers.export(exports, "getHttpRpcClient", ()=>(0, _httpJs.getHttpRpcClient));
parcelHelpers.export(exports, "getSocketRpcClient", ()=>(0, _socketJs.getSocketRpcClient));
parcelHelpers.export(exports, "socketClientCache", ()=>(0, _socketJs.socketClientCache));
parcelHelpers.export(exports, "getWebSocketRpcClient", ()=>(0, _webSocketJs.getWebSocketRpcClient));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJs.stringify));
parcelHelpers.export(exports, "serializeTypedData", ()=>(0, _typedDataJs.serializeTypedData));
parcelHelpers.export(exports, "validateTypedData", ()=>(0, _typedDataJs.validateTypedData));
parcelHelpers.export(exports, "decodeAbiParameters", ()=>(0, _decodeAbiParametersJs.decodeAbiParameters));
parcelHelpers.export(exports, "decodeErrorResult", ()=>(0, _decodeErrorResultJs.decodeErrorResult));
parcelHelpers.export(exports, "decodeEventLog", ()=>(0, _decodeEventLogJs.decodeEventLog));
parcelHelpers.export(exports, "decodeFunctionData", ()=>(0, _decodeFunctionDataJs.decodeFunctionData));
parcelHelpers.export(exports, "decodeFunctionResult", ()=>(0, _decodeFunctionResultJs.decodeFunctionResult));
parcelHelpers.export(exports, "encodeAbiParameters", ()=>(0, _encodeAbiParametersJs.encodeAbiParameters));
parcelHelpers.export(exports, "encodeDeployData", ()=>(0, _encodeDeployDataJs.encodeDeployData));
parcelHelpers.export(exports, "encodeErrorResult", ()=>(0, _encodeErrorResultJs.encodeErrorResult));
parcelHelpers.export(exports, "encodeEventTopics", ()=>(0, _encodeEventTopicsJs.encodeEventTopics));
parcelHelpers.export(exports, "encodeFunctionData", ()=>(0, _encodeFunctionDataJs.encodeFunctionData));
parcelHelpers.export(exports, "encodeFunctionResult", ()=>(0, _encodeFunctionResultJs.encodeFunctionResult));
parcelHelpers.export(exports, "parseEventLogs", ()=>(0, _parseEventLogsJs.parseEventLogs));
parcelHelpers.export(exports, "getAbiItem", ()=>(0, _getAbiItemJs.getAbiItem));
parcelHelpers.export(exports, "parseAbi", ()=>(0, _abitype.parseAbi));
parcelHelpers.export(exports, "parseAbiItem", ()=>(0, _abitype.parseAbiItem));
parcelHelpers.export(exports, "parseAbiParameter", ()=>(0, _abitype.parseAbiParameter));
parcelHelpers.export(exports, "parseAbiParameters", ()=>(0, _abitype.parseAbiParameters));
parcelHelpers.export(exports, "encodePacked", ()=>(0, _encodePackedJs.encodePacked));
parcelHelpers.export(exports, "formatAbiItemWithArgs", ()=>(0, _formatAbiItemWithArgsJs.formatAbiItemWithArgs));
parcelHelpers.export(exports, "formatAbiItem", ()=>(0, _formatAbiItemJs.formatAbiItem));
parcelHelpers.export(exports, "formatAbiParams", ()=>(0, _formatAbiItemJs.formatAbiParams));
parcelHelpers.export(exports, "hashAuthorization", ()=>(0, _hashAuthorizationJs.hashAuthorization));
parcelHelpers.export(exports, "recoverAuthorizationAddress", ()=>(0, _recoverAuthorizationAddressJs.recoverAuthorizationAddress));
parcelHelpers.export(exports, "serializeAuthorizationList", ()=>(0, _serializeAuthorizationListJs.serializeAuthorizationList));
parcelHelpers.export(exports, "verifyAuthorization", ()=>(0, _verifyAuthorizationJs.verifyAuthorization));
parcelHelpers.export(exports, "parseAccount", ()=>(0, _parseAccountJs.parseAccount));
parcelHelpers.export(exports, "publicKeyToAddress", ()=>(0, _publicKeyToAddressJs.publicKeyToAddress));
parcelHelpers.export(exports, "getContractAddress", ()=>(0, _getContractAddressJs.getContractAddress));
parcelHelpers.export(exports, "getCreateAddress", ()=>(0, _getContractAddressJs.getCreateAddress));
parcelHelpers.export(exports, "getCreate2Address", ()=>(0, _getContractAddressJs.getCreate2Address));
parcelHelpers.export(exports, "getAddress", ()=>(0, _getAddressJs.getAddress));
parcelHelpers.export(exports, "isAddress", ()=>(0, _isAddressJs.isAddress));
parcelHelpers.export(exports, "isAddressEqual", ()=>(0, _isAddressEqualJs.isAddressEqual));
parcelHelpers.export(exports, "concat", ()=>(0, _concatJs.concat));
parcelHelpers.export(exports, "concatBytes", ()=>(0, _concatJs.concatBytes));
parcelHelpers.export(exports, "concatHex", ()=>(0, _concatJs.concatHex));
parcelHelpers.export(exports, "isBytes", ()=>(0, _isBytesJs.isBytes));
parcelHelpers.export(exports, "isHex", ()=>(0, _isHexJs.isHex));
parcelHelpers.export(exports, "pad", ()=>(0, _padJs.pad));
parcelHelpers.export(exports, "padBytes", ()=>(0, _padJs.padBytes));
parcelHelpers.export(exports, "padHex", ()=>(0, _padJs.padHex));
parcelHelpers.export(exports, "size", ()=>(0, _sizeJs.size));
parcelHelpers.export(exports, "slice", ()=>(0, _sliceJs.slice));
parcelHelpers.export(exports, "sliceBytes", ()=>(0, _sliceJs.sliceBytes));
parcelHelpers.export(exports, "sliceHex", ()=>(0, _sliceJs.sliceHex));
parcelHelpers.export(exports, "trim", ()=>(0, _trimJs.trim));
parcelHelpers.export(exports, "defineBlock", ()=>(0, _blockJs.defineBlock));
parcelHelpers.export(exports, "formatBlock", ()=>(0, _blockJs.formatBlock));
parcelHelpers.export(exports, "defineTransaction", ()=>(0, _transactionJs.defineTransaction));
parcelHelpers.export(exports, "formatTransaction", ()=>(0, _transactionJs.formatTransaction));
parcelHelpers.export(exports, "transactionType", ()=>(0, _transactionJs.transactionType));
parcelHelpers.export(exports, "formatLog", ()=>(0, _logJs.formatLog));
parcelHelpers.export(exports, "defineTransactionReceipt", ()=>(0, _transactionReceiptJs.defineTransactionReceipt));
parcelHelpers.export(exports, "defineTransactionRequest", ()=>(0, _transactionRequestJs.defineTransactionRequest));
parcelHelpers.export(exports, "formatTransactionRequest", ()=>(0, _transactionRequestJs.formatTransactionRequest));
parcelHelpers.export(exports, "extract", ()=>(0, _extractJs.extract));
parcelHelpers.export(exports, "toRlp", ()=>(0, _toRlpJs.toRlp));
parcelHelpers.export(exports, "boolToBytes", ()=>(0, _toBytesJs.boolToBytes));
parcelHelpers.export(exports, "toBytes", ()=>(0, _toBytesJs.toBytes));
parcelHelpers.export(exports, "hexToBytes", ()=>(0, _toBytesJs.hexToBytes));
parcelHelpers.export(exports, "numberToBytes", ()=>(0, _toBytesJs.numberToBytes));
parcelHelpers.export(exports, "stringToBytes", ()=>(0, _toBytesJs.stringToBytes));
parcelHelpers.export(exports, "boolToHex", ()=>(0, _toHexJs.boolToHex));
parcelHelpers.export(exports, "bytesToHex", ()=>(0, _toHexJs.bytesToHex));
parcelHelpers.export(exports, "toHex", ()=>(0, _toHexJs.toHex));
parcelHelpers.export(exports, "numberToHex", ()=>(0, _toHexJs.numberToHex));
parcelHelpers.export(exports, "stringToHex", ()=>(0, _toHexJs.stringToHex));
parcelHelpers.export(exports, "bytesToBigInt", ()=>(0, _fromBytesJs.bytesToBigInt));
parcelHelpers.export(exports, "bytesToBigint", ()=>(0, _fromBytesJs.bytesToBigInt));
parcelHelpers.export(exports, "bytesToBool", ()=>(0, _fromBytesJs.bytesToBool));
parcelHelpers.export(exports, "bytesToNumber", ()=>(0, _fromBytesJs.bytesToNumber));
parcelHelpers.export(exports, "bytesToString", ()=>(0, _fromBytesJs.bytesToString));
parcelHelpers.export(exports, "fromBytes", ()=>(0, _fromBytesJs.fromBytes));
parcelHelpers.export(exports, "fromHex", ()=>(0, _fromHexJs.fromHex));
parcelHelpers.export(exports, "hexToBool", ()=>(0, _fromHexJs.hexToBool));
parcelHelpers.export(exports, "hexToBigInt", ()=>(0, _fromHexJs.hexToBigInt));
parcelHelpers.export(exports, "hexToNumber", ()=>(0, _fromHexJs.hexToNumber));
parcelHelpers.export(exports, "hexToString", ()=>(0, _fromHexJs.hexToString));
parcelHelpers.export(exports, "fromRlp", ()=>(0, _fromRlpJs.fromRlp));
parcelHelpers.export(exports, "containsNodeError", ()=>(0, _getNodeErrorJs.containsNodeError));
parcelHelpers.export(exports, "getNodeError", ()=>(0, _getNodeErrorJs.getNodeError));
parcelHelpers.export(exports, "getCallError", ()=>(0, _getCallErrorJs.getCallError));
parcelHelpers.export(exports, "getContractError", ()=>(0, _getContractErrorJs.getContractError));
parcelHelpers.export(exports, "getEstimateGasError", ()=>(0, _getEstimateGasErrorJs.getEstimateGasError));
parcelHelpers.export(exports, "getTransactionError", ()=>(0, _getTransactionErrorJs.getTransactionError));
parcelHelpers.export(exports, "getAction", ()=>(0, _getActionJs.getAction));
parcelHelpers.export(exports, "defineFormatter", ()=>(0, _formatterJs.defineFormatter));
parcelHelpers.export(exports, "toEventSelector", ()=>(0, _toEventSelectorJs.toEventSelector));
parcelHelpers.export(exports, "getEventSelector", ()=>(0, _toEventSelectorJs.toEventSelector));
parcelHelpers.export(exports, "toFunctionSelector", ()=>(0, _toFunctionSelectorJs.toFunctionSelector));
parcelHelpers.export(exports, "getFunctionSelector", ()=>(0, _toFunctionSelectorJs.toFunctionSelector));
parcelHelpers.export(exports, "toEventSignature", ()=>(0, _toEventSignatureJs.toEventSignature));
parcelHelpers.export(exports, "getEventSignature", ()=>(0, _toEventSignatureJs.toEventSignature));
parcelHelpers.export(exports, "toFunctionSignature", ()=>(0, _toFunctionSignatureJs.toFunctionSignature));
parcelHelpers.export(exports, "getFunctionSignature", ()=>(0, _toFunctionSignatureJs.toFunctionSignature));
parcelHelpers.export(exports, "toEventHash", ()=>(0, _toEventHashJs.toEventHash));
parcelHelpers.export(exports, "toFunctionHash", ()=>(0, _toFunctionHashJs.toFunctionHash));
parcelHelpers.export(exports, "isHash", ()=>(0, _isHashJs.isHash));
parcelHelpers.export(exports, "keccak256", ()=>(0, _keccak256Js.keccak256));
parcelHelpers.export(exports, "sha256", ()=>(0, _sha256Js.sha256));
parcelHelpers.export(exports, "ripemd160", ()=>(0, _ripemd160Js.ripemd160));
parcelHelpers.export(exports, "hashStruct", ()=>(0, _hashTypedDataJs.hashStruct));
parcelHelpers.export(exports, "hashTypedData", ()=>(0, _hashTypedDataJs.hashTypedData));
parcelHelpers.export(exports, "recoverAddress", ()=>(0, _recoverAddressJs.recoverAddress));
parcelHelpers.export(exports, "recoverMessageAddress", ()=>(0, _recoverMessageAddressJs.recoverMessageAddress));
parcelHelpers.export(exports, "recoverPublicKey", ()=>(0, _recoverPublicKeyJs.recoverPublicKey));
parcelHelpers.export(exports, "recoverTypedDataAddress", ()=>(0, _recoverTypedDataAddressJs.recoverTypedDataAddress));
parcelHelpers.export(exports, "verifyHash", ()=>(0, _verifyHashJs.verifyHash));
parcelHelpers.export(exports, "verifyMessage", ()=>(0, _verifyMessageJs.verifyMessage));
parcelHelpers.export(exports, "verifyTypedData", ()=>(0, _verifyTypedDataJs.verifyTypedData));
parcelHelpers.export(exports, "hashMessage", ()=>(0, _hashMessageJs.hashMessage));
parcelHelpers.export(exports, "parseErc6492Signature", ()=>(0, _parseErc6492SignatureJs.parseErc6492Signature));
parcelHelpers.export(exports, "isErc6492Signature", ()=>(0, _isErc6492SignatureJs.isErc6492Signature));
parcelHelpers.export(exports, "serializeErc6492Signature", ()=>(0, _serializeErc6492SignatureJs.serializeErc6492Signature));
parcelHelpers.export(exports, "getSerializedTransactionType", ()=>(0, _getSerializedTransactionTypeJs.getSerializedTransactionType));
parcelHelpers.export(exports, "getTransactionType", ()=>(0, _getTransactionTypeJs.getTransactionType));
parcelHelpers.export(exports, "assertRequest", ()=>(0, _assertRequestJs.assertRequest));
parcelHelpers.export(exports, "assertTransactionEIP1559", ()=>(0, _assertTransactionJs.assertTransactionEIP1559));
parcelHelpers.export(exports, "assertTransactionEIP2930", ()=>(0, _assertTransactionJs.assertTransactionEIP2930));
parcelHelpers.export(exports, "assertTransactionLegacy", ()=>(0, _assertTransactionJs.assertTransactionLegacy));
parcelHelpers.export(exports, "parseTransaction", ()=>(0, _parseTransactionJs.parseTransaction));
parcelHelpers.export(exports, "serializeTransaction", ()=>(0, _serializeTransactionJs.serializeTransaction));
parcelHelpers.export(exports, "serializeAccessList", ()=>(0, _serializeAccessListJs.serializeAccessList));
parcelHelpers.export(exports, "formatEther", ()=>(0, _formatEtherJs.formatEther));
parcelHelpers.export(exports, "formatGwei", ()=>(0, _formatGweiJs.formatGwei));
parcelHelpers.export(exports, "formatUnits", ()=>(0, _formatUnitsJs.formatUnits));
parcelHelpers.export(exports, "parseUnits", ()=>(0, _parseUnitsJs.parseUnits));
parcelHelpers.export(exports, "parseEther", ()=>(0, _parseEtherJs.parseEther));
parcelHelpers.export(exports, "parseGwei", ()=>(0, _parseGweiJs.parseGwei));
parcelHelpers.export(exports, "createNonceManager", ()=>(0, _nonceManagerJs.createNonceManager));
parcelHelpers.export(exports, "nonceManager", ()=>(0, _nonceManagerJs.nonceManager));
var _buildRequestJs = require("./buildRequest.js");
var _ccipJs = require("./ccip.js");
var _assertCurrentChainJs = require("./chain/assertCurrentChain.js");
var _defineChainJs = require("./chain/defineChain.js");
var _extractChainJs = require("./chain/extractChain.js");
var _getChainContractAddressJs = require("./chain/getChainContractAddress.js");
var _regexJs = require("./regex.js");
var _compatJs = require("./rpc/compat.js");
var _httpJs = require("./rpc/http.js");
var _socketJs = require("./rpc/socket.js");
var _webSocketJs = require("./rpc/webSocket.js");
var _stringifyJs = require("./stringify.js");
var _typedDataJs = require("./typedData.js");
var _decodeAbiParametersJs = require("./abi/decodeAbiParameters.js");
var _decodeErrorResultJs = require("./abi/decodeErrorResult.js");
var _decodeEventLogJs = require("./abi/decodeEventLog.js");
var _decodeFunctionDataJs = require("./abi/decodeFunctionData.js");
var _decodeFunctionResultJs = require("./abi/decodeFunctionResult.js");
var _encodeAbiParametersJs = require("./abi/encodeAbiParameters.js");
var _encodeDeployDataJs = require("./abi/encodeDeployData.js");
var _encodeErrorResultJs = require("./abi/encodeErrorResult.js");
var _encodeEventTopicsJs = require("./abi/encodeEventTopics.js");
var _encodeFunctionDataJs = require("./abi/encodeFunctionData.js");
var _encodeFunctionResultJs = require("./abi/encodeFunctionResult.js");
var _parseEventLogsJs = require("./abi/parseEventLogs.js");
var _getAbiItemJs = require("./abi/getAbiItem.js");
var _abitype = require("abitype");
var _encodePackedJs = require("./abi/encodePacked.js");
var _formatAbiItemWithArgsJs = require("./abi/formatAbiItemWithArgs.js");
var _formatAbiItemJs = require("./abi/formatAbiItem.js");
var _hashAuthorizationJs = require("./authorization/hashAuthorization.js");
var _recoverAuthorizationAddressJs = require("./authorization/recoverAuthorizationAddress.js");
var _serializeAuthorizationListJs = require("./authorization/serializeAuthorizationList.js");
var _verifyAuthorizationJs = require("./authorization/verifyAuthorization.js");
var _parseAccountJs = require("../accounts/utils/parseAccount.js");
var _publicKeyToAddressJs = require("../accounts/utils/publicKeyToAddress.js");
var _getContractAddressJs = require("./address/getContractAddress.js");
var _getAddressJs = require("./address/getAddress.js");
var _isAddressJs = require("./address/isAddress.js");
var _isAddressEqualJs = require("./address/isAddressEqual.js");
var _concatJs = require("./data/concat.js");
var _isBytesJs = require("./data/isBytes.js");
var _isHexJs = require("./data/isHex.js");
var _padJs = require("./data/pad.js");
var _sizeJs = require("./data/size.js");
var _sliceJs = require("./data/slice.js");
var _trimJs = require("./data/trim.js");
var _blockJs = require("./formatters/block.js");
var _transactionJs = require("./formatters/transaction.js");
var _logJs = require("./formatters/log.js");
var _transactionReceiptJs = require("./formatters/transactionReceipt.js");
var _transactionRequestJs = require("./formatters/transactionRequest.js");
var _extractJs = require("./formatters/extract.js");
var _toRlpJs = require("./encoding/toRlp.js");
var _toBytesJs = require("./encoding/toBytes.js");
var _toHexJs = require("./encoding/toHex.js");
var _fromBytesJs = require("./encoding/fromBytes.js");
var _fromHexJs = require("./encoding/fromHex.js");
var _fromRlpJs = require("./encoding/fromRlp.js");
var _getNodeErrorJs = require("./errors/getNodeError.js");
var _getCallErrorJs = require("./errors/getCallError.js");
var _getContractErrorJs = require("./errors/getContractError.js");
var _getEstimateGasErrorJs = require("./errors/getEstimateGasError.js");
var _getTransactionErrorJs = require("./errors/getTransactionError.js");
var _getActionJs = require("./getAction.js");
var _formatterJs = require("./formatters/formatter.js");
var _toEventSelectorJs = require("./hash/toEventSelector.js");
var _toFunctionSelectorJs = require("./hash/toFunctionSelector.js");
var _toEventSignatureJs = require("./hash/toEventSignature.js");
var _toFunctionSignatureJs = require("./hash/toFunctionSignature.js");
var _toEventHashJs = require("./hash/toEventHash.js");
var _toFunctionHashJs = require("./hash/toFunctionHash.js");
var _isHashJs = require("./hash/isHash.js");
var _keccak256Js = require("./hash/keccak256.js");
var _sha256Js = require("./hash/sha256.js");
var _ripemd160Js = require("./hash/ripemd160.js");
var _hashTypedDataJs = require("./signature/hashTypedData.js");
var _recoverAddressJs = require("./signature/recoverAddress.js");
var _recoverMessageAddressJs = require("./signature/recoverMessageAddress.js");
var _recoverPublicKeyJs = require("./signature/recoverPublicKey.js");
var _recoverTypedDataAddressJs = require("./signature/recoverTypedDataAddress.js");
var _verifyHashJs = require("./signature/verifyHash.js");
var _verifyMessageJs = require("./signature/verifyMessage.js");
var _verifyTypedDataJs = require("./signature/verifyTypedData.js");
var _hashMessageJs = require("./signature/hashMessage.js");
var _parseErc6492SignatureJs = require("./signature/parseErc6492Signature.js");
var _isErc6492SignatureJs = require("./signature/isErc6492Signature.js");
var _serializeErc6492SignatureJs = require("./signature/serializeErc6492Signature.js");
var _getSerializedTransactionTypeJs = require("./transaction/getSerializedTransactionType.js");
var _getTransactionTypeJs = require("./transaction/getTransactionType.js");
var _assertRequestJs = require("./transaction/assertRequest.js");
var _assertTransactionJs = require("./transaction/assertTransaction.js");
var _parseTransactionJs = require("./transaction/parseTransaction.js");
var _serializeTransactionJs = require("./transaction/serializeTransaction.js");
var _serializeAccessListJs = require("./transaction/serializeAccessList.js");
var _formatEtherJs = require("./unit/formatEther.js");
var _formatGweiJs = require("./unit/formatGwei.js");
var _formatUnitsJs = require("./unit/formatUnits.js");
var _parseUnitsJs = require("./unit/parseUnits.js");
var _parseEtherJs = require("./unit/parseEther.js");
var _parseGweiJs = require("./unit/parseGwei.js");
var _nonceManagerJs = require("./nonceManager.js");

},{"./buildRequest.js":false,"./ccip.js":false,"./chain/assertCurrentChain.js":false,"./chain/defineChain.js":false,"./chain/extractChain.js":false,"./chain/getChainContractAddress.js":false,"./regex.js":false,"./rpc/compat.js":false,"./rpc/http.js":false,"./rpc/socket.js":false,"./rpc/webSocket.js":false,"./stringify.js":false,"./typedData.js":false,"./abi/decodeAbiParameters.js":false,"./abi/decodeErrorResult.js":false,"./abi/decodeEventLog.js":false,"./abi/decodeFunctionData.js":false,"./abi/decodeFunctionResult.js":false,"./abi/encodeAbiParameters.js":false,"./abi/encodeDeployData.js":false,"./abi/encodeErrorResult.js":false,"./abi/encodeEventTopics.js":false,"./abi/encodeFunctionData.js":"eQLEb","./abi/encodeFunctionResult.js":false,"./abi/parseEventLogs.js":false,"./abi/getAbiItem.js":false,"abitype":false,"./abi/encodePacked.js":false,"./abi/formatAbiItemWithArgs.js":false,"./abi/formatAbiItem.js":false,"./authorization/hashAuthorization.js":false,"./authorization/recoverAuthorizationAddress.js":false,"./authorization/serializeAuthorizationList.js":false,"./authorization/verifyAuthorization.js":false,"../accounts/utils/parseAccount.js":false,"../accounts/utils/publicKeyToAddress.js":false,"./address/getContractAddress.js":false,"./address/getAddress.js":false,"./address/isAddress.js":false,"./address/isAddressEqual.js":false,"./data/concat.js":false,"./data/isBytes.js":false,"./data/isHex.js":false,"./data/pad.js":false,"./data/size.js":false,"./data/slice.js":false,"./data/trim.js":false,"./formatters/block.js":false,"./formatters/transaction.js":false,"./formatters/log.js":false,"./formatters/transactionReceipt.js":false,"./formatters/transactionRequest.js":false,"./formatters/extract.js":false,"./encoding/toRlp.js":false,"./encoding/toBytes.js":false,"./encoding/toHex.js":false,"./encoding/fromBytes.js":false,"./encoding/fromHex.js":"kLfW5","./encoding/fromRlp.js":false,"./errors/getNodeError.js":false,"./errors/getCallError.js":false,"./errors/getContractError.js":false,"./errors/getEstimateGasError.js":false,"./errors/getTransactionError.js":false,"./getAction.js":false,"./formatters/formatter.js":false,"./hash/toEventSelector.js":false,"./hash/toFunctionSelector.js":false,"./hash/toEventSignature.js":false,"./hash/toFunctionSignature.js":false,"./hash/toEventHash.js":false,"./hash/toFunctionHash.js":false,"./hash/isHash.js":false,"./hash/keccak256.js":false,"./hash/sha256.js":false,"./hash/ripemd160.js":false,"./signature/hashTypedData.js":false,"./signature/recoverAddress.js":false,"./signature/recoverMessageAddress.js":false,"./signature/recoverPublicKey.js":false,"./signature/recoverTypedDataAddress.js":false,"./signature/verifyHash.js":false,"./signature/verifyMessage.js":false,"./signature/verifyTypedData.js":false,"./signature/hashMessage.js":false,"./signature/parseErc6492Signature.js":false,"./signature/isErc6492Signature.js":false,"./signature/serializeErc6492Signature.js":false,"./transaction/getSerializedTransactionType.js":false,"./transaction/getTransactionType.js":false,"./transaction/assertRequest.js":false,"./transaction/assertTransaction.js":false,"./transaction/parseTransaction.js":false,"./transaction/serializeTransaction.js":false,"./transaction/serializeAccessList.js":false,"./unit/formatEther.js":false,"./unit/formatGwei.js":false,"./unit/formatUnits.js":false,"./unit/parseUnits.js":false,"./unit/parseEther.js":false,"./unit/parseGwei.js":false,"./nonceManager.js":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1rHaX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "offchainLookupSignature", ()=>offchainLookupSignature);
parcelHelpers.export(exports, "offchainLookupAbiItem", ()=>offchainLookupAbiItem);
parcelHelpers.export(exports, "offchainLookup", ()=>offchainLookup);
parcelHelpers.export(exports, "ccipRequest", ()=>ccipRequest);
var _callJs = require("../actions/public/call.js");
var _ccipJs = require("../errors/ccip.js");
var _requestJs = require("../errors/request.js");
var _decodeErrorResultJs = require("./abi/decodeErrorResult.js");
var _encodeAbiParametersJs = require("./abi/encodeAbiParameters.js");
var _isAddressEqualJs = require("./address/isAddressEqual.js");
var _concatJs = require("./data/concat.js");
var _isHexJs = require("./data/isHex.js");
var _localBatchGatewayRequestJs = require("./ens/localBatchGatewayRequest.js");
var _stringifyJs = require("./stringify.js");
const offchainLookupSignature = '0x556f1830';
const offchainLookupAbiItem = {
    name: 'OffchainLookup',
    type: 'error',
    inputs: [
        {
            name: 'sender',
            type: 'address'
        },
        {
            name: 'urls',
            type: 'string[]'
        },
        {
            name: 'callData',
            type: 'bytes'
        },
        {
            name: 'callbackFunction',
            type: 'bytes4'
        },
        {
            name: 'extraData',
            type: 'bytes'
        }
    ]
};
async function offchainLookup(client, { blockNumber, blockTag, data, to }) {
    const { args } = (0, _decodeErrorResultJs.decodeErrorResult)({
        data,
        abi: [
            offchainLookupAbiItem
        ]
    });
    const [sender, urls, callData, callbackSelector, extraData] = args;
    const { ccipRead } = client;
    const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function' ? ccipRead.request : ccipRequest;
    try {
        if (!(0, _isAddressEqualJs.isAddressEqual)(to, sender)) throw new (0, _ccipJs.OffchainLookupSenderMismatchError)({
            sender,
            to
        });
        const result = urls.includes((0, _localBatchGatewayRequestJs.localBatchGatewayUrl)) ? await (0, _localBatchGatewayRequestJs.localBatchGatewayRequest)({
            data: callData,
            ccipRequest: ccipRequest_
        }) : await ccipRequest_({
            data: callData,
            sender,
            urls
        });
        const { data: data_ } = await (0, _callJs.call)(client, {
            blockNumber,
            blockTag,
            data: (0, _concatJs.concat)([
                callbackSelector,
                (0, _encodeAbiParametersJs.encodeAbiParameters)([
                    {
                        type: 'bytes'
                    },
                    {
                        type: 'bytes'
                    }
                ], [
                    result,
                    extraData
                ])
            ]),
            to
        });
        return data_;
    } catch (err) {
        throw new (0, _ccipJs.OffchainLookupError)({
            callbackSelector,
            cause: err,
            data,
            extraData,
            sender,
            urls
        });
    }
}
async function ccipRequest({ data, sender, urls }) {
    let error = new Error('An unknown error occurred.');
    for(let i = 0; i < urls.length; i++){
        const url = urls[i];
        const method = url.includes('{data}') ? 'GET' : 'POST';
        const body = method === 'POST' ? {
            data,
            sender
        } : undefined;
        const headers = method === 'POST' ? {
            'Content-Type': 'application/json'
        } : {};
        try {
            const response = await fetch(url.replace('{sender}', sender.toLowerCase()).replace('{data}', data), {
                body: JSON.stringify(body),
                headers,
                method
            });
            let result;
            if (response.headers.get('Content-Type')?.startsWith('application/json')) result = (await response.json()).data;
            else result = await response.text();
            if (!response.ok) {
                error = new (0, _requestJs.HttpRequestError)({
                    body,
                    details: result?.error ? (0, _stringifyJs.stringify)(result.error) : response.statusText,
                    headers: response.headers,
                    status: response.status,
                    url
                });
                continue;
            }
            if (!(0, _isHexJs.isHex)(result)) {
                error = new (0, _ccipJs.OffchainLookupResponseMalformedError)({
                    result,
                    url
                });
                continue;
            }
            return result;
        } catch (err) {
            error = new (0, _requestJs.HttpRequestError)({
                body,
                details: err.message,
                url
            });
        }
    }
    throw error;
}

},{"../actions/public/call.js":"85xZD","../errors/ccip.js":"6Cu5K","../errors/request.js":"6LYvf","./abi/decodeErrorResult.js":"kFalj","./abi/encodeAbiParameters.js":"8kHRc","./address/isAddressEqual.js":"lW8Gp","./data/concat.js":"6FL5K","./data/isHex.js":"evOcm","./ens/localBatchGatewayRequest.js":"iuGj1","./stringify.js":"jKcjI","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6Cu5K":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OffchainLookupError", ()=>OffchainLookupError);
parcelHelpers.export(exports, "OffchainLookupResponseMalformedError", ()=>OffchainLookupResponseMalformedError);
parcelHelpers.export(exports, "OffchainLookupSenderMismatchError", ()=>OffchainLookupSenderMismatchError);
var _stringifyJs = require("../utils/stringify.js");
var _baseJs = require("./base.js");
var _utilsJs = require("./utils.js");
class OffchainLookupError extends (0, _baseJs.BaseError) {
    constructor({ callbackSelector, cause, data, extraData, sender, urls }){
        super(cause.shortMessage || 'An error occurred while fetching for an offchain result.', {
            cause,
            metaMessages: [
                ...cause.metaMessages || [],
                cause.metaMessages?.length ? '' : [],
                'Offchain Gateway Call:',
                urls && [
                    '  Gateway URL(s):',
                    ...urls.map((url)=>`    ${(0, _utilsJs.getUrl)(url)}`)
                ],
                `  Sender: ${sender}`,
                `  Data: ${data}`,
                `  Callback selector: ${callbackSelector}`,
                `  Extra data: ${extraData}`
            ].flat(),
            name: 'OffchainLookupError'
        });
    }
}
class OffchainLookupResponseMalformedError extends (0, _baseJs.BaseError) {
    constructor({ result, url }){
        super('Offchain gateway response is malformed. Response data must be a hex value.', {
            metaMessages: [
                `Gateway URL: ${(0, _utilsJs.getUrl)(url)}`,
                `Response: ${(0, _stringifyJs.stringify)(result)}`
            ],
            name: 'OffchainLookupResponseMalformedError'
        });
    }
}
class OffchainLookupSenderMismatchError extends (0, _baseJs.BaseError) {
    constructor({ sender, to }){
        super('Reverted sender address does not match target contract address (`to`).', {
            metaMessages: [
                `Contract address: ${to}`,
                `OffchainLookup sender address: ${sender}`
            ],
            name: 'OffchainLookupSenderMismatchError'
        });
    }
}

},{"../utils/stringify.js":"jKcjI","./base.js":"3SEPF","./utils.js":"3ALY3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6ZWYk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defineChain", ()=>defineChain);
function defineChain(chain) {
    return {
        formatters: undefined,
        fees: undefined,
        serializers: undefined,
        ...chain
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gNS63":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extractChain", ()=>extractChain);
function extractChain({ chains, id }) {
    return chains.find((chain)=>chain.id === id);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"59L70":[function(require,module,exports,__globalThis) {
// TODO(v3): This file is here for backwards compatibility, and to prevent breaking changes.
// These APIs will be removed in v3.
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @deprecated use `getSocketClient` instead.
 *
 * ```diff
 * -import { getSocket } from 'viem/utils'
 * +import { getSocketClient } from 'viem/utils'
 *
 * -const socket = await getSocket(url)
 * +const socketClient = await getSocketClient(url)
 * +const socket = socketClient.socket
 * ```
 */ parcelHelpers.export(exports, "getSocket", ()=>getSocket);
parcelHelpers.export(exports, "rpc", ()=>rpc);
var _httpJs = require("./http.js");
var _webSocketJs = require("./webSocket.js");
function webSocket(socketClient, { body, onError, onResponse }) {
    socketClient.request({
        body,
        onError,
        onResponse
    });
    return socketClient;
}
async function webSocketAsync(socketClient, { body, timeout = 10000 }) {
    return socketClient.requestAsync({
        body,
        timeout
    });
}
async function getSocket(url) {
    const client = await (0, _webSocketJs.getWebSocketRpcClient)(url);
    return Object.assign(client.socket, {
        requests: client.requests,
        subscriptions: client.subscriptions
    });
}
const rpc = {
    /**
     * @deprecated use `getHttpRpcClient` instead.
     *
     * ```diff
     * -import { rpc } from 'viem/utils'
     * +import { getHttpRpcClient } from 'viem/utils'
     *
     * -rpc.http(url, params)
     * +const httpClient = getHttpRpcClient(url)
     * +httpClient.request(params)
     * ```
     */ http (url, params) {
        return (0, _httpJs.getHttpRpcClient)(url).request(params);
    },
    /**
     * @deprecated use `getWebSocketRpcClient` instead.
     *
     * ```diff
     * -import { rpc } from 'viem/utils'
     * +import { getWebSocketRpcClient } from 'viem/utils'
     *
     * -rpc.webSocket(url, params)
     * +const webSocketClient = getWebSocketRpcClient(url)
     * +webSocketClient.request(params)
     * ```
     */ webSocket,
    /**
     * @deprecated use `getWebSocketRpcClient` instead.
     *
     * ```diff
     * -import { rpc } from 'viem/utils'
     * +import { getWebSocketRpcClient } from 'viem/utils'
     *
     * -const response = await rpc.webSocketAsync(url, params)
     * +const webSocketClient = getWebSocketRpcClient(url)
     * +const response = await webSocketClient.requestAsync(params)
     * ```
     */ webSocketAsync
}; /* c8 ignore end */ 

},{"./http.js":"hbLiA","./webSocket.js":"f4gwB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f4gwB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getWebSocketRpcClient", ()=>getWebSocketRpcClient);
var _requestJs = require("../../errors/request.js");
var _socketJs = require("./socket.js");
async function getWebSocketRpcClient(url, options = {}) {
    const { keepAlive, reconnect } = options;
    return (0, _socketJs.getSocketRpcClient)({
        async getSocket ({ onClose, onError, onOpen, onResponse }) {
            const WebSocket = await require("b2eece54133d7329").then((module)=>module.WebSocket);
            const socket = new WebSocket(url);
            function onClose_() {
                socket.removeEventListener('close', onClose_);
                socket.removeEventListener('message', onMessage);
                socket.removeEventListener('error', onError);
                socket.removeEventListener('open', onOpen);
                onClose();
            }
            function onMessage({ data }) {
                try {
                    const _data = JSON.parse(data);
                    onResponse(_data);
                } catch (error) {
                    onError(error);
                }
            }
            // Setup event listeners for RPC & subscription responses.
            socket.addEventListener('close', onClose_);
            socket.addEventListener('message', onMessage);
            socket.addEventListener('error', onError);
            socket.addEventListener('open', onOpen);
            // Wait for the socket to open.
            if (socket.readyState === WebSocket.CONNECTING) await new Promise((resolve, reject)=>{
                if (!socket) return;
                socket.onopen = resolve;
                socket.onerror = reject;
            });
            const { close: close_ } = socket;
            return Object.assign(socket, {
                close () {
                    close_.bind(socket)();
                    onClose_();
                },
                ping () {
                    try {
                        if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) throw new (0, _requestJs.WebSocketRequestError)({
                            url: socket.url,
                            cause: new (0, _requestJs.SocketClosedError)({
                                url: socket.url
                            })
                        });
                        const body = {
                            jsonrpc: '2.0',
                            method: 'net_version',
                            params: []
                        };
                        socket.send(JSON.stringify(body));
                    } catch (error) {
                        onError(error);
                    }
                },
                request ({ body }) {
                    if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING) throw new (0, _requestJs.WebSocketRequestError)({
                        body,
                        url: socket.url,
                        cause: new (0, _requestJs.SocketClosedError)({
                            url: socket.url
                        })
                    });
                    return socket.send(JSON.stringify(body));
                }
            });
        },
        keepAlive,
        reconnect,
        url
    });
}

},{"../../errors/request.js":"6LYvf","./socket.js":"doIme","b2eece54133d7329":"fqY8x","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"doIme":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "socketClientCache", ()=>socketClientCache);
parcelHelpers.export(exports, "getSocketRpcClient", ()=>getSocketRpcClient);
var _requestJs = require("../../errors/request.js");
var _createBatchSchedulerJs = require("../promise/createBatchScheduler.js");
var _withTimeoutJs = require("../promise/withTimeout.js");
var _idJs = require("./id.js");
const socketClientCache = /*#__PURE__*/ new Map();
async function getSocketRpcClient(parameters) {
    const { getSocket, keepAlive = true, key = 'socket', reconnect = true, url } = parameters;
    const { interval: keepAliveInterval = 30000 } = typeof keepAlive === 'object' ? keepAlive : {};
    const { attempts = 5, delay = 2000 } = typeof reconnect === 'object' ? reconnect : {};
    let socketClient = socketClientCache.get(`${key}:${url}`);
    // If the socket already exists, return it.
    if (socketClient) return socketClient;
    let reconnectCount = 0;
    const { schedule } = (0, _createBatchSchedulerJs.createBatchScheduler)({
        id: `${key}:${url}`,
        fn: async ()=>{
            // Set up a cache for incoming "synchronous" requests.
            const requests = new Map();
            // Set up a cache for subscriptions (eth_subscribe).
            const subscriptions = new Map();
            let error;
            let socket;
            let keepAliveTimer;
            // Set up socket implementation.
            async function setup() {
                const result = await getSocket({
                    onClose () {
                        // Notify all requests and subscriptions of the closure error.
                        for (const request of requests.values())request.onError?.(new (0, _requestJs.SocketClosedError)({
                            url
                        }));
                        for (const subscription of subscriptions.values())subscription.onError?.(new (0, _requestJs.SocketClosedError)({
                            url
                        }));
                        // Attempt to reconnect.
                        if (reconnect && reconnectCount < attempts) setTimeout(async ()=>{
                            reconnectCount++;
                            await setup().catch(console.error);
                        }, delay);
                        else {
                            requests.clear();
                            subscriptions.clear();
                        }
                    },
                    onError (error_) {
                        error = error_;
                        // Notify all requests and subscriptions of the error.
                        for (const request of requests.values())request.onError?.(error);
                        for (const subscription of subscriptions.values())subscription.onError?.(error);
                        // Make sure socket is definitely closed.
                        socketClient?.close();
                        // Attempt to reconnect.
                        if (reconnect && reconnectCount < attempts) setTimeout(async ()=>{
                            reconnectCount++;
                            await setup().catch(console.error);
                        }, delay);
                        else {
                            requests.clear();
                            subscriptions.clear();
                        }
                    },
                    onOpen () {
                        error = undefined;
                        reconnectCount = 0;
                    },
                    onResponse (data) {
                        const isSubscription = data.method === 'eth_subscription';
                        const id = isSubscription ? data.params.subscription : data.id;
                        const cache = isSubscription ? subscriptions : requests;
                        const callback = cache.get(id);
                        if (callback) callback.onResponse(data);
                        if (!isSubscription) cache.delete(id);
                    }
                });
                socket = result;
                if (keepAlive) {
                    if (keepAliveTimer) clearInterval(keepAliveTimer);
                    keepAliveTimer = setInterval(()=>socket.ping?.(), keepAliveInterval);
                }
                return result;
            }
            await setup();
            error = undefined;
            // Create a new socket instance.
            socketClient = {
                close () {
                    keepAliveTimer && clearInterval(keepAliveTimer);
                    socket.close();
                    socketClientCache.delete(`${key}:${url}`);
                },
                get socket () {
                    return socket;
                },
                request ({ body, onError, onResponse }) {
                    if (error && onError) onError(error);
                    const id = body.id ?? (0, _idJs.idCache).take();
                    const callback = (response)=>{
                        if (typeof response.id === 'number' && id !== response.id) return;
                        // If we are subscribing to a topic, we want to set up a listener for incoming
                        // messages.
                        if (body.method === 'eth_subscribe' && typeof response.result === 'string') subscriptions.set(response.result, {
                            onResponse: callback,
                            onError
                        });
                        // If we are unsubscribing from a topic, we want to remove the listener.
                        if (body.method === 'eth_unsubscribe') subscriptions.delete(body.params?.[0]);
                        onResponse(response);
                    };
                    requests.set(id, {
                        onResponse: callback,
                        onError
                    });
                    try {
                        socket.request({
                            body: {
                                jsonrpc: '2.0',
                                id,
                                ...body
                            }
                        });
                    } catch (error) {
                        onError?.(error);
                    }
                },
                requestAsync ({ body, timeout = 10000 }) {
                    return (0, _withTimeoutJs.withTimeout)(()=>new Promise((onResponse, onError)=>this.request({
                                body,
                                onError,
                                onResponse
                            })), {
                        errorInstance: new (0, _requestJs.TimeoutError)({
                            body,
                            url
                        }),
                        timeout
                    });
                },
                requests,
                subscriptions,
                url
            };
            socketClientCache.set(`${key}:${url}`, socketClient);
            return [
                socketClient
            ];
        }
    });
    const [_, [socketClient_]] = await schedule();
    return socketClient_;
}

},{"../../errors/request.js":"6LYvf","../promise/createBatchScheduler.js":"cXEx4","../promise/withTimeout.js":"cETnG","./id.js":"l1EzB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fqY8x":[function(require,module,exports,__globalThis) {
module.exports = import("./native.9aa1333f.js").then(()=>module.bundle.root('a3rLQ'));

},{"a3rLQ":"a3rLQ"}],"bBGXA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "serializeTypedData", ()=>serializeTypedData);
parcelHelpers.export(exports, "validateTypedData", ()=>validateTypedData);
parcelHelpers.export(exports, "getTypesForEIP712Domain", ()=>getTypesForEIP712Domain);
parcelHelpers.export(exports, "domainSeparator", ()=>domainSeparator);
var _abiJs = require("../errors/abi.js");
var _addressJs = require("../errors/address.js");
var _typedDataJs = require("../errors/typedData.js");
var _isAddressJs = require("./address/isAddress.js");
var _sizeJs = require("./data/size.js");
var _toHexJs = require("./encoding/toHex.js");
var _regexJs = require("./regex.js");
var _hashTypedDataJs = require("./signature/hashTypedData.js");
var _stringifyJs = require("./stringify.js");
function serializeTypedData(parameters) {
    const { domain: domain_, message: message_, primaryType, types } = parameters;
    const normalizeData = (struct, data_)=>{
        const data = {
            ...data_
        };
        for (const param of struct){
            const { name, type } = param;
            if (type === 'address') data[name] = data[name].toLowerCase();
        }
        return data;
    };
    const domain = (()=>{
        if (!types.EIP712Domain) return {};
        if (!domain_) return {};
        return normalizeData(types.EIP712Domain, domain_);
    })();
    const message = (()=>{
        if (primaryType === 'EIP712Domain') return undefined;
        return normalizeData(types[primaryType], message_);
    })();
    return (0, _stringifyJs.stringify)({
        domain,
        message,
        primaryType,
        types
    });
}
function validateTypedData(parameters) {
    const { domain, message, primaryType, types } = parameters;
    const validateData = (struct, data)=>{
        for (const param of struct){
            const { name, type } = param;
            const value = data[name];
            const integerMatch = type.match((0, _regexJs.integerRegex));
            if (integerMatch && (typeof value === 'number' || typeof value === 'bigint')) {
                const [_type, base, size_] = integerMatch;
                // If number cannot be cast to a sized hex value, it is out of range
                // and will throw.
                (0, _toHexJs.numberToHex)(value, {
                    signed: base === 'int',
                    size: Number.parseInt(size_) / 8
                });
            }
            if (type === 'address' && typeof value === 'string' && !(0, _isAddressJs.isAddress)(value)) throw new (0, _addressJs.InvalidAddressError)({
                address: value
            });
            const bytesMatch = type.match((0, _regexJs.bytesRegex));
            if (bytesMatch) {
                const [_type, size_] = bytesMatch;
                if (size_ && (0, _sizeJs.size)(value) !== Number.parseInt(size_)) throw new (0, _abiJs.BytesSizeMismatchError)({
                    expectedSize: Number.parseInt(size_),
                    givenSize: (0, _sizeJs.size)(value)
                });
            }
            const struct = types[type];
            if (struct) {
                validateReference(type);
                validateData(struct, value);
            }
        }
    };
    // Validate domain types.
    if (types.EIP712Domain && domain) {
        if (typeof domain !== 'object') throw new (0, _typedDataJs.InvalidDomainError)({
            domain
        });
        validateData(types.EIP712Domain, domain);
    }
    // Validate message types.
    if (primaryType !== 'EIP712Domain') {
        if (types[primaryType]) validateData(types[primaryType], message);
        else throw new (0, _typedDataJs.InvalidPrimaryTypeError)({
            primaryType,
            types
        });
    }
}
function getTypesForEIP712Domain({ domain }) {
    return [
        typeof domain?.name === 'string' && {
            name: 'name',
            type: 'string'
        },
        domain?.version && {
            name: 'version',
            type: 'string'
        },
        (typeof domain?.chainId === 'number' || typeof domain?.chainId === 'bigint') && {
            name: 'chainId',
            type: 'uint256'
        },
        domain?.verifyingContract && {
            name: 'verifyingContract',
            type: 'address'
        },
        domain?.salt && {
            name: 'salt',
            type: 'bytes32'
        }
    ].filter(Boolean);
}
function domainSeparator({ domain }) {
    return (0, _hashTypedDataJs.hashDomain)({
        domain,
        types: {
            EIP712Domain: getTypesForEIP712Domain({
                domain
            })
        }
    });
}
/** @internal */ function validateReference(type) {
    // Struct type must not be a Solidity type.
    if (type === 'address' || type === 'bool' || type === 'string' || type.startsWith('bytes') || type.startsWith('uint') || type.startsWith('int')) throw new (0, _typedDataJs.InvalidStructTypeError)({
        type
    });
}

},{"../errors/abi.js":"7l8j7","../errors/address.js":"17VWr","../errors/typedData.js":"5Thdu","./address/isAddress.js":"kdAuv","./data/size.js":"exELm","./encoding/toHex.js":"9GFC6","./regex.js":"cdnY6","./signature/hashTypedData.js":"efmTs","./stringify.js":"jKcjI","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5Thdu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InvalidDomainError", ()=>InvalidDomainError);
parcelHelpers.export(exports, "InvalidPrimaryTypeError", ()=>InvalidPrimaryTypeError);
parcelHelpers.export(exports, "InvalidStructTypeError", ()=>InvalidStructTypeError);
var _stringifyJs = require("../utils/stringify.js");
var _baseJs = require("./base.js");
class InvalidDomainError extends (0, _baseJs.BaseError) {
    constructor({ domain }){
        super(`Invalid domain "${(0, _stringifyJs.stringify)(domain)}".`, {
            metaMessages: [
                'Must be a valid EIP-712 domain.'
            ]
        });
    }
}
class InvalidPrimaryTypeError extends (0, _baseJs.BaseError) {
    constructor({ primaryType, types }){
        super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types))}\`.`, {
            docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',
            metaMessages: [
                'Check that the primary type is a key in `types`.'
            ]
        });
    }
}
class InvalidStructTypeError extends (0, _baseJs.BaseError) {
    constructor({ type }){
        super(`Struct type "${type}" is invalid.`, {
            metaMessages: [
                'Struct type must not be a Solidity type.'
            ],
            name: 'InvalidStructTypeError'
        });
    }
}

},{"../utils/stringify.js":"jKcjI","./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"efmTs":[function(require,module,exports,__globalThis) {
// Implementation forked and adapted from https://github.com/MetaMask/eth-sig-util/blob/main/src/sign-typed-data.ts
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hashTypedData", ()=>hashTypedData);
parcelHelpers.export(exports, "hashDomain", ()=>hashDomain);
parcelHelpers.export(exports, "hashStruct", ()=>hashStruct);
parcelHelpers.export(exports, "encodeType", ()=>encodeType);
var _encodeAbiParametersJs = require("../abi/encodeAbiParameters.js");
var _concatJs = require("../data/concat.js");
var _toHexJs = require("../encoding/toHex.js");
var _keccak256Js = require("../hash/keccak256.js");
var _typedDataJs = require("../typedData.js");
function hashTypedData(parameters) {
    const { domain = {}, message, primaryType } = parameters;
    const types = {
        EIP712Domain: (0, _typedDataJs.getTypesForEIP712Domain)({
            domain
        }),
        ...parameters.types
    };
    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
    // as we can't statically check this with TypeScript.
    (0, _typedDataJs.validateTypedData)({
        domain,
        message,
        primaryType,
        types
    });
    const parts = [
        '0x1901'
    ];
    if (domain) parts.push(hashDomain({
        domain,
        types: types
    }));
    if (primaryType !== 'EIP712Domain') parts.push(hashStruct({
        data: message,
        primaryType,
        types: types
    }));
    return (0, _keccak256Js.keccak256)((0, _concatJs.concat)(parts));
}
function hashDomain({ domain, types }) {
    return hashStruct({
        data: domain,
        primaryType: 'EIP712Domain',
        types
    });
}
function hashStruct({ data, primaryType, types }) {
    const encoded = encodeData({
        data,
        primaryType,
        types
    });
    return (0, _keccak256Js.keccak256)(encoded);
}
function encodeData({ data, primaryType, types }) {
    const encodedTypes = [
        {
            type: 'bytes32'
        }
    ];
    const encodedValues = [
        hashType({
            primaryType,
            types
        })
    ];
    for (const field of types[primaryType]){
        const [type, value] = encodeField({
            types,
            name: field.name,
            type: field.type,
            value: data[field.name]
        });
        encodedTypes.push(type);
        encodedValues.push(value);
    }
    return (0, _encodeAbiParametersJs.encodeAbiParameters)(encodedTypes, encodedValues);
}
function hashType({ primaryType, types }) {
    const encodedHashType = (0, _toHexJs.toHex)(encodeType({
        primaryType,
        types
    }));
    return (0, _keccak256Js.keccak256)(encodedHashType);
}
function encodeType({ primaryType, types }) {
    let result = '';
    const unsortedDeps = findTypeDependencies({
        primaryType,
        types
    });
    unsortedDeps.delete(primaryType);
    const deps = [
        primaryType,
        ...Array.from(unsortedDeps).sort()
    ];
    for (const type of deps)result += `${type}(${types[type].map(({ name, type: t })=>`${t} ${name}`).join(',')})`;
    return result;
}
function findTypeDependencies({ primaryType: primaryType_, types }, results = new Set()) {
    const match = primaryType_.match(/^\w*/u);
    const primaryType = match?.[0];
    if (results.has(primaryType) || types[primaryType] === undefined) return results;
    results.add(primaryType);
    for (const field of types[primaryType])findTypeDependencies({
        primaryType: field.type,
        types
    }, results);
    return results;
}
function encodeField({ types, name, type, value }) {
    if (types[type] !== undefined) return [
        {
            type: 'bytes32'
        },
        (0, _keccak256Js.keccak256)(encodeData({
            data: value,
            primaryType: type,
            types
        }))
    ];
    if (type === 'bytes') {
        const prepend = value.length % 2 ? '0' : '';
        value = `0x${prepend + value.slice(2)}`;
        return [
            {
                type: 'bytes32'
            },
            (0, _keccak256Js.keccak256)(value)
        ];
    }
    if (type === 'string') return [
        {
            type: 'bytes32'
        },
        (0, _keccak256Js.keccak256)((0, _toHexJs.toHex)(value))
    ];
    if (type.lastIndexOf(']') === type.length - 1) {
        const parsedType = type.slice(0, type.lastIndexOf('['));
        const typeValuePairs = value.map((item)=>encodeField({
                name,
                type: parsedType,
                types,
                value: item
            }));
        return [
            {
                type: 'bytes32'
            },
            (0, _keccak256Js.keccak256)((0, _encodeAbiParametersJs.encodeAbiParameters)(typeValuePairs.map(([t])=>t), typeValuePairs.map(([, v])=>v)))
        ];
    }
    return [
        {
            type
        },
        value
    ];
}

},{"../abi/encodeAbiParameters.js":"8kHRc","../data/concat.js":"6FL5K","../encoding/toHex.js":"9GFC6","../hash/keccak256.js":"k4CmV","../typedData.js":"bBGXA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"11WHb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodePacked", ()=>encodePacked);
var _abiJs = require("../../errors/abi.js");
var _addressJs = require("../../errors/address.js");
var _isAddressJs = require("../address/isAddress.js");
var _concatJs = require("../data/concat.js");
var _padJs = require("../data/pad.js");
var _toHexJs = require("../encoding/toHex.js");
var _regexJs = require("../regex.js");
function encodePacked(types, values) {
    if (types.length !== values.length) throw new (0, _abiJs.AbiEncodingLengthMismatchError)({
        expectedLength: types.length,
        givenLength: values.length
    });
    const data = [];
    for(let i = 0; i < types.length; i++){
        const type = types[i];
        const value = values[i];
        data.push(encode(type, value));
    }
    return (0, _concatJs.concatHex)(data);
}
function encode(type, value, isArray = false) {
    if (type === 'address') {
        const address = value;
        if (!(0, _isAddressJs.isAddress)(address)) throw new (0, _addressJs.InvalidAddressError)({
            address
        });
        return (0, _padJs.pad)(address.toLowerCase(), {
            size: isArray ? 32 : null
        });
    }
    if (type === 'string') return (0, _toHexJs.stringToHex)(value);
    if (type === 'bytes') return value;
    if (type === 'bool') return (0, _padJs.pad)((0, _toHexJs.boolToHex)(value), {
        size: isArray ? 32 : 1
    });
    const intMatch = type.match((0, _regexJs.integerRegex));
    if (intMatch) {
        const [_type, baseType, bits = '256'] = intMatch;
        const size = Number.parseInt(bits) / 8;
        return (0, _toHexJs.numberToHex)(value, {
            size: isArray ? 32 : size,
            signed: baseType === 'int'
        });
    }
    const bytesMatch = type.match((0, _regexJs.bytesRegex));
    if (bytesMatch) {
        const [_type, size] = bytesMatch;
        if (Number.parseInt(size) !== (value.length - 2) / 2) throw new (0, _abiJs.BytesSizeMismatchError)({
            expectedSize: Number.parseInt(size),
            givenSize: (value.length - 2) / 2
        });
        return (0, _padJs.pad)(value, {
            dir: 'right',
            size: isArray ? 32 : null
        });
    }
    const arrayMatch = type.match((0, _regexJs.arrayRegex));
    if (arrayMatch && Array.isArray(value)) {
        const [_type, childType] = arrayMatch;
        const data = [];
        for(let i = 0; i < value.length; i++)data.push(encode(childType, value[i], true));
        if (data.length === 0) return '0x';
        return (0, _concatJs.concatHex)(data);
    }
    throw new (0, _abiJs.UnsupportedPackedAbiType)(type);
}

},{"../../errors/abi.js":"7l8j7","../../errors/address.js":"17VWr","../address/isAddress.js":"kdAuv","../data/concat.js":"6FL5K","../data/pad.js":"aAjQN","../encoding/toHex.js":"9GFC6","../regex.js":"cdnY6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eNdkE":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
 * Serializes an EIP-7702 authorization list.
 */ parcelHelpers.export(exports, "serializeAuthorizationList", ()=>serializeAuthorizationList);
var _toHexJs = require("../encoding/toHex.js");
var _serializeTransactionJs = require("../transaction/serializeTransaction.js");
function serializeAuthorizationList(authorizationList) {
    if (!authorizationList || authorizationList.length === 0) return [];
    const serializedAuthorizationList = [];
    for (const authorization of authorizationList){
        const { chainId, nonce, ...signature } = authorization;
        const contractAddress = authorization.address;
        serializedAuthorizationList.push([
            chainId ? (0, _toHexJs.toHex)(chainId) : '0x',
            contractAddress,
            nonce ? (0, _toHexJs.toHex)(nonce) : '0x',
            ...(0, _serializeTransactionJs.toYParitySignatureArray)({}, signature)
        ]);
    }
    return serializedAuthorizationList;
}

},{"../encoding/toHex.js":"9GFC6","../transaction/serializeTransaction.js":"eYYNO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eYYNO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "serializeTransaction", ()=>serializeTransaction);
parcelHelpers.export(exports, "toYParitySignatureArray", ()=>toYParitySignatureArray);
var _transactionJs = require("../../errors/transaction.js");
var _serializeAuthorizationListJs = require("../authorization/serializeAuthorizationList.js");
var _blobsToCommitmentsJs = require("../blob/blobsToCommitments.js");
var _blobsToProofsJs = require("../blob/blobsToProofs.js");
var _commitmentsToVersionedHashesJs = require("../blob/commitmentsToVersionedHashes.js");
var _toBlobSidecarsJs = require("../blob/toBlobSidecars.js");
var _concatJs = require("../data/concat.js");
var _trimJs = require("../data/trim.js");
var _toHexJs = require("../encoding/toHex.js");
var _toRlpJs = require("../encoding/toRlp.js");
var _assertTransactionJs = require("./assertTransaction.js");
var _getTransactionTypeJs = require("./getTransactionType.js");
var _serializeAccessListJs = require("./serializeAccessList.js");
function serializeTransaction(transaction, signature) {
    const type = (0, _getTransactionTypeJs.getTransactionType)(transaction);
    if (type === 'eip1559') return serializeTransactionEIP1559(transaction, signature);
    if (type === 'eip2930') return serializeTransactionEIP2930(transaction, signature);
    if (type === 'eip4844') return serializeTransactionEIP4844(transaction, signature);
    if (type === 'eip7702') return serializeTransactionEIP7702(transaction, signature);
    return serializeTransactionLegacy(transaction, signature);
}
function serializeTransactionEIP7702(transaction, signature) {
    const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    (0, _assertTransactionJs.assertTransactionEIP7702)(transaction);
    const serializedAccessList = (0, _serializeAccessListJs.serializeAccessList)(accessList);
    const serializedAuthorizationList = (0, _serializeAuthorizationListJs.serializeAuthorizationList)(authorizationList);
    return (0, _concatJs.concatHex)([
        '0x04',
        (0, _toRlpJs.toRlp)([
            (0, _toHexJs.toHex)(chainId),
            nonce ? (0, _toHexJs.toHex)(nonce) : '0x',
            maxPriorityFeePerGas ? (0, _toHexJs.toHex)(maxPriorityFeePerGas) : '0x',
            maxFeePerGas ? (0, _toHexJs.toHex)(maxFeePerGas) : '0x',
            gas ? (0, _toHexJs.toHex)(gas) : '0x',
            to ?? '0x',
            value ? (0, _toHexJs.toHex)(value) : '0x',
            data ?? '0x',
            serializedAccessList,
            serializedAuthorizationList,
            ...toYParitySignatureArray(transaction, signature)
        ])
    ]);
}
function serializeTransactionEIP4844(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    (0, _assertTransactionJs.assertTransactionEIP4844)(transaction);
    let blobVersionedHashes = transaction.blobVersionedHashes;
    let sidecars = transaction.sidecars;
    // If `blobs` are passed, we will need to compute the KZG commitments & proofs.
    if (transaction.blobs && (typeof blobVersionedHashes === 'undefined' || typeof sidecars === 'undefined')) {
        const blobs = typeof transaction.blobs[0] === 'string' ? transaction.blobs : transaction.blobs.map((x)=>(0, _toHexJs.bytesToHex)(x));
        const kzg = transaction.kzg;
        const commitments = (0, _blobsToCommitmentsJs.blobsToCommitments)({
            blobs,
            kzg
        });
        if (typeof blobVersionedHashes === 'undefined') blobVersionedHashes = (0, _commitmentsToVersionedHashesJs.commitmentsToVersionedHashes)({
            commitments
        });
        if (typeof sidecars === 'undefined') {
            const proofs = (0, _blobsToProofsJs.blobsToProofs)({
                blobs,
                commitments,
                kzg
            });
            sidecars = (0, _toBlobSidecarsJs.toBlobSidecars)({
                blobs,
                commitments,
                proofs
            });
        }
    }
    const serializedAccessList = (0, _serializeAccessListJs.serializeAccessList)(accessList);
    const serializedTransaction = [
        (0, _toHexJs.toHex)(chainId),
        nonce ? (0, _toHexJs.toHex)(nonce) : '0x',
        maxPriorityFeePerGas ? (0, _toHexJs.toHex)(maxPriorityFeePerGas) : '0x',
        maxFeePerGas ? (0, _toHexJs.toHex)(maxFeePerGas) : '0x',
        gas ? (0, _toHexJs.toHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, _toHexJs.toHex)(value) : '0x',
        data ?? '0x',
        serializedAccessList,
        maxFeePerBlobGas ? (0, _toHexJs.toHex)(maxFeePerBlobGas) : '0x',
        blobVersionedHashes ?? [],
        ...toYParitySignatureArray(transaction, signature)
    ];
    const blobs = [];
    const commitments = [];
    const proofs = [];
    if (sidecars) for(let i = 0; i < sidecars.length; i++){
        const { blob, commitment, proof } = sidecars[i];
        blobs.push(blob);
        commitments.push(commitment);
        proofs.push(proof);
    }
    return (0, _concatJs.concatHex)([
        '0x03',
        sidecars ? (0, _toRlpJs.toRlp)([
            serializedTransaction,
            blobs,
            commitments,
            proofs
        ]) : (0, _toRlpJs.toRlp)(serializedTransaction)
    ]);
}
function serializeTransactionEIP1559(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
    (0, _assertTransactionJs.assertTransactionEIP1559)(transaction);
    const serializedAccessList = (0, _serializeAccessListJs.serializeAccessList)(accessList);
    const serializedTransaction = [
        (0, _toHexJs.toHex)(chainId),
        nonce ? (0, _toHexJs.toHex)(nonce) : '0x',
        maxPriorityFeePerGas ? (0, _toHexJs.toHex)(maxPriorityFeePerGas) : '0x',
        maxFeePerGas ? (0, _toHexJs.toHex)(maxFeePerGas) : '0x',
        gas ? (0, _toHexJs.toHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, _toHexJs.toHex)(value) : '0x',
        data ?? '0x',
        serializedAccessList,
        ...toYParitySignatureArray(transaction, signature)
    ];
    return (0, _concatJs.concatHex)([
        '0x02',
        (0, _toRlpJs.toRlp)(serializedTransaction)
    ]);
}
function serializeTransactionEIP2930(transaction, signature) {
    const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
    (0, _assertTransactionJs.assertTransactionEIP2930)(transaction);
    const serializedAccessList = (0, _serializeAccessListJs.serializeAccessList)(accessList);
    const serializedTransaction = [
        (0, _toHexJs.toHex)(chainId),
        nonce ? (0, _toHexJs.toHex)(nonce) : '0x',
        gasPrice ? (0, _toHexJs.toHex)(gasPrice) : '0x',
        gas ? (0, _toHexJs.toHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, _toHexJs.toHex)(value) : '0x',
        data ?? '0x',
        serializedAccessList,
        ...toYParitySignatureArray(transaction, signature)
    ];
    return (0, _concatJs.concatHex)([
        '0x01',
        (0, _toRlpJs.toRlp)(serializedTransaction)
    ]);
}
function serializeTransactionLegacy(transaction, signature) {
    const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
    (0, _assertTransactionJs.assertTransactionLegacy)(transaction);
    let serializedTransaction = [
        nonce ? (0, _toHexJs.toHex)(nonce) : '0x',
        gasPrice ? (0, _toHexJs.toHex)(gasPrice) : '0x',
        gas ? (0, _toHexJs.toHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, _toHexJs.toHex)(value) : '0x',
        data ?? '0x'
    ];
    if (signature) {
        const v = (()=>{
            // EIP-155 (inferred chainId)
            if (signature.v >= 35n) {
                const inferredChainId = (signature.v - 35n) / 2n;
                if (inferredChainId > 0) return signature.v;
                return 27n + (signature.v === 35n ? 0n : 1n);
            }
            // EIP-155 (explicit chainId)
            if (chainId > 0) return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
            // Pre-EIP-155 (no chainId)
            const v = 27n + (signature.v === 27n ? 0n : 1n);
            if (signature.v !== v) throw new (0, _transactionJs.InvalidLegacyVError)({
                v: signature.v
            });
            return v;
        })();
        const r = (0, _trimJs.trim)(signature.r);
        const s = (0, _trimJs.trim)(signature.s);
        serializedTransaction = [
            ...serializedTransaction,
            (0, _toHexJs.toHex)(v),
            r === '0x00' ? '0x' : r,
            s === '0x00' ? '0x' : s
        ];
    } else if (chainId > 0) serializedTransaction = [
        ...serializedTransaction,
        (0, _toHexJs.toHex)(chainId),
        '0x',
        '0x'
    ];
    return (0, _toRlpJs.toRlp)(serializedTransaction);
}
function toYParitySignatureArray(transaction, signature_) {
    const signature = signature_ ?? transaction;
    const { v, yParity } = signature;
    if (typeof signature.r === 'undefined') return [];
    if (typeof signature.s === 'undefined') return [];
    if (typeof v === 'undefined' && typeof yParity === 'undefined') return [];
    const r = (0, _trimJs.trim)(signature.r);
    const s = (0, _trimJs.trim)(signature.s);
    const yParity_ = (()=>{
        if (typeof yParity === 'number') return yParity ? (0, _toHexJs.toHex)(1) : '0x';
        if (v === 0n) return '0x';
        if (v === 1n) return (0, _toHexJs.toHex)(1);
        return v === 27n ? '0x' : (0, _toHexJs.toHex)(1);
    })();
    return [
        yParity_,
        r === '0x00' ? '0x' : r,
        s === '0x00' ? '0x' : s
    ];
}

},{"../../errors/transaction.js":"4gFzr","../authorization/serializeAuthorizationList.js":"eNdkE","../blob/blobsToCommitments.js":"lGkWy","../blob/blobsToProofs.js":"82xng","../blob/commitmentsToVersionedHashes.js":"hAdbt","../blob/toBlobSidecars.js":"iLFBZ","../data/concat.js":"6FL5K","../data/trim.js":"3ZmMy","../encoding/toHex.js":"9GFC6","../encoding/toRlp.js":"7jPJy","./assertTransaction.js":"4466I","./getTransactionType.js":"2MIAC","./serializeAccessList.js":"3Pxwu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4466I":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "assertTransactionEIP7702", ()=>assertTransactionEIP7702);
parcelHelpers.export(exports, "assertTransactionEIP4844", ()=>assertTransactionEIP4844);
parcelHelpers.export(exports, "assertTransactionEIP1559", ()=>assertTransactionEIP1559);
parcelHelpers.export(exports, "assertTransactionEIP2930", ()=>assertTransactionEIP2930);
parcelHelpers.export(exports, "assertTransactionLegacy", ()=>assertTransactionLegacy);
var _kzgJs = require("../../constants/kzg.js");
var _numberJs = require("../../constants/number.js");
var _addressJs = require("../../errors/address.js");
var _baseJs = require("../../errors/base.js");
var _blobJs = require("../../errors/blob.js");
var _chainJs = require("../../errors/chain.js");
var _nodeJs = require("../../errors/node.js");
var _isAddressJs = require("../address/isAddress.js");
var _sizeJs = require("../data/size.js");
var _sliceJs = require("../data/slice.js");
var _fromHexJs = require("../encoding/fromHex.js");
function assertTransactionEIP7702(transaction) {
    const { authorizationList } = transaction;
    if (authorizationList) for (const authorization of authorizationList){
        const { chainId } = authorization;
        const address = authorization.address;
        if (!(0, _isAddressJs.isAddress)(address)) throw new (0, _addressJs.InvalidAddressError)({
            address
        });
        if (chainId < 0) throw new (0, _chainJs.InvalidChainIdError)({
            chainId
        });
    }
    assertTransactionEIP1559(transaction);
}
function assertTransactionEIP4844(transaction) {
    const { blobVersionedHashes } = transaction;
    if (blobVersionedHashes) {
        if (blobVersionedHashes.length === 0) throw new (0, _blobJs.EmptyBlobError)();
        for (const hash of blobVersionedHashes){
            const size_ = (0, _sizeJs.size)(hash);
            const version = (0, _fromHexJs.hexToNumber)((0, _sliceJs.slice)(hash, 0, 1));
            if (size_ !== 32) throw new (0, _blobJs.InvalidVersionedHashSizeError)({
                hash,
                size: size_
            });
            if (version !== (0, _kzgJs.versionedHashVersionKzg)) throw new (0, _blobJs.InvalidVersionedHashVersionError)({
                hash,
                version
            });
        }
    }
    assertTransactionEIP1559(transaction);
}
function assertTransactionEIP1559(transaction) {
    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction;
    if (chainId <= 0) throw new (0, _chainJs.InvalidChainIdError)({
        chainId
    });
    if (to && !(0, _isAddressJs.isAddress)(to)) throw new (0, _addressJs.InvalidAddressError)({
        address: to
    });
    if (maxFeePerGas && maxFeePerGas > (0, _numberJs.maxUint256)) throw new (0, _nodeJs.FeeCapTooHighError)({
        maxFeePerGas
    });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas) throw new (0, _nodeJs.TipAboveFeeCapError)({
        maxFeePerGas,
        maxPriorityFeePerGas
    });
}
function assertTransactionEIP2930(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (chainId <= 0) throw new (0, _chainJs.InvalidChainIdError)({
        chainId
    });
    if (to && !(0, _isAddressJs.isAddress)(to)) throw new (0, _addressJs.InvalidAddressError)({
        address: to
    });
    if (maxPriorityFeePerGas || maxFeePerGas) throw new (0, _baseJs.BaseError)('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.');
    if (gasPrice && gasPrice > (0, _numberJs.maxUint256)) throw new (0, _nodeJs.FeeCapTooHighError)({
        maxFeePerGas: gasPrice
    });
}
function assertTransactionLegacy(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (to && !(0, _isAddressJs.isAddress)(to)) throw new (0, _addressJs.InvalidAddressError)({
        address: to
    });
    if (typeof chainId !== 'undefined' && chainId <= 0) throw new (0, _chainJs.InvalidChainIdError)({
        chainId
    });
    if (maxPriorityFeePerGas || maxFeePerGas) throw new (0, _baseJs.BaseError)('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.');
    if (gasPrice && gasPrice > (0, _numberJs.maxUint256)) throw new (0, _nodeJs.FeeCapTooHighError)({
        maxFeePerGas: gasPrice
    });
}

},{"../../constants/kzg.js":"6LtNd","../../constants/number.js":"4KokG","../../errors/address.js":"17VWr","../../errors/base.js":"3SEPF","../../errors/blob.js":"76hB9","../../errors/chain.js":"hiOFa","../../errors/node.js":"9Ytun","../address/isAddress.js":"kdAuv","../data/size.js":"exELm","../data/slice.js":"hh6kq","../encoding/fromHex.js":"kLfW5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3Pxwu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/*
 * Serialize an  EIP-2930 access list
 * @remarks
 * Use to create a transaction serializer with support for EIP-2930 access lists
 *
 * @param accessList - Array of objects of address and arrays of Storage Keys
 * @throws InvalidAddressError, InvalidStorageKeySizeError
 * @returns Array of hex strings
 */ parcelHelpers.export(exports, "serializeAccessList", ()=>serializeAccessList);
var _addressJs = require("../../errors/address.js");
var _transactionJs = require("../../errors/transaction.js");
var _isAddressJs = require("../address/isAddress.js");
function serializeAccessList(accessList) {
    if (!accessList || accessList.length === 0) return [];
    const serializedAccessList = [];
    for(let i = 0; i < accessList.length; i++){
        const { address, storageKeys } = accessList[i];
        for(let j = 0; j < storageKeys.length; j++){
            if (storageKeys[j].length - 2 !== 64) throw new (0, _transactionJs.InvalidStorageKeySizeError)({
                storageKey: storageKeys[j]
            });
        }
        if (!(0, _isAddressJs.isAddress)(address, {
            strict: false
        })) throw new (0, _addressJs.InvalidAddressError)({
            address
        });
        serializedAccessList.push([
            address,
            storageKeys
        ]);
    }
    return serializedAccessList;
}

},{"../../errors/address.js":"17VWr","../../errors/transaction.js":"4gFzr","../address/isAddress.js":"kdAuv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"drHbc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getContractAddress", ()=>getContractAddress);
parcelHelpers.export(exports, "getCreateAddress", ()=>getCreateAddress);
parcelHelpers.export(exports, "getCreate2Address", ()=>getCreate2Address);
var _concatJs = require("../data/concat.js");
var _isBytesJs = require("../data/isBytes.js");
var _padJs = require("../data/pad.js");
var _sliceJs = require("../data/slice.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _toRlpJs = require("../encoding/toRlp.js");
var _keccak256Js = require("../hash/keccak256.js");
var _getAddressJs = require("./getAddress.js");
function getContractAddress(opts) {
    if (opts.opcode === 'CREATE2') return getCreate2Address(opts);
    return getCreateAddress(opts);
}
function getCreateAddress(opts) {
    const from = (0, _toBytesJs.toBytes)((0, _getAddressJs.getAddress)(opts.from));
    let nonce = (0, _toBytesJs.toBytes)(opts.nonce);
    if (nonce[0] === 0) nonce = new Uint8Array([]);
    return (0, _getAddressJs.getAddress)(`0x${(0, _keccak256Js.keccak256)((0, _toRlpJs.toRlp)([
        from,
        nonce
    ], 'bytes')).slice(26)}`);
}
function getCreate2Address(opts) {
    const from = (0, _toBytesJs.toBytes)((0, _getAddressJs.getAddress)(opts.from));
    const salt = (0, _padJs.pad)((0, _isBytesJs.isBytes)(opts.salt) ? opts.salt : (0, _toBytesJs.toBytes)(opts.salt), {
        size: 32
    });
    const bytecodeHash = (()=>{
        if ('bytecodeHash' in opts) {
            if ((0, _isBytesJs.isBytes)(opts.bytecodeHash)) return opts.bytecodeHash;
            return (0, _toBytesJs.toBytes)(opts.bytecodeHash);
        }
        return (0, _keccak256Js.keccak256)(opts.bytecode, 'bytes');
    })();
    return (0, _getAddressJs.getAddress)((0, _sliceJs.slice)((0, _keccak256Js.keccak256)((0, _concatJs.concat)([
        (0, _toBytesJs.toBytes)('0xff'),
        from,
        salt,
        bytecodeHash
    ])), 12));
}

},{"../data/concat.js":"6FL5K","../data/isBytes.js":"kWPYQ","../data/pad.js":"aAjQN","../data/slice.js":"hh6kq","../encoding/toBytes.js":"8cx1T","../encoding/toRlp.js":"7jPJy","../hash/keccak256.js":"k4CmV","./getAddress.js":"aGHEi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kWPYQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBytes", ()=>isBytes);
function isBytes(value) {
    if (!value) return false;
    if (typeof value !== 'object') return false;
    if (!('BYTES_PER_ELEMENT' in value)) return false;
    return value.BYTES_PER_ELEMENT === 1 && value.constructor.name === 'Uint8Array';
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4G3aP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromRlp", ()=>fromRlp);
var _baseJs = require("../../errors/base.js");
var _encodingJs = require("../../errors/encoding.js");
var _cursorJs = require("../cursor.js");
var _toBytesJs = require("./toBytes.js");
var _toHexJs = require("./toHex.js");
function fromRlp(value, to = 'hex') {
    const bytes = (()=>{
        if (typeof value === 'string') {
            if (value.length > 3 && value.length % 2 !== 0) throw new (0, _encodingJs.InvalidHexValueError)(value);
            return (0, _toBytesJs.hexToBytes)(value);
        }
        return value;
    })();
    const cursor = (0, _cursorJs.createCursor)(bytes, {
        recursiveReadLimit: Number.POSITIVE_INFINITY
    });
    const result = fromRlpCursor(cursor, to);
    return result;
}
function fromRlpCursor(cursor, to = 'hex') {
    if (cursor.bytes.length === 0) return to === 'hex' ? (0, _toHexJs.bytesToHex)(cursor.bytes) : cursor.bytes;
    const prefix = cursor.readByte();
    if (prefix < 0x80) cursor.decrementPosition(1);
    // bytes
    if (prefix < 0xc0) {
        const length = readLength(cursor, prefix, 0x80);
        const bytes = cursor.readBytes(length);
        return to === 'hex' ? (0, _toHexJs.bytesToHex)(bytes) : bytes;
    }
    // list
    const length = readLength(cursor, prefix, 0xc0);
    return readList(cursor, length, to);
}
function readLength(cursor, prefix, offset) {
    if (offset === 0x80 && prefix < 0x80) return 1;
    if (prefix <= offset + 55) return prefix - offset;
    if (prefix === offset + 55 + 1) return cursor.readUint8();
    if (prefix === offset + 55 + 2) return cursor.readUint16();
    if (prefix === offset + 55 + 3) return cursor.readUint24();
    if (prefix === offset + 55 + 4) return cursor.readUint32();
    throw new (0, _baseJs.BaseError)('Invalid RLP prefix');
}
function readList(cursor, length, to) {
    const position = cursor.position;
    const value = [];
    while(cursor.position - position < length)value.push(fromRlpCursor(cursor, to));
    return value;
}

},{"../../errors/base.js":"3SEPF","../../errors/encoding.js":"45Fmz","../cursor.js":"pWJ3P","./toBytes.js":"8cx1T","./toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3rY9Y":[function(require,module,exports,__globalThis) {
// biome-ignore lint/performance/noBarrelFile: intentional
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toEventSignature", ()=>(0, _toSignatureJs.toSignature));
var _toSignatureJs = require("./toSignature.js");

},{"./toSignature.js":"19eOv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3tfWZ":[function(require,module,exports,__globalThis) {
// biome-ignore lint/performance/noBarrelFile: intentional
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toFunctionSignature", ()=>(0, _toSignatureJs.toSignature));
var _toSignatureJs = require("./toSignature.js");

},{"./toSignature.js":"19eOv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fKDVF":[function(require,module,exports,__globalThis) {
// biome-ignore lint/performance/noBarrelFile: intentional
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toEventHash", ()=>(0, _toSignatureHashJs.toSignatureHash));
var _toSignatureHashJs = require("./toSignatureHash.js");

},{"./toSignatureHash.js":"7T2T5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g3FGI":[function(require,module,exports,__globalThis) {
// biome-ignore lint/performance/noBarrelFile: intentional
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toFunctionHash", ()=>(0, _toSignatureHashJs.toSignatureHash));
var _toSignatureHashJs = require("./toSignatureHash.js");

},{"./toSignatureHash.js":"7T2T5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dQrWx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isHash", ()=>isHash);
var _isHexJs = require("../data/isHex.js");
var _sizeJs = require("../data/size.js");
function isHash(hash) {
    return (0, _isHexJs.isHex)(hash) && (0, _sizeJs.size)(hash) === 32;
}

},{"../data/isHex.js":"evOcm","../data/size.js":"exELm","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"c2yQI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ripemd160", ()=>ripemd160);
var _ripemd160 = require("@noble/hashes/ripemd160");
var _isHexJs = require("../data/isHex.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
function ripemd160(value, to_) {
    const to = to_ || 'hex';
    const bytes = (0, _ripemd160.ripemd160)((0, _isHexJs.isHex)(value, {
        strict: false
    }) ? (0, _toBytesJs.toBytes)(value) : value);
    if (to === 'bytes') return bytes;
    return (0, _toHexJs.toHex)(bytes);
}

},{"@noble/hashes/ripemd160":"h7MUX","../data/isHex.js":"evOcm","../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h7MUX":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ripemd160 = exports.RIPEMD160 = void 0;
/**
 * RIPEMD-160 legacy hash function.
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 * @module
 * @deprecated
 */ const legacy_ts_1 = require("6c592c11de44f983");
/** @deprecated Use import from `noble/hashes/legacy` module */ exports.RIPEMD160 = legacy_ts_1.RIPEMD160;
/** @deprecated Use import from `noble/hashes/legacy` module */ exports.ripemd160 = legacy_ts_1.ripemd160;

},{"6c592c11de44f983":"latsQ"}],"latsQ":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;
/**

SHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.
Don't use them in a new protocol. What "weak" means:

- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.
- No practical pre-image attacks (only theoretical, 2^123.4)
- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151
 * @module
 */ const _md_ts_1 = require("2f20739411ceab2");
const utils_ts_1 = require("608dba3c6b412388");
/** Initial SHA1 state */ const SHA1_IV = /* @__PURE__ */ Uint32Array.from([
    0x67452301,
    0xefcdab89,
    0x98badcfe,
    0x10325476,
    0xc3d2e1f0
]);
// Reusable temporary buffer
const SHA1_W = /* @__PURE__ */ new Uint32Array(80);
/** SHA1 legacy hash class. */ class SHA1 extends _md_ts_1.HashMD {
    constructor(){
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
    }
    get() {
        const { A, B, C, D, E } = this;
        return [
            A,
            B,
            C,
            D,
            E
        ];
    }
    set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
    }
    process(view, offset) {
        for(let i = 0; i < 16; i++, offset += 4)SHA1_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 80; i++)SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        // Compression function main loop, 80 rounds
        let { A, B, C, D, E } = this;
        for(let i = 0; i < 80; i++){
            let F, K;
            if (i < 20) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                K = 0x5a827999;
            } else if (i < 40) {
                F = B ^ C ^ D;
                K = 0x6ed9eba1;
            } else if (i < 60) {
                F = (0, _md_ts_1.Maj)(B, C, D);
                K = 0x8f1bbcdc;
            } else {
                F = B ^ C ^ D;
                K = 0xca62c1d6;
            }
            const T = (0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i] | 0;
            E = D;
            D = C;
            C = (0, utils_ts_1.rotl)(B, 30);
            B = A;
            A = T;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        this.set(A, B, C, D, E);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA1 = SHA1;
/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */ exports.sha1 = (0, utils_ts_1.createHasher)(()=>new SHA1());
/** Per-round constants */ const p32 = /* @__PURE__ */ Math.pow(2, 32);
const K = /* @__PURE__ */ Array.from({
    length: 64
}, (_, i)=>Math.floor(p32 * Math.abs(Math.sin(i + 1))));
/** md5 initial state: same as sha1, but 4 u32 instead of 5. */ const MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
// Reusable temporary buffer
const MD5_W = /* @__PURE__ */ new Uint32Array(16);
/** MD5 legacy hash class. */ class MD5 extends _md_ts_1.HashMD {
    constructor(){
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
    }
    get() {
        const { A, B, C, D } = this;
        return [
            A,
            B,
            C,
            D
        ];
    }
    set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
    }
    process(view, offset) {
        for(let i = 0; i < 16; i++, offset += 4)MD5_W[i] = view.getUint32(offset, true);
        // Compression function main loop, 64 rounds
        let { A, B, C, D } = this;
        for(let i = 0; i < 64; i++){
            let F, g, s;
            if (i < 16) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                g = i;
                s = [
                    7,
                    12,
                    17,
                    22
                ];
            } else if (i < 32) {
                F = (0, _md_ts_1.Chi)(D, B, C);
                g = (5 * i + 1) % 16;
                s = [
                    5,
                    9,
                    14,
                    20
                ];
            } else if (i < 48) {
                F = B ^ C ^ D;
                g = (3 * i + 5) % 16;
                s = [
                    4,
                    11,
                    16,
                    23
                ];
            } else {
                F = C ^ (B | ~D);
                g = 7 * i % 16;
                s = [
                    6,
                    10,
                    15,
                    21
                ];
            }
            F = F + A + K[i] + MD5_W[g];
            A = D;
            D = C;
            C = B;
            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        this.set(A, B, C, D);
    }
    roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
    }
    destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.MD5 = MD5;
/**
 * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.
 * MD5 architecture is similar to SHA1, with some differences:
 * - Reduced output length: 16 bytes (128 bit) instead of 20
 * - 64 rounds, instead of 80
 * - Little-endian: could be faster, but will require more code
 * - Non-linear index selection: huge speed-up for unroll
 * - Per round constants: more memory accesses, additional speed-up for unroll
 */ exports.md5 = (0, utils_ts_1.createHasher)(()=>new MD5());
// RIPEMD-160
const Rho160 = /* @__PURE__ */ Uint8Array.from([
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8
]);
const Id160 = /* @__PURE__ */ (()=>Uint8Array.from(new Array(16).fill(0).map((_, i)=>i)))();
const Pi160 = /* @__PURE__ */ (()=>Id160.map((i)=>(9 * i + 5) % 16))();
const idxLR = /* @__PURE__ */ (()=>{
    const L = [
        Id160
    ];
    const R = [
        Pi160
    ];
    const res = [
        L,
        R
    ];
    for(let i = 0; i < 4; i++)for (let j of res)j.push(j[i].map((k)=>Rho160[k]));
    return res;
})();
const idxL = /* @__PURE__ */ (()=>idxLR[0])();
const idxR = /* @__PURE__ */ (()=>idxLR[1])();
// const [idxL, idxR] = idxLR;
const shifts160 = /* @__PURE__ */ [
    [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8
    ],
    [
        12,
        13,
        11,
        15,
        6,
        9,
        9,
        7,
        12,
        15,
        11,
        13,
        7,
        8,
        7,
        7
    ],
    [
        13,
        15,
        14,
        11,
        7,
        7,
        6,
        8,
        13,
        14,
        13,
        12,
        5,
        5,
        6,
        9
    ],
    [
        14,
        11,
        12,
        14,
        8,
        6,
        5,
        5,
        15,
        12,
        15,
        14,
        9,
        9,
        8,
        6
    ],
    [
        15,
        12,
        13,
        13,
        9,
        5,
        8,
        6,
        14,
        11,
        12,
        11,
        8,
        6,
        5,
        5
    ]
].map((i)=>Uint8Array.from(i));
const shiftsL160 = /* @__PURE__ */ idxL.map((idx, i)=>idx.map((j)=>shifts160[i][j]));
const shiftsR160 = /* @__PURE__ */ idxR.map((idx, i)=>idx.map((j)=>shifts160[i][j]));
const Kl160 = /* @__PURE__ */ Uint32Array.from([
    0x00000000,
    0x5a827999,
    0x6ed9eba1,
    0x8f1bbcdc,
    0xa953fd4e
]);
const Kr160 = /* @__PURE__ */ Uint32Array.from([
    0x50a28be6,
    0x5c4dd124,
    0x6d703ef3,
    0x7a6d76e9,
    0x00000000
]);
// It's called f() in spec.
function ripemd_f(group, x, y, z) {
    if (group === 0) return x ^ y ^ z;
    if (group === 1) return x & y | ~x & z;
    if (group === 2) return (x | ~y) ^ z;
    if (group === 3) return x & z | y & ~z;
    return x ^ (y | ~z);
}
// Reusable temporary buffer
const BUF_160 = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_ts_1.HashMD {
    constructor(){
        super(64, 20, 8, true);
        this.h0 = 1732584193;
        this.h1 = -271733879;
        this.h2 = -1732584194;
        this.h3 = 271733878;
        this.h4 = -1009589776;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [
            h0,
            h1,
            h2,
            h3,
            h4
        ];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for(let i = 0; i < 16; i++, offset += 4)BUF_160[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for(let group = 0; group < 5; group++){
            const rGroup = 4 - group;
            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore
            for(let i = 0; i < 16; i++){
                const tl = (0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el | 0;
                al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for(let i = 0; i < 16; i++){
                const tr = (0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er | 0;
                ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
        (0, utils_ts_1.clean)(BUF_160);
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a legacy hash function from 1990s.
 * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 */ exports.ripemd160 = (0, utils_ts_1.createHasher)(()=>new RIPEMD160());

},{"2f20739411ceab2":"dkX9O","608dba3c6b412388":"fuxLy"}],"7c8Ag":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "recoverMessageAddress", ()=>recoverMessageAddress);
var _hashMessageJs = require("./hashMessage.js");
var _recoverAddressJs = require("./recoverAddress.js");
async function recoverMessageAddress({ message, signature }) {
    return (0, _recoverAddressJs.recoverAddress)({
        hash: (0, _hashMessageJs.hashMessage)(message),
        signature
    });
}

},{"./hashMessage.js":"5oFnZ","./recoverAddress.js":"gBtnk","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5oFnZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hashMessage", ()=>hashMessage);
var _keccak256Js = require("../hash/keccak256.js");
var _toPrefixedMessageJs = require("./toPrefixedMessage.js");
function hashMessage(message, to_) {
    return (0, _keccak256Js.keccak256)((0, _toPrefixedMessageJs.toPrefixedMessage)(message), to_);
}

},{"../hash/keccak256.js":"k4CmV","./toPrefixedMessage.js":"apapX","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"apapX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toPrefixedMessage", ()=>toPrefixedMessage);
var _stringsJs = require("../../constants/strings.js");
var _concatJs = require("../data/concat.js");
var _sizeJs = require("../data/size.js");
var _toHexJs = require("../encoding/toHex.js");
function toPrefixedMessage(message_) {
    const message = (()=>{
        if (typeof message_ === 'string') return (0, _toHexJs.stringToHex)(message_);
        if (typeof message_.raw === 'string') return message_.raw;
        return (0, _toHexJs.bytesToHex)(message_.raw);
    })();
    const prefix = (0, _toHexJs.stringToHex)(`${(0, _stringsJs.presignMessagePrefix)}${(0, _sizeJs.size)(message)}`);
    return (0, _concatJs.concat)([
        prefix,
        message
    ]);
}

},{"../../constants/strings.js":"3bCKG","../data/concat.js":"6FL5K","../data/size.js":"exELm","../encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3bCKG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "presignMessagePrefix", ()=>presignMessagePrefix);
const presignMessagePrefix = '\x19Ethereum Signed Message:\n';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gIg5J":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "recoverTypedDataAddress", ()=>recoverTypedDataAddress);
var _hashTypedDataJs = require("./hashTypedData.js");
var _recoverAddressJs = require("./recoverAddress.js");
async function recoverTypedDataAddress(parameters) {
    const { domain, message, primaryType, signature, types } = parameters;
    return (0, _recoverAddressJs.recoverAddress)({
        hash: (0, _hashTypedDataJs.hashTypedData)({
            domain,
            message,
            primaryType,
            types
        }),
        signature
    });
}

},{"./hashTypedData.js":"efmTs","./recoverAddress.js":"gBtnk","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fuF8L":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Verify that a message was signed by the provided address.
 *
 * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.
 *        It is highly recommended to use `publicClient.verifyHash` instead to ensure
 *        wallet interoperability.
 *
 * - Docs {@link https://viem.sh/docs/utilities/verifyHash}
 *
 * @param parameters - {@link VerifyHashParameters}
 * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}
 */ parcelHelpers.export(exports, "verifyHash", ()=>verifyHash);
var _getAddressJs = require("../address/getAddress.js");
var _isAddressEqualJs = require("../address/isAddressEqual.js");
var _recoverAddressJs = require("./recoverAddress.js");
async function verifyHash({ address, hash, signature }) {
    return (0, _isAddressEqualJs.isAddressEqual)((0, _getAddressJs.getAddress)(address), await (0, _recoverAddressJs.recoverAddress)({
        hash,
        signature
    }));
}

},{"../address/getAddress.js":"aGHEi","../address/isAddressEqual.js":"lW8Gp","./recoverAddress.js":"gBtnk","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1Nrm7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Verify that a message was signed by the provided address.
 *
 * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.
 *        It is highly recommended to use `publicClient.verifyMessage` instead to ensure
 *        wallet interoperability.
 *
 * - Docs {@link https://viem.sh/docs/utilities/verifyMessage}
 *
 * @param parameters - {@link VerifyMessageParameters}
 * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}
 */ parcelHelpers.export(exports, "verifyMessage", ()=>verifyMessage);
var _getAddressJs = require("../address/getAddress.js");
var _isAddressEqualJs = require("../address/isAddressEqual.js");
var _recoverMessageAddressJs = require("./recoverMessageAddress.js");
async function verifyMessage({ address, message, signature }) {
    return (0, _isAddressEqualJs.isAddressEqual)((0, _getAddressJs.getAddress)(address), await (0, _recoverMessageAddressJs.recoverMessageAddress)({
        message,
        signature
    }));
}

},{"../address/getAddress.js":"aGHEi","../address/isAddressEqual.js":"lW8Gp","./recoverMessageAddress.js":"7c8Ag","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cHRUy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Verify that typed data was signed by the provided address.
 *
 * Note:  Only supports Externally Owned Accounts. Does not support Contract Accounts.
 *        It is highly recommended to use `publicClient.verifyTypedData` instead to ensure
 *        wallet interoperability.
 *
 * - Docs {@link https://viem.sh/docs/utilities/verifyTypedData}
 *
 * @param parameters - {@link VerifyTypedDataParameters}
 * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}
 */ parcelHelpers.export(exports, "verifyTypedData", ()=>verifyTypedData);
var _getAddressJs = require("../address/getAddress.js");
var _isAddressEqualJs = require("../address/isAddressEqual.js");
var _recoverTypedDataAddressJs = require("./recoverTypedDataAddress.js");
async function verifyTypedData(parameters) {
    const { address, domain, message, primaryType, signature, types } = parameters;
    return (0, _isAddressEqualJs.isAddressEqual)((0, _getAddressJs.getAddress)(address), await (0, _recoverTypedDataAddressJs.recoverTypedDataAddress)({
        domain,
        message,
        primaryType,
        signature,
        types
    }));
}

},{"../address/getAddress.js":"aGHEi","../address/isAddressEqual.js":"lW8Gp","./recoverTypedDataAddress.js":"gIg5J","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jdT8c":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Parses a hex-formatted ERC-6492 flavoured signature.
 * If the signature is not in ERC-6492 format, then the underlying (original) signature is returned.
 *
 * @param signature ERC-6492 signature in hex format.
 * @returns The parsed ERC-6492 signature.
 *
 * @example
 * parseSignature('0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492')
 * // { address: '0x...', data: '0x...', signature: '0x...' }
 */ parcelHelpers.export(exports, "parseErc6492Signature", ()=>parseErc6492Signature);
var _decodeAbiParametersJs = require("../abi/decodeAbiParameters.js");
var _isErc6492SignatureJs = require("./isErc6492Signature.js");
function parseErc6492Signature(signature) {
    if (!(0, _isErc6492SignatureJs.isErc6492Signature)(signature)) return {
        signature
    };
    const [address, data, signature_] = (0, _decodeAbiParametersJs.decodeAbiParameters)([
        {
            type: 'address'
        },
        {
            type: 'bytes'
        },
        {
            type: 'bytes'
        }
    ], signature);
    return {
        address,
        data,
        signature: signature_
    };
}

},{"../abi/decodeAbiParameters.js":"hR5FN","./isErc6492Signature.js":"gaUAz","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gaUAz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** Whether or not the signature is an ERC-6492 formatted signature. */ parcelHelpers.export(exports, "isErc6492Signature", ()=>isErc6492Signature);
var _bytesJs = require("../../constants/bytes.js");
var _sliceJs = require("../data/slice.js");
function isErc6492Signature(signature) {
    return (0, _sliceJs.sliceHex)(signature, -32) === (0, _bytesJs.erc6492MagicBytes);
}

},{"../../constants/bytes.js":"gVXXw","../data/slice.js":"hh6kq","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gVXXw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "erc6492MagicBytes", ()=>erc6492MagicBytes);
parcelHelpers.export(exports, "zeroHash", ()=>zeroHash);
const erc6492MagicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';
const zeroHash = '0x0000000000000000000000000000000000000000000000000000000000000000';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4KJdz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Serializes a ERC-6492 flavoured signature into hex format.
 *
 * @param signature ERC-6492 signature in object format.
 * @returns ERC-6492 signature in hex format.
 *
 * @example
 * serializeSignature({ address: '0x...', data: '0x...', signature: '0x...' })
 * // '0x000000000000000000000000cafebabecafebabecafebabecafebabecafebabe000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000004deadbeef000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000041a461f509887bd19e312c0c58467ce8ff8e300d3c1a90b608a760c5b80318eaf15fe57c96f9175d6cd4daad4663763baa7e78836e067d0163e9a2ccf2ff753f5b1b000000000000000000000000000000000000000000000000000000000000006492649264926492649264926492649264926492649264926492649264926492'
 */ parcelHelpers.export(exports, "serializeErc6492Signature", ()=>serializeErc6492Signature);
var _bytesJs = require("../../constants/bytes.js");
var _encodeAbiParametersJs = require("../abi/encodeAbiParameters.js");
var _concatJs = require("../data/concat.js");
var _toBytesJs = require("../encoding/toBytes.js");
function serializeErc6492Signature(parameters) {
    const { address, data, signature, to = 'hex' } = parameters;
    const signature_ = (0, _concatJs.concatHex)([
        (0, _encodeAbiParametersJs.encodeAbiParameters)([
            {
                type: 'address'
            },
            {
                type: 'bytes'
            },
            {
                type: 'bytes'
            }
        ], [
            address,
            data,
            signature
        ]),
        (0, _bytesJs.erc6492MagicBytes)
    ]);
    if (to === 'hex') return signature_;
    return (0, _toBytesJs.hexToBytes)(signature_);
}

},{"../../constants/bytes.js":"gVXXw","../abi/encodeAbiParameters.js":"8kHRc","../data/concat.js":"6FL5K","../encoding/toBytes.js":"8cx1T","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jYgXM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSerializedTransactionType", ()=>getSerializedTransactionType);
var _transactionJs = require("../../errors/transaction.js");
var _sliceJs = require("../data/slice.js");
var _fromHexJs = require("../encoding/fromHex.js");
function getSerializedTransactionType(serializedTransaction) {
    const serializedType = (0, _sliceJs.sliceHex)(serializedTransaction, 0, 1);
    if (serializedType === '0x04') return 'eip7702';
    if (serializedType === '0x03') return 'eip4844';
    if (serializedType === '0x02') return 'eip1559';
    if (serializedType === '0x01') return 'eip2930';
    if (serializedType !== '0x' && (0, _fromHexJs.hexToNumber)(serializedType) >= 0xc0) return 'legacy';
    throw new (0, _transactionJs.InvalidSerializedTransactionTypeError)({
        serializedType
    });
}

},{"../../errors/transaction.js":"4gFzr","../data/slice.js":"hh6kq","../encoding/fromHex.js":"kLfW5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a0tzY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseTransaction", ()=>parseTransaction);
parcelHelpers.export(exports, "toTransactionArray", ()=>toTransactionArray);
parcelHelpers.export(exports, "parseAccessList", ()=>parseAccessList);
var _addressJs = require("../../errors/address.js");
var _transactionJs = require("../../errors/transaction.js");
var _isAddressJs = require("../address/isAddress.js");
var _toBlobSidecarsJs = require("../blob/toBlobSidecars.js");
var _isHexJs = require("../data/isHex.js");
var _padJs = require("../data/pad.js");
var _trimJs = require("../data/trim.js");
var _fromHexJs = require("../encoding/fromHex.js");
var _fromRlpJs = require("../encoding/fromRlp.js");
var _isHashJs = require("../hash/isHash.js");
var _assertTransactionJs = require("./assertTransaction.js");
var _getSerializedTransactionTypeJs = require("./getSerializedTransactionType.js");
function parseTransaction(serializedTransaction) {
    const type = (0, _getSerializedTransactionTypeJs.getSerializedTransactionType)(serializedTransaction);
    if (type === 'eip1559') return parseTransactionEIP1559(serializedTransaction);
    if (type === 'eip2930') return parseTransactionEIP2930(serializedTransaction);
    if (type === 'eip4844') return parseTransactionEIP4844(serializedTransaction);
    if (type === 'eip7702') return parseTransactionEIP7702(serializedTransaction);
    return parseTransactionLegacy(serializedTransaction);
}
function parseTransactionEIP7702(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, v, r, s] = transactionArray;
    if (transactionArray.length !== 10 && transactionArray.length !== 13) throw new (0, _transactionJs.InvalidSerializedTransactionError)({
        attributes: {
            chainId,
            nonce,
            maxPriorityFeePerGas,
            maxFeePerGas,
            gas,
            to,
            value,
            data,
            accessList,
            authorizationList,
            ...transactionArray.length > 9 ? {
                v,
                r,
                s
            } : {}
        },
        serializedTransaction,
        type: 'eip7702'
    });
    const transaction = {
        chainId: (0, _fromHexJs.hexToNumber)(chainId),
        type: 'eip7702'
    };
    if ((0, _isHexJs.isHex)(to) && to !== '0x') transaction.to = to;
    if ((0, _isHexJs.isHex)(gas) && gas !== '0x') transaction.gas = (0, _fromHexJs.hexToBigInt)(gas);
    if ((0, _isHexJs.isHex)(data) && data !== '0x') transaction.data = data;
    if ((0, _isHexJs.isHex)(nonce)) transaction.nonce = nonce === '0x' ? 0 : (0, _fromHexJs.hexToNumber)(nonce);
    if ((0, _isHexJs.isHex)(value) && value !== '0x') transaction.value = (0, _fromHexJs.hexToBigInt)(value);
    if ((0, _isHexJs.isHex)(maxFeePerGas) && maxFeePerGas !== '0x') transaction.maxFeePerGas = (0, _fromHexJs.hexToBigInt)(maxFeePerGas);
    if ((0, _isHexJs.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x') transaction.maxPriorityFeePerGas = (0, _fromHexJs.hexToBigInt)(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = parseAccessList(accessList);
    if (authorizationList.length !== 0 && authorizationList !== '0x') transaction.authorizationList = parseAuthorizationList(authorizationList);
    (0, _assertTransactionJs.assertTransactionEIP7702)(transaction);
    const signature = transactionArray.length === 13 ? parseEIP155Signature(transactionArray) : undefined;
    return {
        ...signature,
        ...transaction
    };
}
function parseTransactionEIP4844(serializedTransaction) {
    const transactionOrWrapperArray = toTransactionArray(serializedTransaction);
    const hasNetworkWrapper = transactionOrWrapperArray.length === 4;
    const transactionArray = hasNetworkWrapper ? transactionOrWrapperArray[0] : transactionOrWrapperArray;
    const wrapperArray = hasNetworkWrapper ? transactionOrWrapperArray.slice(1) : [];
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, v, r, s] = transactionArray;
    const [blobs, commitments, proofs] = wrapperArray;
    if (!(transactionArray.length === 11 || transactionArray.length === 14)) throw new (0, _transactionJs.InvalidSerializedTransactionError)({
        attributes: {
            chainId,
            nonce,
            maxPriorityFeePerGas,
            maxFeePerGas,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 9 ? {
                v,
                r,
                s
            } : {}
        },
        serializedTransaction,
        type: 'eip4844'
    });
    const transaction = {
        blobVersionedHashes: blobVersionedHashes,
        chainId: (0, _fromHexJs.hexToNumber)(chainId),
        type: 'eip4844'
    };
    if ((0, _isHexJs.isHex)(to) && to !== '0x') transaction.to = to;
    if ((0, _isHexJs.isHex)(gas) && gas !== '0x') transaction.gas = (0, _fromHexJs.hexToBigInt)(gas);
    if ((0, _isHexJs.isHex)(data) && data !== '0x') transaction.data = data;
    if ((0, _isHexJs.isHex)(nonce)) transaction.nonce = nonce === '0x' ? 0 : (0, _fromHexJs.hexToNumber)(nonce);
    if ((0, _isHexJs.isHex)(value) && value !== '0x') transaction.value = (0, _fromHexJs.hexToBigInt)(value);
    if ((0, _isHexJs.isHex)(maxFeePerBlobGas) && maxFeePerBlobGas !== '0x') transaction.maxFeePerBlobGas = (0, _fromHexJs.hexToBigInt)(maxFeePerBlobGas);
    if ((0, _isHexJs.isHex)(maxFeePerGas) && maxFeePerGas !== '0x') transaction.maxFeePerGas = (0, _fromHexJs.hexToBigInt)(maxFeePerGas);
    if ((0, _isHexJs.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x') transaction.maxPriorityFeePerGas = (0, _fromHexJs.hexToBigInt)(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = parseAccessList(accessList);
    if (blobs && commitments && proofs) transaction.sidecars = (0, _toBlobSidecarsJs.toBlobSidecars)({
        blobs: blobs,
        commitments: commitments,
        proofs: proofs
    });
    (0, _assertTransactionJs.assertTransactionEIP4844)(transaction);
    const signature = transactionArray.length === 14 ? parseEIP155Signature(transactionArray) : undefined;
    return {
        ...signature,
        ...transaction
    };
}
function parseTransactionEIP1559(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s] = transactionArray;
    if (!(transactionArray.length === 9 || transactionArray.length === 12)) throw new (0, _transactionJs.InvalidSerializedTransactionError)({
        attributes: {
            chainId,
            nonce,
            maxPriorityFeePerGas,
            maxFeePerGas,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 9 ? {
                v,
                r,
                s
            } : {}
        },
        serializedTransaction,
        type: 'eip1559'
    });
    const transaction = {
        chainId: (0, _fromHexJs.hexToNumber)(chainId),
        type: 'eip1559'
    };
    if ((0, _isHexJs.isHex)(to) && to !== '0x') transaction.to = to;
    if ((0, _isHexJs.isHex)(gas) && gas !== '0x') transaction.gas = (0, _fromHexJs.hexToBigInt)(gas);
    if ((0, _isHexJs.isHex)(data) && data !== '0x') transaction.data = data;
    if ((0, _isHexJs.isHex)(nonce)) transaction.nonce = nonce === '0x' ? 0 : (0, _fromHexJs.hexToNumber)(nonce);
    if ((0, _isHexJs.isHex)(value) && value !== '0x') transaction.value = (0, _fromHexJs.hexToBigInt)(value);
    if ((0, _isHexJs.isHex)(maxFeePerGas) && maxFeePerGas !== '0x') transaction.maxFeePerGas = (0, _fromHexJs.hexToBigInt)(maxFeePerGas);
    if ((0, _isHexJs.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x') transaction.maxPriorityFeePerGas = (0, _fromHexJs.hexToBigInt)(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = parseAccessList(accessList);
    (0, _assertTransactionJs.assertTransactionEIP1559)(transaction);
    const signature = transactionArray.length === 12 ? parseEIP155Signature(transactionArray) : undefined;
    return {
        ...signature,
        ...transaction
    };
}
function parseTransactionEIP2930(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;
    if (!(transactionArray.length === 8 || transactionArray.length === 11)) throw new (0, _transactionJs.InvalidSerializedTransactionError)({
        attributes: {
            chainId,
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            accessList,
            ...transactionArray.length > 8 ? {
                v,
                r,
                s
            } : {}
        },
        serializedTransaction,
        type: 'eip2930'
    });
    const transaction = {
        chainId: (0, _fromHexJs.hexToNumber)(chainId),
        type: 'eip2930'
    };
    if ((0, _isHexJs.isHex)(to) && to !== '0x') transaction.to = to;
    if ((0, _isHexJs.isHex)(gas) && gas !== '0x') transaction.gas = (0, _fromHexJs.hexToBigInt)(gas);
    if ((0, _isHexJs.isHex)(data) && data !== '0x') transaction.data = data;
    if ((0, _isHexJs.isHex)(nonce)) transaction.nonce = nonce === '0x' ? 0 : (0, _fromHexJs.hexToNumber)(nonce);
    if ((0, _isHexJs.isHex)(value) && value !== '0x') transaction.value = (0, _fromHexJs.hexToBigInt)(value);
    if ((0, _isHexJs.isHex)(gasPrice) && gasPrice !== '0x') transaction.gasPrice = (0, _fromHexJs.hexToBigInt)(gasPrice);
    if (accessList.length !== 0 && accessList !== '0x') transaction.accessList = parseAccessList(accessList);
    (0, _assertTransactionJs.assertTransactionEIP2930)(transaction);
    const signature = transactionArray.length === 11 ? parseEIP155Signature(transactionArray) : undefined;
    return {
        ...signature,
        ...transaction
    };
}
function parseTransactionLegacy(serializedTransaction) {
    const transactionArray = (0, _fromRlpJs.fromRlp)(serializedTransaction, 'hex');
    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
    if (!(transactionArray.length === 6 || transactionArray.length === 9)) throw new (0, _transactionJs.InvalidSerializedTransactionError)({
        attributes: {
            nonce,
            gasPrice,
            gas,
            to,
            value,
            data,
            ...transactionArray.length > 6 ? {
                v: chainIdOrV_,
                r,
                s
            } : {}
        },
        serializedTransaction,
        type: 'legacy'
    });
    const transaction = {
        type: 'legacy'
    };
    if ((0, _isHexJs.isHex)(to) && to !== '0x') transaction.to = to;
    if ((0, _isHexJs.isHex)(gas) && gas !== '0x') transaction.gas = (0, _fromHexJs.hexToBigInt)(gas);
    if ((0, _isHexJs.isHex)(data) && data !== '0x') transaction.data = data;
    if ((0, _isHexJs.isHex)(nonce)) transaction.nonce = nonce === '0x' ? 0 : (0, _fromHexJs.hexToNumber)(nonce);
    if ((0, _isHexJs.isHex)(value) && value !== '0x') transaction.value = (0, _fromHexJs.hexToBigInt)(value);
    if ((0, _isHexJs.isHex)(gasPrice) && gasPrice !== '0x') transaction.gasPrice = (0, _fromHexJs.hexToBigInt)(gasPrice);
    (0, _assertTransactionJs.assertTransactionLegacy)(transaction);
    if (transactionArray.length === 6) return transaction;
    const chainIdOrV = (0, _isHexJs.isHex)(chainIdOrV_) && chainIdOrV_ !== '0x' ? (0, _fromHexJs.hexToBigInt)(chainIdOrV_) : 0n;
    if (s === '0x' && r === '0x') {
        if (chainIdOrV > 0) transaction.chainId = Number(chainIdOrV);
        return transaction;
    }
    const v = chainIdOrV;
    const chainId = Number((v - 35n) / 2n);
    if (chainId > 0) transaction.chainId = chainId;
    else if (v !== 27n && v !== 28n) throw new (0, _transactionJs.InvalidLegacyVError)({
        v
    });
    transaction.v = v;
    transaction.s = s;
    transaction.r = r;
    transaction.yParity = v % 2n === 0n ? 1 : 0;
    return transaction;
}
function toTransactionArray(serializedTransaction) {
    return (0, _fromRlpJs.fromRlp)(`0x${serializedTransaction.slice(4)}`, 'hex');
}
function parseAccessList(accessList_) {
    const accessList = [];
    for(let i = 0; i < accessList_.length; i++){
        const [address, storageKeys] = accessList_[i];
        if (!(0, _isAddressJs.isAddress)(address, {
            strict: false
        })) throw new (0, _addressJs.InvalidAddressError)({
            address
        });
        accessList.push({
            address: address,
            storageKeys: storageKeys.map((key)=>(0, _isHashJs.isHash)(key) ? key : (0, _trimJs.trim)(key))
        });
    }
    return accessList;
}
function parseAuthorizationList(serializedAuthorizationList) {
    const authorizationList = [];
    for(let i = 0; i < serializedAuthorizationList.length; i++){
        const [chainId, address, nonce, yParity, r, s] = serializedAuthorizationList[i];
        authorizationList.push({
            address,
            chainId: (0, _fromHexJs.hexToNumber)(chainId),
            nonce: (0, _fromHexJs.hexToNumber)(nonce),
            ...parseEIP155Signature([
                yParity,
                r,
                s
            ])
        });
    }
    return authorizationList;
}
function parseEIP155Signature(transactionArray) {
    const signature = transactionArray.slice(-3);
    const v = signature[0] === '0x' || (0, _fromHexJs.hexToBigInt)(signature[0]) === 0n ? 27n : 28n;
    return {
        r: (0, _padJs.padHex)(signature[1], {
            size: 32
        }),
        s: (0, _padJs.padHex)(signature[2], {
            size: 32
        }),
        v,
        yParity: v === 27n ? 0 : 1
    };
}

},{"../../errors/address.js":"17VWr","../../errors/transaction.js":"4gFzr","../address/isAddress.js":"kdAuv","../blob/toBlobSidecars.js":"iLFBZ","../data/isHex.js":"evOcm","../data/pad.js":"aAjQN","../data/trim.js":"3ZmMy","../encoding/fromHex.js":"kLfW5","../encoding/fromRlp.js":"4G3aP","../hash/isHash.js":"dQrWx","./assertTransaction.js":"4466I","./getSerializedTransactionType.js":"jYgXM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iISUq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Multiplies a string representation of a number by a given exponent of base 10 (10exponent).
 *
 * - Docs: https://viem.sh/docs/utilities/parseUnits
 *
 * @example
 * import { parseUnits } from 'viem'
 *
 * parseUnits('420', 9)
 * // 420000000000n
 */ parcelHelpers.export(exports, "parseUnits", ()=>parseUnits);
var _unitJs = require("../../errors/unit.js");
function parseUnits(value, decimals) {
    if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value)) throw new (0, _unitJs.InvalidDecimalNumberError)({
        value
    });
    let [integer, fraction = '0'] = value.split('.');
    const negative = integer.startsWith('-');
    if (negative) integer = integer.slice(1);
    // trim trailing zeros.
    fraction = fraction.replace(/(0+)$/, '');
    // round off if the fraction is larger than the number of decimals.
    if (decimals === 0) {
        if (Math.round(Number(`.${fraction}`)) === 1) integer = `${BigInt(integer) + 1n}`;
        fraction = '';
    } else if (fraction.length > decimals) {
        const [left, unit, right] = [
            fraction.slice(0, decimals - 1),
            fraction.slice(decimals - 1, decimals),
            fraction.slice(decimals)
        ];
        const rounded = Math.round(Number(`${unit}.${right}`));
        if (rounded > 9) fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0');
        else fraction = `${left}${rounded}`;
        if (fraction.length > decimals) {
            fraction = fraction.slice(1);
            integer = `${BigInt(integer) + 1n}`;
        }
        fraction = fraction.slice(0, decimals);
    } else fraction = fraction.padEnd(decimals, '0');
    return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);
}

},{"../../errors/unit.js":"7gJBF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7gJBF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InvalidDecimalNumberError", ()=>InvalidDecimalNumberError);
var _baseJs = require("./base.js");
class InvalidDecimalNumberError extends (0, _baseJs.BaseError) {
    constructor({ value }){
        super(`Number \`${value}\` is not a valid decimal number.`, {
            name: 'InvalidDecimalNumberError'
        });
    }
}

},{"./base.js":"3SEPF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"SUgRq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts a string representation of ether to numerical wei.
 *
 * - Docs: https://viem.sh/docs/utilities/parseEther
 *
 * @example
 * import { parseEther } from 'viem'
 *
 * parseEther('420')
 * // 420000000000000000000n
 */ parcelHelpers.export(exports, "parseEther", ()=>parseEther);
var _unitJs = require("../../constants/unit.js");
var _parseUnitsJs = require("./parseUnits.js");
function parseEther(ether, unit = 'wei') {
    return (0, _parseUnitsJs.parseUnits)(ether, (0, _unitJs.etherUnits)[unit]);
}

},{"../../constants/unit.js":"GgDwZ","./parseUnits.js":"iISUq","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hkYek":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts a string representation of gwei to numerical wei.
 *
 * - Docs: https://viem.sh/docs/utilities/parseGwei
 *
 * @example
 * import { parseGwei } from 'viem'
 *
 * parseGwei('420')
 * // 420000000000n
 */ parcelHelpers.export(exports, "parseGwei", ()=>parseGwei);
var _unitJs = require("../../constants/unit.js");
var _parseUnitsJs = require("./parseUnits.js");
function parseGwei(ether, unit = 'wei') {
    return (0, _parseUnitsJs.parseUnits)(ether, (0, _unitJs.gweiUnits)[unit]);
}

},{"../../constants/unit.js":"GgDwZ","./parseUnits.js":"iISUq","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9LOeC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Creates a nonce manager for auto-incrementing transaction nonces.
 *
 * - Docs: https://viem.sh/docs/accounts/createNonceManager
 *
 * @example
 * ```ts
 * const nonceManager = createNonceManager({
 *   source: jsonRpc(),
 * })
 * ```
 */ parcelHelpers.export(exports, "createNonceManager", ()=>createNonceManager);
/** JSON-RPC source for a nonce manager. */ parcelHelpers.export(exports, "jsonRpc", ()=>jsonRpc);
parcelHelpers.export(exports, "nonceManager", ()=>nonceManager);
var _getTransactionCountJs = require("../actions/public/getTransactionCount.js");
var _lruJs = require("./lru.js");
function createNonceManager(parameters) {
    const { source } = parameters;
    const deltaMap = new Map();
    const nonceMap = new (0, _lruJs.LruMap)(8192);
    const promiseMap = new Map();
    const getKey = ({ address, chainId })=>`${address}.${chainId}`;
    return {
        async consume ({ address, chainId, client }) {
            const key = getKey({
                address,
                chainId
            });
            const promise = this.get({
                address,
                chainId,
                client
            });
            this.increment({
                address,
                chainId
            });
            const nonce = await promise;
            await source.set({
                address,
                chainId
            }, nonce);
            nonceMap.set(key, nonce);
            return nonce;
        },
        async increment ({ address, chainId }) {
            const key = getKey({
                address,
                chainId
            });
            const delta = deltaMap.get(key) ?? 0;
            deltaMap.set(key, delta + 1);
        },
        async get ({ address, chainId, client }) {
            const key = getKey({
                address,
                chainId
            });
            let promise = promiseMap.get(key);
            if (!promise) {
                promise = (async ()=>{
                    try {
                        const nonce = await source.get({
                            address,
                            chainId,
                            client
                        });
                        const previousNonce = nonceMap.get(key) ?? 0;
                        if (previousNonce > 0 && nonce <= previousNonce) return previousNonce + 1;
                        nonceMap.delete(key);
                        return nonce;
                    } finally{
                        this.reset({
                            address,
                            chainId
                        });
                    }
                })();
                promiseMap.set(key, promise);
            }
            const delta = deltaMap.get(key) ?? 0;
            return delta + await promise;
        },
        reset ({ address, chainId }) {
            const key = getKey({
                address,
                chainId
            });
            deltaMap.delete(key);
            promiseMap.delete(key);
        }
    };
}
function jsonRpc() {
    return {
        async get (parameters) {
            const { address, client } = parameters;
            return (0, _getTransactionCountJs.getTransactionCount)(client, {
                address,
                blockTag: 'pending'
            });
        },
        set () {}
    };
}
const nonceManager = /*#__PURE__*/ createNonceManager({
    source: jsonRpc()
});

},{"../actions/public/getTransactionCount.js":"7o2N6","./lru.js":"ibK3x","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i5HZM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the value from a storage slot at a given address.
 *
 * - Docs: https://viem.sh/docs/contract/getStorageAt
 * - JSON-RPC Methods: [`eth_getStorageAt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getstorageat)
 *
 * @param client - Client to use
 * @param parameters - {@link GetStorageAtParameters}
 * @returns The value of the storage slot. {@link GetStorageAtReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getStorageAt } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const code = await getStorageAt(client, {
 *   address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *   slot: toHex(0),
 * })
 */ parcelHelpers.export(exports, "getStorageAt", ()=>getStorageAt);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function getStorageAt(client, { address, blockNumber, blockTag = 'latest', slot }) {
    const blockNumberHex = blockNumber !== undefined ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    const data = await client.request({
        method: 'eth_getStorageAt',
        params: [
            address,
            slot,
            blockNumberHex || blockTag
        ]
    });
    return data;
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lrruA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns information about a [Transaction](https://viem.sh/docs/glossary/terms#transaction) given a hash or block identifier.
 *
 * - Docs: https://viem.sh/docs/actions/public/getTransaction
 * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions
 * - JSON-RPC Methods: [`eth_getTransactionByHash`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionByHash)
 *
 * @param client - Client to use
 * @param parameters - {@link GetTransactionParameters}
 * @returns The transaction information. {@link GetTransactionReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getTransaction } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const transaction = await getTransaction(client, {
 *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
 * })
 */ parcelHelpers.export(exports, "getTransaction", ()=>getTransaction);
var _transactionJs = require("../../errors/transaction.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _transactionJs1 = require("../../utils/formatters/transaction.js");
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash, index }) {
    const blockTag = blockTag_ || 'latest';
    const blockNumberHex = blockNumber !== undefined ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
    let transaction = null;
    if (hash) transaction = await client.request({
        method: 'eth_getTransactionByHash',
        params: [
            hash
        ]
    }, {
        dedupe: true
    });
    else if (blockHash) transaction = await client.request({
        method: 'eth_getTransactionByBlockHashAndIndex',
        params: [
            blockHash,
            (0, _toHexJs.numberToHex)(index)
        ]
    }, {
        dedupe: true
    });
    else if (blockNumberHex || blockTag) transaction = await client.request({
        method: 'eth_getTransactionByBlockNumberAndIndex',
        params: [
            blockNumberHex || blockTag,
            (0, _toHexJs.numberToHex)(index)
        ]
    }, {
        dedupe: Boolean(blockNumberHex)
    });
    if (!transaction) throw new (0, _transactionJs.TransactionNotFoundError)({
        blockHash,
        blockNumber,
        blockTag,
        hash,
        index
    });
    const format = client.chain?.formatters?.transaction?.format || (0, _transactionJs1.formatTransaction);
    return format(transaction);
}

},{"../../errors/transaction.js":"4gFzr","../../utils/encoding/toHex.js":"9GFC6","../../utils/formatters/transaction.js":"dhAxe","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lgIAF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the number of blocks passed (confirmations) since the transaction was processed on a block.
 *
 * - Docs: https://viem.sh/docs/actions/public/getTransactionConfirmations
 * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions
 * - JSON-RPC Methods: [`eth_getTransactionConfirmations`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionConfirmations)
 *
 * @param client - Client to use
 * @param parameters - {@link GetTransactionConfirmationsParameters}
 * @returns The number of blocks passed since the transaction was processed. If confirmations is 0, then the Transaction has not been confirmed & processed yet. {@link GetTransactionConfirmationsReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getTransactionConfirmations } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const confirmations = await getTransactionConfirmations(client, {
 *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
 * })
 */ parcelHelpers.export(exports, "getTransactionConfirmations", ()=>getTransactionConfirmations);
var _getActionJs = require("../../utils/getAction.js");
var _getBlockNumberJs = require("./getBlockNumber.js");
var _getTransactionJs = require("./getTransaction.js");
async function getTransactionConfirmations(client, { hash, transactionReceipt }) {
    const [blockNumber, transaction] = await Promise.all([
        (0, _getActionJs.getAction)(client, (0, _getBlockNumberJs.getBlockNumber), 'getBlockNumber')({}),
        hash ? (0, _getActionJs.getAction)(client, (0, _getTransactionJs.getTransaction), 'getTransaction')({
            hash
        }) : undefined
    ]);
    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
    if (!transactionBlockNumber) return 0n;
    return blockNumber - transactionBlockNumber + 1n;
}

},{"../../utils/getAction.js":"d1Bvd","./getBlockNumber.js":"hY1Hu","./getTransaction.js":"lrruA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aEzFk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt) given a [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash.
 *
 * - Docs: https://viem.sh/docs/actions/public/getTransactionReceipt
 * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_fetching-transactions
 * - JSON-RPC Methods: [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionreceipt)
 *
 * @param client - Client to use
 * @param parameters - {@link GetTransactionReceiptParameters}
 * @returns The transaction receipt. {@link GetTransactionReceiptReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getTransactionReceipt } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const transactionReceipt = await getTransactionReceipt(client, {
 *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
 * })
 */ parcelHelpers.export(exports, "getTransactionReceipt", ()=>getTransactionReceipt);
var _transactionJs = require("../../errors/transaction.js");
var _transactionReceiptJs = require("../../utils/formatters/transactionReceipt.js");
async function getTransactionReceipt(client, { hash }) {
    const receipt = await client.request({
        method: 'eth_getTransactionReceipt',
        params: [
            hash
        ]
    }, {
        dedupe: true
    });
    if (!receipt) throw new (0, _transactionJs.TransactionReceiptNotFoundError)({
        hash
    });
    const format = client.chain?.formatters?.transactionReceipt?.format || (0, _transactionReceiptJs.formatTransactionReceipt);
    return format(receipt);
}

},{"../../errors/transaction.js":"4gFzr","../../utils/formatters/transactionReceipt.js":"1XqTn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7H0k4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Similar to [`readContract`](https://viem.sh/docs/contract/readContract), but batches up multiple functions on a contract in a single RPC call via the [`multicall3` contract](https://github.com/mds1/multicall).
 *
 * - Docs: https://viem.sh/docs/contract/multicall
 *
 * @param client - Client to use
 * @param parameters - {@link MulticallParameters}
 * @returns An array of results with accompanying status. {@link MulticallReturnType}
 *
 * @example
 * import { createPublicClient, http, parseAbi } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { multicall } from 'viem/contract'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const abi = parseAbi([
 *   'function balanceOf(address) view returns (uint256)',
 *   'function totalSupply() view returns (uint256)',
 * ])
 * const results = await multicall(client, {
 *   contracts: [
 *     {
 *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *       abi,
 *       functionName: 'balanceOf',
 *       args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
 *     },
 *     {
 *       address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
 *       abi,
 *       functionName: 'totalSupply',
 *     },
 *   ],
 * })
 * // [{ result: 424122n, status: 'success' }, { result: 1000000n, status: 'success' }]
 */ parcelHelpers.export(exports, "multicall", ()=>multicall);
var _abisJs = require("../../constants/abis.js");
var _abiJs = require("../../errors/abi.js");
var _baseJs = require("../../errors/base.js");
var _contractJs = require("../../errors/contract.js");
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _getChainContractAddressJs = require("../../utils/chain/getChainContractAddress.js");
var _getContractErrorJs = require("../../utils/errors/getContractError.js");
var _getActionJs = require("../../utils/getAction.js");
var _readContractJs = require("./readContract.js");
async function multicall(client, parameters) {
    const { account, allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, multicallAddress: multicallAddress_, stateOverride } = parameters;
    const contracts = parameters.contracts;
    const batchSize = batchSize_ ?? (typeof client.batch?.multicall === 'object' && client.batch.multicall.batchSize || 1024);
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
        if (!client.chain) throw new Error('client chain not configured. multicallAddress is required.');
        multicallAddress = (0, _getChainContractAddressJs.getChainContractAddress)({
            blockNumber,
            chain: client.chain,
            contract: 'multicall3'
        });
    }
    const chunkedCalls = [
        []
    ];
    let currentChunk = 0;
    let currentChunkSize = 0;
    for(let i = 0; i < contracts.length; i++){
        const { abi, address, args, functionName } = contracts[i];
        try {
            const callData = (0, _encodeFunctionDataJs.encodeFunctionData)({
                abi,
                args,
                functionName
            });
            currentChunkSize += (callData.length - 2) / 2;
            // Check to see if we need to create a new chunk.
            if (// Check if batching is enabled.
            batchSize > 0 && // Check if the current size of the batch exceeds the size limit.
            currentChunkSize > batchSize && // Check if the current chunk is not already empty.
            chunkedCalls[currentChunk].length > 0) {
                currentChunk++;
                currentChunkSize = (callData.length - 2) / 2;
                chunkedCalls[currentChunk] = [];
            }
            chunkedCalls[currentChunk] = [
                ...chunkedCalls[currentChunk],
                {
                    allowFailure: true,
                    callData,
                    target: address
                }
            ];
        } catch (err) {
            const error = (0, _getContractErrorJs.getContractError)(err, {
                abi,
                address,
                args,
                docsPath: '/docs/contract/multicall',
                functionName,
                sender: account
            });
            if (!allowFailure) throw error;
            chunkedCalls[currentChunk] = [
                ...chunkedCalls[currentChunk],
                {
                    allowFailure: true,
                    callData: '0x',
                    target: address
                }
            ];
        }
    }
    const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls)=>(0, _getActionJs.getAction)(client, (0, _readContractJs.readContract), 'readContract')({
            abi: (0, _abisJs.multicall3Abi),
            account,
            address: multicallAddress,
            args: [
                calls
            ],
            blockNumber,
            blockTag,
            functionName: 'aggregate3',
            stateOverride
        })));
    const results = [];
    for(let i = 0; i < aggregate3Results.length; i++){
        const result = aggregate3Results[i];
        // If an error occurred in a `readContract` invocation (ie. network error),
        // then append the failure reason to each contract result.
        if (result.status === 'rejected') {
            if (!allowFailure) throw result.reason;
            for(let j = 0; j < chunkedCalls[i].length; j++)results.push({
                status: 'failure',
                error: result.reason,
                result: undefined
            });
            continue;
        }
        // If the `readContract` call was successful, then decode the results.
        const aggregate3Result = result.value;
        for(let j = 0; j < aggregate3Result.length; j++){
            // Extract the response from `readContract`
            const { returnData, success } = aggregate3Result[j];
            // Extract the request call data from the original call.
            const { callData } = chunkedCalls[i][j];
            // Extract the contract config for this call from the `contracts` argument
            // for decoding.
            const { abi, address, functionName, args } = contracts[results.length];
            try {
                if (callData === '0x') throw new (0, _abiJs.AbiDecodingZeroDataError)();
                if (!success) throw new (0, _contractJs.RawContractError)({
                    data: returnData
                });
                const result = (0, _decodeFunctionResultJs.decodeFunctionResult)({
                    abi,
                    args,
                    data: returnData,
                    functionName
                });
                results.push(allowFailure ? {
                    result,
                    status: 'success'
                } : result);
            } catch (err) {
                const error = (0, _getContractErrorJs.getContractError)(err, {
                    abi,
                    address,
                    args,
                    docsPath: '/docs/contract/multicall',
                    functionName
                });
                if (!allowFailure) throw error;
                results.push({
                    error,
                    result: undefined,
                    status: 'failure'
                });
            }
        }
    }
    if (results.length !== contracts.length) throw new (0, _baseJs.BaseError)('multicall results mismatch');
    return results;
}

},{"../../constants/abis.js":"ffwQK","../../errors/abi.js":"7l8j7","../../errors/base.js":"3SEPF","../../errors/contract.js":"1S92K","../../utils/abi/decodeFunctionResult.js":"j76hM","../../utils/abi/encodeFunctionData.js":"eQLEb","../../utils/chain/getChainContractAddress.js":"cNh6w","../../utils/errors/getContractError.js":"kESZV","../../utils/getAction.js":"d1Bvd","./readContract.js":"fusIl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hwAPJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Simulates a set of calls on block(s) with optional block and state overrides.
 *
 * @example
 * ```ts
 * import { createClient, http, parseEther } from 'viem'
 * import { simulate } from 'viem/actions'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 *
 * const result = await simulate(client, {
 *   blocks: [{
 *     blockOverrides: {
 *       number: 69420n,
 *     },
 *     calls: [{
 *       {
 *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
 *         data: '0xdeadbeef',
 *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *       },
 *       {
 *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
 *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *         value: parseEther('1'),
 *       },
 *     }],
 *     stateOverrides: [{
 *       address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
 *       balance: parseEther('10'),
 *     }],
 *   }]
 * })
 * ```
 *
 * @param client - Client to use.
 * @param parameters - {@link SimulateBlocksParameters}
 * @returns Simulated blocks. {@link SimulateBlocksReturnType}
 */ parcelHelpers.export(exports, "simulateBlocks", ()=>simulateBlocks);
var _blockOverrides = require("ox/BlockOverrides");
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _abiJs = require("../../errors/abi.js");
var _contractJs = require("../../errors/contract.js");
var _nodeJs = require("../../errors/node.js");
var _decodeFunctionResultJs = require("../../utils/abi/decodeFunctionResult.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _getContractErrorJs = require("../../utils/errors/getContractError.js");
var _getNodeErrorJs = require("../../utils/errors/getNodeError.js");
var _blockJs = require("../../utils/formatters/block.js");
var _logJs = require("../../utils/formatters/log.js");
var _transactionRequestJs = require("../../utils/formatters/transactionRequest.js");
var _stateOverrideJs = require("../../utils/stateOverride.js");
var _assertRequestJs = require("../../utils/transaction/assertRequest.js");
async function simulateBlocks(client, parameters) {
    const { blockNumber, blockTag = 'pending', blocks, returnFullTransactions, traceTransfers, validation } = parameters;
    try {
        const blockStateCalls = [];
        for (const block of blocks){
            const blockOverrides = block.blockOverrides ? _blockOverrides.toRpc(block.blockOverrides) : undefined;
            const calls = block.calls.map((call_)=>{
                const call = call_;
                const account = call.account ? (0, _parseAccountJs.parseAccount)(call.account) : undefined;
                const request = {
                    ...call,
                    data: call.abi ? (0, _encodeFunctionDataJs.encodeFunctionData)(call) : call.data,
                    from: call.from ?? account?.address
                };
                (0, _assertRequestJs.assertRequest)(request);
                return (0, _transactionRequestJs.formatTransactionRequest)(request);
            });
            const stateOverrides = block.stateOverrides ? (0, _stateOverrideJs.serializeStateOverride)(block.stateOverrides) : undefined;
            blockStateCalls.push({
                blockOverrides,
                calls,
                stateOverrides
            });
        }
        const blockNumberHex = typeof blockNumber === 'bigint' ? (0, _toHexJs.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const result = await client.request({
            method: 'eth_simulateV1',
            params: [
                {
                    blockStateCalls,
                    returnFullTransactions,
                    traceTransfers,
                    validation
                },
                block
            ]
        });
        return result.map((block, i)=>({
                ...(0, _blockJs.formatBlock)(block),
                calls: block.calls.map((call, j)=>{
                    const { abi, args, functionName, to } = blocks[i].calls[j];
                    const data = call.error?.data ?? call.returnData;
                    const gasUsed = BigInt(call.gasUsed);
                    const logs = call.logs?.map((log)=>(0, _logJs.formatLog)(log));
                    const status = call.status === '0x1' ? 'success' : 'failure';
                    const result = abi && status === 'success' && data !== '0x' ? (0, _decodeFunctionResultJs.decodeFunctionResult)({
                        abi,
                        data,
                        functionName
                    }) : null;
                    const error = (()=>{
                        if (status === 'success') return undefined;
                        let error = undefined;
                        if (call.error?.data === '0x') error = new (0, _abiJs.AbiDecodingZeroDataError)();
                        else if (call.error) error = new (0, _contractJs.RawContractError)(call.error);
                        if (!error) return undefined;
                        return (0, _getContractErrorJs.getContractError)(error, {
                            abi: abi ?? [],
                            address: to,
                            args,
                            functionName: functionName ?? '<unknown>'
                        });
                    })();
                    return {
                        data,
                        gasUsed,
                        logs,
                        status,
                        ...status === 'success' ? {
                            result
                        } : {
                            error
                        }
                    };
                })
            }));
    } catch (e) {
        const cause = e;
        const error = (0, _getNodeErrorJs.getNodeError)(cause, {});
        if (error instanceof (0, _nodeJs.UnknownNodeError)) throw cause;
        throw error;
    }
}

},{"ox/BlockOverrides":"3pha1","../../accounts/utils/parseAccount.js":"lGQkg","../../errors/abi.js":"7l8j7","../../errors/contract.js":"1S92K","../../errors/node.js":"9Ytun","../../utils/abi/decodeFunctionResult.js":"j76hM","../../utils/abi/encodeFunctionData.js":"eQLEb","../../utils/encoding/toHex.js":"9GFC6","../../utils/errors/getContractError.js":"kESZV","../../utils/errors/getNodeError.js":"7Fxo9","../../utils/formatters/block.js":"kJKKG","../../utils/formatters/log.js":"aaYKq","../../utils/formatters/transactionRequest.js":"dLljr","../../utils/stateOverride.js":"zqcJp","../../utils/transaction/assertRequest.js":"eSiKr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gX7cN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Simulates execution of a batch of calls.
 *
 * @param client - Client to use
 * @param parameters - {@link SimulateCallsParameters}
 * @returns Results. {@link SimulateCallsReturnType}
 *
 * @example
 * ```ts
 * import { createPublicClient, http, parseEther } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { simulateCalls } from 'viem/actions'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 *
 * const result = await simulateCalls(client, {
 *   account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',
 *   calls: [{
 *     {
 *       data: '0xdeadbeef',
 *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *     },
 *     {
 *       to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *       value: parseEther('1'),
 *     },
 *   ]
 * })
 * ```
 */ parcelHelpers.export(exports, "simulateCalls", ()=>simulateCalls);
var _abiConstructor = require("ox/AbiConstructor");
var _abiFunction = require("ox/AbiFunction");
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _addressJs = require("../../constants/address.js");
var _contractsJs = require("../../constants/contracts.js");
var _baseJs = require("../../errors/base.js");
var _encodeFunctionDataJs = require("../../utils/abi/encodeFunctionData.js");
var _indexJs = require("../../utils/index.js");
var _createAccessListJs = require("./createAccessList.js");
var _simulateBlocksJs = require("./simulateBlocks.js");
const getBalanceCode = '0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033';
async function simulateCalls(client, parameters) {
    const { blockNumber, blockTag, calls, stateOverrides, traceAssetChanges, traceTransfers, validation } = parameters;
    const account = parameters.account ? (0, _parseAccountJs.parseAccount)(parameters.account) : undefined;
    if (traceAssetChanges && !account) throw new (0, _baseJs.BaseError)('`account` is required when `traceAssetChanges` is true');
    // Derive bytecode to extract ETH balance via a contract call.
    const getBalanceData = account ? _abiConstructor.encode(_abiConstructor.from('constructor(bytes, bytes)'), {
        bytecode: (0, _contractsJs.deploylessCallViaBytecodeBytecode),
        args: [
            getBalanceCode,
            _abiFunction.encodeData(_abiFunction.from('function getBalance(address)'), [
                account.address
            ])
        ]
    }) : undefined;
    // Fetch ERC20/721 addresses that were "touched" from the calls.
    const assetAddresses = traceAssetChanges ? await Promise.all(parameters.calls.map(async (call)=>{
        if (!call.data && !call.abi) return;
        const { accessList } = await (0, _createAccessListJs.createAccessList)(client, {
            account: account.address,
            ...call,
            data: call.abi ? (0, _encodeFunctionDataJs.encodeFunctionData)(call) : call.data
        });
        return accessList.map(({ address, storageKeys })=>storageKeys.length > 0 ? address : null);
    })).then((x)=>x.flat().filter(Boolean)) : [];
    const resultsStateOverrides = stateOverrides?.map((override)=>{
        if (override.address === account?.address) return {
            ...override,
            nonce: 0
        };
        return override;
    });
    const blocks = await (0, _simulateBlocksJs.simulateBlocks)(client, {
        blockNumber,
        blockTag: blockTag,
        blocks: [
            ...traceAssetChanges ? [
                // ETH pre balances
                {
                    calls: [
                        {
                            data: getBalanceData
                        }
                    ],
                    stateOverrides
                },
                // Asset pre balances
                {
                    calls: assetAddresses.map((address, i)=>({
                            abi: [
                                _abiFunction.from('function balanceOf(address) returns (uint256)')
                            ],
                            functionName: 'balanceOf',
                            args: [
                                account.address
                            ],
                            to: address,
                            from: (0, _addressJs.zeroAddress),
                            nonce: i
                        })),
                    stateOverrides: [
                        {
                            address: (0, _addressJs.zeroAddress),
                            nonce: 0
                        }
                    ]
                }
            ] : [],
            {
                calls: [
                    ...calls,
                    {}
                ].map((call, index)=>({
                        ...call,
                        from: account?.address,
                        nonce: index
                    })),
                stateOverrides: resultsStateOverrides
            },
            ...traceAssetChanges ? [
                // ETH post balances
                {
                    calls: [
                        {
                            data: getBalanceData
                        }
                    ]
                },
                // Asset post balances
                {
                    calls: assetAddresses.map((address, i)=>({
                            abi: [
                                _abiFunction.from('function balanceOf(address) returns (uint256)')
                            ],
                            functionName: 'balanceOf',
                            args: [
                                account.address
                            ],
                            to: address,
                            from: (0, _addressJs.zeroAddress),
                            nonce: i
                        })),
                    stateOverrides: [
                        {
                            address: (0, _addressJs.zeroAddress),
                            nonce: 0
                        }
                    ]
                },
                // Decimals
                {
                    calls: assetAddresses.map((address, i)=>({
                            to: address,
                            abi: [
                                _abiFunction.from('function decimals() returns (uint256)')
                            ],
                            functionName: 'decimals',
                            from: (0, _addressJs.zeroAddress),
                            nonce: i
                        })),
                    stateOverrides: [
                        {
                            address: (0, _addressJs.zeroAddress),
                            nonce: 0
                        }
                    ]
                },
                // Token URI
                {
                    calls: assetAddresses.map((address, i)=>({
                            to: address,
                            abi: [
                                _abiFunction.from('function tokenURI(uint256) returns (string)')
                            ],
                            functionName: 'tokenURI',
                            args: [
                                0n
                            ],
                            from: (0, _addressJs.zeroAddress),
                            nonce: i
                        })),
                    stateOverrides: [
                        {
                            address: (0, _addressJs.zeroAddress),
                            nonce: 0
                        }
                    ]
                },
                // Symbols
                {
                    calls: assetAddresses.map((address, i)=>({
                            to: address,
                            abi: [
                                _abiFunction.from('function symbol() returns (string)')
                            ],
                            functionName: 'symbol',
                            from: (0, _addressJs.zeroAddress),
                            nonce: i
                        })),
                    stateOverrides: [
                        {
                            address: (0, _addressJs.zeroAddress),
                            nonce: 0
                        }
                    ]
                }
            ] : []
        ],
        traceTransfers,
        validation
    });
    const block_results = traceAssetChanges ? blocks[2] : blocks[0];
    const [block_ethPre, block_assetsPre, , block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols] = traceAssetChanges ? blocks : [];
    // Extract call results from the simulation.
    const { calls: block_calls, ...block } = block_results;
    const results = block_calls.slice(0, -1) ?? [];
    // Extract pre-execution ETH and asset balances.
    const ethPre = block_ethPre?.calls ?? [];
    const assetsPre = block_assetsPre?.calls ?? [];
    const balancesPre = [
        ...ethPre,
        ...assetsPre
    ].map((call)=>call.status === 'success' ? (0, _indexJs.hexToBigInt)(call.data) : null);
    // Extract post-execution ETH and asset balances.
    const ethPost = block_ethPost?.calls ?? [];
    const assetsPost = block_assetsPost?.calls ?? [];
    const balancesPost = [
        ...ethPost,
        ...assetsPost
    ].map((call)=>call.status === 'success' ? (0, _indexJs.hexToBigInt)(call.data) : null);
    // Extract asset symbols & decimals.
    const decimals = (block_decimals?.calls ?? []).map((x)=>x.status === 'success' ? x.result : null);
    const symbols = (block_symbols?.calls ?? []).map((x)=>x.status === 'success' ? x.result : null);
    const tokenURI = (block_tokenURI?.calls ?? []).map((x)=>x.status === 'success' ? x.result : null);
    const changes = [];
    for (const [i, balancePost] of balancesPost.entries()){
        const balancePre = balancesPre[i];
        if (typeof balancePost !== 'bigint') continue;
        if (typeof balancePre !== 'bigint') continue;
        const decimals_ = decimals[i - 1];
        const symbol_ = symbols[i - 1];
        const tokenURI_ = tokenURI[i - 1];
        const token = (()=>{
            if (i === 0) return {
                address: (0, _addressJs.ethAddress),
                decimals: 18,
                symbol: 'ETH'
            };
            return {
                address: assetAddresses[i - 1],
                decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,
                symbol: symbol_ ?? undefined
            };
        })();
        if (changes.some((change)=>change.token.address === token.address)) continue;
        changes.push({
            token,
            value: {
                pre: balancePre,
                post: balancePost,
                diff: balancePost - balancePre
            }
        });
    }
    return {
        assetChanges: changes,
        block,
        results
    };
}

},{"ox/AbiConstructor":"dpZ7Y","ox/AbiFunction":"gaPHr","../../accounts/utils/parseAccount.js":"lGQkg","../../constants/address.js":"gjADG","../../constants/contracts.js":"3uCwC","../../errors/base.js":"3SEPF","../../utils/abi/encodeFunctionData.js":"eQLEb","../../utils/index.js":"ceNVN","./createAccessList.js":"gaOy9","./simulateBlocks.js":"hwAPJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dpZ7Y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "decode", ()=>decode);
/**
 * ABI-encodes the provided constructor input (`inputs`).
 *
 * @example
 * ```ts twoslash
 * import { AbiConstructor } from 'ox'
 *
 * const constructor = AbiConstructor.from('constructor(address, uint256)')
 *
 * const data = AbiConstructor.encode(constructor, {
 *   bytecode: '0x...',
 *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],
 * })
 * ```
 *
 * @example
 * ### End-to-end
 *
 * Below is an end-to-end example of using `AbiConstructor.encode` to encode the constructor of a contract and deploy it.
 *
 * ```ts twoslash
 * import 'ox/window'
 * import { AbiConstructor, Hex } from 'ox'
 *
 * // 1. Instantiate the ABI Constructor.
 * const constructor = AbiConstructor.from(
 *   'constructor(address owner, uint256 amount)',
 * )
 *
 * // 2. Encode the ABI Constructor.
 * const data = AbiConstructor.encode(constructor, {
 *   bytecode: '0x...',
 *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],
 * })
 *
 * // 3. Deploy the contract.
 * const hash = await window.ethereum!.request({
 *   method: 'eth_sendTransaction',
 *   params: [{ data }],
 * })
 * ```
 *
 * :::note
 *
 * For simplicity, the above example uses `window.ethereum.request`, but you can use any
 * type of JSON-RPC interface.
 *
 * :::
 *
 * @param abiConstructor - The ABI Constructor to encode.
 * @param options - Encoding options.
 * @returns The encoded constructor.
 */ parcelHelpers.export(exports, "encode", ()=>encode);
/** @internal */ parcelHelpers.export(exports, "format", ()=>format);
/** @internal */ parcelHelpers.export(exports, "from", ()=>from);
/** @internal */ parcelHelpers.export(exports, "fromAbi", ()=>fromAbi);
var _abitype = require("abitype");
var _abiItemJs = require("./AbiItem.js");
var _abiParametersJs = require("./AbiParameters.js");
var _hexJs = require("./Hex.js");
function decode(abiConstructor, options) {
    const { bytecode } = options;
    if (abiConstructor.inputs.length === 0) return undefined;
    const data = options.data.replace(bytecode, '0x');
    return _abiParametersJs.decode(abiConstructor.inputs, data);
}
function encode(abiConstructor, options) {
    const { bytecode, args } = options;
    return _hexJs.concat(bytecode, abiConstructor.inputs?.length && args?.length ? _abiParametersJs.encode(abiConstructor.inputs, args) : '0x');
}
function format(abiConstructor) {
    return _abitype.formatAbiItem(abiConstructor);
}
function from(abiConstructor) {
    return _abiItemJs.from(abiConstructor);
}
function fromAbi(abi) {
    const item = abi.find((item)=>item.type === 'constructor');
    if (!item) throw new _abiItemJs.NotFoundError({
        name: 'constructor'
    });
    return item;
}

},{"abitype":"6tgJn","./AbiItem.js":"eEoef","./AbiParameters.js":"7FDSM","./Hex.js":"bkNyt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eEoef":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.
 *
 * @example
 * ```ts twoslash
 * import { AbiItem } from 'ox'
 *
 * const formatted = AbiItem.format({
 *   type: 'function',
 *   name: 'approve',
 *   stateMutability: 'nonpayable',
 *   inputs: [
 *     {
 *       name: 'spender',
 *       type: 'address',
 *     },
 *     {
 *       name: 'amount',
 *       type: 'uint256',
 *     },
 *   ],
 *   outputs: [{ type: 'bool' }],
 * })
 *
 * formatted
 * //    ^?
 *
 *
 * ```
 *
 * @param abiItem - The ABI Item to format.
 * @returns The formatted ABI Item  .
 */ parcelHelpers.export(exports, "format", ()=>format);
/**
 * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.
 *
 * @example
 * ### JSON ABIs
 *
 * ```ts twoslash
 * import { AbiItem } from 'ox'
 *
 * const abiItem = AbiItem.from({
 *   type: 'function',
 *   name: 'approve',
 *   stateMutability: 'nonpayable',
 *   inputs: [
 *     {
 *       name: 'spender',
 *       type: 'address',
 *     },
 *     {
 *       name: 'amount',
 *       type: 'uint256',
 *     },
 *   ],
 *   outputs: [{ type: 'bool' }],
 * })
 *
 * abiItem
 * //^?
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * ```
 *
 * @example
 * ### Human Readable ABIs
 *
 * A Human Readable ABI can be parsed into a typed ABI object:
 *
 * ```ts twoslash
 * import { AbiItem } from 'ox'
 *
 * const abiItem = AbiItem.from(
 *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]
 * )
 *
 * abiItem
 * //^?
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * ```
 *
 * @example
 * It is possible to specify `struct`s along with your definitions:
 *
 * ```ts twoslash
 * import { AbiItem } from 'ox'
 *
 * const abiItem = AbiItem.from([
 *   'struct Foo { address spender; uint256 amount; }', // [!code hl]
 *   'function approve(Foo foo) returns (bool)',
 * ])
 *
 * abiItem
 * //^?
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * ```
 *
 *
 *
 * @param abiItem - The ABI Item to parse.
 * @returns The typed ABI Item.
 */ parcelHelpers.export(exports, "from", ()=>from);
/**
 * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.
 *
 * @example
 * ABI Items can be extracted by their name using the `name` option:
 *
 * ```ts twoslash
 * import { Abi, AbiItem } from 'ox'
 *
 * const abi = Abi.from([
 *   'function foo()',
 *   'event Transfer(address owner, address to, uint256 tokenId)',
 *   'function bar(string a) returns (uint256 x)',
 * ])
 *
 * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]
 * //    ^?
 *
 *
 *
 *
 *
 *
 * ```
 *
 * @example
 * ### Extracting by Selector
 *
 * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.
 *
 * ```ts twoslash
 * import { Abi, AbiItem } from 'ox'
 *
 * const abi = Abi.from([
 *   'function foo()',
 *   'event Transfer(address owner, address to, uint256 tokenId)',
 *   'function bar(string a) returns (uint256 x)',
 * ])
 * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]
 * //    ^?
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * ```
 *
 * :::note
 *
 * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,
 * a Transaction `input`, or from Event Log `topics`.
 *
 * :::
 *
 * @param abi - The ABI to extract from.
 * @param name - The name (or selector) of the ABI item to extract.
 * @param options - Extraction options.
 * @returns The ABI item.
 */ parcelHelpers.export(exports, "fromAbi", ()=>fromAbi);
/**
 * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiItem.AbiItem}.
 *
 * Useful for computing function selectors for calldata.
 *
 * @example
 * ```ts twoslash
 * import { AbiItem } from 'ox'
 *
 * const selector = AbiItem.getSelector('function ownerOf(uint256 tokenId)')
 * // @log: '0x6352211e'
 * ```
 *
 * @example
 * ```ts twoslash
 * import { AbiItem } from 'ox'
 *
 * const selector = AbiItem.getSelector({
 *   inputs: [{ type: 'uint256' }],
 *   name: 'ownerOf',
 *   outputs: [],
 *   stateMutability: 'view',
 *   type: 'function'
 * })
 * // @log: '0x6352211e'
 * ```
 *
 * @param abiItem - The ABI item to compute the selector for. Can be a signature or an ABI item for an error, event, function, etc.
 * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.
 */ parcelHelpers.export(exports, "getSelector", ()=>getSelector);
/**
 * Computes the stringified signature for a given {@link ox#AbiItem.AbiItem}.
 *
 * @example
 * ```ts twoslash
 * import { AbiItem } from 'ox'
 *
 * const signature = AbiItem.getSignature('function ownerOf(uint256 tokenId)')
 * // @log: 'ownerOf(uint256)'
 * ```
 *
 * @example
 * ```ts twoslash
 * import { AbiItem } from 'ox'
 *
 * const signature = AbiItem.getSignature({
 *   name: 'ownerOf',
 *   type: 'function',
 *   inputs: [{ name: 'tokenId', type: 'uint256' }],
 *   outputs: [],
 *   stateMutability: 'view',
 * })
 * // @log: 'ownerOf(uint256)'
 * ```
 *
 * @param abiItem - The ABI Item to compute the signature for.
 * @returns The stringified signature of the ABI Item.
 */ parcelHelpers.export(exports, "getSignature", ()=>getSignature);
/**
 * Computes the signature hash for an {@link ox#AbiItem.AbiItem}.
 *
 * Useful for computing Event Topic values.
 *
 * @example
 * ```ts twoslash
 * import { AbiItem } from 'ox'
 *
 * const hash = AbiItem.getSignatureHash('event Transfer(address indexed from, address indexed to, uint256 amount)')
 * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'
 * ```
 *
 * @example
 * ```ts twoslash
 * import { AbiItem } from 'ox'
 *
 * const hash = AbiItem.getSignatureHash({
 *   name: 'Transfer',
 *   type: 'event',
 *   inputs: [
 *     { name: 'from', type: 'address', indexed: true },
 *     { name: 'to', type: 'address', indexed: true },
 *     { name: 'amount', type: 'uint256', indexed: false },
 *   ],
 * })
 * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'
 * ```
 *
 * @param abiItem - The ABI Item to compute the signature hash for.
 * @returns The {@link ox#Hash.(keccak256:function)} hash of the ABI item's signature.
 */ parcelHelpers.export(exports, "getSignatureHash", ()=>getSignatureHash);
/**
 * Throws when ambiguous types are found on overloaded ABI items.
 *
 * @example
 * ```ts twoslash
 * import { Abi, AbiFunction } from 'ox'
 *
 * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])
 * AbiFunction.fromAbi(foo, 'foo', {
 *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
 * })
 * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.
 * // @error: `bytes20` in `foo(bytes20)`, and
 * // @error: `address` in `foo(address)`
 * // @error: These types encode differently and cannot be distinguished at runtime.
 * // @error: Remove one of the ambiguous items in the ABI.
 * ```
 *
 * ### Solution
 *
 * Remove one of the ambiguous types from the ABI.
 *
 * ```ts twoslash
 * import { Abi, AbiFunction } from 'ox'
 *
 * const foo = Abi.from([
 *   'function foo(address)',
 *   'function foo(bytes20)' // [!code --]
 * ])
 * AbiFunction.fromAbi(foo, 'foo', {
 *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],
 * })
 * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.
 * // @error: `bytes20` in `foo(bytes20)`, and
 * // @error: `address` in `foo(address)`
 * // @error: These types encode differently and cannot be distinguished at runtime.
 * // @error: Remove one of the ambiguous items in the ABI.
 * ```
 */ parcelHelpers.export(exports, "AmbiguityError", ()=>AmbiguityError);
/**
 * Throws when an ABI item is not found in the ABI.
 *
 * @example
 * ```ts twoslash
 * // @noErrors
 * import { Abi, AbiFunction } from 'ox'
 *
 * const foo = Abi.from([
 *   'function foo(address)',
 *   'function bar(uint)'
 * ])
 * AbiFunction.fromAbi(foo, 'baz')
 * // @error: AbiItem.NotFoundError: ABI function with name "baz" not found.
 * ```
 *
 * ### Solution
 *
 * Ensure the ABI item exists on the ABI.
 *
 * ```ts twoslash
 * // @noErrors
 * import { Abi, AbiFunction } from 'ox'
 *
 * const foo = Abi.from([
 *   'function foo(address)',
 *   'function bar(uint)',
 *   'function baz(bool)' // [!code ++]
 * ])
 * AbiFunction.fromAbi(foo, 'baz')
 * ```
 */ parcelHelpers.export(exports, "NotFoundError", ()=>NotFoundError);
/**
 * Throws when the selector size is invalid.
 *
 * @example
 * ```ts twoslash
 * import { Abi, AbiFunction } from 'ox'
 *
 * const foo = Abi.from([
 *   'function foo(address)',
 *   'function bar(uint)'
 * ])
 * AbiFunction.fromAbi(foo, '0xaaa')
 * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes ("0xaaa").
 * ```
 *
 * ### Solution
 *
 * Ensure the selector size is 4 bytes.
 *
 * ```ts twoslash
 * // @noErrors
 * import { Abi, AbiFunction } from 'ox'
 *
 * const foo = Abi.from([
 *   'function foo(address)',
 *   'function bar(uint)'
 * ])
 * AbiFunction.fromAbi(foo, '0x7af82b1a')
 * ```
 */ parcelHelpers.export(exports, "InvalidSelectorSizeError", ()=>InvalidSelectorSizeError);
var _abitype = require("abitype");
var _errorsJs = require("./Errors.js");
var _hashJs = require("./Hash.js");
var _hexJs = require("./Hex.js");
var _abiItemJs = require("./internal/abiItem.js");
function format(abiItem) {
    return _abitype.formatAbiItem(abiItem);
}
function from(abiItem, options = {}) {
    const { prepare = true } = options;
    const item = (()=>{
        if (Array.isArray(abiItem)) return _abitype.parseAbiItem(abiItem);
        if (typeof abiItem === 'string') return _abitype.parseAbiItem(abiItem);
        return abiItem;
    })();
    return {
        ...item,
        ...prepare ? {
            hash: getSignatureHash(item)
        } : {}
    };
}
function fromAbi(abi, name, options) {
    const { args = [], prepare = true } = options ?? {};
    const isSelector = _hexJs.validate(name, {
        strict: false
    });
    const abiItems = abi.filter((abiItem)=>{
        if (isSelector) {
            if (abiItem.type === 'function' || abiItem.type === 'error') return getSelector(abiItem) === _hexJs.slice(name, 0, 4);
            if (abiItem.type === 'event') return getSignatureHash(abiItem) === name;
            return false;
        }
        return 'name' in abiItem && abiItem.name === name;
    });
    if (abiItems.length === 0) throw new NotFoundError({
        name: name
    });
    if (abiItems.length === 1) return {
        ...abiItems[0],
        ...prepare ? {
            hash: getSignatureHash(abiItems[0])
        } : {}
    };
    let matchedAbiItem = undefined;
    for (const abiItem of abiItems){
        if (!('inputs' in abiItem)) continue;
        if (!args || args.length === 0) {
            if (!abiItem.inputs || abiItem.inputs.length === 0) return {
                ...abiItem,
                ...prepare ? {
                    hash: getSignatureHash(abiItem)
                } : {}
            };
            continue;
        }
        if (!abiItem.inputs) continue;
        if (abiItem.inputs.length === 0) continue;
        if (abiItem.inputs.length !== args.length) continue;
        const matched = args.every((arg, index)=>{
            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];
            if (!abiParameter) return false;
            return _abiItemJs.isArgOfType(arg, abiParameter);
        });
        if (matched) {
            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).
            if (matchedAbiItem && 'inputs' in matchedAbiItem && matchedAbiItem.inputs) {
                const ambiguousTypes = _abiItemJs.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
                if (ambiguousTypes) throw new AmbiguityError({
                    abiItem,
                    type: ambiguousTypes[0]
                }, {
                    abiItem: matchedAbiItem,
                    type: ambiguousTypes[1]
                });
            }
            matchedAbiItem = abiItem;
        }
    }
    const abiItem = (()=>{
        if (matchedAbiItem) return matchedAbiItem;
        const [abiItem, ...overloads] = abiItems;
        return {
            ...abiItem,
            overloads
        };
    })();
    if (!abiItem) throw new NotFoundError({
        name: name
    });
    return {
        ...abiItem,
        ...prepare ? {
            hash: getSignatureHash(abiItem)
        } : {}
    };
}
function getSelector(abiItem) {
    return _hexJs.slice(getSignatureHash(abiItem), 0, 4);
}
function getSignature(abiItem) {
    const signature = (()=>{
        if (typeof abiItem === 'string') return abiItem;
        return _abitype.formatAbiItem(abiItem);
    })();
    return _abiItemJs.normalizeSignature(signature);
}
function getSignatureHash(abiItem) {
    if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash) return abiItem.hash;
    return _hashJs.keccak256(_hexJs.fromString(getSignature(abiItem)));
}
class AmbiguityError extends _errorsJs.BaseError {
    constructor(x, y){
        super('Found ambiguous types in overloaded ABI Items.', {
            metaMessages: [
                // TODO: abitype to add support for signature-formatted ABI items.
                `\`${x.type}\` in \`${_abiItemJs.normalizeSignature(_abitype.formatAbiItem(x.abiItem))}\`, and`,
                `\`${y.type}\` in \`${_abiItemJs.normalizeSignature(_abitype.formatAbiItem(y.abiItem))}\``,
                '',
                'These types encode differently and cannot be distinguished at runtime.',
                'Remove one of the ambiguous items in the ABI.'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiItem.AmbiguityError'
        });
    }
}
class NotFoundError extends _errorsJs.BaseError {
    constructor({ name, data, type = 'item' }){
        const selector = (()=>{
            if (name) return ` with name "${name}"`;
            if (data) return ` with data "${data}"`;
            return '';
        })();
        super(`ABI ${type}${selector} not found.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiItem.NotFoundError'
        });
    }
}
class InvalidSelectorSizeError extends _errorsJs.BaseError {
    constructor({ data }){
        super(`Selector size is invalid. Expected 4 bytes. Received ${_hexJs.size(data)} bytes ("${data}").`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiItem.InvalidSelectorSizeError'
        });
    }
}

},{"abitype":"6tgJn","./Errors.js":"d3pbB","./Hash.js":"iYOoa","./Hex.js":"bkNyt","./internal/abiItem.js":"codBy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iYOoa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.
 *
 * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.
 *
 * @example
 * ```ts twoslash
 * import { Hash } from 'ox'
 *
 * Hash.keccak256('0xdeadbeef')
 * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'
 * ```
 *
 * @example
 * ### Calculate Hash of a String
 *
 * ```ts twoslash
 * import { Hash, Hex } from 'ox'
 *
 * Hash.keccak256(Hex.fromString('hello world'))
 * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'
 * ```
 *
 * @example
 * ### Configure Return Type
 *
 * ```ts twoslash
 * import { Hash } from 'ox'
 *
 * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })
 * // @log: Uint8Array [...]
 * ```
 *
 * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.
 * @param options - Options.
 * @returns Keccak256 hash.
 */ parcelHelpers.export(exports, "keccak256", ()=>keccak256);
/**
 * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.
 *
 * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.
 *
 * @example
 * ```ts twoslash
 * import { Hash } from 'ox'
 *
 * Hash.ripemd160('0xdeadbeef')
 * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'
 * ```
 *
 * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.
 * @param options - Options.
 * @returns Ripemd160 hash.
 */ parcelHelpers.export(exports, "ripemd160", ()=>ripemd160);
/**
 * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.
 *
 * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.
 *
 * @example
 * ```ts twoslash
 * import { Hash } from 'ox'
 *
 * Hash.sha256('0xdeadbeef')
 * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'
 * ```
 *
 * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.
 * @param options - Options.
 * @returns Sha256 hash.
 */ parcelHelpers.export(exports, "sha256", ()=>sha256);
/**
 * Checks if a string is a valid hash value.
 *
 * @example
 * ```ts twoslash
 * import { Hash } from 'ox'
 *
 * Hash.validate('0x')
 * // @log: false
 *
 * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')
 * // @log: true
 * ```
 *
 * @param value - Value to check.
 * @returns Whether the value is a valid hash.
 */ parcelHelpers.export(exports, "validate", ()=>validate);
var _ripemd160 = require("@noble/hashes/ripemd160");
var _sha3 = require("@noble/hashes/sha3");
var _sha256 = require("@noble/hashes/sha256");
var _bytesJs = require("./Bytes.js");
var _hexJs = require("./Hex.js");
function keccak256(value, options = {}) {
    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;
    const bytes = (0, _sha3.keccak_256)(_bytesJs.from(value));
    if (as === 'Bytes') return bytes;
    return _hexJs.fromBytes(bytes);
}
function ripemd160(value, options = {}) {
    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;
    const bytes = (0, _ripemd160.ripemd160)(_bytesJs.from(value));
    if (as === 'Bytes') return bytes;
    return _hexJs.fromBytes(bytes);
}
function sha256(value, options = {}) {
    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;
    const bytes = (0, _sha256.sha256)(_bytesJs.from(value));
    if (as === 'Bytes') return bytes;
    return _hexJs.fromBytes(bytes);
}
function validate(value) {
    return _hexJs.validate(value) && _hexJs.size(value) === 32;
}

},{"@noble/hashes/ripemd160":"h7MUX","@noble/hashes/sha3":"by5a3","@noble/hashes/sha256":"h9cuS","./Bytes.js":"grkDP","./Hex.js":"bkNyt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"codBy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "normalizeSignature", ()=>normalizeSignature);
/** @internal */ parcelHelpers.export(exports, "isArgOfType", ()=>isArgOfType);
/** @internal */ parcelHelpers.export(exports, "getAmbiguousTypes", ()=>getAmbiguousTypes);
var _addressJs = require("../Address.js");
var _errorsJs = require("../Errors.js");
function normalizeSignature(signature) {
    let active = true;
    let current = '';
    let level = 0;
    let result = '';
    let valid = false;
    for(let i = 0; i < signature.length; i++){
        const char = signature[i];
        // If the character is a separator, we want to reactivate.
        if ([
            '(',
            ')',
            ','
        ].includes(char)) active = true;
        // If the character is a "level" token, we want to increment/decrement.
        if (char === '(') level++;
        if (char === ')') level--;
        // If we aren't active, we don't want to mutate the result.
        if (!active) continue;
        // If level === 0, we are at the definition level.
        if (level === 0) {
            if (char === ' ' && [
                'event',
                'function',
                'error',
                ''
            ].includes(result)) result = '';
            else {
                result += char;
                // If we are at the end of the definition, we must be finished.
                if (char === ')') {
                    valid = true;
                    break;
                }
            }
            continue;
        }
        // Ignore spaces
        if (char === ' ') {
            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.
            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {
                current = '';
                active = false;
            }
            continue;
        }
        result += char;
        current += char;
    }
    if (!valid) throw new _errorsJs.BaseError('Unable to normalize signature.');
    return result;
}
function isArgOfType(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch(abiParameterType){
        case 'address':
            return _addressJs.validate(arg, {
                strict: false
            });
        case 'bool':
            return argType === 'boolean';
        case 'function':
            return argType === 'string';
        case 'string':
            return argType === 'string';
        default:
            if (abiParameterType === 'tuple' && 'components' in abiParameter) return Object.values(abiParameter.components).every((component, index)=>{
                return isArgOfType(Object.values(arg)[index], component);
            });
            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`
            // https://regexr.com/6v8hp
            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType)) return argType === 'number' || argType === 'bigint';
            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`
            // https://regexr.com/6va55
            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType)) return argType === 'string' || arg instanceof Uint8Array;
            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays
            // https://regexr.com/6va6i
            if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) return Array.isArray(arg) && arg.every((x)=>isArgOfType(x, {
                    ...abiParameter,
                    // Pop off `[]` or `[M]` from end of type
                    type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, '')
                }));
            return false;
    }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
    for(const parameterIndex in sourceParameters){
        const sourceParameter = sourceParameters[parameterIndex];
        const targetParameter = targetParameters[parameterIndex];
        if (sourceParameter.type === 'tuple' && targetParameter.type === 'tuple' && 'components' in sourceParameter && 'components' in targetParameter) return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
        const types = [
            sourceParameter.type,
            targetParameter.type
        ];
        const ambiguous = (()=>{
            if (types.includes('address') && types.includes('bytes20')) return true;
            if (types.includes('address') && types.includes('string')) return _addressJs.validate(args[parameterIndex], {
                strict: false
            });
            if (types.includes('address') && types.includes('bytes')) return _addressJs.validate(args[parameterIndex], {
                strict: false
            });
            return false;
        })();
        if (ambiguous) return types;
    }
    return;
}

},{"../Address.js":"2a10M","../Errors.js":"d3pbB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2a10M":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Asserts that the given value is a valid {@link ox#Address.Address}.
 *
 * @example
 * ```ts twoslash
 * import { Address } from 'ox'
 *
 * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')
 * ```
 *
 * @example
 * ```ts twoslash
 * import { Address } from 'ox'
 *
 * Address.assert('0xdeadbeef')
 * // @error: InvalidAddressError: Address "0xdeadbeef" is invalid.
 * ```
 *
 * @param value - Value to assert if it is a valid address.
 * @param options - Assertion options.
 */ parcelHelpers.export(exports, "assert", ()=>assert);
/**
 * Computes the checksum address for the given {@link ox#Address.Address}.
 *
 * @example
 * ```ts twoslash
 * import { Address } from 'ox'
 *
 * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')
 * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'
 * ```
 *
 * @param address - The address to compute the checksum for.
 * @returns The checksummed address.
 */ parcelHelpers.export(exports, "checksum", ()=>checksum);
/**
 * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.
 *
 * @example
 * ```ts twoslash
 * import { Address } from 'ox'
 *
 * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')
 * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'
 * ```
 *
 * @example
 * ```ts twoslash
 * import { Address } from 'ox'
 *
 * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {
 *   checksum: false
 * })
 * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'
 * ```
 *
 * @example
 * ```ts twoslash
 * import { Address } from 'ox'
 *
 * Address.from('hello')
 * // @error: InvalidAddressError: Address "0xa" is invalid.
 * ```
 *
 * @param address - An address string to convert to a typed Address.
 * @param options - Conversion options.
 * @returns The typed Address.
 */ parcelHelpers.export(exports, "from", ()=>from);
/**
 * Converts an ECDSA public key to an {@link ox#Address.Address}.
 *
 * @example
 * ```ts twoslash
 * import { Address, PublicKey } from 'ox'
 *
 * const publicKey = PublicKey.from(
 *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',
 * )
 * const address = Address.fromPublicKey(publicKey)
 * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'
 * ```
 *
 * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.
 * @param options - Conversion options.
 * @returns The {@link ox#Address.Address} corresponding to the public key.
 */ parcelHelpers.export(exports, "fromPublicKey", ()=>fromPublicKey);
/**
 * Checks if two {@link ox#Address.Address} are equal.
 *
 * @example
 * ```ts twoslash
 * import { Address } from 'ox'
 *
 * Address.isEqual(
 *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
 *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'
 * )
 * // @log: true
 * ```
 *
 * @example
 * ```ts twoslash
 * import { Address } from 'ox'
 *
 * Address.isEqual(
 *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',
 *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'
 * )
 * // @log: false
 * ```
 *
 * @param addressA - The first address to compare.
 * @param addressB - The second address to compare.
 * @returns Whether the addresses are equal.
 */ parcelHelpers.export(exports, "isEqual", ()=>isEqual);
/**
 * Checks if the given address is a valid {@link ox#Address.Address}.
 *
 * @example
 * ```ts twoslash
 * import { Address } from 'ox'
 *
 * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')
 * // @log: true
 * ```
 *
 * @example
 * ```ts twoslash
 * import { Address } from 'ox'
 *
 * Address.validate('0xdeadbeef')
 * // @log: false
 * ```
 *
 * @param address - Value to check if it is a valid address.
 * @param options - Check options.
 * @returns Whether the address is a valid address.
 */ parcelHelpers.export(exports, "validate", ()=>validate);
/**
 * Thrown when an address is invalid.
 *
 * @example
 * ```ts twoslash
 * import { Address } from 'ox'
 *
 * Address.from('0x123')
 * // @error: Address.InvalidAddressError: Address `0x123` is invalid.
 * ```
 */ parcelHelpers.export(exports, "InvalidAddressError", ()=>InvalidAddressError);
/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */ parcelHelpers.export(exports, "InvalidInputError", ()=>InvalidInputError);
/** Thrown when an address does not match its checksum counterpart. */ parcelHelpers.export(exports, "InvalidChecksumError", ()=>InvalidChecksumError);
var _bytesJs = require("./Bytes.js");
var _cachesJs = require("./Caches.js");
var _errorsJs = require("./Errors.js");
var _hashJs = require("./Hash.js");
var _publicKeyJs = require("./PublicKey.js");
const addressRegex = /*#__PURE__*/ /^0x[a-fA-F0-9]{40}$/;
function assert(value, options = {}) {
    const { strict = true } = options;
    if (!addressRegex.test(value)) throw new InvalidAddressError({
        address: value,
        cause: new InvalidInputError()
    });
    if (strict) {
        if (value.toLowerCase() === value) return;
        if (checksum(value) !== value) throw new InvalidAddressError({
            address: value,
            cause: new InvalidChecksumError()
        });
    }
}
function checksum(address) {
    if (_cachesJs.checksum.has(address)) return _cachesJs.checksum.get(address);
    assert(address, {
        strict: false
    });
    const hexAddress = address.substring(2).toLowerCase();
    const hash = _hashJs.keccak256(_bytesJs.fromString(hexAddress), {
        as: 'Bytes'
    });
    const characters = hexAddress.split('');
    for(let i = 0; i < 40; i += 2){
        if (hash[i >> 1] >> 4 >= 8 && characters[i]) characters[i] = characters[i].toUpperCase();
        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) characters[i + 1] = characters[i + 1].toUpperCase();
    }
    const result = `0x${characters.join('')}`;
    _cachesJs.checksum.set(address, result);
    return result;
}
function from(address, options = {}) {
    const { checksum: checksumVal = false } = options;
    assert(address);
    if (checksumVal) return checksum(address);
    return address;
}
function fromPublicKey(publicKey, options = {}) {
    const address = _hashJs.keccak256(`0x${_publicKeyJs.toHex(publicKey).slice(4)}`).substring(26);
    return from(`0x${address}`, options);
}
function isEqual(addressA, addressB) {
    assert(addressA, {
        strict: false
    });
    assert(addressB, {
        strict: false
    });
    return addressA.toLowerCase() === addressB.toLowerCase();
}
function validate(address, options = {}) {
    const { strict = true } = options ?? {};
    try {
        assert(address, {
            strict
        });
        return true;
    } catch  {
        return false;
    }
}
class InvalidAddressError extends _errorsJs.BaseError {
    constructor({ address, cause }){
        super(`Address "${address}" is invalid.`, {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Address.InvalidAddressError'
        });
    }
}
class InvalidInputError extends _errorsJs.BaseError {
    constructor(){
        super('Address is not a 20 byte (40 hexadecimal character) value.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Address.InvalidInputError'
        });
    }
}
class InvalidChecksumError extends _errorsJs.BaseError {
    constructor(){
        super('Address does not match its checksum counterpart.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Address.InvalidChecksumError'
        });
    }
}

},{"./Bytes.js":"grkDP","./Caches.js":"eGsMZ","./Errors.js":"d3pbB","./Hash.js":"iYOoa","./PublicKey.js":"hThDl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eGsMZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checksum", ()=>checksum);
/**
 * Clears all global caches.
 *
 * @example
 * ```ts
 * import { Caches } from 'ox'
 * Caches.clear()
 * ```
 */ parcelHelpers.export(exports, "clear", ()=>clear);
var _lruJs = require("./internal/lru.js");
const caches = {
    checksum: /*#__PURE__*/ new (0, _lruJs.LruMap)(8192)
};
const checksum = caches.checksum;
function clear() {
    for (const cache of Object.values(caches))cache.clear();
}

},{"./internal/lru.js":"3Mk8A","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3Mk8A":[function(require,module,exports,__globalThis) {
/**
 * @internal
 *
 * Map with a LRU (Least recently used) policy.
 * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LruMap", ()=>LruMap);
class LruMap extends Map {
    constructor(size){
        super();
        Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.maxSize = size;
    }
    get(key) {
        const value = super.get(key);
        if (super.has(key) && value !== undefined) {
            this.delete(key);
            super.set(key, value);
        }
        return value;
    }
    set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize) {
            const firstKey = this.keys().next().value;
            if (firstKey) this.delete(firstKey);
        }
        return this;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hThDl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Asserts that a {@link ox#PublicKey.PublicKey} is valid.
 *
 * @example
 * ```ts twoslash
 * import { PublicKey } from 'ox'
 *
 * PublicKey.assert({
 *   prefix: 4,
 *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,
 * })
 * // @error: PublicKey.InvalidError: Value \`{"y":"1"}\` is not a valid public key.
 * // @error: Public key must contain:
 * // @error: - an `x` and `prefix` value (compressed)
 * // @error: - an `x`, `y`, and `prefix` value (uncompressed)
 * ```
 *
 * @param publicKey - The public key object to assert.
 */ parcelHelpers.export(exports, "assert", ()=>assert);
/**
 * Compresses a {@link ox#PublicKey.PublicKey}.
 *
 * @example
 * ```ts twoslash
 * import { PublicKey } from 'ox'
 *
 * const publicKey = PublicKey.from({
 *   prefix: 4,
 *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,
 *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,
 * })
 *
 * const compressed = PublicKey.compress(publicKey) // [!code focus]
 * // @log: {
 * // @log:   prefix: 3,
 * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,
 * // @log: }
 * ```
 *
 * @param publicKey - The public key to compress.
 * @returns The compressed public key.
 */ parcelHelpers.export(exports, "compress", ()=>compress);
/**
 * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.
 *
 * @example
 * ```ts twoslash
 * import { PublicKey } from 'ox'
 *
 * const publicKey = PublicKey.from({
 *   prefix: 4,
 *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,
 *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,
 * })
 * // @log: {
 * // @log:   prefix: 4,
 * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,
 * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,
 * // @log: }
 * ```
 *
 * @example
 * ### From Serialized
 *
 * ```ts twoslash
 * import { PublicKey } from 'ox'
 *
 * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')
 * // @log: {
 * // @log:   prefix: 4,
 * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,
 * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,
 * // @log: }
 * ```
 *
 * @param value - The public key value to instantiate.
 * @returns The instantiated {@link ox#PublicKey.PublicKey}.
 */ parcelHelpers.export(exports, "from", ()=>from);
/**
 * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.
 *
 * @example
 * ```ts twoslash
 * // @noErrors
 * import { PublicKey } from 'ox'
 *
 * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))
 * // @log: {
 * // @log:   prefix: 4,
 * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,
 * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,
 * // @log: }
 * ```
 *
 * @param publicKey - The serialized public key.
 * @returns The deserialized public key.
 */ parcelHelpers.export(exports, "fromBytes", ()=>fromBytes);
/**
 * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.
 *
 * @example
 * ```ts twoslash
 * import { PublicKey } from 'ox'
 *
 * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')
 * // @log: {
 * // @log:   prefix: 4,
 * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,
 * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,
 * // @log: }
 * ```
 *
 * @example
 * ### Deserializing a Compressed Public Key
 *
 * ```ts twoslash
 * import { PublicKey } from 'ox'
 *
 * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')
 * // @log: {
 * // @log:   prefix: 3,
 * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,
 * // @log: }
 * ```
 *
 * @param publicKey - The serialized public key.
 * @returns The deserialized public key.
 */ parcelHelpers.export(exports, "fromHex", ()=>fromHex);
/**
 * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.
 *
 * @example
 * ```ts twoslash
 * import { PublicKey } from 'ox'
 *
 * const publicKey = PublicKey.from({
 *   prefix: 4,
 *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,
 *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,
 * })
 *
 * const bytes = PublicKey.toBytes(publicKey) // [!code focus]
 * // @log: Uint8Array [128, 3, 131, ...]
 * ```
 *
 * @param publicKey - The public key to serialize.
 * @returns The serialized public key.
 */ parcelHelpers.export(exports, "toBytes", ()=>toBytes);
/**
 * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.
 *
 * @example
 * ```ts twoslash
 * import { PublicKey } from 'ox'
 *
 * const publicKey = PublicKey.from({
 *   prefix: 4,
 *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,
 *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,
 * })
 *
 * const hex = PublicKey.toHex(publicKey) // [!code focus]
 * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'
 * ```
 *
 * @param publicKey - The public key to serialize.
 * @returns The serialized public key.
 */ parcelHelpers.export(exports, "toHex", ()=>toHex);
/**
 * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.
 *
 * @example
 * ```ts twoslash
 * import { PublicKey } from 'ox'
 *
 * const valid = PublicKey.validate({
 *   prefix: 4,
 *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,
 * })
 * // @log: false
 * ```
 *
 * @param publicKey - The public key object to assert.
 */ parcelHelpers.export(exports, "validate", ()=>validate);
/**
 * Thrown when a public key is invalid.
 *
 * @example
 * ```ts twoslash
 * import { PublicKey } from 'ox'
 *
 * PublicKey.assert({ y: 1n })
 * // @error: PublicKey.InvalidError: Value `{"y":1n}` is not a valid public key.
 * // @error: Public key must contain:
 * // @error: - an `x` and `prefix` value (compressed)
 * // @error: - an `x`, `y`, and `prefix` value (uncompressed)
 * ```
 */ parcelHelpers.export(exports, "InvalidError", ()=>InvalidError);
/** Thrown when a public key has an invalid prefix. */ parcelHelpers.export(exports, "InvalidPrefixError", ()=>InvalidPrefixError);
/** Thrown when the public key has an invalid prefix for a compressed public key. */ parcelHelpers.export(exports, "InvalidCompressedPrefixError", ()=>InvalidCompressedPrefixError);
/** Thrown when the public key has an invalid prefix for an uncompressed public key. */ parcelHelpers.export(exports, "InvalidUncompressedPrefixError", ()=>InvalidUncompressedPrefixError);
/** Thrown when the public key has an invalid serialized size. */ parcelHelpers.export(exports, "InvalidSerializedSizeError", ()=>InvalidSerializedSizeError);
var _bytesJs = require("./Bytes.js");
var _errorsJs = require("./Errors.js");
var _hexJs = require("./Hex.js");
var _jsonJs = require("./Json.js");
function assert(publicKey, options = {}) {
    const { compressed } = options;
    const { prefix, x, y } = publicKey;
    // Uncompressed
    if (compressed === false || typeof x === 'bigint' && typeof y === 'bigint') {
        if (prefix !== 4) throw new InvalidPrefixError({
            prefix,
            cause: new InvalidUncompressedPrefixError()
        });
        return;
    }
    // Compressed
    if (compressed === true || typeof x === 'bigint' && typeof y === 'undefined') {
        if (prefix !== 3 && prefix !== 2) throw new InvalidPrefixError({
            prefix,
            cause: new InvalidCompressedPrefixError()
        });
        return;
    }
    // Unknown/invalid
    throw new InvalidError({
        publicKey
    });
}
function compress(publicKey) {
    const { x, y } = publicKey;
    return {
        prefix: y % 2n === 0n ? 2 : 3,
        x
    };
}
function from(value) {
    const publicKey = (()=>{
        if (_hexJs.validate(value)) return fromHex(value);
        if (_bytesJs.validate(value)) return fromBytes(value);
        const { prefix, x, y } = value;
        if (typeof x === 'bigint' && typeof y === 'bigint') return {
            prefix: prefix ?? 0x04,
            x,
            y
        };
        return {
            prefix,
            x
        };
    })();
    assert(publicKey);
    return publicKey;
}
function fromBytes(publicKey) {
    return fromHex(_hexJs.fromBytes(publicKey));
}
function fromHex(publicKey) {
    if (publicKey.length !== 132 && publicKey.length !== 130 && publicKey.length !== 68) throw new InvalidSerializedSizeError({
        publicKey
    });
    if (publicKey.length === 130) {
        const x = BigInt(_hexJs.slice(publicKey, 0, 32));
        const y = BigInt(_hexJs.slice(publicKey, 32, 64));
        return {
            prefix: 4,
            x,
            y
        };
    }
    if (publicKey.length === 132) {
        const prefix = Number(_hexJs.slice(publicKey, 0, 1));
        const x = BigInt(_hexJs.slice(publicKey, 1, 33));
        const y = BigInt(_hexJs.slice(publicKey, 33, 65));
        return {
            prefix,
            x,
            y
        };
    }
    const prefix = Number(_hexJs.slice(publicKey, 0, 1));
    const x = BigInt(_hexJs.slice(publicKey, 1, 33));
    return {
        prefix,
        x
    };
}
function toBytes(publicKey, options = {}) {
    return _bytesJs.fromHex(toHex(publicKey, options));
}
function toHex(publicKey, options = {}) {
    assert(publicKey);
    const { prefix, x, y } = publicKey;
    const { includePrefix = true } = options;
    const publicKey_ = _hexJs.concat(includePrefix ? _hexJs.fromNumber(prefix, {
        size: 1
    }) : '0x', _hexJs.fromNumber(x, {
        size: 32
    }), // If the public key is not compressed, add the y coordinate.
    typeof y === 'bigint' ? _hexJs.fromNumber(y, {
        size: 32
    }) : '0x');
    return publicKey_;
}
function validate(publicKey, options = {}) {
    try {
        assert(publicKey, options);
        return true;
    } catch (error) {
        return false;
    }
}
class InvalidError extends _errorsJs.BaseError {
    constructor({ publicKey }){
        super(`Value \`${_jsonJs.stringify(publicKey)}\` is not a valid public key.`, {
            metaMessages: [
                'Public key must contain:',
                '- an `x` and `prefix` value (compressed)',
                '- an `x`, `y`, and `prefix` value (uncompressed)'
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PublicKey.InvalidError'
        });
    }
}
class InvalidPrefixError extends _errorsJs.BaseError {
    constructor({ prefix, cause }){
        super(`Prefix "${prefix}" is invalid.`, {
            cause
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PublicKey.InvalidPrefixError'
        });
    }
}
class InvalidCompressedPrefixError extends _errorsJs.BaseError {
    constructor(){
        super('Prefix must be 2 or 3 for compressed public keys.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PublicKey.InvalidCompressedPrefixError'
        });
    }
}
class InvalidUncompressedPrefixError extends _errorsJs.BaseError {
    constructor(){
        super('Prefix must be 4 for uncompressed public keys.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PublicKey.InvalidUncompressedPrefixError'
        });
    }
}
class InvalidSerializedSizeError extends _errorsJs.BaseError {
    constructor({ publicKey }){
        super(`Value \`${publicKey}\` is an invalid public key size.`, {
            metaMessages: [
                'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',
                `Received ${_hexJs.size(_hexJs.from(publicKey))} bytes.`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PublicKey.InvalidSerializedSizeError'
        });
    }
}

},{"./Bytes.js":"grkDP","./Errors.js":"d3pbB","./Hex.js":"bkNyt","./Json.js":"k5VJS","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7FDSM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// eslint-disable-next-line jsdoc/require-jsdoc
parcelHelpers.export(exports, "decode", ()=>decode);
/**
 * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).
 *
 * @example
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * const data = AbiParameters.encode(
 *   AbiParameters.from(['string', 'uint', 'bool']),
 *   ['wagmi', 420n, true],
 * )
 * ```
 *
 * @example
 * ### JSON Parameters
 *
 * Specify **JSON ABI** Parameters as schema:
 *
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * const data = AbiParameters.encode(
 *   [
 *     { type: 'string', name: 'name' },
 *     { type: 'uint', name: 'age' },
 *     { type: 'bool', name: 'isOwner' },
 *   ],
 *   ['wagmi', 420n, true],
 * )
 * ```
 *
 * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).
 * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.
 * @returns ABI encoded data.
 */ parcelHelpers.export(exports, "encode", ()=>encode);
/**
 * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).
 *
 * @example
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * const encoded = AbiParameters.encodePacked(
 *   ['address', 'string'],
 *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],
 * )
 * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'
 * ```
 *
 * @param types - Set of ABI types to pack encode.
 * @param values - The set of primitive values that correspond to the ABI types defined in `types`.
 * @returns The encoded packed data.
 */ parcelHelpers.export(exports, "encodePacked", ()=>encodePacked);
/**
 * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.
 *
 * @example
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * const formatted = AbiParameters.format([
 *   {
 *     name: 'spender',
 *     type: 'address',
 *   },
 *   {
 *     name: 'amount',
 *     type: 'uint256',
 *   },
 * ])
 *
 * formatted
 * //    ^?
 *
 *
 * ```
 *
 * @param parameters - The ABI Parameters to format.
 * @returns The formatted ABI Parameters  .
 */ parcelHelpers.export(exports, "format", ()=>format);
/**
 * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.
 *
 * @example
 * ### JSON Parameters
 *
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * const parameters = AbiParameters.from([
 *   {
 *     name: 'spender',
 *     type: 'address',
 *   },
 *   {
 *     name: 'amount',
 *     type: 'uint256',
 *   },
 * ])
 *
 * parameters
 * //^?
 *
 *
 *
 *
 *
 *
 *
 * ```
 *
 * @example
 * ### Human Readable Parameters
 *
 * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:
 *
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * const parameters = AbiParameters.from('address spender, uint256 amount')
 *
 * parameters
 * //^?
 *
 *
 *
 *
 *
 *
 *
 * ```
 *
 * @example
 * It is possible to specify `struct`s along with your definitions:
 *
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * const parameters = AbiParameters.from([
 *   'struct Foo { address spender; uint256 amount; }', // [!code hl]
 *   'Foo foo, address bar',
 * ])
 *
 * parameters
 * //^?
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * ```
 *
 *
 *
 * @param parameters - The ABI Parameters to parse.
 * @returns The typed ABI Parameters.
 */ parcelHelpers.export(exports, "from", ()=>from);
/**
 * Throws when the data size is too small for the given parameters.
 *
 * @example
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * AbiParameters.decode([{ type: 'uint256' }], '0x010f')
 * //                                               2 bytes
 * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.
 * // @error: Params: (uint256)
 * // @error: Data:   0x010f (2 bytes)
 * ```
 *
 * ### Solution
 *
 * Pass a valid data size.
 *
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')
 * //                                               32 bytes
 * ```
 */ parcelHelpers.export(exports, "DataSizeTooSmallError", ()=>DataSizeTooSmallError);
/**
 * Throws when zero data is provided, but data is expected.
 *
 * @example
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * AbiParameters.decode([{ type: 'uint256' }], '0x')
 * //                                             zero data
 * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.
 * // @error: Params: (uint256)
 * // @error: Data:   0x010f (2 bytes)
 * ```
 *
 * ### Solution
 *
 * Pass valid data.
 *
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')
 * //                                               32 bytes
 * ```
 */ parcelHelpers.export(exports, "ZeroDataError", ()=>ZeroDataError);
/**
 * The length of the array value does not match the length specified in the corresponding ABI parameter.
 *
 * ### Example
 *
 * ```ts twoslash
 * // @noErrors
 * import { AbiParameters } from 'ox'
 * // ---cut---
 * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])
 * //                                                expected: 3    length: 2
 * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch
 * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.
 * ```
 *
 * ### Solution
 *
 * Pass an array of the correct length.
 *
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 * // ---cut---
 * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])
 * //                                                           length: 3
 * ```
 */ parcelHelpers.export(exports, "ArrayLengthMismatchError", ()=>ArrayLengthMismatchError);
/**
 * The size of the bytes value does not match the size specified in the corresponding ABI parameter.
 *
 * ### Example
 *
 * ```ts twoslash
 * // @noErrors
 * import { AbiParameters } from 'ox'
 * // ---cut---
 * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])
 * //                                             expected: 8 bytes    size: 12 bytes
 * // @error: BytesSizeMismatchError: Size of bytes "0xdeadbeefdeadbeefdeadbeef"
 * // @error: (bytes12) does not match expected size (bytes8).
 * ```
 *
 * ### Solution
 *
 * Pass a bytes value of the correct size.
 *
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 * // ---cut---
 * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])
 * //                                                         size: 8 bytes
 * ```
 */ parcelHelpers.export(exports, "BytesSizeMismatchError", ()=>BytesSizeMismatchError);
/**
 * The length of the values to encode does not match the length of the ABI parameters.
 *
 * ### Example
 *
 * ```ts twoslash
 * // @noErrors
 * import { AbiParameters } from 'ox'
 * // ---cut---
 * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])
 * // @error: LengthMismatchError: ABI encoding params/values length mismatch.
 * // @error: Expected length (params): 2
 * // @error: Given length (values): 1
 * ```
 *
 * ### Solution
 *
 * Pass the correct number of values to encode.
 *
 * ### Solution
 *
 * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).
 */ parcelHelpers.export(exports, "LengthMismatchError", ()=>LengthMismatchError);
/**
 * The value provided is not a valid array as specified in the corresponding ABI parameter.
 *
 * ### Example
 *
 * ```ts twoslash
 * // @noErrors
 * import { AbiParameters } from 'ox'
 * // ---cut---
 * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])
 * ```
 *
 * ### Solution
 *
 * Pass an array value.
 */ parcelHelpers.export(exports, "InvalidArrayError", ()=>InvalidArrayError);
/**
 * Throws when the ABI parameter type is invalid.
 *
 * @example
 * ```ts twoslash
 * import { AbiParameters } from 'ox'
 *
 * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')
 * //                               invalid type
 * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.
 * ```
 */ parcelHelpers.export(exports, "InvalidTypeError", ()=>InvalidTypeError);
var _abitype = require("abitype");
var _addressJs = require("./Address.js");
var _bytesJs = require("./Bytes.js");
var _errorsJs = require("./Errors.js");
var _hexJs = require("./Hex.js");
var _solidityJs = require("./Solidity.js");
var _abiParametersJs = require("./internal/abiParameters.js");
var _cursorJs = require("./internal/cursor.js");
function decode(parameters, data, options = {}) {
    const { as = 'Array', checksumAddress = false } = options;
    const bytes = typeof data === 'string' ? _bytesJs.fromHex(data) : data;
    const cursor = _cursorJs.create(bytes);
    if (_bytesJs.size(bytes) === 0 && parameters.length > 0) throw new ZeroDataError();
    if (_bytesJs.size(bytes) && _bytesJs.size(bytes) < 32) throw new DataSizeTooSmallError({
        data: typeof data === 'string' ? data : _hexJs.fromBytes(data),
        parameters: parameters,
        size: _bytesJs.size(bytes)
    });
    let consumed = 0;
    const values = as === 'Array' ? [] : {};
    for(let i = 0; i < parameters.length; ++i){
        const param = parameters[i];
        cursor.setPosition(consumed);
        const [data, consumed_] = _abiParametersJs.decodeParameter(cursor, param, {
            checksumAddress,
            staticPosition: 0
        });
        consumed += consumed_;
        if (as === 'Array') values.push(data);
        else values[param.name ?? i] = data;
    }
    return values;
}
function encode(parameters, values, options) {
    const { checksumAddress = false } = options ?? {};
    if (parameters.length !== values.length) throw new LengthMismatchError({
        expectedLength: parameters.length,
        givenLength: values.length
    });
    // Prepare the parameters to determine dynamic types to encode.
    const preparedParameters = _abiParametersJs.prepareParameters({
        checksumAddress,
        parameters: parameters,
        values: values
    });
    const data = _abiParametersJs.encode(preparedParameters);
    if (data.length === 0) return '0x';
    return data;
}
function encodePacked(types, values) {
    if (types.length !== values.length) throw new LengthMismatchError({
        expectedLength: types.length,
        givenLength: values.length
    });
    const data = [];
    for(let i = 0; i < types.length; i++){
        const type = types[i];
        const value = values[i];
        data.push(encodePacked.encode(type, value));
    }
    return _hexJs.concat(...data);
}
(function(encodePacked) {
    // eslint-disable-next-line jsdoc/require-jsdoc
    function encode(type, value, isArray = false) {
        if (type === 'address') {
            const address = value;
            _addressJs.assert(address);
            return _hexJs.padLeft(address.toLowerCase(), isArray ? 32 : 0);
        }
        if (type === 'string') return _hexJs.fromString(value);
        if (type === 'bytes') return value;
        if (type === 'bool') return _hexJs.padLeft(_hexJs.fromBoolean(value), isArray ? 32 : 1);
        const intMatch = type.match(_solidityJs.integerRegex);
        if (intMatch) {
            const [_type, baseType, bits = '256'] = intMatch;
            const size = Number.parseInt(bits) / 8;
            return _hexJs.fromNumber(value, {
                size: isArray ? 32 : size,
                signed: baseType === 'int'
            });
        }
        const bytesMatch = type.match(_solidityJs.bytesRegex);
        if (bytesMatch) {
            const [_type, size] = bytesMatch;
            if (Number.parseInt(size) !== (value.length - 2) / 2) throw new BytesSizeMismatchError({
                expectedSize: Number.parseInt(size),
                value: value
            });
            return _hexJs.padRight(value, isArray ? 32 : 0);
        }
        const arrayMatch = type.match(_solidityJs.arrayRegex);
        if (arrayMatch && Array.isArray(value)) {
            const [_type, childType] = arrayMatch;
            const data = [];
            for(let i = 0; i < value.length; i++)data.push(encode(childType, value[i], true));
            if (data.length === 0) return '0x';
            return _hexJs.concat(...data);
        }
        throw new InvalidTypeError(type);
    }
    encodePacked.encode = encode;
})(encodePacked || (encodePacked = {}));
function format(parameters) {
    return _abitype.formatAbiParameters(parameters);
}
function from(parameters) {
    if (Array.isArray(parameters) && typeof parameters[0] === 'string') return _abitype.parseAbiParameters(parameters);
    if (typeof parameters === 'string') return _abitype.parseAbiParameters(parameters);
    return parameters;
}
class DataSizeTooSmallError extends _errorsJs.BaseError {
    constructor({ data, parameters, size }){
        super(`Data size of ${size} bytes is too small for given parameters.`, {
            metaMessages: [
                `Params: (${_abitype.formatAbiParameters(parameters)})`,
                `Data:   ${data} (${size} bytes)`
            ]
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.DataSizeTooSmallError'
        });
    }
}
class ZeroDataError extends _errorsJs.BaseError {
    constructor(){
        super('Cannot decode zero data ("0x") with ABI parameters.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.ZeroDataError'
        });
    }
}
class ArrayLengthMismatchError extends _errorsJs.BaseError {
    constructor({ expectedLength, givenLength, type }){
        super(`Array length mismatch for type \`${type}\`. Expected: \`${expectedLength}\`. Given: \`${givenLength}\`.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.ArrayLengthMismatchError'
        });
    }
}
class BytesSizeMismatchError extends _errorsJs.BaseError {
    constructor({ expectedSize, value }){
        super(`Size of bytes "${value}" (bytes${_hexJs.size(value)}) does not match expected size (bytes${expectedSize}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.BytesSizeMismatchError'
        });
    }
}
class LengthMismatchError extends _errorsJs.BaseError {
    constructor({ expectedLength, givenLength }){
        super([
            'ABI encoding parameters/values length mismatch.',
            `Expected length (parameters): ${expectedLength}`,
            `Given length (values): ${givenLength}`
        ].join('\n'));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.LengthMismatchError'
        });
    }
}
class InvalidArrayError extends _errorsJs.BaseError {
    constructor(value){
        super(`Value \`${value}\` is not a valid array.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.InvalidArrayError'
        });
    }
}
class InvalidTypeError extends _errorsJs.BaseError {
    constructor(type){
        super(`Type \`${type}\` is not a valid ABI Type.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.InvalidTypeError'
        });
    }
}

},{"abitype":"6tgJn","./Address.js":"2a10M","./Bytes.js":"grkDP","./Errors.js":"d3pbB","./Hex.js":"bkNyt","./Solidity.js":"eu9RI","./internal/abiParameters.js":"epjLy","./internal/cursor.js":"z0Yvm","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eu9RI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arrayRegex", ()=>arrayRegex);
parcelHelpers.export(exports, "bytesRegex", ()=>bytesRegex);
parcelHelpers.export(exports, "integerRegex", ()=>integerRegex);
parcelHelpers.export(exports, "maxInt8", ()=>maxInt8);
parcelHelpers.export(exports, "maxInt16", ()=>maxInt16);
parcelHelpers.export(exports, "maxInt24", ()=>maxInt24);
parcelHelpers.export(exports, "maxInt32", ()=>maxInt32);
parcelHelpers.export(exports, "maxInt40", ()=>maxInt40);
parcelHelpers.export(exports, "maxInt48", ()=>maxInt48);
parcelHelpers.export(exports, "maxInt56", ()=>maxInt56);
parcelHelpers.export(exports, "maxInt64", ()=>maxInt64);
parcelHelpers.export(exports, "maxInt72", ()=>maxInt72);
parcelHelpers.export(exports, "maxInt80", ()=>maxInt80);
parcelHelpers.export(exports, "maxInt88", ()=>maxInt88);
parcelHelpers.export(exports, "maxInt96", ()=>maxInt96);
parcelHelpers.export(exports, "maxInt104", ()=>maxInt104);
parcelHelpers.export(exports, "maxInt112", ()=>maxInt112);
parcelHelpers.export(exports, "maxInt120", ()=>maxInt120);
parcelHelpers.export(exports, "maxInt128", ()=>maxInt128);
parcelHelpers.export(exports, "maxInt136", ()=>maxInt136);
parcelHelpers.export(exports, "maxInt144", ()=>maxInt144);
parcelHelpers.export(exports, "maxInt152", ()=>maxInt152);
parcelHelpers.export(exports, "maxInt160", ()=>maxInt160);
parcelHelpers.export(exports, "maxInt168", ()=>maxInt168);
parcelHelpers.export(exports, "maxInt176", ()=>maxInt176);
parcelHelpers.export(exports, "maxInt184", ()=>maxInt184);
parcelHelpers.export(exports, "maxInt192", ()=>maxInt192);
parcelHelpers.export(exports, "maxInt200", ()=>maxInt200);
parcelHelpers.export(exports, "maxInt208", ()=>maxInt208);
parcelHelpers.export(exports, "maxInt216", ()=>maxInt216);
parcelHelpers.export(exports, "maxInt224", ()=>maxInt224);
parcelHelpers.export(exports, "maxInt232", ()=>maxInt232);
parcelHelpers.export(exports, "maxInt240", ()=>maxInt240);
parcelHelpers.export(exports, "maxInt248", ()=>maxInt248);
parcelHelpers.export(exports, "maxInt256", ()=>maxInt256);
parcelHelpers.export(exports, "minInt8", ()=>minInt8);
parcelHelpers.export(exports, "minInt16", ()=>minInt16);
parcelHelpers.export(exports, "minInt24", ()=>minInt24);
parcelHelpers.export(exports, "minInt32", ()=>minInt32);
parcelHelpers.export(exports, "minInt40", ()=>minInt40);
parcelHelpers.export(exports, "minInt48", ()=>minInt48);
parcelHelpers.export(exports, "minInt56", ()=>minInt56);
parcelHelpers.export(exports, "minInt64", ()=>minInt64);
parcelHelpers.export(exports, "minInt72", ()=>minInt72);
parcelHelpers.export(exports, "minInt80", ()=>minInt80);
parcelHelpers.export(exports, "minInt88", ()=>minInt88);
parcelHelpers.export(exports, "minInt96", ()=>minInt96);
parcelHelpers.export(exports, "minInt104", ()=>minInt104);
parcelHelpers.export(exports, "minInt112", ()=>minInt112);
parcelHelpers.export(exports, "minInt120", ()=>minInt120);
parcelHelpers.export(exports, "minInt128", ()=>minInt128);
parcelHelpers.export(exports, "minInt136", ()=>minInt136);
parcelHelpers.export(exports, "minInt144", ()=>minInt144);
parcelHelpers.export(exports, "minInt152", ()=>minInt152);
parcelHelpers.export(exports, "minInt160", ()=>minInt160);
parcelHelpers.export(exports, "minInt168", ()=>minInt168);
parcelHelpers.export(exports, "minInt176", ()=>minInt176);
parcelHelpers.export(exports, "minInt184", ()=>minInt184);
parcelHelpers.export(exports, "minInt192", ()=>minInt192);
parcelHelpers.export(exports, "minInt200", ()=>minInt200);
parcelHelpers.export(exports, "minInt208", ()=>minInt208);
parcelHelpers.export(exports, "minInt216", ()=>minInt216);
parcelHelpers.export(exports, "minInt224", ()=>minInt224);
parcelHelpers.export(exports, "minInt232", ()=>minInt232);
parcelHelpers.export(exports, "minInt240", ()=>minInt240);
parcelHelpers.export(exports, "minInt248", ()=>minInt248);
parcelHelpers.export(exports, "minInt256", ()=>minInt256);
parcelHelpers.export(exports, "maxUint8", ()=>maxUint8);
parcelHelpers.export(exports, "maxUint16", ()=>maxUint16);
parcelHelpers.export(exports, "maxUint24", ()=>maxUint24);
parcelHelpers.export(exports, "maxUint32", ()=>maxUint32);
parcelHelpers.export(exports, "maxUint40", ()=>maxUint40);
parcelHelpers.export(exports, "maxUint48", ()=>maxUint48);
parcelHelpers.export(exports, "maxUint56", ()=>maxUint56);
parcelHelpers.export(exports, "maxUint64", ()=>maxUint64);
parcelHelpers.export(exports, "maxUint72", ()=>maxUint72);
parcelHelpers.export(exports, "maxUint80", ()=>maxUint80);
parcelHelpers.export(exports, "maxUint88", ()=>maxUint88);
parcelHelpers.export(exports, "maxUint96", ()=>maxUint96);
parcelHelpers.export(exports, "maxUint104", ()=>maxUint104);
parcelHelpers.export(exports, "maxUint112", ()=>maxUint112);
parcelHelpers.export(exports, "maxUint120", ()=>maxUint120);
parcelHelpers.export(exports, "maxUint128", ()=>maxUint128);
parcelHelpers.export(exports, "maxUint136", ()=>maxUint136);
parcelHelpers.export(exports, "maxUint144", ()=>maxUint144);
parcelHelpers.export(exports, "maxUint152", ()=>maxUint152);
parcelHelpers.export(exports, "maxUint160", ()=>maxUint160);
parcelHelpers.export(exports, "maxUint168", ()=>maxUint168);
parcelHelpers.export(exports, "maxUint176", ()=>maxUint176);
parcelHelpers.export(exports, "maxUint184", ()=>maxUint184);
parcelHelpers.export(exports, "maxUint192", ()=>maxUint192);
parcelHelpers.export(exports, "maxUint200", ()=>maxUint200);
parcelHelpers.export(exports, "maxUint208", ()=>maxUint208);
parcelHelpers.export(exports, "maxUint216", ()=>maxUint216);
parcelHelpers.export(exports, "maxUint224", ()=>maxUint224);
parcelHelpers.export(exports, "maxUint232", ()=>maxUint232);
parcelHelpers.export(exports, "maxUint240", ()=>maxUint240);
parcelHelpers.export(exports, "maxUint248", ()=>maxUint248);
parcelHelpers.export(exports, "maxUint256", ()=>maxUint256);
const arrayRegex = /^(.*)\[([0-9]*)\]$/;
const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
const integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
const maxInt8 = 2n ** (8n - 1n) - 1n;
const maxInt16 = 2n ** (16n - 1n) - 1n;
const maxInt24 = 2n ** (24n - 1n) - 1n;
const maxInt32 = 2n ** (32n - 1n) - 1n;
const maxInt40 = 2n ** (40n - 1n) - 1n;
const maxInt48 = 2n ** (48n - 1n) - 1n;
const maxInt56 = 2n ** (56n - 1n) - 1n;
const maxInt64 = 2n ** (64n - 1n) - 1n;
const maxInt72 = 2n ** (72n - 1n) - 1n;
const maxInt80 = 2n ** (80n - 1n) - 1n;
const maxInt88 = 2n ** (88n - 1n) - 1n;
const maxInt96 = 2n ** (96n - 1n) - 1n;
const maxInt104 = 2n ** (104n - 1n) - 1n;
const maxInt112 = 2n ** (112n - 1n) - 1n;
const maxInt120 = 2n ** (120n - 1n) - 1n;
const maxInt128 = 2n ** (128n - 1n) - 1n;
const maxInt136 = 2n ** (136n - 1n) - 1n;
const maxInt144 = 2n ** (144n - 1n) - 1n;
const maxInt152 = 2n ** (152n - 1n) - 1n;
const maxInt160 = 2n ** (160n - 1n) - 1n;
const maxInt168 = 2n ** (168n - 1n) - 1n;
const maxInt176 = 2n ** (176n - 1n) - 1n;
const maxInt184 = 2n ** (184n - 1n) - 1n;
const maxInt192 = 2n ** (192n - 1n) - 1n;
const maxInt200 = 2n ** (200n - 1n) - 1n;
const maxInt208 = 2n ** (208n - 1n) - 1n;
const maxInt216 = 2n ** (216n - 1n) - 1n;
const maxInt224 = 2n ** (224n - 1n) - 1n;
const maxInt232 = 2n ** (232n - 1n) - 1n;
const maxInt240 = 2n ** (240n - 1n) - 1n;
const maxInt248 = 2n ** (248n - 1n) - 1n;
const maxInt256 = 2n ** (256n - 1n) - 1n;
const minInt8 = -(2n ** (8n - 1n));
const minInt16 = -(2n ** (16n - 1n));
const minInt24 = -(2n ** (24n - 1n));
const minInt32 = -(2n ** (32n - 1n));
const minInt40 = -(2n ** (40n - 1n));
const minInt48 = -(2n ** (48n - 1n));
const minInt56 = -(2n ** (56n - 1n));
const minInt64 = -(2n ** (64n - 1n));
const minInt72 = -(2n ** (72n - 1n));
const minInt80 = -(2n ** (80n - 1n));
const minInt88 = -(2n ** (88n - 1n));
const minInt96 = -(2n ** (96n - 1n));
const minInt104 = -(2n ** (104n - 1n));
const minInt112 = -(2n ** (112n - 1n));
const minInt120 = -(2n ** (120n - 1n));
const minInt128 = -(2n ** (128n - 1n));
const minInt136 = -(2n ** (136n - 1n));
const minInt144 = -(2n ** (144n - 1n));
const minInt152 = -(2n ** (152n - 1n));
const minInt160 = -(2n ** (160n - 1n));
const minInt168 = -(2n ** (168n - 1n));
const minInt176 = -(2n ** (176n - 1n));
const minInt184 = -(2n ** (184n - 1n));
const minInt192 = -(2n ** (192n - 1n));
const minInt200 = -(2n ** (200n - 1n));
const minInt208 = -(2n ** (208n - 1n));
const minInt216 = -(2n ** (216n - 1n));
const minInt224 = -(2n ** (224n - 1n));
const minInt232 = -(2n ** (232n - 1n));
const minInt240 = -(2n ** (240n - 1n));
const minInt248 = -(2n ** (248n - 1n));
const minInt256 = -(2n ** (256n - 1n));
const maxUint8 = 2n ** 8n - 1n;
const maxUint16 = 2n ** 16n - 1n;
const maxUint24 = 2n ** 24n - 1n;
const maxUint32 = 2n ** 32n - 1n;
const maxUint40 = 2n ** 40n - 1n;
const maxUint48 = 2n ** 48n - 1n;
const maxUint56 = 2n ** 56n - 1n;
const maxUint64 = 2n ** 64n - 1n;
const maxUint72 = 2n ** 72n - 1n;
const maxUint80 = 2n ** 80n - 1n;
const maxUint88 = 2n ** 88n - 1n;
const maxUint96 = 2n ** 96n - 1n;
const maxUint104 = 2n ** 104n - 1n;
const maxUint112 = 2n ** 112n - 1n;
const maxUint120 = 2n ** 120n - 1n;
const maxUint128 = 2n ** 128n - 1n;
const maxUint136 = 2n ** 136n - 1n;
const maxUint144 = 2n ** 144n - 1n;
const maxUint152 = 2n ** 152n - 1n;
const maxUint160 = 2n ** 160n - 1n;
const maxUint168 = 2n ** 168n - 1n;
const maxUint176 = 2n ** 176n - 1n;
const maxUint184 = 2n ** 184n - 1n;
const maxUint192 = 2n ** 192n - 1n;
const maxUint200 = 2n ** 200n - 1n;
const maxUint208 = 2n ** 208n - 1n;
const maxUint216 = 2n ** 216n - 1n;
const maxUint224 = 2n ** 224n - 1n;
const maxUint232 = 2n ** 232n - 1n;
const maxUint240 = 2n ** 240n - 1n;
const maxUint248 = 2n ** 248n - 1n;
const maxUint256 = 2n ** 256n - 1n;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"epjLy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "decodeParameter", ()=>decodeParameter);
/** @internal */ parcelHelpers.export(exports, "decodeAddress", ()=>decodeAddress);
/** @internal */ parcelHelpers.export(exports, "decodeArray", ()=>decodeArray);
/** @internal */ parcelHelpers.export(exports, "decodeBool", ()=>decodeBool);
/** @internal */ parcelHelpers.export(exports, "decodeBytes", ()=>decodeBytes);
/** @internal */ parcelHelpers.export(exports, "decodeNumber", ()=>decodeNumber);
/** @internal */ parcelHelpers.export(exports, "decodeTuple", ()=>decodeTuple);
/** @internal */ parcelHelpers.export(exports, "decodeString", ()=>decodeString);
/** @internal */ parcelHelpers.export(exports, "prepareParameters", ()=>prepareParameters);
/** @internal */ parcelHelpers.export(exports, "prepareParameter", ()=>prepareParameter);
/** @internal */ parcelHelpers.export(exports, "encode", ()=>encode);
/** @internal */ parcelHelpers.export(exports, "encodeAddress", ()=>encodeAddress);
/** @internal */ parcelHelpers.export(exports, "encodeArray", ()=>encodeArray);
/** @internal */ parcelHelpers.export(exports, "encodeBytes", ()=>encodeBytes);
/** @internal */ parcelHelpers.export(exports, "encodeBoolean", ()=>encodeBoolean);
/** @internal */ parcelHelpers.export(exports, "encodeNumber", ()=>encodeNumber);
/** @internal */ parcelHelpers.export(exports, "encodeString", ()=>encodeString);
/** @internal */ parcelHelpers.export(exports, "encodeTuple", ()=>encodeTuple);
/** @internal */ parcelHelpers.export(exports, "getArrayComponents", ()=>getArrayComponents);
/** @internal */ parcelHelpers.export(exports, "hasDynamicChild", ()=>hasDynamicChild);
var _abiParametersJs = require("../AbiParameters.js");
var _addressJs = require("../Address.js");
var _bytesJs = require("../Bytes.js");
var _errorsJs = require("../Errors.js");
var _hexJs = require("../Hex.js");
var _solidityJs = require("../Solidity.js");
function decodeParameter(cursor, param, options) {
    const { checksumAddress, staticPosition } = options;
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return decodeArray(cursor, {
            ...param,
            type
        }, {
            checksumAddress,
            length,
            staticPosition
        });
    }
    if (param.type === 'tuple') return decodeTuple(cursor, param, {
        checksumAddress,
        staticPosition
    });
    if (param.type === 'address') return decodeAddress(cursor, {
        checksum: checksumAddress
    });
    if (param.type === 'bool') return decodeBool(cursor);
    if (param.type.startsWith('bytes')) return decodeBytes(cursor, param, {
        staticPosition
    });
    if (param.type.startsWith('uint') || param.type.startsWith('int')) return decodeNumber(cursor, param);
    if (param.type === 'string') return decodeString(cursor, {
        staticPosition
    });
    throw new _abiParametersJs.InvalidTypeError(param.type);
}
const sizeOfLength = 32;
const sizeOfOffset = 32;
function decodeAddress(cursor, options = {}) {
    const { checksum = false } = options;
    const value = cursor.readBytes(32);
    const wrap = (address)=>checksum ? _addressJs.checksum(address) : address;
    return [
        wrap(_hexJs.fromBytes(_bytesJs.slice(value, -20))),
        32
    ];
}
function decodeArray(cursor, param, options) {
    const { checksumAddress, length, staticPosition } = options;
    // If the length of the array is not known in advance (dynamic array),
    // this means we will need to wonder off to the pointer and decode.
    if (!length) {
        // Dealing with a dynamic type, so get the offset of the array data.
        const offset = _bytesJs.toNumber(cursor.readBytes(sizeOfOffset));
        // Start is the static position of current slot + offset.
        const start = staticPosition + offset;
        const startOfData = start + sizeOfLength;
        // Get the length of the array from the offset.
        cursor.setPosition(start);
        const length = _bytesJs.toNumber(cursor.readBytes(sizeOfLength));
        // Check if the array has any dynamic children.
        const dynamicChild = hasDynamicChild(param);
        let consumed = 0;
        const value = [];
        for(let i = 0; i < length; ++i){
            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).
            // Otherwise, elements will be the size of their encoding (consumed bytes).
            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));
            const [data, consumed_] = decodeParameter(cursor, param, {
                checksumAddress,
                staticPosition: startOfData
            });
            consumed += consumed_;
            value.push(data);
        }
        // As we have gone wondering, restore to the original position + next slot.
        cursor.setPosition(staticPosition + 32);
        return [
            value,
            32
        ];
    }
    // If the length of the array is known in advance,
    // and the length of an element deeply nested in the array is not known,
    // we need to decode the offset of the array data.
    if (hasDynamicChild(param)) {
        // Dealing with dynamic types, so get the offset of the array data.
        const offset = _bytesJs.toNumber(cursor.readBytes(sizeOfOffset));
        // Start is the static position of current slot + offset.
        const start = staticPosition + offset;
        const value = [];
        for(let i = 0; i < length; ++i){
            // Move cursor along to the next slot (next offset pointer).
            cursor.setPosition(start + i * 32);
            const [data] = decodeParameter(cursor, param, {
                checksumAddress,
                staticPosition: start
            });
            value.push(data);
        }
        // As we have gone wondering, restore to the original position + next slot.
        cursor.setPosition(staticPosition + 32);
        return [
            value,
            32
        ];
    }
    // If the length of the array is known in advance and the array is deeply static,
    // then we can just decode each element in sequence.
    let consumed = 0;
    const value = [];
    for(let i = 0; i < length; ++i){
        const [data, consumed_] = decodeParameter(cursor, param, {
            checksumAddress,
            staticPosition: staticPosition + consumed
        });
        consumed += consumed_;
        value.push(data);
    }
    return [
        value,
        consumed
    ];
}
function decodeBool(cursor) {
    return [
        _bytesJs.toBoolean(cursor.readBytes(32), {
            size: 32
        }),
        32
    ];
}
function decodeBytes(cursor, param, { staticPosition }) {
    const [_, size] = param.type.split('bytes');
    if (!size) {
        // Dealing with dynamic types, so get the offset of the bytes data.
        const offset = _bytesJs.toNumber(cursor.readBytes(32));
        // Set position of the cursor to start of bytes data.
        cursor.setPosition(staticPosition + offset);
        const length = _bytesJs.toNumber(cursor.readBytes(32));
        // If there is no length, we have zero data.
        if (length === 0) {
            // As we have gone wondering, restore to the original position + next slot.
            cursor.setPosition(staticPosition + 32);
            return [
                '0x',
                32
            ];
        }
        const data = cursor.readBytes(length);
        // As we have gone wondering, restore to the original position + next slot.
        cursor.setPosition(staticPosition + 32);
        return [
            _hexJs.fromBytes(data),
            32
        ];
    }
    const value = _hexJs.fromBytes(cursor.readBytes(Number.parseInt(size), 32));
    return [
        value,
        32
    ];
}
function decodeNumber(cursor, param) {
    const signed = param.type.startsWith('int');
    const size = Number.parseInt(param.type.split('int')[1] || '256');
    const value = cursor.readBytes(32);
    return [
        size > 48 ? _bytesJs.toBigInt(value, {
            signed
        }) : _bytesJs.toNumber(value, {
            signed
        }),
        32
    ];
}
function decodeTuple(cursor, param, options) {
    const { checksumAddress, staticPosition } = options;
    // Tuples can have unnamed components (i.e. they are arrays), so we must
    // determine whether the tuple is named or unnamed. In the case of a named
    // tuple, the value will be an object where each property is the name of the
    // component. In the case of an unnamed tuple, the value will be an array.
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name })=>!name);
    // Initialize the value to an object or an array, depending on whether the
    // tuple is named or unnamed.
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    // If the tuple has a dynamic child, we must first decode the offset to the
    // tuple data.
    if (hasDynamicChild(param)) {
        // Dealing with dynamic types, so get the offset of the tuple data.
        const offset = _bytesJs.toNumber(cursor.readBytes(sizeOfOffset));
        // Start is the static position of referencing slot + offset.
        const start = staticPosition + offset;
        for(let i = 0; i < param.components.length; ++i){
            const component = param.components[i];
            cursor.setPosition(start + consumed);
            const [data, consumed_] = decodeParameter(cursor, component, {
                checksumAddress,
                staticPosition: start
            });
            consumed += consumed_;
            value[hasUnnamedChild ? i : component?.name] = data;
        }
        // As we have gone wondering, restore to the original position + next slot.
        cursor.setPosition(staticPosition + 32);
        return [
            value,
            32
        ];
    }
    // If the tuple has static children, we can just decode each component
    // in sequence.
    for(let i = 0; i < param.components.length; ++i){
        const component = param.components[i];
        const [data, consumed_] = decodeParameter(cursor, component, {
            checksumAddress,
            staticPosition
        });
        value[hasUnnamedChild ? i : component?.name] = data;
        consumed += consumed_;
    }
    return [
        value,
        consumed
    ];
}
function decodeString(cursor, { staticPosition }) {
    // Get offset to start of string data.
    const offset = _bytesJs.toNumber(cursor.readBytes(32));
    // Start is the static position of current slot + offset.
    const start = staticPosition + offset;
    cursor.setPosition(start);
    const length = _bytesJs.toNumber(cursor.readBytes(32));
    // If there is no length, we have zero data (empty string).
    if (length === 0) {
        cursor.setPosition(staticPosition + 32);
        return [
            '',
            32
        ];
    }
    const data = cursor.readBytes(length, 32);
    const value = _bytesJs.toString(_bytesJs.trimLeft(data));
    // As we have gone wondering, restore to the original position + next slot.
    cursor.setPosition(staticPosition + 32);
    return [
        value,
        32
    ];
}
function prepareParameters({ checksumAddress, parameters, values }) {
    const preparedParameters = [];
    for(let i = 0; i < parameters.length; i++)preparedParameters.push(prepareParameter({
        checksumAddress,
        parameter: parameters[i],
        value: values[i]
    }));
    return preparedParameters;
}
function prepareParameter({ checksumAddress = false, parameter: parameter_, value }) {
    const parameter = parameter_;
    const arrayComponents = getArrayComponents(parameter.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return encodeArray(value, {
            checksumAddress,
            length,
            parameter: {
                ...parameter,
                type
            }
        });
    }
    if (parameter.type === 'tuple') return encodeTuple(value, {
        checksumAddress,
        parameter: parameter
    });
    if (parameter.type === 'address') return encodeAddress(value, {
        checksum: checksumAddress
    });
    if (parameter.type === 'bool') return encodeBoolean(value);
    if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {
        const signed = parameter.type.startsWith('int');
        const [, , size = '256'] = (0, _solidityJs.integerRegex).exec(parameter.type) ?? [];
        return encodeNumber(value, {
            signed,
            size: Number(size)
        });
    }
    if (parameter.type.startsWith('bytes')) return encodeBytes(value, {
        type: parameter.type
    });
    if (parameter.type === 'string') return encodeString(value);
    throw new _abiParametersJs.InvalidTypeError(parameter.type);
}
function encode(preparedParameters) {
    // 1. Compute the size of the static part of the parameters.
    let staticSize = 0;
    for(let i = 0; i < preparedParameters.length; i++){
        const { dynamic, encoded } = preparedParameters[i];
        if (dynamic) staticSize += 32;
        else staticSize += _hexJs.size(encoded);
    }
    // 2. Split the parameters into static and dynamic parts.
    const staticParameters = [];
    const dynamicParameters = [];
    let dynamicSize = 0;
    for(let i = 0; i < preparedParameters.length; i++){
        const { dynamic, encoded } = preparedParameters[i];
        if (dynamic) {
            staticParameters.push(_hexJs.fromNumber(staticSize + dynamicSize, {
                size: 32
            }));
            dynamicParameters.push(encoded);
            dynamicSize += _hexJs.size(encoded);
        } else staticParameters.push(encoded);
    }
    // 3. Concatenate static and dynamic parts.
    return _hexJs.concat(...staticParameters, ...dynamicParameters);
}
function encodeAddress(value, options) {
    const { checksum = false } = options;
    _addressJs.assert(value, {
        strict: checksum
    });
    return {
        dynamic: false,
        encoded: _hexJs.padLeft(value.toLowerCase())
    };
}
function encodeArray(value, options) {
    const { checksumAddress, length, parameter } = options;
    const dynamic = length === null;
    if (!Array.isArray(value)) throw new _abiParametersJs.InvalidArrayError(value);
    if (!dynamic && value.length !== length) throw new _abiParametersJs.ArrayLengthMismatchError({
        expectedLength: length,
        givenLength: value.length,
        type: `${parameter.type}[${length}]`
    });
    let dynamicChild = false;
    const preparedParameters = [];
    for(let i = 0; i < value.length; i++){
        const preparedParam = prepareParameter({
            checksumAddress,
            parameter,
            value: value[i]
        });
        if (preparedParam.dynamic) dynamicChild = true;
        preparedParameters.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
        const data = encode(preparedParameters);
        if (dynamic) {
            const length = _hexJs.fromNumber(preparedParameters.length, {
                size: 32
            });
            return {
                dynamic: true,
                encoded: preparedParameters.length > 0 ? _hexJs.concat(length, data) : length
            };
        }
        if (dynamicChild) return {
            dynamic: true,
            encoded: data
        };
    }
    return {
        dynamic: false,
        encoded: _hexJs.concat(...preparedParameters.map(({ encoded })=>encoded))
    };
}
function encodeBytes(value, { type }) {
    const [, parametersize] = type.split('bytes');
    const bytesSize = _hexJs.size(value);
    if (!parametersize) {
        let value_ = value;
        // If the size is not divisible by 32 bytes, pad the end
        // with empty bytes to the ceiling 32 bytes.
        if (bytesSize % 32 !== 0) value_ = _hexJs.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);
        return {
            dynamic: true,
            encoded: _hexJs.concat(_hexJs.padLeft(_hexJs.fromNumber(bytesSize, {
                size: 32
            })), value_)
        };
    }
    if (bytesSize !== Number.parseInt(parametersize)) throw new _abiParametersJs.BytesSizeMismatchError({
        expectedSize: Number.parseInt(parametersize),
        value
    });
    return {
        dynamic: false,
        encoded: _hexJs.padRight(value)
    };
}
function encodeBoolean(value) {
    if (typeof value !== 'boolean') throw new _errorsJs.BaseError(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
    return {
        dynamic: false,
        encoded: _hexJs.padLeft(_hexJs.fromBoolean(value))
    };
}
function encodeNumber(value, { signed, size }) {
    if (typeof size === 'number') {
        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;
        const min = signed ? -max - 1n : 0n;
        if (value > max || value < min) throw new _hexJs.IntegerOutOfRangeError({
            max: max.toString(),
            min: min.toString(),
            signed,
            size: size / 8,
            value: value.toString()
        });
    }
    return {
        dynamic: false,
        encoded: _hexJs.fromNumber(value, {
            size: 32,
            signed
        })
    };
}
function encodeString(value) {
    const hexValue = _hexJs.fromString(value);
    const partsLength = Math.ceil(_hexJs.size(hexValue) / 32);
    const parts = [];
    for(let i = 0; i < partsLength; i++)parts.push(_hexJs.padRight(_hexJs.slice(hexValue, i * 32, (i + 1) * 32)));
    return {
        dynamic: true,
        encoded: _hexJs.concat(_hexJs.padRight(_hexJs.fromNumber(_hexJs.size(hexValue), {
            size: 32
        })), ...parts)
    };
}
function encodeTuple(value, options) {
    const { checksumAddress, parameter } = options;
    let dynamic = false;
    const preparedParameters = [];
    for(let i = 0; i < parameter.components.length; i++){
        const param_ = parameter.components[i];
        const index = Array.isArray(value) ? i : param_.name;
        const preparedParam = prepareParameter({
            checksumAddress,
            parameter: param_,
            value: value[index]
        });
        preparedParameters.push(preparedParam);
        if (preparedParam.dynamic) dynamic = true;
    }
    return {
        dynamic,
        encoded: dynamic ? encode(preparedParameters) : _hexJs.concat(...preparedParameters.map(({ encoded })=>encoded))
    };
}
function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? [
        matches[2] ? Number(matches[2]) : null,
        matches[1]
    ] : undefined;
}
function hasDynamicChild(param) {
    const { type } = param;
    if (type === 'string') return true;
    if (type === 'bytes') return true;
    if (type.endsWith('[]')) return true;
    if (type === 'tuple') return param.components?.some(hasDynamicChild);
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents && hasDynamicChild({
        ...param,
        type: arrayComponents[1]
    })) return true;
    return false;
}

},{"../AbiParameters.js":"7FDSM","../Address.js":"2a10M","../Bytes.js":"grkDP","../Errors.js":"d3pbB","../Hex.js":"bkNyt","../Solidity.js":"eu9RI","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"z0Yvm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/** @internal */ parcelHelpers.export(exports, "create", ()=>create);
/** @internal */ parcelHelpers.export(exports, "NegativeOffsetError", ()=>NegativeOffsetError);
/** @internal */ parcelHelpers.export(exports, "PositionOutOfBoundsError", ()=>PositionOutOfBoundsError);
/** @internal */ parcelHelpers.export(exports, "RecursiveReadLimitExceededError", ()=>RecursiveReadLimitExceededError);
var _errorsJs = require("../Errors.js");
const staticCursor = /*#__PURE__*/ {
    bytes: new Uint8Array(),
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: new Map(),
    recursiveReadCount: 0,
    recursiveReadLimit: Number.POSITIVE_INFINITY,
    assertReadLimit () {
        if (this.recursiveReadCount >= this.recursiveReadLimit) throw new RecursiveReadLimitExceededError({
            count: this.recursiveReadCount + 1,
            limit: this.recursiveReadLimit
        });
    },
    assertPosition (position) {
        if (position < 0 || position > this.bytes.length - 1) throw new PositionOutOfBoundsError({
            length: this.bytes.length,
            position
        });
    },
    decrementPosition (offset) {
        if (offset < 0) throw new NegativeOffsetError({
            offset
        });
        const position = this.position - offset;
        this.assertPosition(position);
        this.position = position;
    },
    getReadCount (position) {
        return this.positionReadCount.get(position || this.position) || 0;
    },
    incrementPosition (offset) {
        if (offset < 0) throw new NegativeOffsetError({
            offset
        });
        const position = this.position + offset;
        this.assertPosition(position);
        this.position = position;
    },
    inspectByte (position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
    },
    inspectBytes (length, position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + length - 1);
        return this.bytes.subarray(position, position + length);
    },
    inspectUint8 (position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
    },
    inspectUint16 (position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 1);
        return this.dataView.getUint16(position);
    },
    inspectUint24 (position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 2);
        return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
    },
    inspectUint32 (position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 3);
        return this.dataView.getUint32(position);
    },
    pushByte (byte) {
        this.assertPosition(this.position);
        this.bytes[this.position] = byte;
        this.position++;
    },
    pushBytes (bytes) {
        this.assertPosition(this.position + bytes.length - 1);
        this.bytes.set(bytes, this.position);
        this.position += bytes.length;
    },
    pushUint8 (value) {
        this.assertPosition(this.position);
        this.bytes[this.position] = value;
        this.position++;
    },
    pushUint16 (value) {
        this.assertPosition(this.position + 1);
        this.dataView.setUint16(this.position, value);
        this.position += 2;
    },
    pushUint24 (value) {
        this.assertPosition(this.position + 2);
        this.dataView.setUint16(this.position, value >> 8);
        this.dataView.setUint8(this.position + 2, value & 255);
        this.position += 3;
    },
    pushUint32 (value) {
        this.assertPosition(this.position + 3);
        this.dataView.setUint32(this.position, value);
        this.position += 4;
    },
    readByte () {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectByte();
        this.position++;
        return value;
    },
    readBytes (length, size) {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectBytes(length);
        this.position += size ?? length;
        return value;
    },
    readUint8 () {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint8();
        this.position += 1;
        return value;
    },
    readUint16 () {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint16();
        this.position += 2;
        return value;
    },
    readUint24 () {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint24();
        this.position += 3;
        return value;
    },
    readUint32 () {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint32();
        this.position += 4;
        return value;
    },
    get remaining () {
        return this.bytes.length - this.position;
    },
    setPosition (position) {
        const oldPosition = this.position;
        this.assertPosition(position);
        this.position = position;
        return ()=>this.position = oldPosition;
    },
    _touch () {
        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
        const count = this.getReadCount();
        this.positionReadCount.set(this.position, count + 1);
        if (count > 0) this.recursiveReadCount++;
    }
};
function create(bytes, { recursiveReadLimit = 8192 } = {}) {
    const cursor = Object.create(staticCursor);
    cursor.bytes = bytes;
    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    cursor.positionReadCount = new Map();
    cursor.recursiveReadLimit = recursiveReadLimit;
    return cursor;
}
class NegativeOffsetError extends _errorsJs.BaseError {
    constructor({ offset }){
        super(`Offset \`${offset}\` cannot be negative.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Cursor.NegativeOffsetError'
        });
    }
}
class PositionOutOfBoundsError extends _errorsJs.BaseError {
    constructor({ length, position }){
        super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Cursor.PositionOutOfBoundsError'
        });
    }
}
class RecursiveReadLimitExceededError extends _errorsJs.BaseError {
    constructor({ count, limit }){
        super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Cursor.RecursiveReadLimitExceededError'
        });
    }
}

},{"../Errors.js":"d3pbB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gaPHr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * ABI-decodes function arguments according to the ABI Item's input types (`inputs`).
 *
 * @example
 * ```ts twoslash
 * import { AbiFunction } from 'ox'
 *
 * const approve = AbiFunction.from('function approve(address, uint256)')
 *
 * const data = AbiFunction.encodeData(
 *   approve,
 *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]
 * )
 * // '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'
 *
 * const input = AbiFunction.decodeData(approve, data) // [!code focus]
 * // @log: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]
 * ```
 *
 * @param abiFunction - The ABI Item to decode.
 * @param data - The data to decode.
 */ parcelHelpers.export(exports, "decodeData", ()=>decodeData);
/**
 * ABI-decodes a function's result according to the ABI Item's output types (`outputs`).
 *
 * :::tip
 *
 * This function is typically used to decode contract function return values (e.g. the response of an `eth_call` or the `input` property of a Transaction).
 *
 * See the [End-to-end Example](#end-to-end).
 *
 * :::
 *
 * @example
 * ```ts twoslash
 * import { AbiFunction } from 'ox'
 *
 * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'
 *
 * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')
 *
 * const output = AbiFunction.decodeResult(totalSupply, data)
 * // @log: 42n
 * ```
 *
 * @example
 * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:
 *
 * ```ts twoslash
 * // @noErrors
 * import { Abi, AbiFunction } from 'ox'
 *
 * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'
 *
 * const erc20Abi = Abi.from([...]) // [!code hl]
 * const totalSupply = AbiFunction.fromAbi(erc20Abi, 'totalSupply') // [!code hl]
 *
 * const output = AbiFunction.decodeResult(totalSupply, data)
 * // @log: 42n
 * ```
 *
 * @example
 * ### End-to-end
 *
 * Below is an end-to-end example of using `AbiFunction.decodeResult` to decode the result of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).
 *
 * ```ts twoslash
 * import 'ox/window'
 * import { Abi, AbiFunction } from 'ox'
 *
 * // 1. Extract the Function from the Contract's ABI.
 * const abi = Abi.from([
 *   // ...
 *   {
 *     name: 'balanceOf',
 *     type: 'function',
 *     inputs: [{ name: 'account', type: 'address' }],
 *     outputs: [{ name: 'balance', type: 'uint256' }],
 *     stateMutability: 'view',
 *   },
 *   // ...
 * ])
 * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')
 *
 * // 2. Encode the Function Input.
 * const data = AbiFunction.encodeData(
 *   balanceOf,
 *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B']
 * )
 *
 * // 3. Perform the Contract Call.
 * const response = await window.ethereum!.request({
 *   method: 'eth_call',
 *   params: [
 *     {
 *       data,
 *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
 *     },
 *   ],
 * })
 *
 * // 4. Decode the Function Output. // [!code focus]
 * const balance = AbiFunction.decodeResult(balanceOf, response) // [!code focus]
 * // @log: 42n
 * ```
 *
 * :::note
 *
 * For simplicity, the above example uses `window.ethereum.request`, but you can use any
 * type of JSON-RPC interface.
 *
 * :::
 *
 * @param abiFunction - ABI Function to decode
 * @param data - ABI-encoded function output
 * @param options - Decoding options
 * @returns Decoded function output
 */ parcelHelpers.export(exports, "decodeResult", ()=>decodeResult);
/**
 * ABI-encodes function arguments (`inputs`), prefixed with the 4 byte function selector.
 *
 * :::tip
 *
 * This function is typically used to encode a contract function and its arguments for contract calls (e.g. `data` parameter of an `eth_call` or `eth_sendTransaction`).
 *
 * See the [End-to-end Example](#end-to-end).
 *
 * :::
 *
 * @example
 * ```ts twoslash
 * import { AbiFunction } from 'ox'
 *
 * const approve = AbiFunction.from('function approve(address, uint256)')
 *
 * const data = AbiFunction.encodeData( // [!code focus]
 *   approve, // [!code focus]
 *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n] // [!code focus]
 * ) // [!code focus]
 * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'
 * ```
 *
 * @example
 * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:
 *
 * ```ts twoslash
 * // @noErrors
 * import { Abi, AbiFunction } from 'ox'
 *
 * const erc20Abi = Abi.from([...]) // [!code hl]
 * const approve = AbiFunction.fromAbi(erc20Abi, 'approve') // [!code hl]
 *
 * const data = AbiFunction.encodeData(
 *   approve,
 *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]
 * )
 * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'
 * ```
 *
 * @example
 * ### End-to-end
 *
 * Below is an end-to-end example of using `AbiFunction.encodeData` to encode the input of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).
 *
 * ```ts twoslash
 * import 'ox/window'
 * import { Abi, AbiFunction } from 'ox'
 *
 * // 1. Extract the Function from the Contract's ABI.
 * const abi = Abi.from([
 *   // ...
 *   {
 *     name: 'balanceOf',
 *     type: 'function',
 *     inputs: [{ name: 'account', type: 'address' }],
 *     outputs: [{ name: 'balance', type: 'uint256' }],
 *     stateMutability: 'view',
 *   },
 *   // ...
 * ])
 * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')
 *
 * // 2. Encode the Function Input. // [!code focus]
 * const data = AbiFunction.encodeData( // [!code focus]
 *   balanceOf, // [!code focus]
 *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B'] // [!code focus]
 * ) // [!code focus]
 *
 * // 3. Perform the Contract Call.
 * const response = await window.ethereum!.request({
 *   method: 'eth_call',
 *   params: [
 *     {
 *       data,
 *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',
 *     },
 *   ],
 * })
 *
 * // 4. Decode the Function Output.
 * const balance = AbiFunction.decodeResult(balanceOf, response)
 * ```
 *
 * :::note
 *
 * For simplicity, the above example uses `window.ethereum.request`, but you can use any
 * type of JSON-RPC interface.
 *
 * :::
 *
 * @param abiFunction - ABI Function to encode
 * @param args - Function arguments
 * @returns ABI-encoded function name and arguments
 */ parcelHelpers.export(exports, "encodeData", ()=>encodeData);
/**
 * ABI-encodes a function's result (`outputs`).
 *
 * @example
 * ```ts twoslash
 * import { AbiFunction } from 'ox'
 *
 * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')
 * const output = AbiFunction.decodeResult(totalSupply, '0x000000000000000000000000000000000000000000000000000000000000002a')
 * // 42n
 *
 * const data = AbiFunction.encodeResult(totalSupply, 42n) // [!code focus]
 * // @log: '0x000000000000000000000000000000000000000000000000000000000000002a'
 * ```
 *
 * @param abiFunction - The ABI item to encode the function output for.
 * @param output - The function output to encode.
 * @param options - Encoding options.
 * @returns The encoded function output.
 */ parcelHelpers.export(exports, "encodeResult", ()=>encodeResult);
/**
 * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.
 *
 * @example
 * ```ts twoslash
 * import { AbiFunction } from 'ox'
 *
 * const formatted = AbiFunction.format({
 *   type: 'function',
 *   name: 'approve',
 *   stateMutability: 'nonpayable',
 *   inputs: [
 *     {
 *       name: 'spender',
 *       type: 'address',
 *     },
 *     {
 *       name: 'amount',
 *       type: 'uint256',
 *     },
 *   ],
 *   outputs: [{ type: 'bool' }],
 * })
 *
 * formatted
 * //    ^?
 *
 *
 * ```
 *
 * @param abiFunction - The ABI Function to format.
 * @returns The formatted ABI Function.
 */ parcelHelpers.export(exports, "format", ()=>format);
/**
 * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.
 *
 * @example
 * ### JSON ABIs
 *
 * ```ts twoslash
 * import { AbiFunction } from 'ox'
 *
 * const approve = AbiFunction.from({
 *   type: 'function',
 *   name: 'approve',
 *   stateMutability: 'nonpayable',
 *   inputs: [
 *     {
 *       name: 'spender',
 *       type: 'address',
 *     },
 *     {
 *       name: 'amount',
 *       type: 'uint256',
 *     },
 *   ],
 *   outputs: [{ type: 'bool' }],
 * })
 *
 * approve
 * //^?
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * ```
 *
 * @example
 * ### Human Readable ABIs
 *
 * A Human Readable ABI can be parsed into a typed ABI object:
 *
 * ```ts twoslash
 * import { AbiFunction } from 'ox'
 *
 * const approve = AbiFunction.from(
 *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]
 * )
 *
 * approve
 * //^?
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * ```
 *
 * @example
 * It is possible to specify `struct`s along with your definitions:
 *
 * ```ts twoslash
 * import { AbiFunction } from 'ox'
 *
 * const approve = AbiFunction.from([
 *   'struct Foo { address spender; uint256 amount; }', // [!code hl]
 *   'function approve(Foo foo) returns (bool)',
 * ])
 *
 * approve
 * //^?
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * ```
 *
 *
 *
 * @param abiFunction - The ABI Function to parse.
 * @returns Typed ABI Function.
 */ parcelHelpers.export(exports, "from", ()=>from);
/**
 * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.
 *
 * @example
 * ### Extracting by Name
 *
 * ABI Functions can be extracted by their name using the `name` option:
 *
 * ```ts twoslash
 * import { Abi, AbiFunction } from 'ox'
 *
 * const abi = Abi.from([
 *   'function foo()',
 *   'event Transfer(address owner, address to, uint256 tokenId)',
 *   'function bar(string a) returns (uint256 x)',
 * ])
 *
 * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]
 * //    ^?
 *
 *
 *
 *
 *
 *
 * ```
 *
 * @example
 * ### Extracting by Selector
 *
 * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.
 *
 * ```ts twoslash
 * import { Abi, AbiFunction } from 'ox'
 *
 * const abi = Abi.from([
 *   'function foo()',
 *   'event Transfer(address owner, address to, uint256 tokenId)',
 *   'function bar(string a) returns (uint256 x)',
 * ])
 * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]
 * //    ^?
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * ```
 *
 * :::note
 *
 * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or
 * from a Transaction `input`.
 *
 * :::
 *
 * @param abi - The ABI to extract from.
 * @param name - The name (or selector) of the ABI item to extract.
 * @param options - Extraction options.
 * @returns The ABI item.
 */ parcelHelpers.export(exports, "fromAbi", ()=>fromAbi);
/**
 * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.
 *
 * Useful for computing function selectors for calldata.
 *
 * @example
 * ```ts twoslash
 * import { AbiFunction } from 'ox'
 *
 * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')
 * // @log: '0x6352211e'
 * ```
 *
 * @example
 * ```ts twoslash
 * import { AbiFunction } from 'ox'
 *
 * const selector = AbiFunction.getSelector({
 *   inputs: [{ type: 'uint256' }],
 *   name: 'ownerOf',
 *   outputs: [],
 *   stateMutability: 'view',
 *   type: 'function'
 * })
 * // @log: '0x6352211e'
 * ```
 *
 * @param abiItem - The ABI item to compute the selector for.
 * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.
 */ parcelHelpers.export(exports, "getSelector", ()=>getSelector);
var _abitype = require("abitype");
var _abiItemJs = require("./AbiItem.js");
var _abiParametersJs = require("./AbiParameters.js");
var _hexJs = require("./Hex.js");
function decodeData(abiFunction, data) {
    const { overloads } = abiFunction;
    if (_hexJs.size(data) < 4) throw new _abiItemJs.InvalidSelectorSizeError({
        data
    });
    if (abiFunction.inputs.length === 0) return undefined;
    const item = overloads ? fromAbi([
        abiFunction,
        ...overloads
    ], data) : abiFunction;
    if (_hexJs.size(data) <= 4) return undefined;
    return _abiParametersJs.decode(item.inputs, _hexJs.slice(data, 4));
}
function decodeResult(abiFunction, data, options = {}) {
    const values = _abiParametersJs.decode(abiFunction.outputs, data, options);
    if (values && Object.keys(values).length === 0) return undefined;
    if (values && Object.keys(values).length === 1) {
        if (Array.isArray(values)) return values[0];
        return Object.values(values)[0];
    }
    return values;
}
function encodeData(abiFunction, ...args) {
    const { overloads } = abiFunction;
    const item = overloads ? fromAbi([
        abiFunction,
        ...overloads
    ], abiFunction.name, {
        args: args[0]
    }) : abiFunction;
    const selector = getSelector(item);
    const data = args.length > 0 ? _abiParametersJs.encode(item.inputs, args[0]) : undefined;
    return data ? _hexJs.concat(selector, data) : selector;
}
function encodeResult(abiFunction, output, options = {}) {
    const { as = 'Array' } = options;
    const values = (()=>{
        if (abiFunction.outputs.length === 1) return [
            output
        ];
        if (Array.isArray(output)) return output;
        if (as === 'Object') return Object.values(output);
        return [
            output
        ];
    })();
    return _abiParametersJs.encode(abiFunction.outputs, values);
}
function format(abiFunction) {
    return _abitype.formatAbiItem(abiFunction);
}
function from(abiFunction, options = {}) {
    return _abiItemJs.from(abiFunction, options);
}
function fromAbi(abi, name, options) {
    const item = _abiItemJs.fromAbi(abi, name, options);
    if (item.type !== 'function') throw new _abiItemJs.NotFoundError({
        name,
        type: 'function'
    });
    return item;
}
function getSelector(abiItem) {
    return _abiItemJs.getSelector(abiItem);
}

},{"abitype":"6tgJn","./AbiItem.js":"eEoef","./AbiParameters.js":"7FDSM","./Hex.js":"bkNyt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gjADG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "entryPoint06Address", ()=>entryPoint06Address);
parcelHelpers.export(exports, "entryPoint07Address", ()=>entryPoint07Address);
parcelHelpers.export(exports, "entryPoint08Address", ()=>entryPoint08Address);
parcelHelpers.export(exports, "ethAddress", ()=>ethAddress);
parcelHelpers.export(exports, "zeroAddress", ()=>zeroAddress);
const entryPoint06Address = '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789';
const entryPoint07Address = '0x0000000071727De22E5E9d8BAf0edAc6f37da032';
const entryPoint08Address = '0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108';
const ethAddress = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
const zeroAddress = '0x0000000000000000000000000000000000000000';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"41IZo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Verify that a message was signed by the provided address.
 *
 * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).
 *
 * - Docs {@link https://viem.sh/docs/actions/public/verifyMessage}
 *
 * @param client - Client to use.
 * @param parameters - {@link VerifyMessageParameters}
 * @returns Whether or not the signature is valid. {@link VerifyMessageReturnType}
 */ parcelHelpers.export(exports, "verifyMessage", ()=>verifyMessage);
var _hashMessageJs = require("../../utils/signature/hashMessage.js");
var _verifyHashJs = require("./verifyHash.js");
async function verifyMessage(client, { address, message, factory, factoryData, signature, ...callRequest }) {
    const hash = (0, _hashMessageJs.hashMessage)(message);
    return (0, _verifyHashJs.verifyHash)(client, {
        address,
        factory: factory,
        factoryData: factoryData,
        hash,
        signature,
        ...callRequest
    });
}

},{"../../utils/signature/hashMessage.js":"5oFnZ","./verifyHash.js":"hWvvl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hWvvl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Verifies a message hash onchain using ERC-6492.
 *
 * @param client - Client to use.
 * @param parameters - {@link VerifyHashParameters}
 * @returns Whether or not the signature is valid. {@link VerifyHashReturnType}
 */ parcelHelpers.export(exports, "verifyHash", ()=>verifyHash);
var _abisJs = require("../../constants/abis.js");
var _contractsJs = require("../../constants/contracts.js");
var _contractJs = require("../../errors/contract.js");
var _encodeDeployDataJs = require("../../utils/abi/encodeDeployData.js");
var _getAddressJs = require("../../utils/address/getAddress.js");
var _isAddressEqualJs = require("../../utils/address/isAddressEqual.js");
var _isHexJs = require("../../utils/data/isHex.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _getActionJs = require("../../utils/getAction.js");
var _indexJs = require("../../utils/index.js");
var _isErc6492SignatureJs = require("../../utils/signature/isErc6492Signature.js");
var _recoverAddressJs = require("../../utils/signature/recoverAddress.js");
var _serializeErc6492SignatureJs = require("../../utils/signature/serializeErc6492Signature.js");
var _serializeSignatureJs = require("../../utils/signature/serializeSignature.js");
var _callJs = require("./call.js");
async function verifyHash(client, parameters) {
    const { address, factory, factoryData, hash, signature, universalSignatureVerifierAddress = client.chain?.contracts?.universalSignatureVerifier?.address, ...rest } = parameters;
    const signatureHex = (()=>{
        if ((0, _isHexJs.isHex)(signature)) return signature;
        if (typeof signature === 'object' && 'r' in signature && 's' in signature) return (0, _serializeSignatureJs.serializeSignature)(signature);
        return (0, _toHexJs.bytesToHex)(signature);
    })();
    const wrappedSignature = await (async ()=>{
        // If no `factory` or `factoryData` is provided, it is assumed that the
        // address is not a Smart Account, or the Smart Account is already deployed.
        if (!factory && !factoryData) return signatureHex;
        // If the signature is already wrapped, return the signature.
        if ((0, _isErc6492SignatureJs.isErc6492Signature)(signatureHex)) return signatureHex;
        // If the Smart Account is not deployed, wrap the signature with a 6492 wrapper
        // to perform counterfactual validation.
        return (0, _serializeErc6492SignatureJs.serializeErc6492Signature)({
            address: factory,
            data: factoryData,
            signature: signatureHex
        });
    })();
    try {
        const args = universalSignatureVerifierAddress ? {
            to: universalSignatureVerifierAddress,
            data: (0, _indexJs.encodeFunctionData)({
                abi: (0, _abisJs.universalSignatureValidatorAbi),
                functionName: 'isValidSig',
                args: [
                    address,
                    hash,
                    wrappedSignature
                ]
            }),
            ...rest
        } : {
            data: (0, _encodeDeployDataJs.encodeDeployData)({
                abi: (0, _abisJs.universalSignatureValidatorAbi),
                args: [
                    address,
                    hash,
                    wrappedSignature
                ],
                bytecode: (0, _contractsJs.universalSignatureValidatorByteCode)
            }),
            ...rest
        };
        const { data } = await (0, _getActionJs.getAction)(client, (0, _callJs.call), 'call')(args);
        return (0, _indexJs.hexToBool)(data ?? '0x0');
    } catch (error) {
        // Fallback attempt to verify the signature via ECDSA recovery.
        try {
            const verified = (0, _isAddressEqualJs.isAddressEqual)((0, _getAddressJs.getAddress)(address), await (0, _recoverAddressJs.recoverAddress)({
                hash,
                signature
            }));
            if (verified) return true;
        } catch  {}
        if (error instanceof (0, _contractJs.CallExecutionError)) // if the execution fails, the signature was not valid and an internal method inside of the validator reverted
        // this can happen for many reasons, for example if signer can not be recovered from the signature
        // or if the signature has no valid format
        return false;
        throw error;
    }
}

},{"../../constants/abis.js":"ffwQK","../../constants/contracts.js":"3uCwC","../../errors/contract.js":"1S92K","../../utils/abi/encodeDeployData.js":"55weO","../../utils/address/getAddress.js":"aGHEi","../../utils/address/isAddressEqual.js":"lW8Gp","../../utils/data/isHex.js":"evOcm","../../utils/encoding/toHex.js":"9GFC6","../../utils/getAction.js":"d1Bvd","../../utils/index.js":"ceNVN","../../utils/signature/isErc6492Signature.js":"gaUAz","../../utils/signature/recoverAddress.js":"gBtnk","../../utils/signature/serializeErc6492Signature.js":"4KJdz","../../utils/signature/serializeSignature.js":"3zSx4","./call.js":"85xZD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3zSx4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Converts a signature into hex format.
 *
 * @param signature The signature to convert.
 * @returns The signature in hex format.
 *
 * @example
 * serializeSignature({
 *   r: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf',
 *   s: '0x4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8',
 *   yParity: 1
 * })
 * // "0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c"
 */ parcelHelpers.export(exports, "serializeSignature", ()=>serializeSignature);
var _secp256K1 = require("@noble/curves/secp256k1");
var _fromHexJs = require("../encoding/fromHex.js");
var _toBytesJs = require("../encoding/toBytes.js");
function serializeSignature({ r, s, to = 'hex', v, yParity }) {
    const yParity_ = (()=>{
        if (yParity === 0 || yParity === 1) return yParity;
        if (v && (v === 27n || v === 28n || v >= 35n)) return v % 2n === 0n ? 1 : 0;
        throw new Error('Invalid `v` or `yParity` value');
    })();
    const signature = `0x${new (0, _secp256K1.secp256k1).Signature((0, _fromHexJs.hexToBigInt)(r), (0, _fromHexJs.hexToBigInt)(s)).toCompactHex()}${yParity_ === 0 ? '1b' : '1c'}`;
    if (to === 'hex') return signature;
    return (0, _toBytesJs.hexToBytes)(signature);
}

},{"@noble/curves/secp256k1":"8NuVo","../encoding/fromHex.js":"kLfW5","../encoding/toBytes.js":"8cx1T","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8NuVo":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
/**
 * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).
 *
 * Seems to be rigid (not backdoored)
 * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).
 *
 * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
 * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
 * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
 * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const sha2_1 = require("b9e9aa0f228917dd");
const utils_1 = require("362802f5a451efcb");
const _shortw_utils_ts_1 = require("8a5ef77428763709");
const hash_to_curve_ts_1 = require("992867e7d1ef8b");
const modular_ts_1 = require("6a274edd04635854");
const utils_ts_1 = require("49209a65a14a4a44");
const weierstrass_ts_1 = require("4687d8e71912c9bd");
const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b)=>(a + b / _2n) / b;
/**
 * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */ function sqrtMod(y) {
    const P = secp256k1P;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = y * y * y % P; // x^3, 11
    const b3 = b2 * b2 * y % P; // x^7
    const b6 = (0, modular_ts_1.pow2)(b3, _3n, P) * b3 % P;
    const b9 = (0, modular_ts_1.pow2)(b6, _3n, P) * b3 % P;
    const b11 = (0, modular_ts_1.pow2)(b9, _2n, P) * b2 % P;
    const b22 = (0, modular_ts_1.pow2)(b11, _11n, P) * b11 % P;
    const b44 = (0, modular_ts_1.pow2)(b22, _22n, P) * b22 % P;
    const b88 = (0, modular_ts_1.pow2)(b44, _44n, P) * b44 % P;
    const b176 = (0, modular_ts_1.pow2)(b88, _88n, P) * b88 % P;
    const b220 = (0, modular_ts_1.pow2)(b176, _44n, P) * b44 % P;
    const b223 = (0, modular_ts_1.pow2)(b220, _3n, P) * b3 % P;
    const t1 = (0, modular_ts_1.pow2)(b223, _23n, P) * b22 % P;
    const t2 = (0, modular_ts_1.pow2)(t1, _6n, P) * b2 % P;
    const root = (0, modular_ts_1.pow2)(t2, _2n, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');
    return root;
}
const Fpk1 = (0, modular_ts_1.Field)(secp256k1P, undefined, undefined, {
    sqrt: sqrtMod
});
/**
 * secp256k1 curve, ECDSA and ECDH methods.
 *
 * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`
 *
 * @example
 * ```js
 * import { secp256k1 } from '@noble/curves/secp256k1';
 * const priv = secp256k1.utils.randomPrivateKey();
 * const pub = secp256k1.getPublicKey(priv);
 * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa
 * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available
 * const isValid = secp256k1.verify(sig, msg, pub) === true;
 * ```
 */ exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({
    a: _0n,
    b: BigInt(7),
    Fp: Fpk1,
    n: secp256k1N,
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    h: BigInt(1),
    lowS: true,
    endo: {
        // Endomorphism, see above
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: (k)=>{
            const n = secp256k1N;
            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
            const b2 = a1;
            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = (0, modular_ts_1.mod)(k - c1 * a1 - c2 * a2, n);
            let k2 = (0, modular_ts_1.mod)(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg) k1 = n - k1;
            if (k2neg) k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) throw new Error('splitScalar: Endomorphism failed, k=' + k);
            return {
                k1neg,
                k1,
                k2neg,
                k2
            };
        }
    }
}, sha2_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha2_1.sha256)(Uint8Array.from(tag, (c)=>c.charCodeAt(0)));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha2_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point)=>point.toRawBytes(true).slice(1);
const numTo32b = (n)=>(0, utils_ts_1.numberToBytesBE)(n, 32);
const modP = (x)=>(0, modular_ts_1.mod)(x, secp256k1P);
const modN = (x)=>(0, modular_ts_1.mod)(x, secp256k1N);
const Point = /* @__PURE__ */ (()=>exports.secp256k1.ProjectivePoint)();
const GmulAdd = (Q, a, b)=>Point.BASE.multiplyAndAddUnsafe(Q, a, b);
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside
    const scalar = p.hasEvenY() ? d_ : modN(-d_);
    return {
        scalar: scalar,
        bytes: pointToBytes(p)
    };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */ function lift_x(x) {
    (0, utils_ts_1.aInRange)('x', x, _1n, secp256k1P); // Fail if x  p.
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.
    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and
    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
const num = utils_ts_1.bytesToNumberBE;
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */ function challenge(...args) {
    return modN(num(taggedHash('BIP0340/challenge', ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */ function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */ function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
    const a = (0, utils_ts_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    const k_ = modN(num(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */ function schnorrVerify(signature, message, publicKey) {
    const sig = (0, utils_ts_1.ensureBytes)('signature', signature, 64);
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const pub = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, 32);
    try {
        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.
        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1P)) return false;
        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.
        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1N)) return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP
        if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.
    } catch (error) {
        return false;
    }
}
/**
 * Schnorr signatures over secp256k1.
 * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 * @example
 * ```js
 * import { schnorr } from '@noble/curves/secp256k1';
 * const priv = schnorr.utils.randomPrivateKey();
 * const pub = schnorr.getPublicKey(priv);
 * const msg = new TextEncoder().encode('hello');
 * const sig = schnorr.sign(msg, priv);
 * const isValid = schnorr.verify(sig, msg, pub);
 * ```
 */ exports.schnorr = (()=>({
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        utils: {
            randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
            lift_x,
            pointToBytes,
            numberToBytesBE: utils_ts_1.numberToBytesBE,
            bytesToNumberBE: utils_ts_1.bytesToNumberBE,
            taggedHash,
            mod: modular_ts_1.mod
        }
    }))();
const isoMap = /* @__PURE__ */ (()=>(0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
        // xNum
        [
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
            '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
            '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'
        ],
        // xDen
        [
            '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
            '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
            '0x0000000000000000000000000000000000000000000000000000000000000001'
        ],
        // yNum
        [
            '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
            '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
            '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
            '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'
        ],
        // yDen
        [
            '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
            '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
            '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
            '0x0000000000000000000000000000000000000000000000000000000000000001'
        ]
    ].map((i)=>i.map((j)=>BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (()=>(0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
        A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
        B: BigInt('1771'),
        Z: Fpk1.create(BigInt('-11'))
    }))();
/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */ exports.secp256k1_hasher = (()=>(0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars)=>{
        const { x, y } = mapSWU(Fpk1.create(scalars[0]));
        return isoMap(x, y);
    }, {
        DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
        encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
        p: Fpk1.ORDER,
        m: 1,
        k: 128,
        expand: 'xmd',
        hash: sha2_1.sha256
    }))();
exports.hashToCurve = (()=>exports.secp256k1_hasher.hashToCurve)();
exports.encodeToCurve = (()=>exports.secp256k1_hasher.encodeToCurve)();

},{"b9e9aa0f228917dd":"5Nc2s","362802f5a451efcb":"fuxLy","8a5ef77428763709":"aB8tU","992867e7d1ef8b":"7mgY5","6a274edd04635854":"1jGup","49209a65a14a4a44":"fc0Wi","4687d8e71912c9bd":"lULXb"}],"aB8tU":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getHash = getHash;
exports.createCurve = createCurve;
/**
 * Utilities for short weierstrass curves, combined with noble-hashes.
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const hmac_1 = require("2bb3ed73a71161e3");
const utils_1 = require("808050cc11f056c7");
const weierstrass_ts_1 = require("bceff96a5b87336d");
/** connects noble-curves to noble-hashes */ function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs)=>(0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
    };
}
function createCurve(curveDef, defHash) {
    const create = (hash)=>(0, weierstrass_ts_1.weierstrass)({
            ...curveDef,
            ...getHash(hash)
        });
    return {
        ...create(defHash),
        create
    };
}

},{"2bb3ed73a71161e3":"higgt","808050cc11f056c7":"fuxLy","bceff96a5b87336d":"lULXb"}],"higgt":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hmac = exports.HMAC = void 0;
/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */ const utils_ts_1 = require("337359ae358d0fc");
class HMAC extends utils_ts_1.Hash {
    constructor(hash, _key){
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for(let i = 0; i < pad.length; i++)pad[i] ^= 106;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
    }
    update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */ const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key)=>new HMAC(hash, key);

},{"337359ae358d0fc":"fuxLy"}],"lULXb":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DER = exports.DERErr = void 0;
exports.weierstrassPoints = weierstrassPoints;
exports.weierstrass = weierstrass;
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
/**
 * Short Weierstrass curve methods. The formula is: y = x + ax + b.
 *
 * ### Parameters
 *
 * To initialize a weierstrass curve, one needs to pass following params:
 *
 * * a: formula param
 * * b: formula param
 * * Fp: finite field of prime characteristic P; may be complex (Fp2). Arithmetics is done in field
 * * n: order of prime subgroup a.k.a total amount of valid curve points
 * * Gx: Base point (x, y) aka generator point. Gx = x coordinate
 * * Gy: ...y coordinate
 * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)
 * * lowS: whether to enable (default) or disable "low-s" non-malleable signatures
 *
 * ### Design rationale for types
 *
 * * Interaction between classes from different curves should fail:
 *   `k256.Point.BASE.add(p256.Point.BASE)`
 * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime
 * * Different calls of `curve()` would return different classes -
 *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,
 *   it won't affect others
 *
 * TypeScript can't infer types for classes created inside a function. Classes is one instance
 * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create
 * unique type for every function call.
 *
 * We can use generic types via some param, like curve opts, but that would:
 *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)
 *     which is hard to debug.
 *     2. Params can be generic and we can't enforce them to be constant value:
 *     if somebody creates curve from non-constant params,
 *     it would be allowed to interact with other curves with non-constant params
 *
 * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // prettier-ignore
const curve_ts_1 = require("11f68d725b0f6f5d");
// prettier-ignore
const modular_ts_1 = require("d8b1615c256fe3fa");
// prettier-ignore
const utils_ts_1 = require("aae491f09795d5ee");
function validateSigVerOpts(opts) {
    if (opts.lowS !== undefined) (0, utils_ts_1.abool)('lowS', opts.lowS);
    if (opts.prehash !== undefined) (0, utils_ts_1.abool)('prehash', opts.prehash);
}
function validatePointOpts(curve) {
    const opts = (0, curve_ts_1.validateBasic)(curve);
    (0, utils_ts_1.validateObject)(opts, {
        a: 'field',
        b: 'field'
    }, {
        allowInfinityPoint: 'boolean',
        allowedPrivateKeyLengths: 'array',
        clearCofactor: 'function',
        fromBytes: 'function',
        isTorsionFree: 'function',
        toBytes: 'function',
        wrapPrivateKey: 'boolean'
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) throw new Error('invalid endo: CURVE.a must be 0');
        if (typeof endo !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function');
    }
    return Object.freeze({
        ...opts
    });
}
class DERErr extends Error {
    constructor(m = ''){
        super(m);
    }
}
exports.DERErr = DERErr;
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */ exports.DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (tag, data)=>{
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');
            if (data.length & 1) throw new E('tlv.encode: unpadded data');
            const dataLen = data.length / 2;
            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
            if (len.length / 2 & 128) throw new E('tlv.encode: long form length too big');
            // length of length with long form flag
            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)(len.length / 2 | 128) : '';
            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
            return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode (tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');
            if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');
            const first = data[pos++];
            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
            let length = 0;
            if (!isLong) length = first;
            else {
                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                const lenLen = first & 127;
                if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');
                if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');
                if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');
                for (const b of lengthBytes)length = length << 8 | b;
                pos += lenLen;
                if (length < 128) throw new E('tlv.decode(long): not minimal encoding');
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length) throw new E('tlv.decode: wrong value length');
            return {
                v,
                l: data.subarray(pos + length)
            };
        }
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode (num) {
            const { Err: E } = exports.DER;
            if (num < _0n) throw new E('integer: negative integers are not allowed');
            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
            // Pad with zero byte if negative flag is present
            if (Number.parseInt(hex[0], 16) & 8) hex = '00' + hex;
            if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');
            return hex;
        },
        decode (data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128) throw new E('invalid signature integer: negative');
            if (data[0] === 0x00 && !(data[1] & 128)) throw new E('invalid signature integer: unnecessary leading zero');
            return (0, utils_ts_1.bytesToNumberBE)(data);
        }
    },
    toSig (hex) {
        // parse DER signature
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = (0, utils_ts_1.ensureBytes)('signature', hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
        if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');
        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
        if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');
        return {
            r: int.decode(rBytes),
            s: int.decode(sBytes)
        };
    },
    hexFromSig (sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs = tlv.encode(0x02, int.encode(sig.r));
        const ss = tlv.encode(0x02, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(0x30, seq);
    }
};
function numToSizedHex(num, size) {
    return (0, utils_ts_1.bytesToHex)((0, utils_ts_1.numberToBytesBE)(num, size));
}
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const Fn = (0, modular_ts_1.Field)(CURVE.n, CURVE.nBitLength);
    const toBytes = CURVE.toBytes || ((_c, point, _isCompressed)=>{
        const a = point.toAffine();
        return (0, utils_ts_1.concatBytes)(Uint8Array.from([
            0x04
        ]), Fp.toBytes(a.x), Fp.toBytes(a.y));
    });
    const fromBytes = CURVE.fromBytes || ((bytes)=>{
        // const head = bytes[0];
        const tail = bytes.subarray(1);
        // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return {
            x,
            y
        };
    });
    /**
     * y = x + ax + b: Short weierstrass curve formula. Takes x, returns y.
     * @returns y
     */ function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x + a * x + b
    }
    function isValidXY(x, y) {
        const left = Fp.sqr(y); // y
        const right = weierstrassEquation(x); // x + ax + b
        return Fp.eql(left, right);
    }
    // Validate whether the passed curve params are valid.
    // Test 1: equation y = x + ax + b should work for generator point.
    if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');
    // Test 2: discriminant  part should be non-zero: 4a + 27b != 0.
    // Guarantees curve is genus-1, smooth (non-singular).
    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
    if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, CURVE.n);
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
        if (lengths && typeof key !== 'bigint') {
            if ((0, utils_ts_1.isBytes)(key)) key = (0, utils_ts_1.bytesToHex)(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('invalid private key');
            key = key.padStart(nByteLength * 2, '0');
        }
        let num;
        try {
            num = typeof key === 'bigint' ? key : (0, utils_ts_1.bytesToNumberBE)((0, utils_ts_1.ensureBytes)('private key', key, nByteLength));
        } catch (error) {
            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);
        }
        if (wrapPrivateKey) num = (0, modular_ts_1.mod)(num, N); // disabled by default, enabled for BLS
        (0, utils_ts_1.aInRange)('private key', num, _1n, N); // num in range [1..N-1]
        return num;
    }
    function aprjpoint(other) {
        if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');
    }
    // Memoized toAffine / validity check. They are heavy. Points are immutable.
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (X, Y, Z)  (x=X/Z, y=Y/Z)
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz)=>{
        const { px: x, py: y, pz: z } = p;
        // Fast-path for normalized points
        if (Fp.eql(z, Fp.ONE)) return {
            x,
            y
        };
        const is0 = p.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0) return {
            x: Fp.ZERO,
            y: Fp.ZERO
        };
        if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');
        return {
            x: ax,
            y: ay
        };
    });
    // NOTE: on exception this will crash 'cached' and no value will be set.
    // Otherwise true will be return
    const assertValidMemo = (0, utils_ts_1.memoized)((p)=>{
        if (p.is0()) {
            // (0, 1, 0) aka ZERO is invalid in most contexts.
            // In BLS, ZERO can be serialized, so we allow it.
            // (0, 0, 0) is invalid representation of ZERO.
            if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;
            throw new Error('bad point: ZERO');
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        const { x, y } = p.toAffine();
        // Check if x, y are valid field elements
        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');
        if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');
        if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');
        return true;
    });
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (X, Y, Z)  (x=X/Z, y=Y/Z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */ class Point {
        constructor(px, py, pz){
            if (px == null || !Fp.isValid(px)) throw new Error('x required');
            if (py == null || !Fp.isValid(py) || Fp.is0(py)) throw new Error('y required');
            if (pz == null || !Fp.isValid(pz)) throw new Error('z required');
            this.px = px;
            this.py = py;
            this.pz = pz;
            Object.freeze(this);
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');
            if (p instanceof Point) throw new Error('projective point not allowed');
            const is0 = (i)=>Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y)) return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */ static normalizeZ(points) {
            const toInv = (0, modular_ts_1.FpInvertBatch)(Fp, points.map((p)=>p.pz));
            return points.map((p, i)=>p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */ static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // Multiscalar Multiplication
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            wnaf.setWindowSize(this, windowSize);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd) return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */ equals(other) {
            aprjpoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */ negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            aprjpoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, n, Point.normalizeZ);
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */ multiplyUnsafe(sc) {
            const { endo, n: N } = CURVE;
            (0, utils_ts_1.aInRange)('scalar', sc, _0n, N);
            const I = Point.ZERO;
            if (sc === _0n) return I;
            if (this.is0() || sc === _1n) return this;
            // Case a: no endomorphism. Case b: has precomputes.
            if (!endo || wnaf.hasPrecomputes(this)) return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);
            // Case c: endomorphism
            /** See docs for {@link EndomorphismOpts} */ let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
            let k1p = I;
            let k2p = I;
            let d = this;
            while(k1 > _0n || k2 > _0n){
                if (k1 & _1n) k1p = k1p.add(d);
                if (k2 & _1n) k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg) k1p = k1p.negate();
            if (k2neg) k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */ multiply(scalar) {
            const { endo, n: N } = CURVE;
            (0, utils_ts_1.aInRange)('scalar', scalar, _1n, N);
            let point, fake; // Fake point is used to const-time mult
            /** See docs for {@link EndomorphismOpts} */ if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            } else {
                const { p, f } = this.wNAF(scalar);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([
                point,
                fake
            ])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */ multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            )=>a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
            return toAffineMemo(this, iz);
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n) return true; // No subgroups, always torsion-free
            if (isTorsionFree) return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n) return this; // Fast-path
            if (clearCofactor) return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            (0, utils_ts_1.abool)('isCompressed', isCompressed);
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            (0, utils_ts_1.abool)('isCompressed', isCompressed);
            return (0, utils_ts_1.bytesToHex)(this.toRawBytes(isCompressed));
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    // zero / infinity / identity point
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0
    const { endo, nBitLength } = CURVE;
    const wnaf = (0, curve_ts_1.wNAF)(Point, endo ? Math.ceil(nBitLength / 2) : nBitLength);
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
    };
}
function validateOpts(curve) {
    const opts = (0, curve_ts_1.validateBasic)(curve);
    (0, utils_ts_1.validateObject)(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function'
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean'
    });
    return Object.freeze({
        lowS: true,
        ...opts
    });
}
/**
 * Creates short weierstrass curve and ECDSA signature methods for it.
 * @example
 * import { Field } from '@noble/curves/abstract/modular';
 * // Before that, define BigInt-s: a, b, p, n, Gx, Gy
 * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })
 */ function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER, nByteLength, nBitLength } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function modN(a) {
        return (0, modular_ts_1.mod)(a, CURVE_ORDER);
    }
    function invN(a) {
        return (0, modular_ts_1.invert)(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes (_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = utils_ts_1.concatBytes;
            (0, utils_ts_1.abool)('isCompressed', isCompressed);
            if (isCompressed) return cat(Uint8Array.from([
                point.hasEvenY() ? 0x02 : 0x03
            ]), x);
            else return cat(Uint8Array.from([
                0x04
            ]), x, Fp.toBytes(a.y));
        },
        fromBytes (bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = (0, utils_ts_1.bytesToNumberBE)(tail);
                if (!(0, utils_ts_1.inRange)(x, _1n, Fp.ORDER)) throw new Error('Point is not on curve');
                const y2 = weierstrassEquation(x); // y = x + ax + b
                let y;
                try {
                    y = Fp.sqrt(y2); // y = y ^ (p+1)/4
                } catch (sqrtError) {
                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                    throw new Error('Point is not on curve' + suffix);
                }
                const isYOdd = (y & _1n) === _1n;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd) y = Fp.neg(y);
                return {
                    x,
                    y
                };
            } else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return {
                    x,
                    y
                };
            } else {
                const cl = compressedLen;
                const ul = uncompressedLen;
                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);
            }
        }
    });
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to)=>(0, utils_ts_1.bytesToNumberBE)(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */ class Signature {
        constructor(r, s, recovery){
            (0, utils_ts_1.aInRange)('r', r, _1n, CURVE_ORDER); // r in [1..N]
            (0, utils_ts_1.aInRange)('s', s, _1n, CURVE_ORDER); // s in [1..N]
            this.r = r;
            this.s = s;
            if (recovery != null) this.recovery = recovery;
            Object.freeze(this);
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = nByteLength;
            hex = (0, utils_ts_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_ts_1.ensureBytes)('DER', hex));
            return new Signature(r, s);
        }
        /**
         * @todo remove
         * @deprecated
         */ assertValidity() {}
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![
                0,
                1,
                2,
                3
            ].includes(rec)) throw new Error('recovery id invalid');
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');
            const prefix = (rec & 1) === 0 ? '02' : '03';
            const R = Point.fromHex(prefix + numToSizedHex(radj, Fp.BYTES));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return (0, utils_ts_1.hexToBytes)(this.toDERHex());
        }
        toDERHex() {
            return exports.DER.hexFromSig(this);
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return (0, utils_ts_1.hexToBytes)(this.toCompactHex());
        }
        toCompactHex() {
            const l = nByteLength;
            return numToSizedHex(this.r, l) + numToSizedHex(this.s, l);
        }
    }
    const utils = {
        isValidPrivateKey (privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            } catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */ randomPrivateKey: ()=>{
            const length = (0, modular_ts_1.getMinHashLength)(CURVE.n);
            return (0, modular_ts_1.mapHashToField)(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */ precompute (windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        }
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */ function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */ function isProbPub(item) {
        if (typeof item === 'bigint') return false;
        if (item instanceof Point) return true;
        const arr = (0, utils_ts_1.ensureBytes)('key', item);
        const len = arr.length;
        const fpl = Fp.BYTES;
        const compLen = fpl + 1; // e.g. 33 for 32
        const uncompLen = 2 * fpl + 1; // e.g. 65 for 32
        if (CURVE.allowedPrivateKeyLengths || nByteLength === compLen) return undefined;
        else return len === compLen || len === uncompLen;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */ function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA) === true) throw new Error('first arg must be private key');
        if (isProbPub(publicB) === false) throw new Error('second arg must be public key');
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int || function(bytes) {
        // Our custom check "just in case", for protection against DoS
        if (bytes.length > 8192) throw new Error('input is too large');
        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
        // for some cases, since bytes.length * 8 is not actual bitLength.
        const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here
        const delta = bytes.length * 8 - nBitLength; // truncate to nBitLength leftmost bits
        return delta > 0 ? num >> BigInt(delta) : num;
    };
    const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes)); // can't use bytesToNumberBE here
    };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = (0, utils_ts_1.bitMask)(nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */ function int2octets(num) {
        (0, utils_ts_1.aInRange)('num < 2^' + nBitLength, num, _0n, ORDER_MASK);
        // works with order, can have different size than numToField!
        return (0, utils_ts_1.numberToBytesBE)(num, nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,
    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if ([
            'recovered',
            'canonical'
        ].some((k)=>k in opts)) throw new Error('sign() legacy options not supported');
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_ts_1.ensureBytes)('msgHash', msgHash);
        validateSigVerOpts(opts);
        if (prehash) msgHash = (0, utils_ts_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [
            int2octets(d),
            int2octets(h1int)
        ];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null && ent !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n) return;
            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n) return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return {
            seed,
            k2sig
        };
    }
    const defaultSigOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    const defaultVerOpts = {
        lowS: CURVE.lowS,
        prehash: false
    };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */ function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = (0, utils_ts_1.createHmacDrbg)(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1G - U2P
     *   mod(R.x, n) == r
     * ```
     */ function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_ts_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);
        const { lowS, prehash, format } = opts;
        // Verify opts, deduce signature format
        validateSigVerOpts(opts);
        if ('strict' in opts) throw new Error('options.strict was renamed to lowS');
        if (format !== undefined && format !== 'compact' && format !== 'der') throw new Error('format must be compact or der');
        const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex && !format && typeof sg === 'object' && sg !== null && typeof sg.r === 'bigint' && typeof sg.s === 'bigint';
        if (!isHex && !isObj) throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');
        let _sig = undefined;
        let P;
        try {
            if (isObj) _sig = new Signature(sg.r, sg.s);
            if (isHex) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    if (format !== 'compact') _sig = Signature.fromDER(sg);
                } catch (derError) {
                    if (!(derError instanceof exports.DER.Err)) throw derError;
                }
                if (!_sig && format !== 'der') _sig = Signature.fromCompact(sg);
            }
            P = Point.fromHex(publicKey);
        } catch (error) {
            return false;
        }
        if (!_sig) return false;
        if (lowS && _sig.hasHighS()) return false;
        if (prehash) msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P
        if (!R) return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
    };
}
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */ function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v)=>{
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for(let i = c1; i > _1n; i--){
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return {
            isValid: isQR,
            value: tv3
        };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v)=>{
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return {
                isValid: isQR,
                value: y
            }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */ function mapToCurveSimpleSWU(Fp, opts) {
    (0, modular_ts_1.validateField)(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u)=>{
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [
            tv4
        ], true)[0];
        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4
        return {
            x,
            y
        };
    };
}

},{"11f68d725b0f6f5d":"gtZZm","d8b1615c256fe3fa":"1jGup","aae491f09795d5ee":"fc0Wi"}],"gtZZm":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.wNAF = wNAF;
exports.pippenger = pippenger;
exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
exports.validateBasic = validateBasic;
/**
 * Methods for elliptic curve multiplication by scalars.
 * Contains wNAF, pippenger
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const modular_ts_1 = require("72c8f755a25fddc3");
const utils_ts_1 = require("f90fcba6ea31de55");
const _0n = BigInt(0);
const _1n = BigInt(1);
function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);
}
function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero
    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero
    const maxNumber = 2 ** W; // W=8 256
    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111
    const shiftBy = BigInt(W); // W=8 8
    return {
        windows,
        windowSize,
        mask,
        maxNumber,
        shiftBy
    };
}
function calcOffsets(n, window, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask); // extract W bits.
    let nextN = n >> shiftBy; // shift number by W bits.
    // What actually happens here:
    // const highestBit = Number(mask ^ (mask >> 1n));
    // let wbits2 = wbits - 1; // skip zero
    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);
    // split if bits > max: +224 => 256-32
    if (wbits > windowSize) {
        // we skip zero, which means instead of `>= size-1`, we do `> size`
        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.
        nextN += _1n; // +256 (carry)
    }
    const offsetStart = window * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero
    const isZero = wbits === 0; // is current window slice a 0?
    const isNeg = wbits < 0; // is current window slice negative?
    const isNegF = window % 2 !== 0; // fake random statement for noise
    const offsetF = offsetStart; // fake offset for noise
    return {
        nextN,
        offset,
        isZero,
        isNeg,
        isNegF,
        offsetF
    };
}
function validateMSMPoints(points, c) {
    if (!Array.isArray(points)) throw new Error('array expected');
    points.forEach((p, i)=>{
        if (!(p instanceof c)) throw new Error('invalid point at index ' + i);
    });
}
function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars)) throw new Error('array of scalars expected');
    scalars.forEach((s, i)=>{
        if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);
    });
}
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes.
// Allows to make points frozen / immutable.
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap();
function getW(P) {
    return pointWindowSizes.get(P) || 1;
}
/**
 * Elliptic curve multiplication of Point by scalar. Fragile.
 * Scalars should always be less than curve order: this should be checked inside of a curve itself.
 * Creates precomputation tables for fast multiplication:
 * - private scalar is split by fixed size windows of W bits
 * - every window point is collected from window's table & added to accumulator
 * - since windows are different, same point inside tables won't be accessed more than once per calc
 * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
 * - +1 window is neccessary for wNAF
 * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
 *
 * @todo Research returning 2d JS array of windows, instead of a single window.
 * This would allow windows to be in different memory locations
 */ function wNAF(c, bits) {
    return {
        constTimeNegate,
        hasPrecomputes (elm) {
            return getW(elm) !== 1;
        },
        // non-const time multiplication ladder
        unsafeLadder (elm, n, p = c.ZERO) {
            let d = elm;
            while(n > _0n){
                if (n & _1n) p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @param elm Point instance
         * @param W window size
         * @returns precomputed point tables flattened to a single array
         */ precomputeWindow (elm, W) {
            const { windows, windowSize } = calcWOpts(W, bits);
            const points = [];
            let p = elm;
            let base = p;
            for(let window = 0; window < windows; window++){
                base = p;
                points.push(base);
                // i=1, bc we skip 0
                for(let i = 1; i < windowSize; i++){
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */ wNAF (W, precomputes, n) {
            // Smaller version:
            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
            // TODO: check the scalar is less than group order?
            // wNAF behavior is undefined otherwise. But have to carefully remove
            // other checks before wNAF. ORDER == bits here.
            // Accumulators
            let p = c.ZERO;
            let f = c.BASE;
            // This code was first written with assumption that 'f' and 'p' will never be infinity point:
            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
            // there is negate now: it is possible that negated element from low value
            // would be the same as high element, which will create carry into next window.
            // It's not obvious how this can fail, but still worth investigating later.
            const wo = calcWOpts(W, bits);
            for(let window = 0; window < wo.windows; window++){
                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise
                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
                n = nextN;
                if (isZero) // bits are 0: add garbage to fake point
                // Important part for const-time getPublicKey: add random "noise" point to f.
                f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));
                else // bits are 1: add to result point
                p = p.add(constTimeNegate(isNeg, precomputes[offset]));
            }
            // Return both real and fake points: JIT won't eliminate f.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return {
                p,
                f
            };
        },
        /**
         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @param acc accumulator point to add result of multiplication
         * @returns point
         */ wNAFUnsafe (W, precomputes, n, acc = c.ZERO) {
            const wo = calcWOpts(W, bits);
            for(let window = 0; window < wo.windows; window++){
                if (n === _0n) break; // Early-exit, skip 0 value
                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);
                n = nextN;
                if (isZero) continue;
                else {
                    const item = precomputes[offset];
                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM
                }
            }
            return acc;
        },
        getPrecomputes (W, P, transform) {
            // Calculate precomputes on a first run, reuse them after
            let comp = pointPrecomputes.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) pointPrecomputes.set(P, transform(comp));
            }
            return comp;
        },
        wNAFCached (P, n, transform) {
            const W = getW(P);
            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);
        },
        wNAFCachedUnsafe (P, n, transform, prev) {
            const W = getW(P);
            if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster
            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize (P, W) {
            validateW(W, bits);
            pointWindowSizes.set(P, W);
            pointPrecomputes.delete(P);
        }
    };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster than precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka private keys / bigints)
 */ function pippenger(c, fieldN, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength) throw new Error('arrays of points and scalars must have equal length');
    // if (plength === 0) throw new Error('array must be of length >= 2');
    const zero = c.ZERO;
    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
    let windowSize = 1; // bits
    if (wbits > 12) windowSize = wbits - 3;
    else if (wbits > 4) windowSize = wbits - 2;
    else if (wbits > 0) windowSize = 2;
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for(let i = lastBits; i >= 0; i -= windowSize){
        buckets.fill(zero);
        for(let j = 0; j < slength; j++){
            const scalar = scalars[j];
            const wbits = Number(scalar >> BigInt(i) & MASK);
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = zero; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();
    }
    return sum;
}
/**
 * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @returns function which multiplies points with scaars
 */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
    /**
     * Performance Analysis of Window-based Precomputation
     *
     * Base Case (256-bit scalar, 8-bit window):
     * - Standard precomputation requires:
     *   - 31 additions per scalar  256 scalars = 7,936 ops
     *   - Plus 255 summary additions = 8,191 total ops
     *   Note: Summary additions can be optimized via accumulator
     *
     * Chunked Precomputation Analysis:
     * - Using 32 chunks requires:
     *   - 255 additions per chunk
     *   - 256 doublings
     *   - Total: (255  32) + 256 = 8,416 ops
     *
     * Memory Usage Comparison:
     * Window Size | Standard Points | Chunked Points
     * ------------|-----------------|---------------
     *     4-bit   |     520         |      15
     *     8-bit   |    4,224        |     255
     *    10-bit   |   13,824        |   1,023
     *    16-bit   |  557,056        |  65,535
     *
     * Key Advantages:
     * 1. Enables larger window sizes due to reduced memory overhead
     * 2. More efficient for smaller scalar counts:
     *    - 16 chunks: (16  255) + 256 = 4,336 ops
     *    - ~2x faster than standard 8,191 ops
     *
     * Limitations:
     * - Not suitable for plain precomputes (requires 256 constant doublings)
     * - Performance degrades with larger scalar counts:
     *   - Optimal for ~256 scalars
     *   - Less efficient for 4096+ scalars (Pippenger preferred)
     */ validateW(windowSize, fieldN.BITS);
    validateMSMPoints(points, c);
    const zero = c.ZERO;
    const tableSize = 2 ** windowSize - 1; // table size (without zero)
    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const tables = points.map((p)=>{
        const res = [];
        for(let i = 0, acc = p; i < tableSize; i++){
            res.push(acc);
            acc = acc.add(p);
        }
        return res;
    });
    return (scalars)=>{
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length) throw new Error('array of scalars must be smaller than array of points');
        let res = zero;
        for(let i = 0; i < chunks; i++){
            // No need to double if accumulator is still zero.
            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();
            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
            for(let j = 0; j < scalars.length; j++){
                const n = scalars[j];
                const curr = Number(n >> shiftBy & MASK);
                if (!curr) continue; // skip zero scalars chunks
                res = res.add(tables[j][curr - 1]);
            }
        }
        return res;
    };
}
function validateBasic(curve) {
    (0, modular_ts_1.validateField)(curve.Fp);
    (0, utils_ts_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field'
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger'
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        p: curve.Fp.ORDER
    });
}

},{"72c8f755a25fddc3":"1jGup","f90fcba6ea31de55":"fc0Wi"}],"1jGup":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isNegativeLE = void 0;
exports.mod = mod;
exports.pow = pow;
exports.pow2 = pow2;
exports.invert = invert;
exports.tonelliShanks = tonelliShanks;
exports.FpSqrt = FpSqrt;
exports.validateField = validateField;
exports.FpPow = FpPow;
exports.FpInvertBatch = FpInvertBatch;
exports.FpDiv = FpDiv;
exports.FpLegendre = FpLegendre;
exports.FpIsSquare = FpIsSquare;
exports.nLength = nLength;
exports.Field = Field;
exports.FpSqrtOdd = FpSqrtOdd;
exports.FpSqrtEven = FpSqrtEven;
exports.hashToPrivateScalar = hashToPrivateScalar;
exports.getFieldBytesLength = getFieldBytesLength;
exports.getMinHashLength = getMinHashLength;
exports.mapHashToField = mapHashToField;
/**
 * Utils for modular division and finite fields.
 * A finite field over 11 is integer number operations `mod 11`.
 * There is no division: it is replaced by modular multiplicative inverse.
 * @module
 */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const utils_1 = require("4dab0c60690648d");
const utils_ts_1 = require("d8ac4b6c79c60614");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);
// prettier-ignore
const _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * TODO: remove.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */ function pow(num, power, modulo) {
    return FpPow(Field(modulo), num, power);
}
/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {
    let res = x;
    while(power-- > _0n){
        res *= res;
        res %= modulo;
    }
    return res;
}
/**
 * Inverses number over modulo.
 * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
 */ function invert(number, modulo) {
    if (number === _0n) throw new Error('invert: expected non-zero number');
    if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n) throw new Error('invert: does not exist');
    return mod(x, modulo);
}
// Not all roots are possible! Example which will throw:
// const NUM =
// n = 72057594037927816n;
// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));
function sqrt3mod4(Fp, n) {
    const p1div4 = (Fp.ORDER + _1n) / _4n;
    const root = Fp.pow(n, p1div4);
    // Throw if root^2 != n
    if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
    return root;
}
function sqrt5mod8(Fp, n) {
    const p5div8 = (Fp.ORDER - _5n) / _8n;
    const n2 = Fp.mul(n, _2n);
    const v = Fp.pow(n2, p5div8);
    const nv = Fp.mul(n, v);
    const i = Fp.mul(Fp.mul(nv, _2n), v);
    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
    if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
    return root;
}
// TODO: Commented-out for now. Provide test vectors.
// Tonelli is too slow for extension fields Fp2.
// That means we can't use sqrt (c1, c2...) even for initialization constants.
// if (P % _16n === _9n) return sqrt9mod16;
// // prettier-ignore
// function sqrt9mod16<T>(Fp: IField<T>, n: T, p7div16?: bigint) {
//   if (p7div16 === undefined) p7div16 = (Fp.ORDER + BigInt(7)) / _16n;
//   const c1 = Fp.sqrt(Fp.neg(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
//   const c2 = Fp.sqrt(c1);             //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
//   const c3 = Fp.sqrt(Fp.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
//   const c4 = p7div16;                 //  4. c4 = (q + 7) / 16        # Integer arithmetic
//   let tv1 = Fp.pow(n, c4);            //  1. tv1 = x^c4
//   let tv2 = Fp.mul(c1, tv1);          //  2. tv2 = c1 * tv1
//   const tv3 = Fp.mul(c2, tv1);        //  3. tv3 = c2 * tv1
//   let tv4 = Fp.mul(c3, tv1);          //  4. tv4 = c3 * tv1
//   const e1 = Fp.eql(Fp.sqr(tv2), n);  //  5.  e1 = (tv2^2) == x
//   const e2 = Fp.eql(Fp.sqr(tv3), n);  //  6.  e2 = (tv3^2) == x
//   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
//   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
//   const e3 = Fp.eql(Fp.sqr(tv2), n);  //  9.  e3 = (tv2^2) == x
//   return Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3) # Select the sqrt from tv1 and tv2
// }
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */ function tonelliShanks(P) {
    // Initialization (precomputation).
    if (P < BigInt(3)) throw new Error('sqrt is not defined for small field');
    // Factor P - 1 = Q * 2^S, where Q is odd
    let Q = P - _1n;
    let S = 0;
    while(Q % _2n === _0n){
        Q /= _2n;
        S++;
    }
    // Find the first quadratic non-residue Z >= 2
    let Z = _2n;
    const _Fp = Field(P);
    while(FpLegendre(_Fp, Z) === 1){
        // Basic primality test for P. After x iterations, chance of
        // not finding quadratic non-residue is 2^x, so 2^1000.
        if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');
    }
    // Fast-path; usually done before Z, but we do "primality test".
    if (S === 1) return sqrt3mod4;
    // Slow-path
    // TODO: test on Fp2 and others
    let cc = _Fp.pow(Z, Q); // c = z^Q
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        if (Fp.is0(n)) return n;
        // Check if n is a quadratic residue using Legendre symbol
        if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');
        // Initialize variables for the main loop
        let M = S;
        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp
        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor
        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root
        // Main loop
        // while t != 1
        while(!Fp.eql(t, Fp.ONE)){
            if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0
            let i = 1;
            // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)
            let t_tmp = Fp.sqr(t); // t^(2^1)
            while(!Fp.eql(t_tmp, Fp.ONE)){
                i++;
                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...
                if (i === M) throw new Error('Cannot find square root');
            }
            // Calculate the exponent for b: 2^(M - i - 1)
            const exponent = _1n << BigInt(M - i - 1); // bigint is important
            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)
            // Update variables
            M = i;
            c = Fp.sqr(b); // c = b^2
            t = Fp.mul(t, c); // t = (t * b^2)
            R = Fp.mul(R, b); // R = R*b
        }
        return R;
    };
}
/**
 * Square root for a finite field. Will try optimized versions first:
 *
 * 1. P  3 (mod 4)
 * 2. P  5 (mod 8)
 * 3. Tonelli-Shanks algorithm
 *
 * Different algorithms can give different roots, it is up to user to decide which one they want.
 * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
 */ function FpSqrt(P) {
    // P  3 (mod 4) => n = n^((P+1)/4)
    if (P % _4n === _3n) return sqrt3mod4;
    // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf
    if (P % _8n === _5n) return sqrt5mod8;
    // P  9 (mod 16) not implemented, see above
    // Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create',
    'isValid',
    'is0',
    'neg',
    'inv',
    'sqrt',
    'sqr',
    'eql',
    'add',
    'sub',
    'mul',
    'pow',
    'div',
    'addN',
    'subN',
    'mulN',
    'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger'
    };
    const opts = FIELD_FIELDS.reduce((map, val)=>{
        map[val] = 'function';
        return map;
    }, initial);
    return (0, utils_ts_1.validateObject)(field, opts);
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */ function FpPow(Fp, num, power) {
    if (power < _0n) throw new Error('invalid exponent, negatives unsupported');
    if (power === _0n) return Fp.ONE;
    if (power === _1n) return num;
    let p = Fp.ONE;
    let d = num;
    while(power > _0n){
        if (power & _1n) p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * Exception-free. Will return `undefined` for 0 elements.
 * @param passZero map 0 to 0 (instead of undefined)
 */ function FpInvertBatch(Fp, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);
    // Walk from first to last, multiply them by each other MOD p
    const multipliedAcc = nums.reduce((acc, num, i)=>{
        if (Fp.is0(num)) return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
    }, Fp.ONE);
    // Invert last element
    const invertedAcc = Fp.inv(multipliedAcc);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i)=>{
        if (Fp.is0(num)) return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
    }, invertedAcc);
    return inverted;
}
// TODO: remove
function FpDiv(Fp, lhs, rhs) {
    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
}
/**
 * Legendre symbol.
 * Legendre constant is used to calculate Legendre symbol (a | p)
 * which denotes the value of a^((p-1)/2) (mod p).
 *
 * * (a | p)  1    if a is a square (mod p), quadratic residue
 * * (a | p)  -1   if a is not a square (mod p), quadratic non residue
 * * (a | p)  0    if a  0 (mod p)
 */ function FpLegendre(Fp, n) {
    // We can use 3rd argument as optional cache of this value
    // but seems unneeded for now. The operation is very fast.
    const p1mod2 = (Fp.ORDER - _1n) / _2n;
    const powered = Fp.pow(n, p1mod2);
    const yes = Fp.eql(powered, Fp.ONE);
    const zero = Fp.eql(powered, Fp.ZERO);
    const no = Fp.eql(powered, Fp.neg(Fp.ONE));
    if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');
    return yes ? 1 : zero ? 0 : -1;
}
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(Fp, n) {
    const l = FpLegendre(Fp, n);
    return l === 1;
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    if (nBitLength !== undefined) (0, utils_1.anumber)(nBitLength);
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return {
        nBitLength: _nBitLength,
        nByteLength
    };
}
/**
 * Initializes a finite field over prime.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * Fragile: always run a benchmark on a change.
 * Security note: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you're doing.
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */ function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');
    let sqrtP; // cached sqrtP
    const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num)=>mod(num, ORDER),
        isValid: (num)=>{
            if (typeof num !== 'bigint') throw new Error('invalid field element: expected bigint, got ' + typeof num);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num)=>num === _0n,
        isOdd: (num)=>(num & _1n) === _1n,
        neg: (num)=>mod(-num, ORDER),
        eql: (lhs, rhs)=>lhs === rhs,
        sqr: (num)=>mod(num * num, ORDER),
        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),
        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),
        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),
        pow: (num, power)=>FpPow(f, num, power),
        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num)=>num * num,
        addN: (lhs, rhs)=>lhs + rhs,
        subN: (lhs, rhs)=>lhs - rhs,
        mulN: (lhs, rhs)=>lhs * rhs,
        inv: (num)=>invert(num, ORDER),
        sqrt: redef.sqrt || ((n)=>{
            if (!sqrtP) sqrtP = FpSqrt(ORDER);
            return sqrtP(f, n);
        }),
        toBytes: (num)=>isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes)=>{
            if (bytes.length !== BYTES) throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);
            return isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst)=>FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c)=>c ? b : a
    });
    return Object.freeze(f);
}
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use `mapKeyToField` instead
 */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */ function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */ function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */ function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024) throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
}

},{"4dab0c60690648d":"fuxLy","d8ac4b6c79c60614":"fc0Wi"}],"7mgY5":[function(require,module,exports,__globalThis) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.expand_message_xmd = expand_message_xmd;
exports.expand_message_xof = expand_message_xof;
exports.hash_to_field = hash_to_field;
exports.isogenyMap = isogenyMap;
exports.createHasher = createHasher;
const modular_ts_1 = require("eccb35e649679ca");
const utils_ts_1 = require("202487820f28c009");
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_ts_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << 8 * length) throw new Error('invalid I2OSP input: ' + value);
    const res = Array.from({
        length
    }).fill(0);
    for(let i = length - 1; i >= 0; i--){
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for(let i = 0; i < a.length; i++)arr[i] = a[i] ^ b[i];
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item)) throw new Error('number expected');
}
/**
 * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.
 * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).
 */ function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_ts_1.abytes)(msg);
    (0, utils_ts_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255) DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');
    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for(let i = 1; i <= ell; i++){
        const args = [
            strxor(b_0, b[i - 1]),
            i2osp(i + 1, 1),
            DST_prime
        ];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
/**
 * Produces a uniformly random byte string using an extendable-output function (XOF) H.
 * 1. The collision resistance of H MUST be at least k bits.
 * 2. H MUST be an XOF that has been proved indifferentiable from
 *    a random oracle under a reasonable cryptographic assumption.
 * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).
 */ function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_ts_1.abytes)(msg);
    (0, utils_ts_1.abytes)(DST);
    anum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({
            dkLen
        }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');
    return H.create({
        dkLen: lenInBytes
    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)
    .update(DST).update(i2osp(DST.length, 1)).digest();
}
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.
 * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */ function hash_to_field(msg, count, options) {
    (0, utils_ts_1.validateObject)(options, {
        DST: 'stringOrUint8Array',
        p: 'bigint',
        m: 'isSafeInteger',
        k: 'isSafeInteger',
        hash: 'hash'
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    (0, utils_ts_1.abytes)(msg);
    anum(count);
    const DST = typeof _DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(_DST) : _DST;
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    else if (expand === 'xof') prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    else if (expand === '_internal_pass') // for internal tests only
    prb = msg;
    else throw new Error('expand must be "xmd" or "xof"');
    const u = new Array(count);
    for(let i = 0; i < count; i++){
        const e = new Array(m);
        for(let j = 0; j < m; j++){
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const coeff = map.map((i)=>Array.from(i).reverse());
    return (x, y)=>{
        const [xn, xd, yn, yd] = coeff.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));
        // 6.6.3
        // Exceptional cases of iso_map are inputs that cause the denominator of
        // either rational function to evaluate to zero; such cases MUST return
        // the identity point on E.
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [
            xd,
            yd
        ], true);
        x = field.mul(xn, xd_inv); // xNum / xDen
        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)
        return {
            x,
            y
        };
    };
}
/** Creates hash-to-curve methods from EC Point and mapToCurve function. */ function createHasher(Point, mapToCurve, defaults) {
    if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');
    function map(num) {
        return Point.fromAffine(mapToCurve(num));
    }
    function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert
        P.assertValidity();
        return P;
    }
    return {
        defaults,
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve (msg, options) {
            const u = hash_to_field(msg, 2, {
                ...defaults,
                DST: defaults.DST,
                ...options
            });
            const u0 = map(u[0]);
            const u1 = map(u[1]);
            return clear(u0.add(u1));
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve (msg, options) {
            const u = hash_to_field(msg, 1, {
                ...defaults,
                DST: defaults.encodeDST,
                ...options
            });
            return clear(map(u[0]));
        },
        // Same as encodeToCurve, but without hash
        mapToCurve (scalars) {
            if (!Array.isArray(scalars)) throw new Error('expected array of bigints');
            for (const i of scalars)if (typeof i !== 'bigint') throw new Error('expected array of bigints');
            return clear(map(scalars));
        }
    };
}

},{"eccb35e649679ca":"1jGup","202487820f28c009":"fc0Wi"}],"geW4Q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Verify that typed data was signed by the provided address.
 *
 * - Docs {@link https://viem.sh/docs/actions/public/verifyTypedData}
 *
 * @param client - Client to use.
 * @param parameters - {@link VerifyTypedDataParameters}
 * @returns Whether or not the signature is valid. {@link VerifyTypedDataReturnType}
 */ parcelHelpers.export(exports, "verifyTypedData", ()=>verifyTypedData);
var _hashTypedDataJs = require("../../utils/signature/hashTypedData.js");
var _verifyHashJs = require("./verifyHash.js");
async function verifyTypedData(client, parameters) {
    const { address, factory, factoryData, signature, message, primaryType, types, domain, ...callRequest } = parameters;
    const hash = (0, _hashTypedDataJs.hashTypedData)({
        message,
        primaryType,
        types,
        domain
    });
    return (0, _verifyHashJs.verifyHash)(client, {
        address,
        factory: factory,
        factoryData: factoryData,
        hash,
        signature,
        ...callRequest
    });
}

},{"../../utils/signature/hashTypedData.js":"efmTs","./verifyHash.js":"hWvvl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gBaOA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).
 *
 * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt
 * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions
 * - JSON-RPC Methods:
 *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.
 *   - If a Transaction has been replaced:
 *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions
 *     - Checks if one of the Transactions is a replacement
 *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).
 *
 * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).
 *
 * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.
 *
 * There are 3 types of Transaction Replacement reasons:
 *
 * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)
 * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)
 * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)
 *
 * @param client - Client to use
 * @param parameters - {@link WaitForTransactionReceiptParameters}
 * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}
 *
 * @example
 * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const transactionReceipt = await waitForTransactionReceipt(client, {
 *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',
 * })
 */ parcelHelpers.export(exports, "waitForTransactionReceipt", ()=>waitForTransactionReceipt);
var _blockJs = require("../../errors/block.js");
var _transactionJs = require("../../errors/transaction.js");
var _getActionJs = require("../../utils/getAction.js");
var _observeJs = require("../../utils/observe.js");
var _withResolversJs = require("../../utils/promise/withResolvers.js");
var _withRetryJs = require("../../utils/promise/withRetry.js");
var _stringifyJs = require("../../utils/stringify.js");
var _getBlockJs = require("./getBlock.js");
var _getTransactionJs = require("./getTransaction.js");
var _getTransactionReceiptJs = require("./getTransactionReceipt.js");
var _watchBlockNumberJs = require("./watchBlockNumber.js");
async function waitForTransactionReceipt(client, { confirmations = 1, hash, onReplaced, pollingInterval = client.pollingInterval, retryCount = 6, retryDelay = ({ count })=>~~(1 << count) * 200, timeout = 180000 }) {
    const observerId = (0, _stringifyJs.stringify)([
        'waitForTransactionReceipt',
        client.uid,
        hash
    ]);
    let transaction;
    let replacedTransaction;
    let receipt;
    let retrying = false;
    // biome-ignore lint/style/useConst:
    let _unobserve;
    let _unwatch;
    const { promise, resolve, reject } = (0, _withResolversJs.withResolvers)();
    const timer = timeout ? setTimeout(()=>{
        _unwatch();
        _unobserve();
        reject(new (0, _transactionJs.WaitForTransactionReceiptTimeoutError)({
            hash
        }));
    }, timeout) : undefined;
    _unobserve = (0, _observeJs.observe)(observerId, {
        onReplaced,
        resolve,
        reject
    }, (emit)=>{
        _unwatch = (0, _getActionJs.getAction)(client, (0, _watchBlockNumberJs.watchBlockNumber), 'watchBlockNumber')({
            emitMissed: true,
            emitOnBegin: true,
            poll: true,
            pollingInterval,
            async onBlockNumber (blockNumber_) {
                const done = (fn)=>{
                    clearTimeout(timer);
                    _unwatch();
                    fn();
                    _unobserve();
                };
                let blockNumber = blockNumber_;
                if (retrying) return;
                try {
                    // If we already have a valid receipt, let's check if we have enough
                    // confirmations. If we do, then we can resolve.
                    if (receipt) {
                        if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;
                        done(()=>emit.resolve(receipt));
                        return;
                    }
                    // Get the transaction to check if it's been replaced.
                    // We need to retry as some RPC Providers may be slow to sync
                    // up mined transactions.
                    if (!transaction) {
                        retrying = true;
                        await (0, _withRetryJs.withRetry)(async ()=>{
                            transaction = await (0, _getActionJs.getAction)(client, (0, _getTransactionJs.getTransaction), 'getTransaction')({
                                hash
                            });
                            if (transaction.blockNumber) blockNumber = transaction.blockNumber;
                        }, {
                            delay: retryDelay,
                            retryCount
                        });
                        retrying = false;
                    }
                    // Get the receipt to check if it's been processed.
                    receipt = await (0, _getActionJs.getAction)(client, (0, _getTransactionReceiptJs.getTransactionReceipt), 'getTransactionReceipt')({
                        hash
                    });
                    // Check if we have enough confirmations. If not, continue polling.
                    if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;
                    done(()=>emit.resolve(receipt));
                } catch (err) {
                    // If the receipt is not found, the transaction will be pending.
                    // We need to check if it has potentially been replaced.
                    if (err instanceof (0, _transactionJs.TransactionNotFoundError) || err instanceof (0, _transactionJs.TransactionReceiptNotFoundError)) {
                        if (!transaction) {
                            retrying = false;
                            return;
                        }
                        try {
                            replacedTransaction = transaction;
                            // Let's retrieve the transactions from the current block.
                            // We need to retry as some RPC Providers may be slow to sync
                            // up mined blocks.
                            retrying = true;
                            const block = await (0, _withRetryJs.withRetry)(()=>(0, _getActionJs.getAction)(client, (0, _getBlockJs.getBlock), 'getBlock')({
                                    blockNumber,
                                    includeTransactions: true
                                }), {
                                delay: retryDelay,
                                retryCount,
                                shouldRetry: ({ error })=>error instanceof (0, _blockJs.BlockNotFoundError)
                            });
                            retrying = false;
                            const replacementTransaction = block.transactions.find(({ from, nonce })=>from === replacedTransaction.from && nonce === replacedTransaction.nonce);
                            // If we couldn't find a replacement transaction, continue polling.
                            if (!replacementTransaction) return;
                            // If we found a replacement transaction, return it's receipt.
                            receipt = await (0, _getActionJs.getAction)(client, (0, _getTransactionReceiptJs.getTransactionReceipt), 'getTransactionReceipt')({
                                hash: replacementTransaction.hash
                            });
                            // Check if we have enough confirmations. If not, continue polling.
                            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;
                            let reason = 'replaced';
                            if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) reason = 'repriced';
                            else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) reason = 'cancelled';
                            done(()=>{
                                emit.onReplaced?.({
                                    reason,
                                    replacedTransaction: replacedTransaction,
                                    transaction: replacementTransaction,
                                    transactionReceipt: receipt
                                });
                                emit.resolve(receipt);
                            });
                        } catch (err_) {
                            done(()=>emit.reject(err_));
                        }
                    } else done(()=>emit.reject(err));
                }
            }
        });
    });
    return promise;
}

},{"../../errors/block.js":"iTpgp","../../errors/transaction.js":"4gFzr","../../utils/getAction.js":"d1Bvd","../../utils/observe.js":"3BbFn","../../utils/promise/withResolvers.js":"5yXnT","../../utils/promise/withRetry.js":"3qWqJ","../../utils/stringify.js":"jKcjI","./getBlock.js":"1M4Cs","./getTransaction.js":"lrruA","./getTransactionReceipt.js":"aEzFk","./watchBlockNumber.js":"fq9gv","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fq9gv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Watches and returns incoming block numbers.
 *
 * - Docs: https://viem.sh/docs/actions/public/watchBlockNumber
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks
 * - JSON-RPC Methods:
 *   - When `poll: true`, calls [`eth_blockNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_blocknumber) on a polling interval.
 *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event.
 *
 * @param client - Client to use
 * @param parameters - {@link WatchBlockNumberParameters}
 * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlockNumberReturnType}
 *
 * @example
 * import { createPublicClient, watchBlockNumber, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const unwatch = watchBlockNumber(client, {
 *   onBlockNumber: (blockNumber) => console.log(blockNumber),
 * })
 */ parcelHelpers.export(exports, "watchBlockNumber", ()=>watchBlockNumber);
var _fromHexJs = require("../../utils/encoding/fromHex.js");
var _getActionJs = require("../../utils/getAction.js");
var _observeJs = require("../../utils/observe.js");
var _pollJs = require("../../utils/poll.js");
var _stringifyJs = require("../../utils/stringify.js");
var _getBlockNumberJs = require("./getBlockNumber.js");
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = (()=>{
        if (typeof poll_ !== 'undefined') return poll_;
        if (client.transport.type === 'webSocket') return false;
        if (client.transport.type === 'fallback' && client.transport.transports[0].config.type === 'webSocket') return false;
        return true;
    })();
    let prevBlockNumber;
    const pollBlockNumber = ()=>{
        const observerId = (0, _stringifyJs.stringify)([
            'watchBlockNumber',
            client.uid,
            emitOnBegin,
            emitMissed,
            pollingInterval
        ]);
        return (0, _observeJs.observe)(observerId, {
            onBlockNumber,
            onError
        }, (emit)=>(0, _pollJs.poll)(async ()=>{
                try {
                    const blockNumber = await (0, _getActionJs.getAction)(client, (0, _getBlockNumberJs.getBlockNumber), 'getBlockNumber')({
                        cacheTime: 0
                    });
                    if (prevBlockNumber) {
                        // If the current block number is the same as the previous,
                        // we can skip.
                        if (blockNumber === prevBlockNumber) return;
                        // If we have missed out on some previous blocks, and the
                        // `emitMissed` flag is truthy, let's emit those blocks.
                        if (blockNumber - prevBlockNumber > 1 && emitMissed) for(let i = prevBlockNumber + 1n; i < blockNumber; i++){
                            emit.onBlockNumber(i, prevBlockNumber);
                            prevBlockNumber = i;
                        }
                    }
                    // If the next block number is greater than the previous,
                    // it is not in the past, and we can emit the new block number.
                    if (!prevBlockNumber || blockNumber > prevBlockNumber) {
                        emit.onBlockNumber(blockNumber, prevBlockNumber);
                        prevBlockNumber = blockNumber;
                    }
                } catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin,
                interval: pollingInterval
            }));
    };
    const subscribeBlockNumber = ()=>{
        const observerId = (0, _stringifyJs.stringify)([
            'watchBlockNumber',
            client.uid,
            emitOnBegin,
            emitMissed
        ]);
        return (0, _observeJs.observe)(observerId, {
            onBlockNumber,
            onError
        }, (emit)=>{
            let active = true;
            let unsubscribe = ()=>active = false;
            (async ()=>{
                try {
                    const transport = (()=>{
                        if (client.transport.type === 'fallback') {
                            const transport = client.transport.transports.find((transport)=>transport.config.type === 'webSocket');
                            if (!transport) return client.transport;
                            return transport.value;
                        }
                        return client.transport;
                    })();
                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({
                        params: [
                            'newHeads'
                        ],
                        onData (data) {
                            if (!active) return;
                            const blockNumber = (0, _fromHexJs.hexToBigInt)(data.result?.number);
                            emit.onBlockNumber(blockNumber, prevBlockNumber);
                            prevBlockNumber = blockNumber;
                        },
                        onError (error) {
                            emit.onError?.(error);
                        }
                    });
                    unsubscribe = unsubscribe_;
                    if (!active) unsubscribe();
                } catch (err) {
                    onError?.(err);
                }
            })();
            return ()=>unsubscribe();
        });
    };
    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}

},{"../../utils/encoding/fromHex.js":"kLfW5","../../utils/getAction.js":"d1Bvd","../../utils/observe.js":"3BbFn","../../utils/poll.js":"6Dkrj","../../utils/stringify.js":"jKcjI","./getBlockNumber.js":"hY1Hu","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gM5SM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Watches and returns information for incoming blocks.
 *
 * - Docs: https://viem.sh/docs/actions/public/watchBlocks
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/blocks_watching-blocks
 * - JSON-RPC Methods:
 *   - When `poll: true`, calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getBlockByNumber) on a polling interval.
 *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newHeads"` event.
 *
 * @param client - Client to use
 * @param parameters - {@link WatchBlocksParameters}
 * @returns A function that can be invoked to stop watching for new block numbers. {@link WatchBlocksReturnType}
 *
 * @example
 * import { createPublicClient, watchBlocks, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const unwatch = watchBlocks(client, {
 *   onBlock: (block) => console.log(block),
 * })
 */ parcelHelpers.export(exports, "watchBlocks", ()=>watchBlocks);
var _getActionJs = require("../../utils/getAction.js");
var _observeJs = require("../../utils/observe.js");
var _pollJs = require("../../utils/poll.js");
var _stringifyJs = require("../../utils/stringify.js");
var _getBlockJs = require("./getBlock.js");
function watchBlocks(client, { blockTag = 'latest', emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = (()=>{
        if (typeof poll_ !== 'undefined') return poll_;
        if (client.transport.type === 'webSocket') return false;
        if (client.transport.type === 'fallback' && client.transport.transports[0].config.type === 'webSocket') return false;
        return true;
    })();
    const includeTransactions = includeTransactions_ ?? false;
    let prevBlock;
    const pollBlocks = ()=>{
        const observerId = (0, _stringifyJs.stringify)([
            'watchBlocks',
            client.uid,
            blockTag,
            emitMissed,
            emitOnBegin,
            includeTransactions,
            pollingInterval
        ]);
        return (0, _observeJs.observe)(observerId, {
            onBlock,
            onError
        }, (emit)=>(0, _pollJs.poll)(async ()=>{
                try {
                    const block = await (0, _getActionJs.getAction)(client, (0, _getBlockJs.getBlock), 'getBlock')({
                        blockTag,
                        includeTransactions
                    });
                    if (block.number !== null && prevBlock?.number != null) {
                        // If the current block number is the same as the previous,
                        // we can skip.
                        if (block.number === prevBlock.number) return;
                        // If we have missed out on some previous blocks, and the
                        // `emitMissed` flag is truthy, let's emit those blocks.
                        if (block.number - prevBlock.number > 1 && emitMissed) for(let i = prevBlock?.number + 1n; i < block.number; i++){
                            const block = await (0, _getActionJs.getAction)(client, (0, _getBlockJs.getBlock), 'getBlock')({
                                blockNumber: i,
                                includeTransactions
                            });
                            emit.onBlock(block, prevBlock);
                            prevBlock = block;
                        }
                    }
                    if (// If no previous block exists, emit.
                    prevBlock?.number == null || // If the block tag is "pending" with no block number, emit.
                    blockTag === 'pending' && block?.number == null || // If the next block number is greater than the previous block number, emit.
                    // We don't want to emit blocks in the past.
                    block.number !== null && block.number > prevBlock.number) {
                        emit.onBlock(block, prevBlock);
                        prevBlock = block;
                    }
                } catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin,
                interval: pollingInterval
            }));
    };
    const subscribeBlocks = ()=>{
        let active = true;
        let emitFetched = true;
        let unsubscribe = ()=>active = false;
        (async ()=>{
            try {
                if (emitOnBegin) (0, _getActionJs.getAction)(client, (0, _getBlockJs.getBlock), 'getBlock')({
                    blockTag,
                    includeTransactions
                }).then((block)=>{
                    if (!active) return;
                    if (!emitFetched) return;
                    onBlock(block, undefined);
                    emitFetched = false;
                }).catch(onError);
                const transport = (()=>{
                    if (client.transport.type === 'fallback') {
                        const transport = client.transport.transports.find((transport)=>transport.config.type === 'webSocket');
                        if (!transport) return client.transport;
                        return transport.value;
                    }
                    return client.transport;
                })();
                const { unsubscribe: unsubscribe_ } = await transport.subscribe({
                    params: [
                        'newHeads'
                    ],
                    async onData (data) {
                        if (!active) return;
                        const block = await (0, _getActionJs.getAction)(client, (0, _getBlockJs.getBlock), 'getBlock')({
                            blockNumber: data.blockNumber,
                            includeTransactions
                        }).catch(()=>{});
                        if (!active) return;
                        onBlock(block, prevBlock);
                        emitFetched = false;
                        prevBlock = block;
                    },
                    onError (error) {
                        onError?.(error);
                    }
                });
                unsubscribe = unsubscribe_;
                if (!active) unsubscribe();
            } catch (err) {
                onError?.(err);
            }
        })();
        return ()=>unsubscribe();
    };
    return enablePolling ? pollBlocks() : subscribeBlocks();
}

},{"../../utils/getAction.js":"d1Bvd","../../utils/observe.js":"3BbFn","../../utils/poll.js":"6Dkrj","../../utils/stringify.js":"jKcjI","./getBlock.js":"1M4Cs","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"byghu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Watches and returns emitted [Event Logs](https://viem.sh/docs/glossary/terms#event-log).
 *
 * - Docs: https://viem.sh/docs/actions/public/watchEvent
 * - JSON-RPC Methods:
 *   - **RPC Provider supports `eth_newFilter`:**
 *     - Calls [`eth_newFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newfilter) to create a filter (called on initialize).
 *     - On a polling interval, it will call [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).
 *   - **RPC Provider does not support `eth_newFilter`:**
 *     - Calls [`eth_getLogs`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getlogs) for each block between the polling interval.
 *
 * This Action will batch up all the Event Logs found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchEvent#pollinginterval-optional), and invoke them via [`onLogs`](https://viem.sh/docs/actions/public/watchEvent#onLogs).
 *
 * `watchEvent` will attempt to create an [Event Filter](https://viem.sh/docs/actions/public/createEventFilter) and listen to changes to the Filter per polling interval, however, if the RPC Provider does not support Filters (e.g. `eth_newFilter`), then `watchEvent` will fall back to using [`getLogs`](https://viem.sh/docs/actions/public/getLogs) instead.
 *
 * @param client - Client to use
 * @param parameters - {@link WatchEventParameters}
 * @returns A function that can be invoked to stop watching for new Event Logs. {@link WatchEventReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { watchEvent } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const unwatch = watchEvent(client, {
 *   onLogs: (logs) => console.log(logs),
 * })
 */ parcelHelpers.export(exports, "watchEvent", ()=>watchEvent);
var _encodeEventTopicsJs = require("../../utils/abi/encodeEventTopics.js");
var _observeJs = require("../../utils/observe.js");
var _pollJs = require("../../utils/poll.js");
var _stringifyJs = require("../../utils/stringify.js");
var _abiJs = require("../../errors/abi.js");
var _rpcJs = require("../../errors/rpc.js");
var _decodeEventLogJs = require("../../utils/abi/decodeEventLog.js");
var _logJs = require("../../utils/formatters/log.js");
var _getActionJs = require("../../utils/getAction.js");
var _createEventFilterJs = require("./createEventFilter.js");
var _getBlockNumberJs = require("./getBlockNumber.js");
var _getFilterChangesJs = require("./getFilterChanges.js");
var _getLogsJs = require("./getLogs.js");
var _uninstallFilterJs = require("./uninstallFilter.js");
function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ }) {
    const enablePolling = (()=>{
        if (typeof poll_ !== 'undefined') return poll_;
        if (typeof fromBlock === 'bigint') return true;
        if (client.transport.type === 'webSocket') return false;
        if (client.transport.type === 'fallback' && client.transport.transports[0].config.type === 'webSocket') return false;
        return true;
    })();
    const strict = strict_ ?? false;
    const pollEvent = ()=>{
        const observerId = (0, _stringifyJs.stringify)([
            'watchEvent',
            address,
            args,
            batch,
            client.uid,
            event,
            pollingInterval,
            fromBlock
        ]);
        return (0, _observeJs.observe)(observerId, {
            onLogs,
            onError
        }, (emit)=>{
            let previousBlockNumber;
            if (fromBlock !== undefined) previousBlockNumber = fromBlock - 1n;
            let filter;
            let initialized = false;
            const unwatch = (0, _pollJs.poll)(async ()=>{
                if (!initialized) {
                    try {
                        filter = await (0, _getActionJs.getAction)(client, (0, _createEventFilterJs.createEventFilter), 'createEventFilter')({
                            address,
                            args,
                            event: event,
                            events,
                            strict,
                            fromBlock
                        });
                    } catch  {}
                    initialized = true;
                    return;
                }
                try {
                    let logs;
                    if (filter) logs = await (0, _getActionJs.getAction)(client, (0, _getFilterChangesJs.getFilterChanges), 'getFilterChanges')({
                        filter
                    });
                    else {
                        // If the filter doesn't exist, we will fall back to use `getLogs`.
                        // The fall back exists because some RPC Providers do not support filters.
                        // Fetch the block number to use for `getLogs`.
                        const blockNumber = await (0, _getActionJs.getAction)(client, (0, _getBlockNumberJs.getBlockNumber), 'getBlockNumber')({});
                        // If the block number has changed, we will need to fetch the logs.
                        // If the block number doesn't exist, we are yet to reach the first poll interval,
                        // so do not emit any logs.
                        if (previousBlockNumber && previousBlockNumber !== blockNumber) logs = await (0, _getActionJs.getAction)(client, (0, _getLogsJs.getLogs), 'getLogs')({
                            address,
                            args,
                            event: event,
                            events,
                            fromBlock: previousBlockNumber + 1n,
                            toBlock: blockNumber
                        });
                        else logs = [];
                        previousBlockNumber = blockNumber;
                    }
                    if (logs.length === 0) return;
                    if (batch) emit.onLogs(logs);
                    else for (const log of logs)emit.onLogs([
                        log
                    ]);
                } catch (err) {
                    // If a filter has been set and gets uninstalled, providers will throw an InvalidInput error.
                    // Reinitialize the filter when this occurs
                    if (filter && err instanceof (0, _rpcJs.InvalidInputRpcError)) initialized = false;
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval
            });
            return async ()=>{
                if (filter) await (0, _getActionJs.getAction)(client, (0, _uninstallFilterJs.uninstallFilter), 'uninstallFilter')({
                    filter
                });
                unwatch();
            };
        });
    };
    const subscribeEvent = ()=>{
        let active = true;
        let unsubscribe = ()=>active = false;
        (async ()=>{
            try {
                const transport = (()=>{
                    if (client.transport.type === 'fallback') {
                        const transport = client.transport.transports.find((transport)=>transport.config.type === 'webSocket');
                        if (!transport) return client.transport;
                        return transport.value;
                    }
                    return client.transport;
                })();
                const events_ = events ?? (event ? [
                    event
                ] : undefined);
                let topics = [];
                if (events_) {
                    const encoded = events_.flatMap((event)=>(0, _encodeEventTopicsJs.encodeEventTopics)({
                            abi: [
                                event
                            ],
                            eventName: event.name,
                            args
                        }));
                    // TODO: Clean up type casting
                    topics = [
                        encoded
                    ];
                    if (event) topics = topics[0];
                }
                const { unsubscribe: unsubscribe_ } = await transport.subscribe({
                    params: [
                        'logs',
                        {
                            address,
                            topics
                        }
                    ],
                    onData (data) {
                        if (!active) return;
                        const log = data.result;
                        try {
                            const { eventName, args } = (0, _decodeEventLogJs.decodeEventLog)({
                                abi: events_ ?? [],
                                data: log.data,
                                topics: log.topics,
                                strict
                            });
                            const formatted = (0, _logJs.formatLog)(log, {
                                args,
                                eventName
                            });
                            onLogs([
                                formatted
                            ]);
                        } catch (err) {
                            let eventName;
                            let isUnnamed;
                            if (err instanceof (0, _abiJs.DecodeLogDataMismatch) || err instanceof (0, _abiJs.DecodeLogTopicsMismatch)) {
                                // If strict mode is on, and log data/topics do not match event definition, skip.
                                if (strict_) return;
                                eventName = err.abiItem.name;
                                isUnnamed = err.abiItem.inputs?.some((x)=>!('name' in x && x.name));
                            }
                            // Set args to empty if there is an error decoding (e.g. indexed/non-indexed params mismatch).
                            const formatted = (0, _logJs.formatLog)(log, {
                                args: isUnnamed ? [] : {},
                                eventName
                            });
                            onLogs([
                                formatted
                            ]);
                        }
                    },
                    onError (error) {
                        onError?.(error);
                    }
                });
                unsubscribe = unsubscribe_;
                if (!active) unsubscribe();
            } catch (err) {
                onError?.(err);
            }
        })();
        return ()=>unsubscribe();
    };
    return enablePolling ? pollEvent() : subscribeEvent();
}

},{"../../utils/abi/encodeEventTopics.js":"7zHy3","../../utils/observe.js":"3BbFn","../../utils/poll.js":"6Dkrj","../../utils/stringify.js":"jKcjI","../../errors/abi.js":"7l8j7","../../errors/rpc.js":"jYSPv","../../utils/abi/decodeEventLog.js":"8uUoF","../../utils/formatters/log.js":"aaYKq","../../utils/getAction.js":"d1Bvd","./createEventFilter.js":"4xY9E","./getBlockNumber.js":"hY1Hu","./getFilterChanges.js":"6g1rZ","./getLogs.js":"245SH","./uninstallFilter.js":"Yq58O","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7FFnI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Watches and returns pending transaction hashes.
 *
 * - Docs: https://viem.sh/docs/actions/public/watchPendingTransactions
 * - JSON-RPC Methods:
 *   - When `poll: true`
 *     - Calls [`eth_newPendingTransactionFilter`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_newpendingtransactionfilter) to initialize the filter.
 *     - Calls [`eth_getFilterChanges`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getFilterChanges) on a polling interval.
 *   - When `poll: false` & WebSocket Transport, uses a WebSocket subscription via [`eth_subscribe`](https://docs.alchemy.com/reference/eth-subscribe-polygon) and the `"newPendingTransactions"` event.
 *
 * This Action will batch up all the pending transactions found within the [`pollingInterval`](https://viem.sh/docs/actions/public/watchPendingTransactions#pollinginterval-optional), and invoke them via [`onTransactions`](https://viem.sh/docs/actions/public/watchPendingTransactions#ontransactions).
 *
 * @param client - Client to use
 * @param parameters - {@link WatchPendingTransactionsParameters}
 * @returns A function that can be invoked to stop watching for new pending transaction hashes. {@link WatchPendingTransactionsReturnType}
 *
 * @example
 * import { createPublicClient, http } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { watchPendingTransactions } from 'viem/public'
 *
 * const client = createPublicClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const unwatch = await watchPendingTransactions(client, {
 *   onTransactions: (hashes) => console.log(hashes),
 * })
 */ parcelHelpers.export(exports, "watchPendingTransactions", ()=>watchPendingTransactions);
var _getActionJs = require("../../utils/getAction.js");
var _observeJs = require("../../utils/observe.js");
var _pollJs = require("../../utils/poll.js");
var _stringifyJs = require("../../utils/stringify.js");
var _createPendingTransactionFilterJs = require("./createPendingTransactionFilter.js");
var _getFilterChangesJs = require("./getFilterChanges.js");
var _uninstallFilterJs = require("./uninstallFilter.js");
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== 'undefined' ? poll_ : client.transport.type !== 'webSocket';
    const pollPendingTransactions = ()=>{
        const observerId = (0, _stringifyJs.stringify)([
            'watchPendingTransactions',
            client.uid,
            batch,
            pollingInterval
        ]);
        return (0, _observeJs.observe)(observerId, {
            onTransactions,
            onError
        }, (emit)=>{
            let filter;
            const unwatch = (0, _pollJs.poll)(async ()=>{
                try {
                    if (!filter) try {
                        filter = await (0, _getActionJs.getAction)(client, (0, _createPendingTransactionFilterJs.createPendingTransactionFilter), 'createPendingTransactionFilter')({});
                        return;
                    } catch (err) {
                        unwatch();
                        throw err;
                    }
                    const hashes = await (0, _getActionJs.getAction)(client, (0, _getFilterChangesJs.getFilterChanges), 'getFilterChanges')({
                        filter
                    });
                    if (hashes.length === 0) return;
                    if (batch) emit.onTransactions(hashes);
                    else for (const hash of hashes)emit.onTransactions([
                        hash
                    ]);
                } catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval
            });
            return async ()=>{
                if (filter) await (0, _getActionJs.getAction)(client, (0, _uninstallFilterJs.uninstallFilter), 'uninstallFilter')({
                    filter
                });
                unwatch();
            };
        });
    };
    const subscribePendingTransactions = ()=>{
        let active = true;
        let unsubscribe = ()=>active = false;
        (async ()=>{
            try {
                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                    params: [
                        'newPendingTransactions'
                    ],
                    onData (data) {
                        if (!active) return;
                        const transaction = data.result;
                        onTransactions([
                            transaction
                        ]);
                    },
                    onError (error) {
                        onError?.(error);
                    }
                });
                unsubscribe = unsubscribe_;
                if (!active) unsubscribe();
            } catch (err) {
                onError?.(err);
            }
        })();
        return ()=>unsubscribe();
    };
    return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
}

},{"../../utils/getAction.js":"d1Bvd","../../utils/observe.js":"3BbFn","../../utils/poll.js":"6Dkrj","../../utils/stringify.js":"jKcjI","./createPendingTransactionFilter.js":"4xwLI","./getFilterChanges.js":"6g1rZ","./uninstallFilter.js":"Yq58O","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6Xlmr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Verifies [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) formatted message was signed.
 *
 * Compatible with Smart Contract Accounts & Externally Owned Accounts via [ERC-6492](https://eips.ethereum.org/EIPS/eip-6492).
 *
 * - Docs {@link https://viem.sh/docs/siwe/actions/verifySiweMessage}
 *
 * @param client - Client to use.
 * @param parameters - {@link VerifySiweMessageParameters}
 * @returns Whether or not the signature is valid. {@link VerifySiweMessageReturnType}
 */ parcelHelpers.export(exports, "verifySiweMessage", ()=>verifySiweMessage);
var _hashMessageJs = require("../../utils/signature/hashMessage.js");
var _parseSiweMessageJs = require("../../utils/siwe/parseSiweMessage.js");
var _validateSiweMessageJs = require("../../utils/siwe/validateSiweMessage.js");
var _verifyHashJs = require("../public/verifyHash.js");
async function verifySiweMessage(client, parameters) {
    const { address, domain, message, nonce, scheme, signature, time = new Date(), ...callRequest } = parameters;
    const parsed = (0, _parseSiweMessageJs.parseSiweMessage)(message);
    if (!parsed.address) return false;
    const isValid = (0, _validateSiweMessageJs.validateSiweMessage)({
        address,
        domain,
        message: parsed,
        nonce,
        scheme,
        time
    });
    if (!isValid) return false;
    const hash = (0, _hashMessageJs.hashMessage)(message);
    return (0, _verifyHashJs.verifyHash)(client, {
        address: parsed.address,
        hash,
        signature,
        ...callRequest
    });
}

},{"../../utils/signature/hashMessage.js":"5oFnZ","../../utils/siwe/parseSiweMessage.js":"2mXH2","../../utils/siwe/validateSiweMessage.js":"dZy13","../public/verifyHash.js":"hWvvl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2mXH2":[function(require,module,exports,__globalThis) {
/**
 * @description Parses EIP-4361 formatted message into message fields object.
 *
 * @see https://eips.ethereum.org/EIPS/eip-4361
 *
 * @returns EIP-4361 fields object
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "parseSiweMessage", ()=>parseSiweMessage);
function parseSiweMessage(message) {
    const { scheme, statement, ...prefix } = message.match(prefixRegex)?.groups ?? {};
    const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = message.match(suffixRegex)?.groups ?? {};
    const resources = message.split('Resources:')[1]?.split('\n- ').slice(1);
    return {
        ...prefix,
        ...suffix,
        ...chainId ? {
            chainId: Number(chainId)
        } : {},
        ...expirationTime ? {
            expirationTime: new Date(expirationTime)
        } : {},
        ...issuedAt ? {
            issuedAt: new Date(issuedAt)
        } : {},
        ...notBefore ? {
            notBefore: new Date(notBefore)
        } : {},
        ...requestId ? {
            requestId
        } : {},
        ...resources ? {
            resources
        } : {},
        ...scheme ? {
            scheme
        } : {},
        ...statement ? {
            statement
        } : {}
    };
}
// https://regexr.com/80gdj
const prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
// https://regexr.com/80gf9
const suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dZy13":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Validates EIP-4361 message.
 *
 * @see https://eips.ethereum.org/EIPS/eip-4361
 */ parcelHelpers.export(exports, "validateSiweMessage", ()=>validateSiweMessage);
var _isAddressJs = require("../address/isAddress.js");
var _isAddressEqualJs = require("../address/isAddressEqual.js");
function validateSiweMessage(parameters) {
    const { address, domain, message, nonce, scheme, time = new Date() } = parameters;
    if (domain && message.domain !== domain) return false;
    if (nonce && message.nonce !== nonce) return false;
    if (scheme && message.scheme !== scheme) return false;
    if (message.expirationTime && time >= message.expirationTime) return false;
    if (message.notBefore && time < message.notBefore) return false;
    try {
        if (!message.address) return false;
        if (!(0, _isAddressJs.isAddress)(message.address, {
            strict: false
        })) return false;
        if (address && !(0, _isAddressEqualJs.isAddressEqual)(message.address, address)) return false;
    } catch  {
        return false;
    }
    return true;
}

},{"../address/isAddress.js":"kdAuv","../address/isAddressEqual.js":"lW8Gp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k9AuU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createTestClient", ()=>createTestClient);
var _createClientJs = require("./createClient.js");
var _testJs = require("./decorators/test.js");
function createTestClient(parameters) {
    const { key = 'test', name = 'Test Client', mode } = parameters;
    const client = (0, _createClientJs.createClient)({
        ...parameters,
        key,
        name,
        type: 'testClient'
    });
    return client.extend((config)=>({
            mode,
            ...(0, _testJs.testActions)({
                mode
            })(config)
        }));
}

},{"./createClient.js":"7sQFR","./decorators/test.js":"fJO79","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fJO79":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "testActions", ()=>testActions);
var _dropTransactionJs = require("../../actions/test/dropTransaction.js");
var _dumpStateJs = require("../../actions/test/dumpState.js");
var _getAutomineJs = require("../../actions/test/getAutomine.js");
var _getTxpoolContentJs = require("../../actions/test/getTxpoolContent.js");
var _getTxpoolStatusJs = require("../../actions/test/getTxpoolStatus.js");
var _impersonateAccountJs = require("../../actions/test/impersonateAccount.js");
var _increaseTimeJs = require("../../actions/test/increaseTime.js");
var _inspectTxpoolJs = require("../../actions/test/inspectTxpool.js");
var _loadStateJs = require("../../actions/test/loadState.js");
var _mineJs = require("../../actions/test/mine.js");
var _removeBlockTimestampIntervalJs = require("../../actions/test/removeBlockTimestampInterval.js");
var _resetJs = require("../../actions/test/reset.js");
var _revertJs = require("../../actions/test/revert.js");
var _sendUnsignedTransactionJs = require("../../actions/test/sendUnsignedTransaction.js");
var _setAutomineJs = require("../../actions/test/setAutomine.js");
var _setBalanceJs = require("../../actions/test/setBalance.js");
var _setBlockGasLimitJs = require("../../actions/test/setBlockGasLimit.js");
var _setBlockTimestampIntervalJs = require("../../actions/test/setBlockTimestampInterval.js");
var _setCodeJs = require("../../actions/test/setCode.js");
var _setCoinbaseJs = require("../../actions/test/setCoinbase.js");
var _setIntervalMiningJs = require("../../actions/test/setIntervalMining.js");
var _setLoggingEnabledJs = require("../../actions/test/setLoggingEnabled.js");
var _setMinGasPriceJs = require("../../actions/test/setMinGasPrice.js");
var _setNextBlockBaseFeePerGasJs = require("../../actions/test/setNextBlockBaseFeePerGas.js");
var _setNextBlockTimestampJs = require("../../actions/test/setNextBlockTimestamp.js");
var _setNonceJs = require("../../actions/test/setNonce.js");
var _setRpcUrlJs = require("../../actions/test/setRpcUrl.js");
var _setStorageAtJs = require("../../actions/test/setStorageAt.js");
var _snapshotJs = require("../../actions/test/snapshot.js");
var _stopImpersonatingAccountJs = require("../../actions/test/stopImpersonatingAccount.js");
function testActions({ mode }) {
    return (client_)=>{
        const client = client_.extend(()=>({
                mode
            }));
        return {
            dropTransaction: (args)=>(0, _dropTransactionJs.dropTransaction)(client, args),
            dumpState: ()=>(0, _dumpStateJs.dumpState)(client),
            getAutomine: ()=>(0, _getAutomineJs.getAutomine)(client),
            getTxpoolContent: ()=>(0, _getTxpoolContentJs.getTxpoolContent)(client),
            getTxpoolStatus: ()=>(0, _getTxpoolStatusJs.getTxpoolStatus)(client),
            impersonateAccount: (args)=>(0, _impersonateAccountJs.impersonateAccount)(client, args),
            increaseTime: (args)=>(0, _increaseTimeJs.increaseTime)(client, args),
            inspectTxpool: ()=>(0, _inspectTxpoolJs.inspectTxpool)(client),
            loadState: (args)=>(0, _loadStateJs.loadState)(client, args),
            mine: (args)=>(0, _mineJs.mine)(client, args),
            removeBlockTimestampInterval: ()=>(0, _removeBlockTimestampIntervalJs.removeBlockTimestampInterval)(client),
            reset: (args)=>(0, _resetJs.reset)(client, args),
            revert: (args)=>(0, _revertJs.revert)(client, args),
            sendUnsignedTransaction: (args)=>(0, _sendUnsignedTransactionJs.sendUnsignedTransaction)(client, args),
            setAutomine: (args)=>(0, _setAutomineJs.setAutomine)(client, args),
            setBalance: (args)=>(0, _setBalanceJs.setBalance)(client, args),
            setBlockGasLimit: (args)=>(0, _setBlockGasLimitJs.setBlockGasLimit)(client, args),
            setBlockTimestampInterval: (args)=>(0, _setBlockTimestampIntervalJs.setBlockTimestampInterval)(client, args),
            setCode: (args)=>(0, _setCodeJs.setCode)(client, args),
            setCoinbase: (args)=>(0, _setCoinbaseJs.setCoinbase)(client, args),
            setIntervalMining: (args)=>(0, _setIntervalMiningJs.setIntervalMining)(client, args),
            setLoggingEnabled: (args)=>(0, _setLoggingEnabledJs.setLoggingEnabled)(client, args),
            setMinGasPrice: (args)=>(0, _setMinGasPriceJs.setMinGasPrice)(client, args),
            setNextBlockBaseFeePerGas: (args)=>(0, _setNextBlockBaseFeePerGasJs.setNextBlockBaseFeePerGas)(client, args),
            setNextBlockTimestamp: (args)=>(0, _setNextBlockTimestampJs.setNextBlockTimestamp)(client, args),
            setNonce: (args)=>(0, _setNonceJs.setNonce)(client, args),
            setRpcUrl: (args)=>(0, _setRpcUrlJs.setRpcUrl)(client, args),
            setStorageAt: (args)=>(0, _setStorageAtJs.setStorageAt)(client, args),
            snapshot: ()=>(0, _snapshotJs.snapshot)(client),
            stopImpersonatingAccount: (args)=>(0, _stopImpersonatingAccountJs.stopImpersonatingAccount)(client, args)
        };
    };
}

},{"../../actions/test/dropTransaction.js":"etwNf","../../actions/test/dumpState.js":"g9uYo","../../actions/test/getAutomine.js":"aTVSe","../../actions/test/getTxpoolContent.js":"hpspR","../../actions/test/getTxpoolStatus.js":"l9GKV","../../actions/test/impersonateAccount.js":"7semO","../../actions/test/increaseTime.js":"eUZaN","../../actions/test/inspectTxpool.js":"9cEYU","../../actions/test/loadState.js":"RVkSh","../../actions/test/mine.js":"jPUy8","../../actions/test/removeBlockTimestampInterval.js":"2fJ3W","../../actions/test/reset.js":"j0ewV","../../actions/test/revert.js":"96tc7","../../actions/test/sendUnsignedTransaction.js":"caHLT","../../actions/test/setAutomine.js":"6cKis","../../actions/test/setBalance.js":"bM650","../../actions/test/setBlockGasLimit.js":"ei6Ru","../../actions/test/setBlockTimestampInterval.js":"iIA6u","../../actions/test/setCode.js":"kOcjU","../../actions/test/setCoinbase.js":"cnpjj","../../actions/test/setIntervalMining.js":"cpOg0","../../actions/test/setLoggingEnabled.js":"7sJRQ","../../actions/test/setMinGasPrice.js":"7uEoq","../../actions/test/setNextBlockBaseFeePerGas.js":"hYbqD","../../actions/test/setNextBlockTimestamp.js":"73qje","../../actions/test/setNonce.js":"fSmqX","../../actions/test/setRpcUrl.js":"30m8T","../../actions/test/setStorageAt.js":"A2tfA","../../actions/test/snapshot.js":"v8762","../../actions/test/stopImpersonatingAccount.js":"2gn3f","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"etwNf":[function(require,module,exports,__globalThis) {
/**
 * Removes a transaction from the mempool.
 *
 * - Docs: https://viem.sh/docs/actions/test/dropTransaction
 *
 * @param client - Client to use
 * @param parameters - {@link DropTransactionParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { dropTransaction } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await dropTransaction(client, {
 *   hash: '0xe58dceb6b20b03965bb678e27d141e151d7d4efc2334c2d6a49b9fac523f7364'
 * })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dropTransaction", ()=>dropTransaction);
async function dropTransaction(client, { hash }) {
    await client.request({
        method: `${client.mode}_dropTransaction`,
        params: [
            hash
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"g9uYo":[function(require,module,exports,__globalThis) {
/**
 * Serializes the current state (including contracts code, contract's storage,
 * accounts properties, etc.) into a savable data blob.
 *
 * - Docs: https://viem.sh/docs/actions/test/dumpState
 *
 * @param client - Client to use
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { dumpState } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await dumpState(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dumpState", ()=>dumpState);
async function dumpState(client) {
    return client.request({
        method: `${client.mode}_dumpState`
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aTVSe":[function(require,module,exports,__globalThis) {
/**
 * Returns the automatic mining status of the node.
 *
 * - Docs: https://viem.sh/docs/actions/test/getAutomine
 *
 * @param client - Client to use
 * @returns Whether or not the node is auto mining. {@link GetAutomineReturnType}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { getAutomine } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const isAutomining = await getAutomine(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAutomine", ()=>getAutomine);
async function getAutomine(client) {
    if (client.mode === 'ganache') return await client.request({
        method: 'eth_mining'
    });
    return await client.request({
        method: `${client.mode}_getAutomine`
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hpspR":[function(require,module,exports,__globalThis) {
/**
 * Returns the details of all transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.
 *
 * - Docs: https://viem.sh/docs/actions/test/getTxpoolContent
 *
 * @param client - Client to use
 * @returns Transaction pool content. {@link GetTxpoolContentReturnType}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { getTxpoolContent } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const content = await getTxpoolContent(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getTxpoolContent", ()=>getTxpoolContent);
async function getTxpoolContent(client) {
    return await client.request({
        method: 'txpool_content'
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l9GKV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.
 *
 * - Docs: https://viem.sh/docs/actions/test/getTxpoolStatus
 *
 * @param client - Client to use
 * @returns Transaction pool status. {@link GetTxpoolStatusReturnType}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { getTxpoolStatus } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const status = await getTxpoolStatus(client)
 */ parcelHelpers.export(exports, "getTxpoolStatus", ()=>getTxpoolStatus);
var _fromHexJs = require("../../utils/encoding/fromHex.js");
async function getTxpoolStatus(client) {
    const { pending, queued } = await client.request({
        method: 'txpool_status'
    });
    return {
        pending: (0, _fromHexJs.hexToNumber)(pending),
        queued: (0, _fromHexJs.hexToNumber)(queued)
    };
}

},{"../../utils/encoding/fromHex.js":"kLfW5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7semO":[function(require,module,exports,__globalThis) {
/**
 * Impersonate an account or contract address. This lets you send transactions from that account even if you don't have access to its private key.
 *
 * - Docs: https://viem.sh/docs/actions/test/impersonateAccount
 *
 * @param client - Client to use
 * @param parameters - {@link ImpersonateAccountParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { impersonateAccount } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const content = await impersonateAccount(client, {
 *   address: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "impersonateAccount", ()=>impersonateAccount);
async function impersonateAccount(client, { address }) {
    await client.request({
        method: `${client.mode}_impersonateAccount`,
        params: [
            address
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eUZaN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Jump forward in time by the given amount of time, in seconds.
 *
 * - Docs: https://viem.sh/docs/actions/test/increaseTime
 *
 * @param client - Client to use
 * @param parameters  {@link IncreaseTimeParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { increaseTime } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await increaseTime(client, {
 *   seconds: 420,
 * })
 */ parcelHelpers.export(exports, "increaseTime", ()=>increaseTime);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function increaseTime(client, { seconds }) {
    return await client.request({
        method: 'evm_increaseTime',
        params: [
            (0, _toHexJs.numberToHex)(seconds)
        ]
    });
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9cEYU":[function(require,module,exports,__globalThis) {
/**
 * Returns a summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.
 *
 * - Docs: https://viem.sh/docs/actions/test/inspectTxpool
 *
 * @param client - Client to use
 * @returns Transaction pool inspection data. {@link InspectTxpoolReturnType}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { inspectTxpool } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const data = await inspectTxpool(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "inspectTxpool", ()=>inspectTxpool);
async function inspectTxpool(client) {
    return await client.request({
        method: 'txpool_inspect'
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"RVkSh":[function(require,module,exports,__globalThis) {
/**
 * Adds state previously dumped with `dumpState` to the current chain.
 *
 * - Docs: https://viem.sh/docs/actions/test/loadState
 *
 * @param client - Client to use
 * @param parameters - {@link LoadStateParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { loadState } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await loadState(client, { state: '0x...' })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadState", ()=>loadState);
async function loadState(client, { state }) {
    await client.request({
        method: `${client.mode}_loadState`,
        params: [
            state
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jPUy8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Mine a specified number of blocks.
 *
 * - Docs: https://viem.sh/docs/actions/test/mine
 *
 * @param client - Client to use
 * @param parameters  {@link MineParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { mine } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await mine(client, { blocks: 1 })
 */ parcelHelpers.export(exports, "mine", ()=>mine);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function mine(client, { blocks, interval }) {
    if (client.mode === 'ganache') await client.request({
        method: 'evm_mine',
        params: [
            {
                blocks: (0, _toHexJs.numberToHex)(blocks)
            }
        ]
    });
    else await client.request({
        method: `${client.mode}_mine`,
        params: [
            (0, _toHexJs.numberToHex)(blocks),
            (0, _toHexJs.numberToHex)(interval || 0)
        ]
    });
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2fJ3W":[function(require,module,exports,__globalThis) {
/**
 * Removes [`setBlockTimestampInterval`](https://viem.sh/docs/actions/test/setBlockTimestampInterval) if it exists.
 *
 * - Docs: https://viem.sh/docs/actions/test/removeBlockTimestampInterval
 *
 * @param client - Client to use
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { removeBlockTimestampInterval } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await removeBlockTimestampInterval(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "removeBlockTimestampInterval", ()=>removeBlockTimestampInterval);
async function removeBlockTimestampInterval(client) {
    await client.request({
        method: `${client.mode}_removeBlockTimestampInterval`
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j0ewV":[function(require,module,exports,__globalThis) {
/**
 * Resets fork back to its original state.
 *
 * - Docs: https://viem.sh/docs/actions/test/reset
 *
 * @param client - Client to use
 * @param parameters  {@link ResetParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { reset } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await reset(client, { blockNumber: 69420n })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "reset", ()=>reset);
async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
    await client.request({
        method: `${client.mode}_reset`,
        params: [
            {
                forking: {
                    blockNumber: Number(blockNumber),
                    jsonRpcUrl
                }
            }
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"96tc7":[function(require,module,exports,__globalThis) {
/**
 * Revert the state of the blockchain at the current block.
 *
 * - Docs: https://viem.sh/docs/actions/test/revert
 *
 * @param client - Client to use
 * @param parameters  {@link RevertParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { revert } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await revert(client, { id: '0x' })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "revert", ()=>revert);
async function revert(client, { id }) {
    await client.request({
        method: 'evm_revert',
        params: [
            id
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"caHLT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Executes a transaction regardless of the signature.
 *
 * - Docs: https://viem.sh/docs/actions/test/sendUnsignedTransaction#sendunsignedtransaction
 *
 * @param client - Client to use
 * @param parameters  {@link SendUnsignedTransactionParameters}
 * @returns The transaction hash. {@link SendUnsignedTransactionReturnType}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { sendUnsignedTransaction } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * const hash = await sendUnsignedTransaction(client, {
 *   from: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',
 *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',
 *   value: 1000000000000000000n,
 * })
 */ parcelHelpers.export(exports, "sendUnsignedTransaction", ()=>sendUnsignedTransaction);
var _extractJs = require("../../utils/formatters/extract.js");
var _transactionRequestJs = require("../../utils/formatters/transactionRequest.js");
async function sendUnsignedTransaction(client, args) {
    const { accessList, data, from, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || (0, _transactionRequestJs.formatTransactionRequest);
    const request = format({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...(0, _extractJs.extract)(rest, {
            format: chainFormat
        }),
        accessList,
        data,
        from,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
    });
    const hash = await client.request({
        method: 'eth_sendUnsignedTransaction',
        params: [
            request
        ]
    });
    return hash;
}

},{"../../utils/formatters/extract.js":"g9KS8","../../utils/formatters/transactionRequest.js":"dLljr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6cKis":[function(require,module,exports,__globalThis) {
/**
 * Enables or disables the automatic mining of new blocks with each new transaction submitted to the network.
 *
 * - Docs: https://viem.sh/docs/actions/test/setAutomine
 *
 * @param client - Client to use
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setAutomine } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setAutomine(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setAutomine", ()=>setAutomine);
async function setAutomine(client, enabled) {
    if (client.mode === 'ganache') {
        if (enabled) await client.request({
            method: 'miner_start'
        });
        else await client.request({
            method: 'miner_stop'
        });
    } else await client.request({
        method: 'evm_setAutomine',
        params: [
            enabled
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bM650":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Modifies the balance of an account.
 *
 * - Docs: https://viem.sh/docs/actions/test/setBalance
 *
 * @param client - Client to use
 * @param parameters  {@link SetBalanceParameters}
 *
 * @example
 * import { createTestClient, http, parseEther } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setBalance } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setBalance(client, {
 *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
 *   value: parseEther('1'),
 * })
 */ parcelHelpers.export(exports, "setBalance", ()=>setBalance);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function setBalance(client, { address, value }) {
    if (client.mode === 'ganache') await client.request({
        method: 'evm_setAccountBalance',
        params: [
            address,
            (0, _toHexJs.numberToHex)(value)
        ]
    });
    else await client.request({
        method: `${client.mode}_setBalance`,
        params: [
            address,
            (0, _toHexJs.numberToHex)(value)
        ]
    });
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ei6Ru":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Sets the block's gas limit.
 *
 * - Docs: https://viem.sh/docs/actions/test/setBlockGasLimit
 *
 * @param client - Client to use
 * @param parameters  {@link SetBlockGasLimitParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setBlockGasLimit } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setBlockGasLimit(client, { gasLimit: 420_000n })
 */ parcelHelpers.export(exports, "setBlockGasLimit", ()=>setBlockGasLimit);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function setBlockGasLimit(client, { gasLimit }) {
    await client.request({
        method: 'evm_setBlockGasLimit',
        params: [
            (0, _toHexJs.numberToHex)(gasLimit)
        ]
    });
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iIA6u":[function(require,module,exports,__globalThis) {
/**
 * Similar to [`increaseTime`](https://viem.sh/docs/actions/test/increaseTime), but sets a block timestamp `interval`. The timestamp of future blocks will be computed as `lastBlock_timestamp` + `interval`.
 *
 * - Docs: https://viem.sh/docs/actions/test/setBlockTimestampInterval
 *
 * @param client - Client to use
 * @param parameters  {@link SetBlockTimestampIntervalParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setBlockTimestampInterval } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setBlockTimestampInterval(client, { interval: 5 })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setBlockTimestampInterval", ()=>setBlockTimestampInterval);
async function setBlockTimestampInterval(client, { interval }) {
    const interval_ = (()=>{
        if (client.mode === 'hardhat') return interval * 1000;
        return interval;
    })();
    await client.request({
        method: `${client.mode}_setBlockTimestampInterval`,
        params: [
            interval_
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kOcjU":[function(require,module,exports,__globalThis) {
/**
 * Modifies the bytecode stored at an account's address.
 *
 * - Docs: https://viem.sh/docs/actions/test/setCode
 *
 * @param client - Client to use
 * @param parameters  {@link SetCodeParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setCode } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setCode(client, {
 *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',
 *   bytecode: '0x60806040526000600355600019600955600c80546001600160a01b031916737a250d5630b4cf539739df',
 * })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setCode", ()=>setCode);
async function setCode(client, { address, bytecode }) {
    if (client.mode === 'ganache') await client.request({
        method: 'evm_setAccountCode',
        params: [
            address,
            bytecode
        ]
    });
    else await client.request({
        method: `${client.mode}_setCode`,
        params: [
            address,
            bytecode
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cnpjj":[function(require,module,exports,__globalThis) {
/**
 * Sets the coinbase address to be used in new blocks.
 *
 * - Docs: https://viem.sh/docs/actions/test/setCoinbase
 *
 * @param client - Client to use
 * @param parameters  {@link SetCoinbaseParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setCoinbase } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setCoinbase(client, {
 *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',
 * })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setCoinbase", ()=>setCoinbase);
async function setCoinbase(client, { address }) {
    await client.request({
        method: `${client.mode}_setCoinbase`,
        params: [
            address
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cpOg0":[function(require,module,exports,__globalThis) {
/**
 * Sets the automatic mining interval (in seconds) of blocks. Setting the interval to 0 will disable automatic mining.
 *
 * - Docs: https://viem.sh/docs/actions/test/setIntervalMining
 *
 * @param client - Client to use
 * @param parameters  {@link SetIntervalMiningParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setIntervalMining } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setIntervalMining(client, { interval: 5 })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setIntervalMining", ()=>setIntervalMining);
async function setIntervalMining(client, { interval }) {
    const interval_ = (()=>{
        if (client.mode === 'hardhat') return interval * 1000;
        return interval;
    })();
    await client.request({
        method: 'evm_setIntervalMining',
        params: [
            interval_
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7sJRQ":[function(require,module,exports,__globalThis) {
/**
 * Enable or disable logging on the test node network.
 *
 * - Docs: https://viem.sh/docs/actions/test/setLoggingEnabled
 *
 * @param client - Client to use
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setLoggingEnabled } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setLoggingEnabled(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setLoggingEnabled", ()=>setLoggingEnabled);
async function setLoggingEnabled(client, enabled) {
    await client.request({
        method: `${client.mode}_setLoggingEnabled`,
        params: [
            enabled
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7uEoq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Change the minimum gas price accepted by the network (in wei).
 *
 * - Docs: https://viem.sh/docs/actions/test/setMinGasPrice
 *
 * Note: `setMinGasPrice` can only be used on clients that do not have EIP-1559 enabled.
 *
 * @param client - Client to use
 * @param parameters  {@link SetBlockGasLimitParameters}
 *
 * @example
 * import { createTestClient, http, parseGwei } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setMinGasPrice } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setMinGasPrice(client, {
 *   gasPrice: parseGwei('20'),
 * })
 */ parcelHelpers.export(exports, "setMinGasPrice", ()=>setMinGasPrice);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function setMinGasPrice(client, { gasPrice }) {
    await client.request({
        method: `${client.mode}_setMinGasPrice`,
        params: [
            (0, _toHexJs.numberToHex)(gasPrice)
        ]
    });
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hYbqD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Sets the next block's base fee per gas.
 *
 * - Docs: https://viem.sh/docs/actions/test/setNextBlockBaseFeePerGas
 *
 * @param client - Client to use
 * @param parameters  {@link SetNextBlockBaseFeePerGasParameters}
 *
 * @example
 * import { createTestClient, http, parseGwei } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setNextBlockBaseFeePerGas } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setNextBlockBaseFeePerGas(client, {
 *   baseFeePerGas: parseGwei('20'),
 * })
 */ parcelHelpers.export(exports, "setNextBlockBaseFeePerGas", ()=>setNextBlockBaseFeePerGas);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
    await client.request({
        method: `${client.mode}_setNextBlockBaseFeePerGas`,
        params: [
            (0, _toHexJs.numberToHex)(baseFeePerGas)
        ]
    });
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"73qje":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Sets the next block's timestamp.
 *
 * - Docs: https://viem.sh/docs/actions/test/setNextBlockTimestamp
 *
 * @param client - Client to use
 * @param parameters  {@link SetNextBlockTimestampParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setNextBlockTimestamp } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setNextBlockTimestamp(client, { timestamp: 1671744314n })
 */ parcelHelpers.export(exports, "setNextBlockTimestamp", ()=>setNextBlockTimestamp);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function setNextBlockTimestamp(client, { timestamp }) {
    await client.request({
        method: 'evm_setNextBlockTimestamp',
        params: [
            (0, _toHexJs.numberToHex)(timestamp)
        ]
    });
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fSmqX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Modifies (overrides) the nonce of an account.
 *
 * - Docs: https://viem.sh/docs/actions/test/setNonce
 *
 * @param client - Client to use
 * @param parameters  {@link SetNonceParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setNonce } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setNonce(client, {
 *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
 *   nonce: 420,
 * })
 */ parcelHelpers.export(exports, "setNonce", ()=>setNonce);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function setNonce(client, { address, nonce }) {
    await client.request({
        method: `${client.mode}_setNonce`,
        params: [
            address,
            (0, _toHexJs.numberToHex)(nonce)
        ]
    });
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"30m8T":[function(require,module,exports,__globalThis) {
/**
 * Sets the backend RPC URL.
 *
 * - Docs: https://viem.sh/docs/actions/test/setRpcUrl
 *
 * @param client - Client to use
 * @param jsonRpcUrl  RPC URL
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setRpcUrl } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setRpcUrl(client, 'https://eth-mainnet.g.alchemy.com/v2')
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setRpcUrl", ()=>setRpcUrl);
async function setRpcUrl(client, jsonRpcUrl) {
    await client.request({
        method: `${client.mode}_setRpcUrl`,
        params: [
            jsonRpcUrl
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"A2tfA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Writes to a slot of an account's storage.
 *
 * - Docs: https://viem.sh/docs/actions/test/setStorageAt
 *
 * @param client - Client to use
 * @param parameters  {@link SetStorageAtParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { setStorageAt } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await setStorageAt(client, {
 *   address: '0xe846c6fcf817734ca4527b28ccb4aea2b6663c79',
 *   index: 2,
 *   value: '0x0000000000000000000000000000000000000000000000000000000000000069',
 * })
 */ parcelHelpers.export(exports, "setStorageAt", ()=>setStorageAt);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function setStorageAt(client, { address, index, value }) {
    await client.request({
        method: `${client.mode}_setStorageAt`,
        params: [
            address,
            typeof index === 'number' ? (0, _toHexJs.numberToHex)(index) : index,
            value
        ]
    });
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"v8762":[function(require,module,exports,__globalThis) {
/**
 * Snapshot the state of the blockchain at the current block.
 *
 * - Docs: https://viem.sh/docs/actions/test/snapshot
 *
 * @param client - Client to use
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { snapshot } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await snapshot(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "snapshot", ()=>snapshot);
async function snapshot(client) {
    return await client.request({
        method: 'evm_snapshot'
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2gn3f":[function(require,module,exports,__globalThis) {
/**
 * Stop impersonating an account after having previously used [`impersonateAccount`](https://viem.sh/docs/actions/test/impersonateAccount).
 *
 * - Docs: https://viem.sh/docs/actions/test/stopImpersonatingAccount
 *
 * @param client - Client to use
 * @param parameters  {@link StopImpersonatingAccountParameters}
 *
 * @example
 * import { createTestClient, http } from 'viem'
 * import { foundry } from 'viem/chains'
 * import { stopImpersonatingAccount } from 'viem/test'
 *
 * const client = createTestClient({
 *   mode: 'anvil',
 *   chain: 'foundry',
 *   transport: http(),
 * })
 * await stopImpersonatingAccount(client, {
 *   address: '0xa5cc3c03994DB5b0d9A5eEdD10CabaB0813678AC',
 * })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stopImpersonatingAccount", ()=>stopImpersonatingAccount);
async function stopImpersonatingAccount(client, { address }) {
    await client.request({
        method: `${client.mode}_stopImpersonatingAccount`,
        params: [
            address
        ]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6yK4d":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "walletActions", ()=>walletActions);
var _getChainIdJs = require("../../actions/public/getChainId.js");
var _addChainJs = require("../../actions/wallet/addChain.js");
var _deployContractJs = require("../../actions/wallet/deployContract.js");
var _getAddressesJs = require("../../actions/wallet/getAddresses.js");
var _getCallsStatusJs = require("../../actions/wallet/getCallsStatus.js");
var _getCapabilitiesJs = require("../../actions/wallet/getCapabilities.js");
var _getPermissionsJs = require("../../actions/wallet/getPermissions.js");
var _prepareAuthorizationJs = require("../../actions/wallet/prepareAuthorization.js");
var _prepareTransactionRequestJs = require("../../actions/wallet/prepareTransactionRequest.js");
var _requestAddressesJs = require("../../actions/wallet/requestAddresses.js");
var _requestPermissionsJs = require("../../actions/wallet/requestPermissions.js");
var _sendCallsJs = require("../../actions/wallet/sendCalls.js");
var _sendRawTransactionJs = require("../../actions/wallet/sendRawTransaction.js");
var _sendTransactionJs = require("../../actions/wallet/sendTransaction.js");
var _showCallsStatusJs = require("../../actions/wallet/showCallsStatus.js");
var _signAuthorizationJs = require("../../actions/wallet/signAuthorization.js");
var _signMessageJs = require("../../actions/wallet/signMessage.js");
var _signTransactionJs = require("../../actions/wallet/signTransaction.js");
var _signTypedDataJs = require("../../actions/wallet/signTypedData.js");
var _switchChainJs = require("../../actions/wallet/switchChain.js");
var _waitForCallsStatusJs = require("../../actions/wallet/waitForCallsStatus.js");
var _watchAssetJs = require("../../actions/wallet/watchAsset.js");
var _writeContractJs = require("../../actions/wallet/writeContract.js");
function walletActions(client) {
    return {
        addChain: (args)=>(0, _addChainJs.addChain)(client, args),
        deployContract: (args)=>(0, _deployContractJs.deployContract)(client, args),
        getAddresses: ()=>(0, _getAddressesJs.getAddresses)(client),
        getCallsStatus: (args)=>(0, _getCallsStatusJs.getCallsStatus)(client, args),
        getCapabilities: (args)=>(0, _getCapabilitiesJs.getCapabilities)(client, args),
        getChainId: ()=>(0, _getChainIdJs.getChainId)(client),
        getPermissions: ()=>(0, _getPermissionsJs.getPermissions)(client),
        prepareAuthorization: (args)=>(0, _prepareAuthorizationJs.prepareAuthorization)(client, args),
        prepareTransactionRequest: (args)=>(0, _prepareTransactionRequestJs.prepareTransactionRequest)(client, args),
        requestAddresses: ()=>(0, _requestAddressesJs.requestAddresses)(client),
        requestPermissions: (args)=>(0, _requestPermissionsJs.requestPermissions)(client, args),
        sendCalls: (args)=>(0, _sendCallsJs.sendCalls)(client, args),
        sendRawTransaction: (args)=>(0, _sendRawTransactionJs.sendRawTransaction)(client, args),
        sendTransaction: (args)=>(0, _sendTransactionJs.sendTransaction)(client, args),
        showCallsStatus: (args)=>(0, _showCallsStatusJs.showCallsStatus)(client, args),
        signAuthorization: (args)=>(0, _signAuthorizationJs.signAuthorization)(client, args),
        signMessage: (args)=>(0, _signMessageJs.signMessage)(client, args),
        signTransaction: (args)=>(0, _signTransactionJs.signTransaction)(client, args),
        signTypedData: (args)=>(0, _signTypedDataJs.signTypedData)(client, args),
        switchChain: (args)=>(0, _switchChainJs.switchChain)(client, args),
        waitForCallsStatus: (args)=>(0, _waitForCallsStatusJs.waitForCallsStatus)(client, args),
        watchAsset: (args)=>(0, _watchAssetJs.watchAsset)(client, args),
        writeContract: (args)=>(0, _writeContractJs.writeContract)(client, args)
    };
}

},{"../../actions/public/getChainId.js":"lXOca","../../actions/wallet/addChain.js":"4l7XG","../../actions/wallet/deployContract.js":"dnYKo","../../actions/wallet/getAddresses.js":"l4G8B","../../actions/wallet/getCallsStatus.js":"90ztp","../../actions/wallet/getCapabilities.js":"62ll8","../../actions/wallet/getPermissions.js":"h2NP6","../../actions/wallet/prepareAuthorization.js":"2b5FD","../../actions/wallet/prepareTransactionRequest.js":"53wjM","../../actions/wallet/requestAddresses.js":"hmRKc","../../actions/wallet/requestPermissions.js":"6bNSB","../../actions/wallet/sendCalls.js":"8063v","../../actions/wallet/sendRawTransaction.js":"6SNuf","../../actions/wallet/sendTransaction.js":"910Bd","../../actions/wallet/showCallsStatus.js":"d9IK4","../../actions/wallet/signAuthorization.js":"3Wjpi","../../actions/wallet/signMessage.js":"lBlcJ","../../actions/wallet/signTransaction.js":"3t05t","../../actions/wallet/signTypedData.js":"gnYqv","../../actions/wallet/switchChain.js":"kIRBs","../../actions/wallet/waitForCallsStatus.js":"hSeJ1","../../actions/wallet/watchAsset.js":"aOu1Z","../../actions/wallet/writeContract.js":"FOZdN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4l7XG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Adds an EVM chain to the wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/addChain
 * - JSON-RPC Methods: [`eth_addEthereumChain`](https://eips.ethereum.org/EIPS/eip-3085)
 *
 * @param client - Client to use
 * @param parameters - {@link AddChainParameters}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { optimism } from 'viem/chains'
 * import { addChain } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   transport: custom(window.ethereum),
 * })
 * await addChain(client, { chain: optimism })
 */ parcelHelpers.export(exports, "addChain", ()=>addChain);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function addChain(client, { chain }) {
    const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
    await client.request({
        method: 'wallet_addEthereumChain',
        params: [
            {
                chainId: (0, _toHexJs.numberToHex)(id),
                chainName: name,
                nativeCurrency,
                rpcUrls: rpcUrls.default.http,
                blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url })=>url) : undefined
            }
        ]
    }, {
        dedupe: true,
        retryCount: 0
    });
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dnYKo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Deploys a contract to the network, given bytecode and constructor arguments.
 *
 * - Docs: https://viem.sh/docs/contract/deployContract
 * - Examples: https://stackblitz.com/github/wevm/viem/tree/main/examples/contracts_deploying-contracts
 *
 * @param client - Client to use
 * @param parameters - {@link DeployContractParameters}
 * @returns The [Transaction](https://viem.sh/docs/glossary/terms#transaction) hash. {@link DeployContractReturnType}
 *
 * @example
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { deployContract } from 'viem/contract'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const hash = await deployContract(client, {
 *   abi: [],
 *   account: '0x,
 *   bytecode: '0x608060405260405161083e38038061083e833981016040819052610...',
 * })
 */ parcelHelpers.export(exports, "deployContract", ()=>deployContract);
var _encodeDeployDataJs = require("../../utils/abi/encodeDeployData.js");
var _sendTransactionJs = require("./sendTransaction.js");
function deployContract(walletClient, parameters) {
    const { abi, args, bytecode, ...request } = parameters;
    const calldata = (0, _encodeDeployDataJs.encodeDeployData)({
        abi,
        args,
        bytecode
    });
    return (0, _sendTransactionJs.sendTransaction)(walletClient, {
        ...request,
        ...request.authorizationList ? {
            to: null
        } : {},
        data: calldata
    });
}

},{"../../utils/abi/encodeDeployData.js":"55weO","./sendTransaction.js":"910Bd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l4G8B":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a list of account addresses owned by the wallet or client.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/getAddresses
 * - JSON-RPC Methods: [`eth_accounts`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_accounts)
 *
 * @param client - Client to use
 * @returns List of account addresses owned by the wallet or client. {@link GetAddressesReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getAddresses } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const accounts = await getAddresses(client)
 */ parcelHelpers.export(exports, "getAddresses", ()=>getAddresses);
var _getAddressJs = require("../../utils/address/getAddress.js");
async function getAddresses(client) {
    if (client.account?.type === 'local') return [
        client.account.address
    ];
    const addresses = await client.request({
        method: 'eth_accounts'
    }, {
        dedupe: true
    });
    return addresses.map((address)=>(0, _getAddressJs.checksumAddress)(address));
}

},{"../../utils/address/getAddress.js":"aGHEi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"62ll8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Extract capabilities that a connected wallet supports (e.g. paymasters, session keys, etc).
 *
 * - Docs: https://viem.sh/docs/actions/wallet/getCapabilities
 * - JSON-RPC Methods: [`wallet_getCapabilities`](https://eips.ethereum.org/EIPS/eip-5792)
 *
 * @param client - Client to use
 * @returns The wallet's capabilities. {@link GetCapabilitiesReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getCapabilities } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const capabilities = await getCapabilities(client)
 */ parcelHelpers.export(exports, "getCapabilities", ()=>getCapabilities);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
async function getCapabilities(client, parameters = {}) {
    const { account = client.account, chainId } = parameters;
    const account_ = account ? (0, _parseAccountJs.parseAccount)(account) : undefined;
    const params = chainId ? [
        account_?.address,
        [
            (0, _toHexJs.numberToHex)(chainId)
        ]
    ] : [
        account_?.address
    ];
    const capabilities_raw = await client.request({
        method: 'wallet_getCapabilities',
        params
    });
    const capabilities = {};
    for (const [chainId, capabilities_] of Object.entries(capabilities_raw)){
        capabilities[Number(chainId)] = {};
        for (let [key, value] of Object.entries(capabilities_)){
            if (key === 'addSubAccount') key = 'unstable_addSubAccount';
            capabilities[Number(chainId)][key] = value;
        }
    }
    return typeof chainId === 'number' ? capabilities[chainId] : capabilities;
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h2NP6":[function(require,module,exports,__globalThis) {
/**
 * Gets the wallets current permissions.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/getPermissions
 * - JSON-RPC Methods: [`wallet_getPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
 *
 * @param client - Client to use
 * @returns The wallet permissions. {@link GetPermissionsReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { getPermissions } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const permissions = await getPermissions(client)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getPermissions", ()=>getPermissions);
async function getPermissions(client) {
    const permissions = await client.request({
        method: 'wallet_getPermissions'
    }, {
        dedupe: true
    });
    return permissions;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2b5FD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Prepares an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object for signing.
 * This Action will fill the required fields of the Authorization object if they are not provided (e.g. `nonce` and `chainId`).
 *
 * With the prepared Authorization object, you can use [`signAuthorization`](https://viem.sh/docs/eip7702/signAuthorization) to sign over the Authorization object.
 *
 * @param client - Client to use
 * @param parameters - {@link PrepareAuthorizationParameters}
 * @returns The prepared Authorization object. {@link PrepareAuthorizationReturnType}
 *
 * @example
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { prepareAuthorization } from 'viem/experimental'
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const authorization = await prepareAuthorization(client, {
 *   account: privateKeyToAccount('0x..'),
 *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 *
 * @example
 * // Account Hoisting
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { prepareAuthorization } from 'viem/experimental'
 *
 * const client = createClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const authorization = await prepareAuthorization(client, {
 *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 */ parcelHelpers.export(exports, "prepareAuthorization", ()=>prepareAuthorization);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _isAddressEqualJs = require("../../utils/address/isAddressEqual.js");
var _getActionJs = require("../../utils/getAction.js");
var _getChainIdJs = require("../public/getChainId.js");
var _getTransactionCountJs = require("../public/getTransactionCount.js");
async function prepareAuthorization(client, parameters) {
    const { account: account_ = client.account, chainId, nonce } = parameters;
    if (!account_) throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: '/docs/eip7702/prepareAuthorization'
    });
    const account = (0, _parseAccountJs.parseAccount)(account_);
    const executor = (()=>{
        if (!parameters.executor) return undefined;
        if (parameters.executor === 'self') return parameters.executor;
        return (0, _parseAccountJs.parseAccount)(parameters.executor);
    })();
    const authorization = {
        address: parameters.contractAddress ?? parameters.address,
        chainId,
        nonce
    };
    if (typeof authorization.chainId === 'undefined') authorization.chainId = client.chain?.id ?? await (0, _getActionJs.getAction)(client, (0, _getChainIdJs.getChainId), 'getChainId')({});
    if (typeof authorization.nonce === 'undefined') {
        authorization.nonce = await (0, _getActionJs.getAction)(client, (0, _getTransactionCountJs.getTransactionCount), 'getTransactionCount')({
            address: account.address,
            blockTag: 'pending'
        });
        if (executor === 'self' || executor?.address && (0, _isAddressEqualJs.isAddressEqual)(executor.address, account.address)) authorization.nonce += 1;
    }
    return authorization;
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../errors/account.js":"39pf0","../../utils/address/isAddressEqual.js":"lW8Gp","../../utils/getAction.js":"d1Bvd","../public/getChainId.js":"lXOca","../public/getTransactionCount.js":"7o2N6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hmRKc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Requests a list of accounts managed by a wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/requestAddresses
 * - JSON-RPC Methods: [`eth_requestAccounts`](https://eips.ethereum.org/EIPS/eip-1102)
 *
 * Sends a request to the wallet, asking for permission to access the user's accounts. After the user accepts the request, it will return a list of accounts (addresses).
 *
 * This API can be useful for dapps that need to access the user's accounts in order to execute transactions or interact with smart contracts.
 *
 * @param client - Client to use
 * @returns List of accounts managed by a wallet {@link RequestAddressesReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { requestAddresses } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const accounts = await requestAddresses(client)
 */ parcelHelpers.export(exports, "requestAddresses", ()=>requestAddresses);
var _getAddressJs = require("../../utils/address/getAddress.js");
async function requestAddresses(client) {
    const addresses = await client.request({
        method: 'eth_requestAccounts'
    }, {
        dedupe: true,
        retryCount: 0
    });
    return addresses.map((address)=>(0, _getAddressJs.getAddress)(address));
}

},{"../../utils/address/getAddress.js":"aGHEi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6bNSB":[function(require,module,exports,__globalThis) {
/**
 * Requests permissions for a wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/requestPermissions
 * - JSON-RPC Methods: [`wallet_requestPermissions`](https://eips.ethereum.org/EIPS/eip-2255)
 *
 * @param client - Client to use
 * @param parameters - {@link RequestPermissionsParameters}
 * @returns The wallet permissions. {@link RequestPermissionsReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { requestPermissions } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const permissions = await requestPermissions(client, {
 *   eth_accounts: {}
 * })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "requestPermissions", ()=>requestPermissions);
async function requestPermissions(client, permissions) {
    return client.request({
        method: 'wallet_requestPermissions',
        params: [
            permissions
        ]
    }, {
        retryCount: 0
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d9IK4":[function(require,module,exports,__globalThis) {
/**
 * Requests for the wallet to show information about a call batch
 * that was sent via `sendCalls`.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/showCallsStatus
 * - JSON-RPC Methods: [`wallet_showCallsStatus`](https://eips.ethereum.org/EIPS/eip-5792)
 *
 * @param client - Client to use
 * @returns Status of the calls. {@link ShowCallsStatusReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { showCallsStatus } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * await showCallsStatus(client, { id: '0xdeadbeef' })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showCallsStatus", ()=>showCallsStatus);
async function showCallsStatus(client, parameters) {
    const { id } = parameters;
    await client.request({
        method: 'wallet_showCallsStatus',
        params: [
            id
        ]
    });
    return;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3Wjpi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Signs an [EIP-7702 Authorization](https://eips.ethereum.org/EIPS/eip-7702) object.
 *
 * With the calculated signature, you can:
 * - use [`verifyAuthorization`](https://viem.sh/docs/eip7702/verifyAuthorization) to verify the signed Authorization object,
 * - use [`recoverAuthorizationAddress`](https://viem.sh/docs/eip7702/recoverAuthorizationAddress) to recover the signing address from the signed Authorization object.
 *
 * @param client - Client to use
 * @param parameters - {@link SignAuthorizationParameters}
 * @returns The signed Authorization object. {@link SignAuthorizationReturnType}
 *
 * @example
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signAuthorization } from 'viem/experimental'
 *
 * const client = createClient({
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const signature = await signAuthorization(client, {
 *   account: privateKeyToAccount('0x..'),
 *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 *
 * @example
 * // Account Hoisting
 * import { createClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signAuthorization } from 'viem/experimental'
 *
 * const client = createClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const signature = await signAuthorization(client, {
 *   contractAddress: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 * })
 */ parcelHelpers.export(exports, "signAuthorization", ()=>signAuthorization);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _prepareAuthorizationJs = require("./prepareAuthorization.js");
async function signAuthorization(client, parameters) {
    const { account: account_ = client.account } = parameters;
    if (!account_) throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: '/docs/eip7702/signAuthorization'
    });
    const account = (0, _parseAccountJs.parseAccount)(account_);
    if (!account.signAuthorization) throw new (0, _accountJs.AccountTypeNotSupportedError)({
        docsPath: '/docs/eip7702/signAuthorization',
        metaMessages: [
            'The `signAuthorization` Action does not support JSON-RPC Accounts.'
        ],
        type: account.type
    });
    const authorization = await (0, _prepareAuthorizationJs.prepareAuthorization)(client, parameters);
    return account.signAuthorization(authorization);
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../errors/account.js":"39pf0","./prepareAuthorization.js":"2b5FD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lBlcJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculates an Ethereum-specific signature in [EIP-191 format](https://eips.ethereum.org/EIPS/eip-191): `keccak256("\x19Ethereum Signed Message:\n" + len(message) + message))`.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/signMessage
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`personal_sign`](https://docs.metamask.io/guide/signing-data#personal-sign)
 *   - Local Accounts: Signs locally. No JSON-RPC request.
 *
 * With the calculated signature, you can:
 * - use [`verifyMessage`](https://viem.sh/docs/utilities/verifyMessage) to verify the signature,
 * - use [`recoverMessageAddress`](https://viem.sh/docs/utilities/recoverMessageAddress) to recover the signing address from a signature.
 *
 * @param client - Client to use
 * @param parameters - {@link SignMessageParameters}
 * @returns The signed message. {@link SignMessageReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { signMessage } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signMessage(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   message: 'hello world',
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, custom } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signMessage } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signMessage(client, {
 *   message: 'hello world',
 * })
 */ parcelHelpers.export(exports, "signMessage", ()=>signMessage);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
async function signMessage(client, { account: account_ = client.account, message }) {
    if (!account_) throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: '/docs/actions/wallet/signMessage'
    });
    const account = (0, _parseAccountJs.parseAccount)(account_);
    if (account.signMessage) return account.signMessage({
        message
    });
    const message_ = (()=>{
        if (typeof message === 'string') return (0, _toHexJs.stringToHex)(message);
        if (message.raw instanceof Uint8Array) return (0, _toHexJs.toHex)(message.raw);
        return message.raw;
    })();
    return client.request({
        method: 'personal_sign',
        params: [
            message_,
            account.address
        ]
    }, {
        retryCount: 0
    });
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../errors/account.js":"39pf0","../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3t05t":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Signs a transaction.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/signTransaction
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`eth_signTransaction`](https://ethereum.github.io/execution-apis/api-documentation/)
 *   - Local Accounts: Signs locally. No JSON-RPC request.
 *
 * @param args - {@link SignTransactionParameters}
 * @returns The signed serialized transaction. {@link SignTransactionReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { signTransaction } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signTransaction(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signTransaction } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signTransaction(client, {
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 */ parcelHelpers.export(exports, "signTransaction", ()=>signTransaction);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _assertCurrentChainJs = require("../../utils/chain/assertCurrentChain.js");
var _toHexJs = require("../../utils/encoding/toHex.js");
var _transactionRequestJs = require("../../utils/formatters/transactionRequest.js");
var _getActionJs = require("../../utils/getAction.js");
var _assertRequestJs = require("../../utils/transaction/assertRequest.js");
var _getChainIdJs = require("../public/getChainId.js");
async function signTransaction(client, parameters) {
    const { account: account_ = client.account, chain = client.chain, ...transaction } = parameters;
    if (!account_) throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: '/docs/actions/wallet/signTransaction'
    });
    const account = (0, _parseAccountJs.parseAccount)(account_);
    (0, _assertRequestJs.assertRequest)({
        account,
        ...parameters
    });
    const chainId = await (0, _getActionJs.getAction)(client, (0, _getChainIdJs.getChainId), 'getChainId')({});
    if (chain !== null) (0, _assertCurrentChainJs.assertCurrentChain)({
        currentChainId: chainId,
        chain
    });
    const formatters = chain?.formatters || client.chain?.formatters;
    const format = formatters?.transactionRequest?.format || (0, _transactionRequestJs.formatTransactionRequest);
    if (account.signTransaction) return account.signTransaction({
        ...transaction,
        chainId
    }, {
        serializer: client.chain?.serializers?.transaction
    });
    return await client.request({
        method: 'eth_signTransaction',
        params: [
            {
                ...format(transaction),
                chainId: (0, _toHexJs.numberToHex)(chainId),
                from: account.address
            }
        ]
    }, {
        retryCount: 0
    });
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../errors/account.js":"39pf0","../../utils/chain/assertCurrentChain.js":"g3OLr","../../utils/encoding/toHex.js":"9GFC6","../../utils/formatters/transactionRequest.js":"dLljr","../../utils/getAction.js":"d1Bvd","../../utils/transaction/assertRequest.js":"eSiKr","../public/getChainId.js":"lXOca","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gnYqv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Signs typed data and calculates an Ethereum-specific signature in [https://eips.ethereum.org/EIPS/eip-712](https://eips.ethereum.org/EIPS/eip-712): `sign(keccak256("\x19\x01"  domainSeparator  hashStruct(message)))`
 *
 * - Docs: https://viem.sh/docs/actions/wallet/signTypedData
 * - JSON-RPC Methods:
 *   - JSON-RPC Accounts: [`eth_signTypedData_v4`](https://docs.metamask.io/guide/signing-data#signtypeddata-v4)
 *   - Local Accounts: Signs locally. No JSON-RPC request.
 *
 * @param client - Client to use
 * @param parameters - {@link SignTypedDataParameters}
 * @returns The signed data. {@link SignTypedDataReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { signTypedData } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const signature = await signTypedData(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   domain: {
 *     name: 'Ether Mail',
 *     version: '1',
 *     chainId: 1,
 *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
 *   },
 *   types: {
 *     Person: [
 *       { name: 'name', type: 'string' },
 *       { name: 'wallet', type: 'address' },
 *     ],
 *     Mail: [
 *       { name: 'from', type: 'Person' },
 *       { name: 'to', type: 'Person' },
 *       { name: 'contents', type: 'string' },
 *     ],
 *   },
 *   primaryType: 'Mail',
 *   message: {
 *     from: {
 *       name: 'Cow',
 *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
 *     },
 *     to: {
 *       name: 'Bob',
 *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
 *     },
 *     contents: 'Hello, Bob!',
 *   },
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { signTypedData } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0x'),
 *   chain: mainnet,
 *   transport: http(),
 * })
 * const signature = await signTypedData(client, {
 *   domain: {
 *     name: 'Ether Mail',
 *     version: '1',
 *     chainId: 1,
 *     verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
 *   },
 *   types: {
 *     Person: [
 *       { name: 'name', type: 'string' },
 *       { name: 'wallet', type: 'address' },
 *     ],
 *     Mail: [
 *       { name: 'from', type: 'Person' },
 *       { name: 'to', type: 'Person' },
 *       { name: 'contents', type: 'string' },
 *     ],
 *   },
 *   primaryType: 'Mail',
 *   message: {
 *     from: {
 *       name: 'Cow',
 *       wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826',
 *     },
 *     to: {
 *       name: 'Bob',
 *       wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB',
 *     },
 *     contents: 'Hello, Bob!',
 *   },
 * })
 */ parcelHelpers.export(exports, "signTypedData", ()=>signTypedData);
var _parseAccountJs = require("../../accounts/utils/parseAccount.js");
var _accountJs = require("../../errors/account.js");
var _typedDataJs = require("../../utils/typedData.js");
async function signTypedData(client, parameters) {
    const { account: account_ = client.account, domain, message, primaryType } = parameters;
    if (!account_) throw new (0, _accountJs.AccountNotFoundError)({
        docsPath: '/docs/actions/wallet/signTypedData'
    });
    const account = (0, _parseAccountJs.parseAccount)(account_);
    const types = {
        EIP712Domain: (0, _typedDataJs.getTypesForEIP712Domain)({
            domain
        }),
        ...parameters.types
    };
    // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc
    // as we can't statically check this with TypeScript.
    (0, _typedDataJs.validateTypedData)({
        domain,
        message,
        primaryType,
        types
    });
    if (account.signTypedData) return account.signTypedData({
        domain,
        message,
        primaryType,
        types
    });
    const typedData = (0, _typedDataJs.serializeTypedData)({
        domain,
        message,
        primaryType,
        types
    });
    return client.request({
        method: 'eth_signTypedData_v4',
        params: [
            account.address,
            typedData
        ]
    }, {
        retryCount: 0
    });
}

},{"../../accounts/utils/parseAccount.js":"lGQkg","../../errors/account.js":"39pf0","../../utils/typedData.js":"bBGXA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kIRBs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Switch the target chain in a wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/switchChain
 * - JSON-RPC Methods: [`wallet_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-3326)
 *
 * @param client - Client to use
 * @param parameters - {@link SwitchChainParameters}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet, optimism } from 'viem/chains'
 * import { switchChain } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * await switchChain(client, { id: optimism.id })
 */ parcelHelpers.export(exports, "switchChain", ()=>switchChain);
var _toHexJs = require("../../utils/encoding/toHex.js");
async function switchChain(client, { id }) {
    await client.request({
        method: 'wallet_switchEthereumChain',
        params: [
            {
                chainId: (0, _toHexJs.numberToHex)(id)
            }
        ]
    }, {
        retryCount: 0
    });
}

},{"../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aOu1Z":[function(require,module,exports,__globalThis) {
/**
 * Adds an EVM chain to the wallet.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/watchAsset
 * - JSON-RPC Methods: [`eth_switchEthereumChain`](https://eips.ethereum.org/EIPS/eip-747)
 *
 * @param client - Client to use
 * @param parameters - {@link WatchAssetParameters}
 * @returns Boolean indicating if the token was successfully added. {@link WatchAssetReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { watchAsset } from 'viem/wallet'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const success = await watchAsset(client, {
 *   type: 'ERC20',
 *   options: {
 *     address: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',
 *     decimals: 18,
 *     symbol: 'WETH',
 *   },
 * })
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "watchAsset", ()=>watchAsset);
async function watchAsset(client, params) {
    const added = await client.request({
        method: 'wallet_watchAsset',
        params
    }, {
        retryCount: 0
    });
    return added;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2a2ks":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createWalletClient", ()=>createWalletClient);
var _createClientJs = require("./createClient.js");
var _walletJs = require("./decorators/wallet.js");
function createWalletClient(parameters) {
    const { key = 'wallet', name = 'Wallet Client', transport } = parameters;
    const client = (0, _createClientJs.createClient)({
        ...parameters,
        key,
        name,
        transport,
        type: 'walletClient'
    });
    return client.extend((0, _walletJs.walletActions));
}

},{"./createClient.js":"7sQFR","./decorators/wallet.js":"6yK4d","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3CJeJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Creates a WebSocket transport that connects to a JSON-RPC API.
 */ parcelHelpers.export(exports, "webSocket", ()=>webSocket);
var _requestJs = require("../../errors/request.js");
var _transportJs = require("../../errors/transport.js");
var _compatJs = require("../../utils/rpc/compat.js");
var _webSocketJs = require("../../utils/rpc/webSocket.js");
var _createTransportJs = require("./createTransport.js");
function webSocket(/** URL of the JSON-RPC API. Defaults to the chain's public RPC URL. */ url, config = {}) {
    const { keepAlive, key = 'webSocket', methods, name = 'WebSocket JSON-RPC', reconnect, retryDelay } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ })=>{
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 10000;
        const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
        const wsRpcClientOpts = {
            keepAlive,
            reconnect
        };
        if (!url_) throw new (0, _transportJs.UrlRequiredError)();
        return (0, _createTransportJs.createTransport)({
            key,
            methods,
            name,
            async request ({ method, params }) {
                const body = {
                    method,
                    params
                };
                const rpcClient = await (0, _webSocketJs.getWebSocketRpcClient)(url_, wsRpcClientOpts);
                const { error, result } = await rpcClient.requestAsync({
                    body,
                    timeout
                });
                if (error) throw new (0, _requestJs.RpcRequestError)({
                    body,
                    error,
                    url: url_
                });
                return result;
            },
            retryCount,
            retryDelay,
            timeout,
            type: 'webSocket'
        }, {
            getSocket () {
                return (0, _compatJs.getSocket)(url_);
            },
            getRpcClient () {
                return (0, _webSocketJs.getWebSocketRpcClient)(url_, wsRpcClientOpts);
            },
            async subscribe ({ params, onData, onError }) {
                const rpcClient = await (0, _webSocketJs.getWebSocketRpcClient)(url_, wsRpcClientOpts);
                const { result: subscriptionId } = await new Promise((resolve, reject)=>rpcClient.request({
                        body: {
                            method: 'eth_subscribe',
                            params
                        },
                        onError (error) {
                            reject(error);
                            onError?.(error);
                            return;
                        },
                        onResponse (response) {
                            if (response.error) {
                                reject(response.error);
                                onError?.(response.error);
                                return;
                            }
                            if (typeof response.id === 'number') {
                                resolve(response);
                                return;
                            }
                            if (response.method !== 'eth_subscription') return;
                            onData(response.params);
                        }
                    }));
                return {
                    subscriptionId,
                    async unsubscribe () {
                        return new Promise((resolve)=>rpcClient.request({
                                body: {
                                    method: 'eth_unsubscribe',
                                    params: [
                                        subscriptionId
                                    ]
                                },
                                onResponse: resolve
                            }));
                    }
                };
            }
        });
    };
}

},{"../../errors/request.js":"6LYvf","../../errors/transport.js":"gIsZQ","../../utils/rpc/compat.js":"59L70","../../utils/rpc/webSocket.js":"f4gwB","./createTransport.js":"cK0QC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jlvfC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ProviderRpcError", ()=>ProviderRpcError);
class ProviderRpcError extends Error {
    constructor(code, message){
        super(message);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.code = code;
        this.details = message;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4BWEN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeDeployData", ()=>decodeDeployData);
var _abiJs = require("../../errors/abi.js");
var _decodeAbiParametersJs = require("./decodeAbiParameters.js");
const docsPath = '/docs/contract/decodeDeployData';
function decodeDeployData(parameters) {
    const { abi, bytecode, data } = parameters;
    if (data === bytecode) return {
        bytecode
    };
    const description = abi.find((x)=>'type' in x && x.type === 'constructor');
    if (!description) throw new (0, _abiJs.AbiConstructorNotFoundError)({
        docsPath
    });
    if (!('inputs' in description)) throw new (0, _abiJs.AbiConstructorParamsNotFoundError)({
        docsPath
    });
    if (!description.inputs || description.inputs.length === 0) throw new (0, _abiJs.AbiConstructorParamsNotFoundError)({
        docsPath
    });
    const args = (0, _decodeAbiParametersJs.decodeAbiParameters)(description.inputs, `0x${data.replace(bytecode, '')}`);
    return {
        args,
        bytecode
    };
}

},{"../../errors/abi.js":"7l8j7","./decodeAbiParameters.js":"hR5FN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1OqbS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Converts an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098) into signature format.
 *
 * @param signature The compact signature to convert.
 * @returns The compact signature in signature format.
 *
 * @example
 * compactSignatureToSignature({
 *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
 *   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
 * })
 * // {
 * //   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
 * //   s: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
 * //   v: 27n
 * // }
 */ parcelHelpers.export(exports, "compactSignatureToSignature", ()=>compactSignatureToSignature);
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
function compactSignatureToSignature({ r, yParityAndS }) {
    const yParityAndS_bytes = (0, _toBytesJs.hexToBytes)(yParityAndS);
    const yParity = yParityAndS_bytes[0] & 0x80 ? 1 : 0;
    const s = yParityAndS_bytes;
    if (yParity === 1) s[0] &= 0x7f;
    return {
        r,
        s: (0, _toHexJs.bytesToHex)(s),
        yParity
    };
}

},{"../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5pPuk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Parses a hex formatted compact signature into a structured compact signature.
 *
 * @param signatureHex Signature in hex format.
 * @returns The structured signature.
 *
 * @example
 * parseCompactSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')
 * // { r: '0x...', yParityAndS: '0x...' }
 */ parcelHelpers.export(exports, "parseCompactSignature", ()=>parseCompactSignature);
var _secp256K1 = require("@noble/curves/secp256k1");
var _toHexJs = require("../encoding/toHex.js");
function parseCompactSignature(signatureHex) {
    const { r, s } = (0, _secp256K1.secp256k1).Signature.fromCompact(signatureHex.slice(2, 130));
    return {
        r: (0, _toHexJs.numberToHex)(r, {
            size: 32
        }),
        yParityAndS: (0, _toHexJs.numberToHex)(s, {
            size: 32
        })
    };
}

},{"@noble/curves/secp256k1":"8NuVo","../encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a2WwA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Parses a hex formatted signature into a structured signature.
 *
 * @param signatureHex Signature in hex format.
 * @returns The structured signature.
 *
 * @example
 * parseSignature('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')
 * // { r: '0x...', s: '0x...', v: 28n }
 */ parcelHelpers.export(exports, "parseSignature", ()=>parseSignature);
var _secp256K1 = require("@noble/curves/secp256k1");
var _toHexJs = require("../../utils/encoding/toHex.js");
function parseSignature(signatureHex) {
    const { r, s } = (0, _secp256K1.secp256k1).Signature.fromCompact(signatureHex.slice(2, 130));
    const yParityOrV = Number(`0x${signatureHex.slice(130)}`);
    const [v, yParity] = (()=>{
        if (yParityOrV === 0 || yParityOrV === 1) return [
            undefined,
            yParityOrV
        ];
        if (yParityOrV === 27) return [
            BigInt(yParityOrV),
            0
        ];
        if (yParityOrV === 28) return [
            BigInt(yParityOrV),
            1
        ];
        throw new Error('Invalid yParityOrV value');
    })();
    if (typeof v !== 'undefined') return {
        r: (0, _toHexJs.numberToHex)(r, {
            size: 32
        }),
        s: (0, _toHexJs.numberToHex)(s, {
            size: 32
        }),
        v,
        yParity
    };
    return {
        r: (0, _toHexJs.numberToHex)(r, {
            size: 32
        }),
        s: (0, _toHexJs.numberToHex)(s, {
            size: 32
        }),
        yParity
    };
}

},{"@noble/curves/secp256k1":"8NuVo","../../utils/encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9lNOC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "recoverTransactionAddress", ()=>recoverTransactionAddress);
var _keccak256Js = require("../hash/keccak256.js");
var _parseTransactionJs = require("../transaction/parseTransaction.js");
var _serializeTransactionJs = require("../transaction/serializeTransaction.js");
var _recoverAddressJs = require("./recoverAddress.js");
async function recoverTransactionAddress(parameters) {
    const { serializedTransaction, signature: signature_ } = parameters;
    const transaction = (0, _parseTransactionJs.parseTransaction)(serializedTransaction);
    const signature = signature_ ?? {
        r: transaction.r,
        s: transaction.s,
        v: transaction.v,
        yParity: transaction.yParity
    };
    const serialized = (0, _serializeTransactionJs.serializeTransaction)({
        ...transaction,
        r: undefined,
        s: undefined,
        v: undefined,
        yParity: undefined,
        sidecars: undefined
    });
    return await (0, _recoverAddressJs.recoverAddress)({
        hash: (0, _keccak256Js.keccak256)(serialized),
        signature
    });
}

},{"../hash/keccak256.js":"k4CmV","../transaction/parseTransaction.js":"a0tzY","../transaction/serializeTransaction.js":"eYYNO","./recoverAddress.js":"gBtnk","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"koUXF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Converts a signature into an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098).
 *
 * @param signature The signature to convert.
 * @returns The signature in compact format.
 *
 * @example
 * signatureToCompactSignature({
 *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
 *   s: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
 *   yParity: 0
 * })
 * // {
 * //   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
 * //   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'
 * // }
 */ parcelHelpers.export(exports, "signatureToCompactSignature", ()=>signatureToCompactSignature);
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
function signatureToCompactSignature(signature) {
    const { r, s, v, yParity } = signature;
    const yParity_ = Number(yParity ?? v - 27n);
    let yParityAndS = s;
    if (yParity_ === 1) {
        const bytes = (0, _toBytesJs.hexToBytes)(s);
        bytes[0] |= 0x80;
        yParityAndS = (0, _toHexJs.bytesToHex)(bytes);
    }
    return {
        r,
        yParityAndS
    };
}

},{"../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5LzHY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * @description Converts an [EIP-2098 compact signature](https://eips.ethereum.org/EIPS/eip-2098) into hex format.
 *
 * @param signature The compact signature to convert.
 * @returns The compact signature in hex format.
 *
 * @example
 * serializeCompactSignature({
 *   r: '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',
 *   yParityAndS: '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',
 * })
 * // "0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c"
 */ parcelHelpers.export(exports, "serializeCompactSignature", ()=>serializeCompactSignature);
var _secp256K1 = require("@noble/curves/secp256k1");
var _fromHexJs = require("../encoding/fromHex.js");
function serializeCompactSignature({ r, yParityAndS }) {
    return `0x${new (0, _secp256K1.secp256k1).Signature((0, _fromHexJs.hexToBigInt)(r), (0, _fromHexJs.hexToBigInt)(yParityAndS)).toCompactHex()}`;
}

},{"@noble/curves/secp256k1":"8NuVo","../encoding/fromHex.js":"kLfW5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bw1TC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Transforms a list of sidecars to their versioned hashes.
 *
 * @example
 * ```ts
 * import { toBlobSidecars, sidecarsToVersionedHashes, stringToHex } from 'viem'
 *
 * const sidecars = toBlobSidecars({ data: stringToHex('hello world') })
 * const versionedHashes = sidecarsToVersionedHashes({ sidecars })
 * ```
 */ parcelHelpers.export(exports, "sidecarsToVersionedHashes", ()=>sidecarsToVersionedHashes);
var _commitmentToVersionedHashJs = require("./commitmentToVersionedHash.js");
function sidecarsToVersionedHashes(parameters) {
    const { sidecars, version } = parameters;
    const to = parameters.to ?? (typeof sidecars[0].blob === 'string' ? 'hex' : 'bytes');
    const hashes = [];
    for (const { commitment } of sidecars)hashes.push((0, _commitmentToVersionedHashJs.commitmentToVersionedHash)({
        commitment,
        to,
        version
    }));
    return hashes;
}

},{"./commitmentToVersionedHash.js":"cAPDC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4Wzbt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromBlobs", ()=>fromBlobs);
var _cursorJs = require("../cursor.js");
var _toBytesJs = require("../encoding/toBytes.js");
var _toHexJs = require("../encoding/toHex.js");
function fromBlobs(parameters) {
    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
    const blobs = typeof parameters.blobs[0] === 'string' ? parameters.blobs.map((x)=>(0, _toBytesJs.hexToBytes)(x)) : parameters.blobs;
    const length = blobs.reduce((length, blob)=>length + blob.length, 0);
    const data = (0, _cursorJs.createCursor)(new Uint8Array(length));
    let active = true;
    for (const blob of blobs){
        const cursor = (0, _cursorJs.createCursor)(blob);
        while(active && cursor.position < blob.length){
            // First byte will be a zero 0x00 byte  we can skip.
            cursor.incrementPosition(1);
            let consume = 31;
            if (blob.length - cursor.position < 31) consume = blob.length - cursor.position;
            for(const _ in Array.from({
                length: consume
            })){
                const byte = cursor.readByte();
                const isTerminator = byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80);
                if (isTerminator) {
                    active = false;
                    break;
                }
                data.pushByte(byte);
            }
        }
    }
    const trimmedData = data.bytes.slice(0, data.position);
    return to === 'hex' ? (0, _toHexJs.bytesToHex)(trimmedData) : trimmedData;
}

},{"../cursor.js":"pWJ3P","../encoding/toBytes.js":"8cx1T","../encoding/toHex.js":"9GFC6","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lK8hy":[function(require,module,exports,__globalThis) {
/**
 * Defines a KZG interface.
 *
 * @example
 * ```ts
 * import * as cKzg from 'c-kzg'
 * import { defineKzg } from 'viem'
 * import { mainnetTrustedSetupPath } from 'viem/node'
 *
 * cKzg.loadTrustedSetup(mainnetTrustedSetupPath)
 *
 * const kzg = defineKzg(cKzg)
 * ```
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defineKzg", ()=>defineKzg);
function defineKzg({ blobToKzgCommitment, computeBlobKzgProof }) {
    return {
        blobToKzgCommitment,
        computeBlobKzgProof
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f2dU5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Sets up and returns a KZG interface.
 *
 * @example
 * ```ts
 * import * as cKzg from 'c-kzg'
 * import { setupKzg } from 'viem'
 * import { mainnetTrustedSetupPath } from 'viem/node'
 *
 * const kzg = setupKzg(cKzg, mainnetTrustedSetupPath)
 * ```
 */ parcelHelpers.export(exports, "setupKzg", ()=>setupKzg);
var _defineKzgJs = require("./defineKzg.js");
function setupKzg(parameters, path) {
    try {
        parameters.loadTrustedSetup(path);
    } catch (e) {
        const error = e;
        if (!error.message.includes('trusted setup is already loaded')) throw error;
    }
    return (0, _defineKzgJs.defineKzg)(parameters);
}

},{"./defineKzg.js":"lK8hy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4O6Uu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AppResponseSchema", ()=>t);
var _zod = require("zod");
var _appConfigMjs = require("./app-config.mjs");
var _cryptoAssetMjs = require("./crypto-asset.mjs");
const t = (0, _zod.z).object({
    id: (0, _zod.z).string(),
    name: (0, _zod.z).string(),
    logo_url: (0, _zod.z).string().nullable(),
    icon_url: (0, _zod.z).string().nullable(),
    terms_and_conditions_url: (0, _zod.z).string().nullable(),
    privacy_policy_url: (0, _zod.z).string().nullable(),
    require_users_accept_terms: (0, _zod.z).boolean().nullable(),
    theme: (0, _zod.z).string(),
    accent_color: (0, _zod.z).string().nullable(),
    show_wallet_login_first: (0, _zod.z).boolean(),
    allowed_domains: (0, _zod.z).array((0, _zod.z).string()),
    allowed_native_app_ids: (0, _zod.z).array((0, _zod.z).string()),
    allowed_native_app_url_schemes: (0, _zod.z).array((0, _zod.z).string()),
    wallet_auth: (0, _zod.z).boolean(),
    email_auth: (0, _zod.z).boolean(),
    sms_auth: (0, _zod.z).boolean(),
    google_oauth: (0, _zod.z).boolean(),
    twitter_oauth: (0, _zod.z).boolean(),
    discord_oauth: (0, _zod.z).boolean(),
    github_oauth: (0, _zod.z).boolean(),
    spotify_oauth: (0, _zod.z).boolean(),
    instagram_oauth: (0, _zod.z).boolean(),
    tiktok_oauth: (0, _zod.z).boolean(),
    linkedin_oauth: (0, _zod.z).boolean(),
    apple_oauth: (0, _zod.z).boolean(),
    farcaster_auth: (0, _zod.z).boolean(),
    passkey_auth: (0, _zod.z).boolean(),
    passkeys_for_signup_enabled: (0, _zod.z).boolean(),
    telegram_auth: (0, _zod.z).boolean(),
    guest_auth: (0, _zod.z).boolean(),
    solana_wallet_auth: (0, _zod.z).boolean(),
    custom_jwt_auth: (0, _zod.z).boolean(),
    disable_plus_emails: (0, _zod.z).boolean(),
    allowlist_enabled: (0, _zod.z).boolean(),
    allowlist_config: (0, _zod.z).object({
        error_title: (0, _zod.z).string().nullable(),
        error_detail: (0, _zod.z).string().nullable(),
        cta_text: (0, _zod.z).string().nullable(),
        cta_link: (0, _zod.z).string().nullable()
    }),
    wallet_connect_cloud_project_id: (0, _zod.z).string().nullable(),
    custom_api_url: (0, _zod.z).string().nullable(),
    embedded_wallet_config: (0, _appConfigMjs.EmbeddedWalletConfigSchema),
    enforce_wallet_uis: (0, _zod.z).boolean(),
    legacy_wallet_ui_config: (0, _zod.z).boolean(),
    fiat_on_ramp_enabled: (0, _zod.z).boolean(),
    captcha_enabled: (0, _zod.z).boolean(),
    twitter_oauth_on_mobile_enabled: (0, _zod.z).boolean(),
    mfa_methods: (0, _zod.z).array((0, _zod.z).enum([
        "sms",
        "totp",
        "passkey"
    ])),
    captcha_site_key: (0, _zod.z).string().optional(),
    verification_key: (0, _zod.z).string(),
    telegram_auth_config: (0, _appConfigMjs.TelegramAuthConfigSchema).optional(),
    funding_config: (0, _appConfigMjs.FundingConfigResponseSchema).optional(),
    max_linked_wallets_per_user: (0, _zod.z).number().nullable(),
    farcaster_link_wallets_enabled: (0, _zod.z).boolean(),
    whatsapp_enabled: (0, _zod.z).boolean()
});

},{"zod":"fOFdH","./app-config.mjs":"ftEfr","./crypto-asset.mjs":"eDVeC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ftEfr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmbeddedWalletConfigSchema", ()=>n);
parcelHelpers.export(exports, "EmbeddedWalletInputSchema", ()=>r);
parcelHelpers.export(exports, "FundingConfigResponseSchema", ()=>l);
parcelHelpers.export(exports, "FundingMethodArraySchema", ()=>s);
parcelHelpers.export(exports, "FundingMethodEnum", ()=>a);
parcelHelpers.export(exports, "TelegramAuthConfigSchema", ()=>t);
var _zod = require("zod");
var _cryptoAssetMjs = require("./crypto-asset.mjs");
const r = (0, _zod.z).object({
    create_on_login: (0, _zod.z).enum([
        "users-without-wallets",
        "all-users",
        "off"
    ]),
    ethereum: (0, _zod.z).object({
        create_on_login: (0, _zod.z).enum([
            "users-without-wallets",
            "all-users",
            "off"
        ])
    }),
    solana: (0, _zod.z).object({
        create_on_login: (0, _zod.z).enum([
            "users-without-wallets",
            "all-users",
            "off"
        ])
    }),
    user_owned_recovery_options: (0, _zod.z).array((0, _zod.z).enum([
        "user-passcode",
        "google-drive",
        "icloud"
    ])),
    require_user_owned_recovery_on_create: (0, _zod.z).boolean().optional(),
    require_user_password_on_create: (0, _zod.z).boolean().optional()
}), n = r.merge((0, _zod.z).object({
    mode: (0, _zod.z).enum([
        "legacy-embedded-wallets-only",
        "user-controlled-server-wallets-only"
    ])
})), t = (0, _zod.z).object({
    bot_id: (0, _zod.z).string(),
    bot_name: (0, _zod.z).string(),
    link_enabled: (0, _zod.z).boolean(),
    seamless_auth_enabled: (0, _zod.z).boolean()
}), a = (0, _zod.z).enum([
    "moonpay",
    "coinbase-onramp",
    "external"
]), s = (0, _zod.z).array(a), l = (0, _zod.z).object({
    default_recommended_currency: (0, _cryptoAssetMjs.Currency),
    default_recommended_amount: (0, _zod.z).string(),
    methods: s,
    options: (0, _zod.z).array((0, _zod.z).object({
        method: (0, _zod.z).string(),
        provider: (0, _zod.z).string()
    })),
    prompt_funding_on_wallet_creation: (0, _zod.z).boolean(),
    cross_chain_bridging_enabled: (0, _zod.z).boolean()
});

},{"zod":"fOFdH","./crypto-asset.mjs":"eDVeC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eDVeC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Currency", ()=>t);
var _zod = require("zod");
var _zodDefault = parcelHelpers.interopDefault(_zod);
const t = (0, _zodDefault.default).object({
    chain: (0, _zodDefault.default).string(),
    asset: (0, _zodDefault.default).enum([
        "native-currency",
        "USDC"
    ]).optional()
});

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aicc3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CoinbaseOnRampInitInput", ()=>m);
parcelHelpers.export(exports, "CoinbaseOnRampInitResponse", ()=>p);
parcelHelpers.export(exports, "CoinbaseOnRampStatusResponse", ()=>c);
var _zod = require("zod");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
let e = (0, _zod.z).enum([
    "ethereum",
    "bitcoin",
    "base",
    "avacchain",
    "optimism",
    "solana",
    "polygon",
    "arbitrum",
    "stellar"
]), o = (0, _zod.z).enum([
    "eth",
    "ETH",
    "USDC"
]).transform((r)=>r.toUpperCase()), t = (0, _zod.z).enum([
    "SOL",
    "USDC"
]).transform((r)=>r.toUpperCase()), n = (0, _zod.z).object({
    addresses: (0, _zod.z).array((0, _zod.z).object({
        address: (0, _coreMjs.WalletAddress),
        blockchains: (0, _zod.z).array(e)
    })).max(1).min(1),
    assets: (0, _zod.z).array(o).optional()
}), i = (0, _zod.z).object({
    addresses: (0, _zod.z).array((0, _zod.z).object({
        address: (0, _coreMjs.SolanaWalletAddress),
        blockchains: (0, _zod.z).array(e)
    })).max(1).min(1),
    assets: (0, _zod.z).array(t).optional()
});
const m = (0, _zod.z).union([
    n,
    i
]), p = (0, _zod.z).object({
    app_id: (0, _zod.z).string(),
    session_token: (0, _zod.z).string(),
    channel_id: (0, _zod.z).string(),
    partner_user_id: (0, _zod.z).string()
}), c = (0, _zod.z).object({
    status: (0, _zod.z).enum([
        "pending",
        "success",
        "failure"
    ])
});

},{"zod":"fOFdH","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dYxg2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CrossAppConnectionsResponse", ()=>o);
var _zod = require("zod");
const o = (0, _zod.z).object({
    connections: (0, _zod.z).array((0, _zod.z).object({
        provider_app_id: (0, _zod.z).string(),
        provider_app_name: (0, _zod.z).string(),
        provider_app_icon_url: (0, _zod.z).string().url().nullable(),
        provider_app_custom_api_url: (0, _zod.z).string().url().nullable(),
        read_only: (0, _zod.z).boolean()
    }))
});

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"13N5i":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthenticateJwtInput", ()=>r);
parcelHelpers.export(exports, "LinkJwtInput", ()=>m);
var _zod = require("zod");
var _zodDefault = parcelHelpers.interopDefault(_zod);
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
const r = (0, _zodDefault.default).object({
    token: (0, _zodDefault.default).string().optional()
}).merge((0, _coreMjs.AuthenticateMode)), m = (0, _zodDefault.default).object({
    token: (0, _zodDefault.default).string().optional()
});

},{"zod":"fOFdH","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iYakZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthenticateEmailInput", ()=>s);
parcelHelpers.export(exports, "InitEmailInput", ()=>d);
parcelHelpers.export(exports, "TransferEmailInput", ()=>p);
parcelHelpers.export(exports, "UnlinkEmailInput", ()=>c);
parcelHelpers.export(exports, "UpdateEmailInput", ()=>n);
parcelHelpers.export(exports, "VerifyEmailInput", ()=>i);
var _zod = require("zod");
var _accountTransferMjs = require("./account-transfer.mjs");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
const i = (0, _zod.z).object({
    code: (0, _coreMjs.PasswordlessCode),
    email: (0, _coreMjs.Email)
}), s = i.merge((0, _coreMjs.AuthenticateMode)), d = (0, _zod.z).object({
    email: (0, _coreMjs.Email),
    token: (0, _zod.z).string().optional()
}), c = (0, _zod.z).object({
    address: (0, _coreMjs.Email)
}), n = (0, _zod.z).object({
    oldAddress: (0, _coreMjs.Email),
    newAddress: (0, _coreMjs.Email),
    code: (0, _coreMjs.PasswordlessCode)
}), p = (0, _accountTransferMjs.BaseAccountTransferInput).extend({
    email: (0, _coreMjs.Email)
});

},{"zod":"fOFdH","./account-transfer.mjs":"f44i0","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f44i0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseAccountTransferInput", ()=>t);
var _zod = require("zod");
const t = (0, _zod.z).object({
    nonce: (0, _zod.z).string()
});

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eiJwy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JsonWebKey", ()=>n);
parcelHelpers.export(exports, "JsonWebKeySet", ()=>o);
var _zod = require("zod");
const n = (0, _zod.z).object({
    kty: (0, _zod.z).string(),
    use: (0, _zod.z).enum([
        "sig",
        "enc"
    ]).optional(),
    key_ops: (0, _zod.z).array((0, _zod.z).enum([
        "sign",
        "verify",
        "encrypt",
        "decrypt",
        "wrapKey",
        "unwrapKey",
        "deriveKey",
        "deriveBits"
    ])).optional(),
    alg: (0, _zod.z).enum([
        "RS256",
        "ES256"
    ]),
    kid: (0, _zod.z).string().optional(),
    x5u: (0, _zod.z).string().optional(),
    x5c: (0, _zod.z).array((0, _zod.z).string()).optional(),
    x5t: (0, _zod.z).string().optional(),
    "x5t#S256": (0, _zod.z).string().optional(),
    n: (0, _zod.z).string().optional(),
    e: (0, _zod.z).string().optional(),
    d: (0, _zod.z).string().optional(),
    crv: (0, _zod.z).string().optional(),
    x: (0, _zod.z).string().optional(),
    y: (0, _zod.z).string().optional(),
    xvalue: (0, _zod.z).string().optional(),
    yvalue: (0, _zod.z).string().optional()
}), o = (0, _zod.z).object({
    keys: (0, _zod.z).array(n)
});

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9mYsv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FarcasterAuthenticateInput", ()=>o);
parcelHelpers.export(exports, "FarcasterConnectInitResponse", ()=>n);
parcelHelpers.export(exports, "FarcasterConnectStatusCompletedResponse", ()=>i);
parcelHelpers.export(exports, "FarcasterConnectStatusPendingResponse", ()=>s);
parcelHelpers.export(exports, "FarcasterInitInput", ()=>a);
parcelHelpers.export(exports, "FarcasterLinkInput", ()=>g);
parcelHelpers.export(exports, "FarcasterUnlinkInput", ()=>m);
parcelHelpers.export(exports, "FarcasterV2AuthenticateInput", ()=>d);
parcelHelpers.export(exports, "FarcasterV2InitInput", ()=>b);
parcelHelpers.export(exports, "FarcasterV2InitResponse", ()=>p);
parcelHelpers.export(exports, "TransferFarcasterInput", ()=>c);
var _zod = require("zod");
var _accountTransferMjs = require("./account-transfer.mjs");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
const n = (0, _zod.z).object({
    channel_token: (0, _zod.z).string(),
    connect_uri: (0, _zod.z).string()
}), i = (0, _zod.z).object({
    state: (0, _zod.z).literal("completed"),
    nonce: (0, _zod.z).string(),
    message: (0, _zod.z).string(),
    signature: (0, _zod.z).string(),
    fid: (0, _zod.z).number(),
    username: (0, _zod.z).string(),
    display_name: (0, _zod.z).string(),
    bio: (0, _zod.z).string(),
    pfp_url: (0, _zod.z).string()
}), s = (0, _zod.z).object({
    state: (0, _zod.z).literal("pending"),
    nonce: (0, _zod.z).string()
}), o = (0, _zod.z).object({
    channel_token: (0, _zod.z).string(),
    message: (0, _zod.z).string(),
    signature: (0, _zod.z).string(),
    fid: (0, _zod.z).number()
}).merge((0, _coreMjs.AuthenticateMode)), g = (0, _zod.z).object({
    channel_token: (0, _zod.z).string(),
    message: (0, _zod.z).string(),
    signature: (0, _zod.z).string(),
    fid: (0, _zod.z).number()
}), a = (0, _zod.z).object({
    token: (0, _zod.z).string().optional(),
    redirect_url: (0, _zod.z).string().url().optional(),
    relying_party: (0, _zod.z).string().optional()
}), m = (0, _zod.z).object({
    fid: (0, _zod.z).number()
}), c = (0, _accountTransferMjs.BaseAccountTransferInput).extend({
    farcaster_id: (0, _zod.z).string(),
    farcaster_embedded_address: (0, _zod.z).string()
}), b = (0, _zod.z).object({}), p = (0, _zod.z).object({
    nonce: (0, _zod.z).string(),
    expires_at: (0, _zod.z).string()
}), d = (0, _zod.z).object({
    fid: (0, _zod.z).number(),
    message: (0, _zod.z).string(),
    signature: (0, _zod.z).string()
}).merge((0, _coreMjs.AuthenticateMode));

},{"zod":"fOFdH","./account-transfer.mjs":"f44i0","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"17BIU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FarcasterSignerInitInput", ()=>i);
parcelHelpers.export(exports, "FarcasterSignerInitResponse", ()=>e);
parcelHelpers.export(exports, "FarcasterSignerStatusResponse", ()=>n);
var _zod = require("zod");
const i = (0, _zod.z).object({
    ed25519_public_key: (0, _zod.z).string().refine((t)=>t.startsWith("0x") && 66 === t.length),
    deadline: (0, _zod.z).bigint().optional().default(()=>BigInt(Math.floor(Date.now() / 1e3) + 3600))
}), e = (0, _zod.z).discriminatedUnion("status", [
    (0, _zod.z).object({
        public_key: (0, _zod.z).string(),
        status: (0, _zod.z).literal("pending_approval"),
        signer_approval_url: (0, _zod.z).string()
    }),
    (0, _zod.z).object({
        public_key: (0, _zod.z).string(),
        status: (0, _zod.z).literal("approved"),
        fid: (0, _zod.z).bigint()
    }),
    (0, _zod.z).object({
        public_key: (0, _zod.z).string(),
        status: (0, _zod.z).literal("revoked"),
        fid: (0, _zod.z).bigint()
    })
]), n = (0, _zod.z).discriminatedUnion("status", [
    (0, _zod.z).object({
        public_key: (0, _zod.z).string(),
        status: (0, _zod.z).literal("pending_approval")
    }),
    (0, _zod.z).object({
        public_key: (0, _zod.z).string(),
        status: (0, _zod.z).literal("approved"),
        fid: (0, _zod.z).bigint()
    }),
    (0, _zod.z).object({
        public_key: (0, _zod.z).string(),
        status: (0, _zod.z).literal("revoked"),
        fid: (0, _zod.z).bigint()
    })
]);

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l2QE3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthenticateGuestInput", ()=>e);
var _zod = require("zod");
const e = (0, _zod.z).object({
    guest_credential: (0, _zod.z).string().length(43)
}).strict();

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"couzx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AppleOauthIdTokenEntry", ()=>F);
parcelHelpers.export(exports, "CrossAppIdTokenEntry", ()=>H);
parcelHelpers.export(exports, "CustomJwtIdTokenEntry", ()=>G);
parcelHelpers.export(exports, "DiscordOauthIdTokenEntry", ()=>q);
parcelHelpers.export(exports, "EmailIdTokenEntry", ()=>j);
parcelHelpers.export(exports, "FarcasterIdTokenEntry", ()=>f);
parcelHelpers.export(exports, "GithubOauthIdTokenEntry", ()=>A);
parcelHelpers.export(exports, "GoogleOauthIdTokenEntry", ()=>N);
parcelHelpers.export(exports, "InstagramOauthIdTokenEntry", ()=>D);
parcelHelpers.export(exports, "LinkedInOauthIdTokenEntry", ()=>B);
parcelHelpers.export(exports, "PasskeyIdTokenEntry", ()=>h);
parcelHelpers.export(exports, "PhoneIdTokenEntry", ()=>g);
parcelHelpers.export(exports, "SmartWalletIdTokenEntry", ()=>I);
parcelHelpers.export(exports, "SpotifyOauthIdTokenEntry", ()=>C);
parcelHelpers.export(exports, "TelegramIdTokenEntry", ()=>v);
parcelHelpers.export(exports, "TiktokOauthIdTokenEntry", ()=>E);
parcelHelpers.export(exports, "TwitterOauthIdTokenEntry", ()=>z);
parcelHelpers.export(exports, "WalletIdTokenEntry", ()=>w);
var _zod = require("zod");
var _userMjs = require("./user.mjs");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
var _smartWalletConfigMjs = require("./smart-wallet-config.mjs");
var _smartWalletsMjs = require("../constants/smart-wallets.mjs");
let _ = {
    lv: (0, _zod.z).number().nullable()
};
const j = (0, _userMjs.EmailAccount).pick({
    type: !0,
    address: !0
}).extend(_), g = (0, _userMjs.PhoneAccount).pick({
    type: !0,
    phoneNumber: !0
}).extend(_).transform(({ phoneNumber: e, ...t })=>({
        phone_number: e,
        ...t
    })), w = (0, _userMjs.EthereumAccount).pick({
    type: !0,
    address: !0,
    chain_type: !0,
    wallet_client_type: !0
}).extend({
    ..._,
    id: (0, _zod.z).string().optional()
}), f = (0, _userMjs.FarcasterAccount).pick({
    type: !0,
    fid: !0,
    username: !0,
    owner_address: !0
}).extend(_).transform(({ owner_address: e, ...t })=>({
        oa: e,
        ...t
    })), h = (0, _userMjs.PasskeyAccount).pick({
    type: !0,
    credential_id: !0
}).extend(_), v = (0, _zod.z).object({
    type: (0, _zod.z).literal("telegram"),
    telegram_user_id: (0, _zod.z).string(),
    username: (0, _zod.z).string().nullish(),
    lv: (0, _zod.z).number().nullable()
}), N = (0, _userMjs.GoogleOauthAccount).pick({
    type: !0,
    subject: !0,
    email: !0,
    name: !0
}).extend(_), z = (0, _userMjs.TwitterOauthAccount).pick({
    type: !0,
    subject: !0,
    username: !0
}).extend(_).extend({
    name: (0, _zod.z).string().nullable().optional(),
    pfp: (0, _zod.z).string().nullable().optional()
}), q = (0, _userMjs.DiscordOauthAccount).pick({
    type: !0,
    subject: !0,
    username: !0
}).extend(_), A = (0, _userMjs.GithubOauthAccount).pick({
    type: !0,
    subject: !0,
    username: !0
}).extend(_), B = (0, _userMjs.LinkedInOauthAccount).pick({
    type: !0,
    subject: !0,
    email: !0
}).extend(_), C = (0, _userMjs.SpotifyOauthAccount).pick({
    type: !0,
    subject: !0,
    email: !0
}).extend(_), D = (0, _userMjs.InstagramOauthAccount).pick({
    type: !0,
    subject: !0,
    username: !0
}).extend(_), E = (0, _userMjs.TiktokOauthAccount).pick({
    type: !0,
    subject: !0,
    username: !0
}).extend(_), F = (0, _userMjs.AppleOauthAccount).pick({
    type: !0,
    subject: !0,
    email: !0
}).extend(_), G = (0, _userMjs.CustomJwtAccount).pick({
    type: !0,
    custom_user_id: !0
}).extend(_), H = (0, _userMjs.CrossAppAccount).pick({
    type: !0,
    subject: !0,
    provider_app_id: !0,
    embedded_wallets: !0,
    smart_wallets: !0
}).extend(_), I = (0, _userMjs.SmartWalletAccount).pick({
    type: !0,
    smart_wallet_type: !0,
    address: !0
}).extend(_);

},{"zod":"fOFdH","./user.mjs":"59vYa","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","./smart-wallet-config.mjs":"eeJcS","../constants/smart-wallets.mjs":"hQh54","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"59vYa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AppleOauthAccount", ()=>U);
parcelHelpers.export(exports, "AuthenticatedUser", ()=>P);
parcelHelpers.export(exports, "AuthorizationKeyAccount", ()=>C);
parcelHelpers.export(exports, "BaseWalletAccount", ()=>n);
parcelHelpers.export(exports, "BitcoinSegwitEmbeddedWalletAccount", ()=>g);
parcelHelpers.export(exports, "BitcoinTaprootEmbeddedWalletAccount", ()=>f);
parcelHelpers.export(exports, "CrossAppAccount", ()=>B);
parcelHelpers.export(exports, "CrossAppEmbeddedWallet", ()=>q);
parcelHelpers.export(exports, "CrossAppSmartWallet", ()=>A);
parcelHelpers.export(exports, "CustomJwtAccount", ()=>V);
parcelHelpers.export(exports, "CustomMetadata", ()=>J);
parcelHelpers.export(exports, "DiscordOauthAccount", ()=>k);
parcelHelpers.export(exports, "EmailAccount", ()=>r);
parcelHelpers.export(exports, "EthereumAccount", ()=>a);
parcelHelpers.export(exports, "EthereumEmbeddedWalletAccount", ()=>c);
parcelHelpers.export(exports, "FarcasterAccount", ()=>_);
parcelHelpers.export(exports, "GithubOauthAccount", ()=>w);
parcelHelpers.export(exports, "GoogleOauthAccount", ()=>j);
parcelHelpers.export(exports, "InstagramOauthAccount", ()=>N);
parcelHelpers.export(exports, "LinkedAccount", ()=>D);
parcelHelpers.export(exports, "LinkedInOauthAccount", ()=>x);
parcelHelpers.export(exports, "LinkedMfaMethod", ()=>H);
parcelHelpers.export(exports, "LoggedOutUser", ()=>Q);
parcelHelpers.export(exports, "MaybeUser", ()=>R);
parcelHelpers.export(exports, "OAuthTokens", ()=>K);
parcelHelpers.export(exports, "PasskeyAccount", ()=>u);
parcelHelpers.export(exports, "PasskeyMfaMethod", ()=>G);
parcelHelpers.export(exports, "PhoneAccount", ()=>l);
parcelHelpers.export(exports, "SessionUpdateActionEnum", ()=>M);
parcelHelpers.export(exports, "SmartWalletAccount", ()=>s);
parcelHelpers.export(exports, "SmsMfaMethod", ()=>E);
parcelHelpers.export(exports, "SolanaAccount", ()=>o);
parcelHelpers.export(exports, "SolanaEmbeddedWalletAccount", ()=>p);
parcelHelpers.export(exports, "SpotifyOauthAccount", ()=>z);
parcelHelpers.export(exports, "TelegramAccount", ()=>b);
parcelHelpers.export(exports, "TiktokOauthAccount", ()=>I);
parcelHelpers.export(exports, "TotpMfaMethod", ()=>F);
parcelHelpers.export(exports, "TwitterOauthAccount", ()=>h);
parcelHelpers.export(exports, "UnifiedWalletAccount", ()=>y);
parcelHelpers.export(exports, "User", ()=>L);
parcelHelpers.export(exports, "UserWithIdentityToken", ()=>O);
var _zod = require("zod");
var _coreMjs = require("./core.mjs");
var _smartWalletConfigMjs = require("./smart-wallet-config.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
var _smartWalletsMjs = require("../constants/smart-wallets.mjs");
const r = (0, _zod.z).object({
    type: (0, _zod.z).literal("email"),
    address: (0, _zod.z).string(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), l = (0, _zod.z).object({
    type: (0, _zod.z).literal("phone"),
    number: (0, _zod.z).string().optional(),
    phoneNumber: (0, _zod.z).string(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), n = (0, _zod.z).object({
    type: (0, _zod.z).enum([
        "wallet",
        "smart_wallet"
    ]),
    address: (0, _zod.z).string(),
    chain_type: (0, _zod.z).enum([
        "solana",
        "ethereum"
    ])
}), a = (0, _zod.z).object({
    type: (0, _zod.z).literal("wallet"),
    address: (0, _zod.z).string(),
    chain_id: (0, _zod.z).string().optional(),
    chain_type: (0, _zod.z).literal("ethereum"),
    wallet_client: (0, _zod.z).literal("unknown"),
    wallet_client_type: (0, _zod.z).string().optional(),
    connector_type: (0, _zod.z).string().optional(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), s = (0, _zod.z).object({
    type: (0, _zod.z).literal("smart_wallet"),
    address: (0, _zod.z).string(),
    smart_wallet_type: (0, _smartWalletConfigMjs.SmartWalletProvider),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), o = (0, _zod.z).object({
    type: (0, _zod.z).literal("wallet"),
    address: (0, _zod.z).string(),
    chain_type: (0, _zod.z).literal("solana"),
    wallet_client: (0, _zod.z).literal("unknown"),
    wallet_client_type: (0, _zod.z).string().optional(),
    connector_type: (0, _zod.z).string().optional(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), _ = (0, _zod.z).object({
    type: (0, _zod.z).literal("farcaster"),
    fid: (0, _zod.z).number(),
    owner_address: (0, _coreMjs.WalletAddress),
    username: (0, _zod.z).string().optional(),
    display_name: (0, _zod.z).string().optional(),
    bio: (0, _zod.z).string().optional(),
    profile_picture: (0, _zod.z).string().optional(),
    profile_picture_url: (0, _zod.z).string().optional(),
    homepage_url: (0, _zod.z).string().optional(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable(),
    signer_public_key: (0, _zod.z).string().optional()
}), u = (0, _zod.z).object({
    type: (0, _zod.z).literal("passkey"),
    created_with_browser: (0, _zod.z).string().optional(),
    created_with_os: (0, _zod.z).string().optional(),
    created_with_device: (0, _zod.z).string().optional(),
    credential_id: (0, _zod.z).string(),
    authenticator_name: (0, _zod.z).string().optional(),
    enrolled_in_mfa: (0, _zod.z).boolean(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), b = (0, _zod.z).object({
    type: (0, _zod.z).literal("telegram"),
    telegram_user_id: (0, _zod.z).string(),
    first_name: (0, _zod.z).string().nullish(),
    last_name: (0, _zod.z).string().nullish(),
    username: (0, _zod.z).string().nullish(),
    photo_url: (0, _zod.z).string().nullish(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}).transform((e)=>({
        ...e,
        telegramUserId: e.telegram_user_id,
        firstName: e.first_name
    }));
let m = (0, _zod.z).enum([
    "privy",
    "user-passcode",
    "google-drive",
    "icloud",
    "recovery-encryption-key",
    "privy-v2"
]), d = (0, _zod.z).object({
    id: (0, _zod.z).string().nullable().default(null),
    type: (0, _zod.z).literal("wallet"),
    address: (0, _zod.z).string(),
    imported: (0, _zod.z).boolean().default(!1),
    delegated: (0, _zod.z).boolean().default(!1),
    wallet_index: (0, _zod.z).number(),
    chain_id: (0, _zod.z).string(),
    chain_type: (0, _zod.z).string(),
    wallet_client: (0, _zod.z).literal("privy"),
    wallet_client_type: (0, _zod.z).literal("privy"),
    connector_type: (0, _zod.z).literal("embedded"),
    recovery_method: m,
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
});
const c = d.merge((0, _zod.z).object({
    chain_type: (0, _zod.z).literal("ethereum")
})), p = d.merge((0, _zod.z).object({
    chain_type: (0, _zod.z).literal("solana"),
    public_key: (0, _zod.z).string()
})), g = d.merge((0, _zod.z).object({
    chain_type: (0, _zod.z).literal("bitcoin-segwit"),
    public_key: (0, _zod.z).string()
})), f = d.merge((0, _zod.z).object({
    chain_type: (0, _zod.z).literal("bitcoin-taproot"),
    public_key: (0, _zod.z).string()
}));
let v = (0, _zod.z).object({
    id: (0, _zod.z).string(),
    recovery_method: (0, _zod.z).literal("privy-v2")
});
const y = (0, _zod.z).union([
    c.merge(v),
    p.merge(v),
    g.merge(v),
    f.merge(v)
]), j = (0, _zod.z).object({
    type: (0, _zod.z).literal("google_oauth"),
    subject: (0, _zod.z).string(),
    email: (0, _zod.z).string(),
    name: (0, _zod.z).string().nullable(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), h = (0, _zod.z).object({
    type: (0, _zod.z).literal("twitter_oauth"),
    subject: (0, _zod.z).string(),
    username: (0, _zod.z).string().nullable(),
    name: (0, _zod.z).string().nullable(),
    profile_picture_url: (0, _zod.z).string().nullable(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), k = (0, _zod.z).object({
    type: (0, _zod.z).literal("discord_oauth"),
    subject: (0, _zod.z).string(),
    username: (0, _zod.z).string().nullable(),
    email: (0, _zod.z).string().nullable(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), w = (0, _zod.z).object({
    type: (0, _zod.z).literal("github_oauth"),
    subject: (0, _zod.z).string(),
    username: (0, _zod.z).string().nullable(),
    name: (0, _zod.z).string().nullable(),
    email: (0, _zod.z).string().nullable(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), x = (0, _zod.z).object({
    type: (0, _zod.z).literal("linkedin_oauth"),
    subject: (0, _zod.z).string(),
    name: (0, _zod.z).string().optional(),
    email: (0, _zod.z).string().nullable(),
    vanity_name: (0, _zod.z).string().optional(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), z = (0, _zod.z).object({
    type: (0, _zod.z).literal("spotify_oauth"),
    subject: (0, _zod.z).string(),
    email: (0, _zod.z).string().nullable(),
    name: (0, _zod.z).string().nullable(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), N = (0, _zod.z).object({
    type: (0, _zod.z).literal("instagram_oauth"),
    subject: (0, _zod.z).string(),
    username: (0, _zod.z).string().nullable(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), I = (0, _zod.z).object({
    type: (0, _zod.z).literal("tiktok_oauth"),
    subject: (0, _zod.z).string(),
    username: (0, _zod.z).string().nullable(),
    name: (0, _zod.z).string().nullable(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), U = (0, _zod.z).object({
    type: (0, _zod.z).literal("apple_oauth"),
    subject: (0, _zod.z).string(),
    email: (0, _zod.z).string().nullable(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), V = (0, _zod.z).object({
    type: (0, _zod.z).literal("custom_auth"),
    custom_user_id: (0, _zod.z).string(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), q = (0, _zod.z).object({
    address: (0, _zod.z).string()
}), A = (0, _zod.z).object({
    address: (0, _zod.z).string()
}), B = (0, _zod.z).object({
    type: (0, _zod.z).literal("cross_app"),
    subject: (0, _zod.z).string(),
    provider_app_id: (0, _zod.z).string(),
    embedded_wallets: (0, _zod.z).array(q),
    smart_wallets: (0, _zod.z).array(A),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), C = (0, _zod.z).object({
    type: (0, _zod.z).literal("authorization_key"),
    public_key: (0, _zod.z).string(),
    verified_at: (0, _zod.z).number(),
    first_verified_at: (0, _zod.z).number().nullable(),
    latest_verified_at: (0, _zod.z).number().nullable()
}), D = (0, _zod.z).union([
    r,
    l,
    a,
    o,
    s,
    c,
    p,
    g,
    f,
    j,
    h,
    k,
    w,
    z,
    N,
    I,
    x,
    U,
    V,
    _,
    u,
    b,
    B,
    C
]), E = (0, _zod.z).object({
    type: (0, _zod.z).literal("sms"),
    verified_at: (0, _zod.z).number()
}), F = (0, _zod.z).object({
    type: (0, _zod.z).literal("totp"),
    verified_at: (0, _zod.z).number()
}), G = (0, _zod.z).object({
    type: (0, _zod.z).literal("passkey"),
    verified_at: (0, _zod.z).number()
}), H = (0, _zod.z).union([
    E,
    F,
    G
]), J = (0, _zod.z).record((0, _zod.z).string(), (0, _zod.z).union([
    (0, _zod.z).string(),
    (0, _zod.z).number(),
    (0, _zod.z).boolean()
])), K = (0, _zod.z).object({
    provider: (0, _zod.z).string(),
    access_token: (0, _zod.z).string(),
    access_token_expires_in_seconds: (0, _zod.z).number().optional(),
    refresh_token: (0, _zod.z).string().optional(),
    refresh_token_expires_in_seconds: (0, _zod.z).number().optional(),
    scopes: (0, _zod.z).array((0, _zod.z).string()).optional()
}), L = (0, _zod.z).object({
    id: (0, _zod.z).string(),
    linked_accounts: (0, _zod.z).array(D),
    mfa_methods: (0, _zod.z).array(H),
    created_at: (0, _zod.z).number(),
    has_accepted_terms: (0, _zod.z).boolean(),
    is_guest: (0, _zod.z).boolean(),
    custom_metadata: J.optional()
}), M = (0, _zod.z).enum([
    "set",
    "ignore",
    "clear"
]), O = (0, _zod.z).object({
    user: L,
    identity_token: (0, _zod.z).string().min(1).nullable()
}), P = (0, _zod.z).object({
    user: L,
    token: (0, _zod.z).string().min(1).nullable(),
    privy_access_token: (0, _zod.z).string().min(1).nullable(),
    refresh_token: (0, _zod.z).string().min(1).nullable(),
    identity_token: (0, _zod.z).string().min(1).optional(),
    is_new_user: (0, _zod.z).boolean().optional(),
    oauth_tokens: K.optional(),
    oauth_provider_tokens: (0, _zod.z).object({
        provider: (0, _zod.z).string(),
        access_token: (0, _zod.z).string(),
        access_token_expires_in_seconds: (0, _zod.z).number().optional(),
        refresh_token: (0, _zod.z).string().optional(),
        scopes: (0, _zod.z).array((0, _zod.z).string()).optional()
    }).optional(),
    session_update_action: M
}), Q = (0, _zod.z).object({
    user: (0, _zod.z).null(),
    token: (0, _zod.z).null(),
    refresh_token: (0, _zod.z).null(),
    session_update_action: (0, _zod.z).literal(M.Values.clear)
}), R = (0, _zod.z).union([
    P,
    Q
]);

},{"zod":"fOFdH","./core.mjs":"9c2nU","./smart-wallet-config.mjs":"eeJcS","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","../constants/smart-wallets.mjs":"hQh54","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eeJcS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BICONOMY", ()=>(0, _smartWalletsMjs.BICONOMY));
parcelHelpers.export(exports, "COINBASE_SMART_WALLET", ()=>(0, _smartWalletsMjs.COINBASE_SMART_WALLET));
parcelHelpers.export(exports, "KERNEL", ()=>(0, _smartWalletsMjs.KERNEL));
parcelHelpers.export(exports, "LIGHT_ACCOUNT", ()=>(0, _smartWalletsMjs.LIGHT_ACCOUNT));
parcelHelpers.export(exports, "SAFE", ()=>(0, _smartWalletsMjs.SAFE));
parcelHelpers.export(exports, "THIRDWEB", ()=>(0, _smartWalletsMjs.THIRDWEB));
parcelHelpers.export(exports, "AlchemyPaymasterContextSchema", ()=>a);
parcelHelpers.export(exports, "SUPPORTED_SMART_WALLET_TYPES", ()=>(0, _smartWalletsMjs.SUPPORTED_SMART_WALLET_TYPES));
parcelHelpers.export(exports, "SmartWalletConfigurationInputSchema", ()=>s);
parcelHelpers.export(exports, "SmartWalletConfigurationResponseSchema", ()=>p);
parcelHelpers.export(exports, "SmartWalletConfigurationSchema", ()=>l);
parcelHelpers.export(exports, "SmartWalletNetworkConfigurationInputSchema", ()=>o);
parcelHelpers.export(exports, "SmartWalletProvider", ()=>r);
var _zod = require("zod");
var _smartWalletsMjs = require("../constants/smart-wallets.mjs");
const r = (0, _zod.z).enum((0, _smartWalletsMjs.SUPPORTED_SMART_WALLET_TYPES), {
    invalid_type_error: "Please specify a supported provider.",
    required_error: "Please specify a supported provider."
});
let n = (0, _zod.z).string().regex(/^eip155:\d+$/, "Chain ID must be an eip155 chain ID");
const a = (0, _zod.z).object({
    policy_id: (0, _zod.z).string().uuid()
});
let i = (0, _zod.z).object({
    chain_id: n,
    bundler_url: (0, _zod.z).string(),
    paymaster_url: (0, _zod.z).string().optional(),
    rpc_url: (0, _zod.z).string().optional(),
    chain_name: (0, _zod.z).string().optional(),
    paymaster_context: a.optional()
});
const o = (0, _zod.z).object({
    chain_id: n,
    bundler_url: (0, _zod.z).string().optional(),
    paymaster_url: (0, _zod.z).string().optional(),
    rpc_url: (0, _zod.z).string().optional(),
    chain_name: (0, _zod.z).string().optional(),
    paymaster_context: a.optional()
}), l = (0, _zod.z).discriminatedUnion("enabled", [
    (0, _zod.z).object({
        enabled: (0, _zod.z).literal(!1)
    }),
    (0, _zod.z).object({
        enabled: (0, _zod.z).literal(!0),
        smart_wallet_type: r,
        configured_networks: (0, _zod.z).array(i).min(1)
    })
]), s = (0, _zod.z).discriminatedUnion("enabled", [
    (0, _zod.z).object({
        enabled: (0, _zod.z).literal(!1)
    }),
    (0, _zod.z).object({
        enabled: (0, _zod.z).literal(!0),
        smart_wallet_type: r,
        configured_networks: (0, _zod.z).array(o).min(1)
    })
]), p = l;

},{"zod":"fOFdH","../constants/smart-wallets.mjs":"hQh54","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hQh54":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BICONOMY", ()=>a);
parcelHelpers.export(exports, "COINBASE_SMART_WALLET", ()=>c);
parcelHelpers.export(exports, "KERNEL", ()=>t);
parcelHelpers.export(exports, "LIGHT_ACCOUNT", ()=>o);
parcelHelpers.export(exports, "SAFE", ()=>e);
parcelHelpers.export(exports, "SUPPORTED_SMART_WALLET_TYPES", ()=>i);
parcelHelpers.export(exports, "THIRDWEB", ()=>n);
const e = "safe", t = "kernel", a = "biconomy", o = "light_account", c = "coinbase_smart_wallet", n = "thirdweb", i = [
    "safe",
    "kernel",
    "biconomy",
    "light_account",
    "coinbase_smart_wallet",
    "thirdweb"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2vYSX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MfaSmsAuthenticateEnrollInput", ()=>s);
parcelHelpers.export(exports, "MfaSmsEnrollInput", ()=>b);
parcelHelpers.export(exports, "MfaSmsInitInput", ()=>n);
parcelHelpers.export(exports, "MfaSmsVerifyInput", ()=>l);
parcelHelpers.export(exports, "MfaTotpInput", ()=>m);
parcelHelpers.export(exports, "MfaVerifyResponse", ()=>r);
parcelHelpers.export(exports, "ResponseTotpInitMfa", ()=>p);
var _zod = require("zod");
var _zodDefault = parcelHelpers.interopDefault(_zod);
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
const r = (0, _zodDefault.default).object({
    token: (0, _zodDefault.default).string()
}).strict();
let c = (0, _zodDefault.default).object({
    action: (0, _zodDefault.default).literal("verify")
}).strict(), i = (0, _zodDefault.default).object({
    action: (0, _zodDefault.default).literal("enroll"),
    phoneNumber: (0, _coreMjs.PhoneNumber)
}).strict();
const n = (0, _zodDefault.default).union([
    c,
    i
]), s = (0, _zodDefault.default).object({
    action: (0, _zodDefault.default).literal("enroll").optional(),
    code: (0, _coreMjs.PasswordlessCode),
    phoneNumber: (0, _coreMjs.PhoneNumber)
}).strict(), b = (0, _zodDefault.default).object({
    code: (0, _coreMjs.PasswordlessCode),
    phoneNumber: (0, _coreMjs.PhoneNumber)
}).strict(), l = (0, _zodDefault.default).object({
    code: (0, _coreMjs.PasswordlessCode)
}).strict(), m = (0, _zodDefault.default).object({
    code: (0, _coreMjs.PasswordlessCode)
}).strict(), p = (0, _zodDefault.default).object({
    totpSecret: (0, _zodDefault.default).string(),
    totpAuthUrl: (0, _zodDefault.default).string()
}).strict();

},{"zod":"fOFdH","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5Sb9y":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MfaEnrollmentPasskeyInput", ()=>s);
parcelHelpers.export(exports, "MfaPasskeyInitInput", ()=>e);
parcelHelpers.export(exports, "MfaPasskeyVerifyInput", ()=>n);
parcelHelpers.export(exports, "ResponsePasskeyInitMfa", ()=>i);
var _zod = require("zod");
var _zodDefault = parcelHelpers.interopDefault(_zod);
var _passkeyMjs = require("./passkey.mjs");
const e = (0, _zodDefault.default).object({
    relying_party: (0, _zodDefault.default).string().url().optional()
}).strict(), i = (0, _zodDefault.default).object({
    options: (0, _passkeyMjs.PasskeyAuthenticatorVerifyOptions)
}).strict(), n = (0, _zodDefault.default).object({
    authenticator_response: (0, _passkeyMjs.PasskeyAuthenticatorVerifyResponse),
    relying_party: (0, _zodDefault.default).string().url().optional()
}).strict(), s = (0, _zodDefault.default).object({
    credential_ids: (0, _zodDefault.default).array((0, _zodDefault.default).string()),
    remove_for_login: (0, _zodDefault.default).boolean().default(!0)
});

},{"zod":"fOFdH","./passkey.mjs":"leBN7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"leBN7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PasskeyAuthenticateInput", ()=>_);
parcelHelpers.export(exports, "PasskeyAuthenticatorEnrollmentOptions", ()=>n);
parcelHelpers.export(exports, "PasskeyAuthenticatorEnrollmentResponse", ()=>e);
parcelHelpers.export(exports, "PasskeyAuthenticatorVerifyOptions", ()=>o);
parcelHelpers.export(exports, "PasskeyAuthenticatorVerifyResponse", ()=>i);
parcelHelpers.export(exports, "PasskeyInitInput", ()=>r);
parcelHelpers.export(exports, "PasskeyLinkInput", ()=>p);
parcelHelpers.export(exports, "PasskeyRegisterInput", ()=>c);
parcelHelpers.export(exports, "ResponsePasskeyInitAuthenticate", ()=>a);
parcelHelpers.export(exports, "ResponsePasskeyInitLink", ()=>l);
parcelHelpers.export(exports, "ResponsePasskeyInitRegister", ()=>s);
parcelHelpers.export(exports, "UnlinkPasskeyInput", ()=>g);
var _zod = require("zod");
var _zodDefault = parcelHelpers.interopDefault(_zod);
const o = (0, _zodDefault.default).object({
    challenge: (0, _zodDefault.default).string(),
    timeout: (0, _zodDefault.default).number().optional(),
    rp_id: (0, _zodDefault.default).string().optional(),
    allow_credentials: (0, _zodDefault.default).array((0, _zodDefault.default).object({
        id: (0, _zodDefault.default).string(),
        type: (0, _zodDefault.default).string(),
        transports: (0, _zodDefault.default).array((0, _zodDefault.default).string()).optional()
    })).optional(),
    user_verification: (0, _zodDefault.default).string().optional(),
    extensions: (0, _zodDefault.default).object({
        app_id: (0, _zodDefault.default).string().optional(),
        cred_props: (0, _zodDefault.default).boolean().optional(),
        hmac_create_secret: (0, _zodDefault.default).boolean().optional()
    }).optional()
}), n = (0, _zodDefault.default).object({
    rp: (0, _zodDefault.default).object({
        name: (0, _zodDefault.default).string(),
        id: (0, _zodDefault.default).string().optional()
    }),
    user: (0, _zodDefault.default).object({
        id: (0, _zodDefault.default).string(),
        name: (0, _zodDefault.default).string(),
        display_name: (0, _zodDefault.default).string()
    }),
    challenge: (0, _zodDefault.default).string(),
    pub_key_cred_params: (0, _zodDefault.default).array((0, _zodDefault.default).object({
        alg: (0, _zodDefault.default).number(),
        type: (0, _zodDefault.default).literal("public-key")
    })),
    timeout: (0, _zodDefault.default).number().optional(),
    exclude_credentials: (0, _zodDefault.default).array((0, _zodDefault.default).object({
        id: (0, _zodDefault.default).string(),
        type: (0, _zodDefault.default).string(),
        transports: (0, _zodDefault.default).array((0, _zodDefault.default).string()).optional()
    })).optional(),
    authenticator_selection: (0, _zodDefault.default).object({
        authenticator_attachment: (0, _zodDefault.default).string().optional(),
        require_resident_key: (0, _zodDefault.default).boolean().optional(),
        resident_key: (0, _zodDefault.default).string().optional(),
        user_verification: (0, _zodDefault.default).string().optional()
    }).optional(),
    attestation: (0, _zodDefault.default).string().optional(),
    extensions: (0, _zodDefault.default).object({
        app_id: (0, _zodDefault.default).string().optional(),
        cred_props: (0, _zodDefault.default).object({
            rk: (0, _zodDefault.default).boolean().optional()
        }).optional(),
        hmac_create_secret: (0, _zodDefault.default).boolean().optional()
    }).optional()
}), i = (0, _zodDefault.default).object({
    id: (0, _zodDefault.default).string(),
    raw_id: (0, _zodDefault.default).string(),
    response: (0, _zodDefault.default).object({
        client_data_json: (0, _zodDefault.default).string(),
        authenticator_data: (0, _zodDefault.default).string(),
        signature: (0, _zodDefault.default).string(),
        user_handle: (0, _zodDefault.default).string().optional()
    }),
    authenticator_attachment: (0, _zodDefault.default).string().optional(),
    client_extension_results: (0, _zodDefault.default).object({
        app_id: (0, _zodDefault.default).boolean().optional(),
        cred_props: (0, _zodDefault.default).object({
            rk: (0, _zodDefault.default).boolean().optional()
        }).optional(),
        hmac_create_secret: (0, _zodDefault.default).boolean().optional()
    }),
    type: (0, _zodDefault.default).literal("public-key")
}), e = (0, _zodDefault.default).object({
    id: (0, _zodDefault.default).string(),
    raw_id: (0, _zodDefault.default).string(),
    response: (0, _zodDefault.default).object({
        client_data_json: (0, _zodDefault.default).string(),
        attestation_object: (0, _zodDefault.default).string(),
        authenticator_data: (0, _zodDefault.default).string().optional(),
        transports: (0, _zodDefault.default).array((0, _zodDefault.default).any()).optional(),
        public_key_algorithm: (0, _zodDefault.default).number().optional(),
        public_key: (0, _zodDefault.default).string().optional()
    }),
    authenticator_attachment: (0, _zodDefault.default).string().optional(),
    client_extension_results: (0, _zodDefault.default).object({
        app_id: (0, _zodDefault.default).boolean().optional(),
        cred_props: (0, _zodDefault.default).object({
            rk: (0, _zodDefault.default).boolean().optional()
        }).optional(),
        hmac_create_secret: (0, _zodDefault.default).boolean().optional()
    }),
    type: (0, _zodDefault.default).literal("public-key")
}), r = (0, _zodDefault.default).object({
    relying_party: (0, _zodDefault.default).string().url().optional(),
    token: (0, _zodDefault.default).string().optional()
}).strict(), a = (0, _zodDefault.default).object({
    relying_party: (0, _zodDefault.default).string().url().optional(),
    options: o
}).strict(), l = (0, _zodDefault.default).object({
    relying_party: (0, _zodDefault.default).string().url().optional(),
    options: n
}).strict(), s = (0, _zodDefault.default).object({
    relying_party: (0, _zodDefault.default).string().url().optional(),
    options: n
}).strict(), p = (0, _zodDefault.default).object({
    relying_party: (0, _zodDefault.default).string().url().optional(),
    authenticator_response: e
}).strict(), c = (0, _zodDefault.default).object({
    relying_party: (0, _zodDefault.default).string().url().optional(),
    authenticator_response: e
}).strict(), _ = (0, _zodDefault.default).object({
    relying_party: (0, _zodDefault.default).string().url().optional(),
    challenge: (0, _zodDefault.default).string(),
    authenticator_response: i
}).strict(), g = (0, _zodDefault.default).object({
    credential_id: (0, _zodDefault.default).string(),
    remove_as_mfa: (0, _zodDefault.default).boolean().default(!0)
});

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hWsxb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MoonpayOnRampSignInput", ()=>c);
parcelHelpers.export(exports, "MoonpayOnRampSignResponse", ()=>o);
var _zod = require("zod");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
let a = (0, _zod.z).enum([
    "ach_bank_transfer",
    "credit_debit_card",
    "gbp_bank_transfer",
    "gbp_open_banking_payment",
    "mobile_wallet",
    "sepa_bank_transfer",
    "sepa_open_banking_payment",
    "pix_instant_payment",
    "yellow_card_bank_transfer"
]), t = (0, _zod.z).enum([
    "AVAX_CCHAIN",
    "CELO_CELO",
    "CUSD_CELO",
    "DAI_ETHEREUM",
    "ETH_ETHEREUM",
    "ETH_ARBITRUM",
    "ETH_OPTIMISM",
    "ETH_POLYGON",
    "ETH_BASE",
    "FIL_FVM",
    "MATIC_ETHEREUM",
    "MATIC_POLYGON",
    "USDC_ETHEREUM",
    "USDC_ARBITRUM",
    "USDC_OPTIMISM",
    "USDC_POLYGON",
    "USDC_BASE",
    "USDC_SOL",
    "USDT_ETHEREUM",
    "USDT_POLYGON",
    "WETH_POLYGON",
    "WBTC_ETHEREUM",
    "BNB_BNB",
    "BNB_BSC",
    "CELO",
    "CUSD",
    "DAI",
    "ETH",
    "FIL",
    "MATIC",
    "USDC",
    "USDT",
    "WETH",
    "WBTC"
]), E = (0, _zod.z).object({
    quoteCurrencyAmount: (0, _zod.z).number().optional(),
    email: (0, _coreMjs.Email).optional(),
    paymentMethod: a.optional(),
    uiConfig: (0, _zod.z).object({
        accentColor: (0, _zod.z).string().optional(),
        theme: (0, _zod.z).enum([
            "light",
            "dark"
        ]).optional()
    }).optional()
}), T = (0, _zod.z).object({
    address: (0, _coreMjs.WalletAddress),
    config: E.extend({
        currencyCode: t.transform((e)=>{
            switch(e){
                case "AVAX_CCHAIN":
                    return "AVAX_CCHAIN";
                case "CELO_CELO":
                    return "CELO";
                case "CUSD_CELO":
                    return "CUSD";
                case "DAI_ETHEREUM":
                    return "DAI";
                case "ETH_ETHEREUM":
                    return "ETH";
                case "ETH_ARBITRUM":
                    return "ETH_ARBITRUM";
                case "ETH_OPTIMISM":
                    return "ETH_OPTIMISM";
                case "ETH_POLYGON":
                    return "ETH_POLYGON";
                case "ETH_BASE":
                    return "ETH_BASE";
                case "FIL_FVM":
                    return "FIL";
                case "MATIC_ETHEREUM":
                    return "MATIC";
                case "MATIC_POLYGON":
                    return "MATIC_POLYGON";
                case "USDC_ETHEREUM":
                    return "USDC";
                case "USDC_ARBITRUM":
                    return "USDC_ARBITRUM";
                case "USDC_OPTIMISM":
                    return "USDC_OPTIMISM";
                case "USDC_POLYGON":
                    return "USDC_POLYGON";
                case "USDC_BASE":
                    return "USDC_BASE";
                case "USDC_SOL":
                    return "USDC_SOL";
                case "USDT_ETHEREUM":
                    return "USDT";
                case "USDT_POLYGON":
                    return "USDT_POLYGON";
                case "WETH_POLYGON":
                    return "WETH";
                case "WBTC_ETHEREUM":
                    return "WBTC";
                case "BNB_BNB":
                    return "BNB";
                case "BNB_BSC":
                    return "BNB_BSC";
                case "CELO":
                case "CUSD":
                case "DAI":
                case "ETH":
                case "FIL":
                case "MATIC":
                case "USDC":
                case "USDT":
                case "WETH":
                case "WBTC":
                    return e;
                default:
                    throw Error(`Invalid currency code: ${e}`);
            }
        }).optional()
    })
}), C = (0, _zod.z).object({
    address: (0, _coreMjs.SolanaWalletAddress),
    config: E.extend({
        currencyCode: (0, _zod.z).enum([
            "SOL",
            "USDC_SOL"
        ]).optional()
    })
});
const c = (0, _zod.z).union([
    T,
    C
]).and((0, _zod.z).object({
    useSandbox: (0, _zod.z).boolean().optional().default(!1)
})), o = (0, _zod.z).object({
    signedUrl: (0, _zod.z).string(),
    externalTransactionId: (0, _zod.z).string()
});

},{"zod":"fOFdH","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gfeVW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SUPPORTED_OAUTH_PROVIDERS", ()=>t);
const t = [
    "google",
    "discord",
    "twitter",
    "github",
    "spotify",
    "instagram",
    "tiktok",
    "linkedin",
    "apple"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jz7dd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthenticateOauthInput", ()=>c);
parcelHelpers.export(exports, "ExternalOAuthProvider", ()=>p);
parcelHelpers.export(exports, "LinkOAuthInput", ()=>d);
parcelHelpers.export(exports, "OAuthInitInput", ()=>l);
parcelHelpers.export(exports, "OAuthInitResponse", ()=>g);
parcelHelpers.export(exports, "OAuthLinkResponse", ()=>_);
parcelHelpers.export(exports, "OAuthProvider", ()=>m);
parcelHelpers.export(exports, "OAuthUnlinkInput", ()=>u);
parcelHelpers.export(exports, "SUPPORTED_OAUTH_PROVIDERS", ()=>(0, _oauthMjs.SUPPORTED_OAUTH_PROVIDERS));
parcelHelpers.export(exports, "TransferOAuthInput", ()=>f);
var _zod = require("zod");
var _apiBase = require("@privy-io/api-base");
var _oauthMjs = require("../constants/oauth.mjs");
var _accountTransferMjs = require("./account-transfer.mjs");
var _coreMjs = require("./core.mjs");
var _userMjs = require("./user.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
var _smartWalletConfigMjs = require("./smart-wallet-config.mjs");
var _smartWalletsMjs = require("../constants/smart-wallets.mjs");
const p = (0, _zod.z).enum((0, _oauthMjs.SUPPORTED_OAUTH_PROVIDERS), {
    invalid_type_error: "Please specify a supported provider.",
    required_error: "Please specify a supported provider."
}), m = p.or((0, _zod.z).custom((e)=>"string" == typeof e && /^privy:[a-z0-9]{25}$/i.test(e), {
    message: "Please specify a supported provider."
})), c = (0, _zod.z).object({
    authorization_code: (0, _zod.z).string(),
    state_code: (0, _zod.z).string(),
    code_verifier: (0, _zod.z).string().min(43).max(128).optional(),
    code_type: (0, _zod.z).enum([
        "raw"
    ]).optional()
}).merge((0, _coreMjs.AuthenticateMode)).catch(()=>{
    throw new (0, _apiBase.UnauthorizedError)("Please specify authorization_code and state_code.", (0, _apiBase.PrivyErrorCode).INVALID_CREDENTIALS);
}), l = (0, _zod.z).object({
    redirect_to: (0, _zod.z).string({
        required_error: "Please provide a redirect_to value."
    }),
    provider: m,
    token: (0, _zod.z).string().optional(),
    state_code: (0, _zod.z).string().optional(),
    code_challenge: (0, _zod.z).string().optional()
}), d = (0, _zod.z).object({
    authorization_code: (0, _zod.z).string(),
    state_code: (0, _zod.z).string(),
    code_verifier: (0, _zod.z).string().min(43).max(128).optional(),
    code_type: (0, _zod.z).enum([
        "raw"
    ]).optional()
}), u = (0, _zod.z).object({
    subject: (0, _zod.z).string(),
    provider: m
}), g = (0, _zod.z).object({
    url: (0, _zod.z).string()
}), _ = (0, _userMjs.User).extend({
    oauth_tokens: (0, _userMjs.OAuthTokens).optional()
}), f = (0, _accountTransferMjs.BaseAccountTransferInput).extend({
    userInfo: (0, _zod.z).object({
        subject: (0, _zod.z).string(),
        name: (0, _zod.z).string().optional(),
        username: (0, _zod.z).string().optional(),
        profilePictureUrl: (0, _zod.z).string().optional(),
        email: (0, _zod.z).string().optional().nullable(),
        vanityName: (0, _zod.z).string().optional()
    })
});

},{"zod":"fOFdH","@privy-io/api-base":"lvLPC","../constants/oauth.mjs":"gfeVW","./account-transfer.mjs":"f44i0","./core.mjs":"9c2nU","./user.mjs":"59vYa","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","./smart-wallet-config.mjs":"eeJcS","../constants/smart-wallets.mjs":"hQh54","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hawiR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthorizationCodeInput", ()=>e);
var _zod = require("zod");
const e = (0, _zod.z).object({
    redirect_to: (0, _zod.z).string(),
    state: (0, _zod.z).string(),
    code_challenge: (0, _zod.z).string()
});

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8CKI2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmptyObject", ()=>e);
parcelHelpers.export(exports, "SuccessObject", ()=>r);
var _zod = require("zod");
const e = (0, _zod.z).record((0, _zod.z).string(), (0, _zod.z).never()), r = (0, _zod.z).object({
    success: (0, _zod.z).boolean()
});

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aO8b9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseCondition", ()=>d);
parcelHelpers.export(exports, "Condition", ()=>y);
parcelHelpers.export(exports, "ConditionOperator", ()=>m);
parcelHelpers.export(exports, "EthereumCalldataCondition", ()=>_);
parcelHelpers.export(exports, "EthereumTransactionCondition", ()=>u);
parcelHelpers.export(exports, "EthereumTypedDataDomainCondition", ()=>p);
parcelHelpers.export(exports, "EthereumTypedDataMessageCondition", ()=>f);
parcelHelpers.export(exports, "LegacyRule", ()=>j);
parcelHelpers.export(exports, "PolicyAction", ()=>l);
parcelHelpers.export(exports, "PolicyIdFromPath", ()=>L);
parcelHelpers.export(exports, "PolicyResponse", ()=>D);
parcelHelpers.export(exports, "PolicyWithoutValidation", ()=>I);
parcelHelpers.export(exports, "Rule", ()=>T);
parcelHelpers.export(exports, "SolanaProgramInstruction", ()=>h);
parcelHelpers.export(exports, "SolanaSystemProgramInstruction", ()=>g);
parcelHelpers.export(exports, "SolanaTokenProgramInstruction", ()=>b);
parcelHelpers.export(exports, "UpdatePolicyInput", ()=>C);
var _zod = require("zod");
var _apiBase = require("@privy-io/api-base");
var _walletsMjs = require("./wallet-api/wallets.mjs");
var _apiMjs = require("./api.mjs");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
var _transactionMjs = require("./transaction.mjs");
var _exportMjs = require("./wallet-api/export.mjs");
const l = (0, _zod.z).enum([
    "ALLOW",
    "DENY"
]);
let s = (0, _zod.z).union([
    (0, _zod.z).string(),
    (0, _zod.z).number(),
    (0, _zod.z).boolean(),
    (0, _zod.z).null()
]), c = (0, _zod.z).lazy(()=>(0, _zod.z).union([
        s,
        (0, _zod.z).array(c),
        (0, _zod.z).record(c)
    ]));
const m = (0, _zod.z).union([
    (0, _zod.z).literal("eq"),
    (0, _zod.z).literal("gt"),
    (0, _zod.z).literal("gte"),
    (0, _zod.z).literal("lt"),
    (0, _zod.z).literal("lte"),
    (0, _zod.z).literal("in")
]), d = (0, _zod.z).object({
    operator: m,
    value: (0, _zod.z).union([
        (0, _zod.z).string(),
        (0, _zod.z).array((0, _zod.z).string())
    ])
}), u = (0, _zod.z).object({
    field_source: (0, _zod.z).literal("ethereum_transaction"),
    field: (0, _zod.z).union([
        (0, _zod.z).literal("to"),
        (0, _zod.z).literal("value")
    ])
}).strict().merge(d), _ = (0, _zod.z).object({
    field_source: (0, _zod.z).literal("ethereum_calldata"),
    field: (0, _zod.z).string(),
    abi: c
}).strict().merge(d), p = (0, _zod.z).object({
    field_source: (0, _zod.z).literal("ethereum_typed_data_domain"),
    field: (0, _zod.z).union([
        (0, _zod.z).literal("chainId"),
        (0, _zod.z).literal("verifyingContract"),
        (0, _zod.z).literal("chain_id"),
        (0, _zod.z).literal("verifying_contract")
    ])
}).strict().merge(d), f = (0, _zod.z).object({
    field_source: (0, _zod.z).literal("ethereum_typed_data_message"),
    field: (0, _zod.z).string(),
    typed_data: (0, _zod.z).object({
        types: (0, _walletsMjs.TypedDataTypesInputParams),
        primary_type: (0, _zod.z).string()
    })
}).strict().merge(d), h = (0, _zod.z).object({
    field_source: (0, _zod.z).literal("solana_program_instruction"),
    field: (0, _zod.z).literal("programId")
}).strict().merge(d), g = (0, _zod.z).object({
    field_source: (0, _zod.z).literal("solana_system_program_instruction"),
    field: (0, _zod.z).union([
        (0, _zod.z).literal("instructionName"),
        (0, _zod.z).literal("Transfer.from"),
        (0, _zod.z).literal("Transfer.to"),
        (0, _zod.z).literal("Transfer.lamports")
    ])
}).strict().merge(d), b = (0, _zod.z).object({
    field_source: (0, _zod.z).literal("solana_token_program_instruction"),
    field: (0, _zod.z).union([
        (0, _zod.z).literal("instructionName"),
        (0, _zod.z).literal("TransferChecked.source"),
        (0, _zod.z).literal("TransferChecked.destination"),
        (0, _zod.z).literal("TransferChecked.authority"),
        (0, _zod.z).literal("TransferChecked.amount"),
        (0, _zod.z).literal("TransferChecked.mint")
    ])
}).strict().merge(d), y = (0, _zod.z).discriminatedUnion("field_source", [
    u,
    _,
    p,
    f,
    h,
    g,
    b
]), j = (0, _zod.z).object({
    name: (0, _zod.z).string().max(50, "Rule name must be fewer than 50 characters"),
    conditions: (0, _zod.z).array(y),
    action: l
}).strict();
let v = (0, _zod.z).union([
    (0, _zod.z).literal("eth_sendTransaction"),
    (0, _zod.z).literal("eth_signTransaction"),
    (0, _zod.z).literal("eth_signTypedData_v4"),
    (0, _zod.z).literal("signTransaction"),
    (0, _zod.z).literal("signAndSendTransaction"),
    (0, _zod.z).literal("exportPrivateKey"),
    (0, _zod.z).literal("*")
]), w = (0, _zod.z).object({
    method: v,
    rules: (0, _zod.z).array(j)
}).strict().transform((e)=>{
    let r = [];
    for (let t of e.rules){
        let i = T.parse({
            name: t.name,
            method: e.method,
            conditions: t.conditions,
            action: t.action
        });
        r.push(i);
    }
    return r;
});
const T = (0, _zod.z).object({
    name: (0, _zod.z).string().max(50, "Rule name must be fewer than 50 characters"),
    method: v,
    conditions: (0, _zod.z).array(y),
    action: l
}).strict();
let x = (0, _zod.z).object({
    version: (0, _zod.z).literal("1.0"),
    name: (0, _zod.z).string().max(50, "Policy name must be fewer than 50 characters"),
    chain_type: (0, _walletsMjs.ChainType),
    method_rules: (0, _zod.z).array(w),
    default_action: l,
    ...(0, _walletsMjs.OwnerInputFields)
}).strict(), A = (0, _zod.z).object({
    version: (0, _zod.z).literal("1.0"),
    name: (0, _zod.z).string().max(50, "Policy name must be fewer than 50 characters"),
    chain_type: (0, _walletsMjs.ChainType),
    rules: (0, _zod.z).array(T),
    ...(0, _walletsMjs.OwnerInputFields)
}).strict();
const I = (0, _zod.z).union([
    x,
    A
]).transform((e)=>{
    if (!("method_rules" in e)) return e;
    {
        let r = {
            version: e.version,
            name: e.name,
            chain_type: e.chain_type,
            rules: e.method_rules.flat(),
            owner: e.owner,
            owner_id: e.owner_id
        };
        return "ALLOW" === e.default_action && r.rules.push(T.parse({
            name: "Default Action",
            method: "*",
            conditions: [],
            action: l.enum.ALLOW
        })), A.parse(r);
    }
}).refine((e)=>!e.owner || !e.owner_id, {
    message: "Only one of owner or owner_id can be provided."
}), D = A.omit({
    owner: !0,
    owner_id: !0
}).extend({
    id: (0, _zod.z).string(),
    created_at: (0, _zod.z).number(),
    owner_id: (0, _walletsMjs.KeyQuorumId).nullable()
}), L = (0, _zod.z).object({
    policy_id: (0, _zod.z).string({
        required_error: "Policy ID must be provided",
        invalid_type_error: "Policy ID is not a valid string"
    }).min(1)
}).catch(({ error: e })=>{
    throw new (0, _apiBase.InvalidInputError)(e.message, (0, _apiBase.PrivyErrorCode).INVALID_DATA);
});
let P = (0, _zod.z).object({
    name: (0, _zod.z).string().trim().min(1, "Name is required").max(50, "Policy name must be fewer than 50 characters").optional(),
    method_rules: (0, _zod.z).array(w).optional()
}).strict().superRefine((e, r)=>{
    Object.values(e).every((e)=>null == e) && r.addIssue({
        code: "custom",
        message: "At least one field must be provided"
    });
}), k = (0, _zod.z).object({
    name: (0, _zod.z).string().trim().min(1, "Name is required").max(50, "Policy name must be fewer than 50 characters").optional(),
    rules: (0, _zod.z).array(T).optional()
}).strict().superRefine((e, r)=>{
    Object.values(e).every((e)=>null == e) && r.addIssue({
        code: "custom",
        message: "At least one field must be provided"
    });
});
const C = (0, _zod.z).union([
    P,
    k
]).transform((e)=>"method_rules" in e ? k.parse({
        name: e.name,
        rules: e.method_rules?.flat() ?? []
    }) : k.parse(e));

},{"zod":"fOFdH","@privy-io/api-base":"lvLPC","./wallet-api/wallets.mjs":"eUydR","./api.mjs":"bMsze","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","./transaction.mjs":"kzolK","./wallet-api/export.mjs":"3JZvH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eUydR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AdditionalSignerInput", ()=>lt);
parcelHelpers.export(exports, "Asset", ()=>ht);
parcelHelpers.export(exports, "AssetAmountDetails", ()=>bt);
parcelHelpers.export(exports, "AuthorizationKeyDashboardResponse", ()=>vt);
parcelHelpers.export(exports, "AuthorizationKeyResponse", ()=>zt);
parcelHelpers.export(exports, "AuthorizationKeyRole", ()=>u);
parcelHelpers.export(exports, "BalanceFiatCurrency", ()=>_t);
parcelHelpers.export(exports, "BaseWalletApiCreateInput", ()=>dt);
parcelHelpers.export(exports, "CAIP2", ()=>h);
parcelHelpers.export(exports, "ChainNameInput", ()=>mt);
parcelHelpers.export(exports, "ChainType", ()=>et);
parcelHelpers.export(exports, "Cosmos", ()=>J);
parcelHelpers.export(exports, "CurveSigningChainTypes", ()=>Y);
parcelHelpers.export(exports, "CurveType", ()=>l);
parcelHelpers.export(exports, "ECDSA", ()=>c);
parcelHelpers.export(exports, "EdDSA", ()=>g);
parcelHelpers.export(exports, "FirstClassChainTypes", ()=>tt);
parcelHelpers.export(exports, "HDPath", ()=>d);
parcelHelpers.export(exports, "Hash", ()=>z);
parcelHelpers.export(exports, "Hex", ()=>v);
parcelHelpers.export(exports, "KeyQuorumId", ()=>at);
parcelHelpers.export(exports, "OwnerInput", ()=>nt);
parcelHelpers.export(exports, "OwnerInputFields", ()=>ot);
parcelHelpers.export(exports, "P256PublicKey", ()=>rt);
parcelHelpers.export(exports, "PolicyInput", ()=>st);
parcelHelpers.export(exports, "PrivyTransactionResponseWithDetails", ()=>Tt);
parcelHelpers.export(exports, "Quantity", ()=>x);
parcelHelpers.export(exports, "SigningAlgorithm", ()=>p);
parcelHelpers.export(exports, "Stellar", ()=>Q);
parcelHelpers.export(exports, "Sui", ()=>X);
parcelHelpers.export(exports, "TransactionDetail", ()=>Dt);
parcelHelpers.export(exports, "TransactionResponseWithDetails", ()=>At);
parcelHelpers.export(exports, "TransferReceivedTransactionDetail", ()=>It);
parcelHelpers.export(exports, "TransferSentTransactionDetail", ()=>wt);
parcelHelpers.export(exports, "TypedDataDomainInputParams", ()=>E);
parcelHelpers.export(exports, "TypedDataTypesInputParams", ()=>S);
parcelHelpers.export(exports, "UnsignedEthereumTransaction", ()=>k);
parcelHelpers.export(exports, "WalletApiCreateInput", ()=>ct);
parcelHelpers.export(exports, "WalletApiCreateResponse", ()=>gt);
parcelHelpers.export(exports, "WalletApiEthereumPersonalSignRpcInput", ()=>A);
parcelHelpers.export(exports, "WalletApiEthereumPersonalSignRpcInputParams", ()=>D);
parcelHelpers.export(exports, "WalletApiEthereumPersonalSignRpcResponse", ()=>V);
parcelHelpers.export(exports, "WalletApiEthereumRpcInput", ()=>C);
parcelHelpers.export(exports, "WalletApiEthereumSecp256k1SignRpcInput", ()=>T);
parcelHelpers.export(exports, "WalletApiEthereumSecp256k1SignRpcResponse", ()=>$);
parcelHelpers.export(exports, "WalletApiEthereumSendTransactionRpcInput", ()=>I);
parcelHelpers.export(exports, "WalletApiEthereumSendTransactionRpcResponse", ()=>N);
parcelHelpers.export(exports, "WalletApiEthereumSignTransactionRpcInput", ()=>w);
parcelHelpers.export(exports, "WalletApiEthereumSignTransactionRpcResponse", ()=>L);
parcelHelpers.export(exports, "WalletApiEthereumSignTypedDataRpcInput", ()=>U);
parcelHelpers.export(exports, "WalletApiEthereumSignTypedDataRpcResponse", ()=>R);
parcelHelpers.export(exports, "WalletApiExportPrivateKeyRpcInput", ()=>q);
parcelHelpers.export(exports, "WalletApiExportPrivateKeyRpcResponse", ()=>Z);
parcelHelpers.export(exports, "WalletApiRawSignInput", ()=>P);
parcelHelpers.export(exports, "WalletApiRawSignResponse", ()=>F);
parcelHelpers.export(exports, "WalletApiRegisterAuthorizationKeyInput", ()=>H);
parcelHelpers.export(exports, "WalletApiRevokeAuthorizationKeyInput", ()=>jt);
parcelHelpers.export(exports, "WalletApiRpcInput", ()=>O);
parcelHelpers.export(exports, "WalletApiRpcResponse", ()=>G);
parcelHelpers.export(exports, "WalletApiSolanaRpcInput", ()=>M);
parcelHelpers.export(exports, "WalletApiSolanaSignAndSendTransactionRpcInput", ()=>y);
parcelHelpers.export(exports, "WalletApiSolanaSignAndSendTransactionRpcResponse", ()=>B);
parcelHelpers.export(exports, "WalletApiSolanaSignMessageRpcInput", ()=>j);
parcelHelpers.export(exports, "WalletApiSolanaSignMessageRpcResponse", ()=>K);
parcelHelpers.export(exports, "WalletApiSolanaSignTransactionRpcInput", ()=>b);
parcelHelpers.export(exports, "WalletApiSolanaSignTransactionRpcResponse", ()=>W);
parcelHelpers.export(exports, "WalletGetBalanceInput", ()=>ut);
parcelHelpers.export(exports, "WalletGetBalanceResponse", ()=>yt);
parcelHelpers.export(exports, "WalletGetTransactionsInput", ()=>kt);
parcelHelpers.export(exports, "WalletGetTransactionsResponse", ()=>Pt);
parcelHelpers.export(exports, "WalletIdFromPath", ()=>pt);
parcelHelpers.export(exports, "WalletResponse", ()=>it);
parcelHelpers.export(exports, "WalletUpdateInput", ()=>xt);
parcelHelpers.export(exports, "WalletsSearchInput", ()=>ft);
var _zod = require("zod");
var _apiBase = require("@privy-io/api-base");
var _apiMjs = require("../api.mjs");
var _coreMjs = require("../core.mjs");
var _transactionMjs = require("../transaction.mjs");
var _exportMjs = require("./export.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
const l = (0, _zod.z).enum([
    "secp256k1",
    "ed25519"
]), d = (0, _zod.z).string().regex(/^[mM]'?(\/\d+'?)*$/), c = (0, _zod.z).literal("ECDSA"), g = (0, _zod.z).literal("EdDSA"), p = (0, _zod.z).union([
    c,
    g
]), h = (0, _zod.z).string().regex(/^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/, "Chain ID must be a valid CAIP-2 chain ID, e.g. 'eip155:1'");
let m = (0, _zod.z).object({
    address: (0, _coreMjs.SolanaWalletAddress).optional(),
    chain_type: (0, _zod.z).literal("solana").optional(),
    wallet_id: (0, _zod.z).string().optional()
}), _ = (0, _zod.z).object({
    address: (0, _coreMjs.WalletAddress).optional(),
    chain_type: (0, _zod.z).literal("ethereum").optional(),
    wallet_id: (0, _zod.z).string().optional()
});
const u = (0, _zod.z).enum([
    "root",
    "manager",
    "delegated-actions"
]).nullable(), b = (0, _zod.z).object({
    method: (0, _zod.z).literal("signTransaction"),
    params: (0, _zod.z).object({
        transaction: (0, _zod.z).string(),
        encoding: (0, _zod.z).literal("base64")
    }).strict()
}).merge(m).strict(), y = (0, _zod.z).object({
    method: (0, _zod.z).literal("signAndSendTransaction"),
    caip2: h,
    params: (0, _zod.z).object({
        transaction: (0, _zod.z).string(),
        encoding: (0, _zod.z).literal("base64")
    }).strict()
}).merge(m).strict(), j = (0, _zod.z).object({
    method: (0, _zod.z).literal("signMessage"),
    params: (0, _zod.z).object({
        message: (0, _zod.z).string(),
        encoding: (0, _zod.z).literal("base64")
    }).strict()
}).merge(m).strict(), v = (0, _zod.z).string().startsWith("0x").refine((t)=>!t.includes("."), "Invalid hex string: must start with '0x' and not contain decimal points"), z = v.transform((t)=>t);
let f = (0, _zod.z).number().int().nonnegative().safe({
    message: 'Please use hex string prefixed with "0x" to represent large numbers (e.g. "0xDE0B6B3A7640000").'
});
const x = (0, _zod.z).union([
    v,
    f
], {
    invalid_type_error: "Invalid quantity: must be either a hex string starting with '0x' or a non-negative integer."
}), k = (0, _zod.z).object({
    from: (0, _coreMjs.WalletAddress).optional(),
    to: (0, _coreMjs.WalletAddress).optional(),
    chain_id: x.optional(),
    nonce: x.optional(),
    data: v.optional(),
    value: x.optional(),
    type: (0, _zod.z).union([
        (0, _zod.z).literal(0),
        (0, _zod.z).literal(1),
        (0, _zod.z).literal(2)
    ]).optional(),
    gas_limit: x.optional(),
    gas_price: x.optional(),
    max_fee_per_gas: x.optional(),
    max_priority_fee_per_gas: x.optional()
}).strict(), w = (0, _zod.z).object({
    method: (0, _zod.z).literal("eth_signTransaction"),
    params: (0, _zod.z).object({
        transaction: k
    }).strict()
}).merge(_).strict(), I = (0, _zod.z).object({
    method: (0, _zod.z).literal("eth_sendTransaction"),
    caip2: h,
    params: (0, _zod.z).object({
        transaction: k
    }).strict()
}).merge(_).strict(), D = (0, _zod.z).object({
    message: (0, _zod.z).string(),
    encoding: (0, _zod.z).union([
        (0, _zod.z).literal("utf-8"),
        (0, _zod.z).literal("hex")
    ])
}).strict(), A = (0, _zod.z).object({
    method: (0, _zod.z).literal("personal_sign"),
    params: D
}).merge(_).strict(), T = (0, _zod.z).object({
    method: (0, _zod.z).literal("secp256k1_sign"),
    params: (0, _zod.z).object({
        hash: z
    }).strict()
}).merge(_).strict(), P = (0, _zod.z).object({
    params: (0, _zod.z).object({
        hash: z
    }).strict()
}).strict(), E = (0, _zod.z).record((0, _zod.z).string(), (0, _zod.z).any()), S = (0, _zod.z).record((0, _zod.z).array((0, _zod.z).object({
    name: (0, _zod.z).string(),
    type: (0, _zod.z).string()
}))).refine((t)=>"EIP712Domain" in t, {
    message: "TypedDataTypesInputParams must contain an EIP712Domain key",
    path: [
        "EIP712Domain"
    ]
}), U = (0, _zod.z).object({
    method: (0, _zod.z).literal("eth_signTypedData_v4"),
    params: (0, _zod.z).object({
        typed_data: (0, _zod.z).object({
            domain: E,
            types: S,
            message: (0, _zod.z).record((0, _zod.z).string(), (0, _zod.z).any()),
            primary_type: (0, _zod.z).string()
        }).strict()
    }).strict()
}).merge(_).strict(), q = (0, _zod.z).object({
    address: (0, _zod.z).string(),
    method: (0, _zod.z).literal("exportPrivateKey"),
    params: (0, _exportMjs.PrivateKeyExportInput)
}).strict(), C = (0, _zod.z).discriminatedUnion("method", [
    w,
    I,
    A,
    U,
    T
]), M = (0, _zod.z).discriminatedUnion("method", [
    b,
    y,
    j
]), O = (0, _zod.z).union([
    C,
    M,
    q
]), W = (0, _zod.z).object({
    method: (0, _zod.z).literal("signTransaction"),
    data: (0, _zod.z).object({
        signed_transaction: (0, _zod.z).string(),
        encoding: (0, _zod.z).literal("base64")
    })
}), B = (0, _zod.z).object({
    method: (0, _zod.z).literal("signAndSendTransaction"),
    data: (0, _zod.z).object({
        transaction_id: (0, _zod.z).string().optional(),
        hash: (0, _zod.z).string(),
        caip2: h
    }).optional(),
    error: (0, _zod.z).object({
        code: (0, _zod.z).string(),
        message: (0, _zod.z).string()
    }).optional()
}), K = (0, _zod.z).object({
    method: (0, _zod.z).literal("signMessage"),
    data: (0, _zod.z).object({
        signature: (0, _zod.z).string(),
        encoding: (0, _zod.z).literal("base64")
    })
}), L = (0, _zod.z).object({
    method: (0, _zod.z).literal("eth_signTransaction"),
    data: (0, _zod.z).object({
        signed_transaction: (0, _zod.z).string(),
        encoding: (0, _zod.z).literal("rlp")
    })
}), N = (0, _zod.z).object({
    method: (0, _zod.z).literal("eth_sendTransaction"),
    data: (0, _zod.z).object({
        transaction_id: (0, _zod.z).string().optional(),
        hash: (0, _zod.z).string(),
        caip2: h,
        transaction_request: k.optional()
    }).optional(),
    error: (0, _zod.z).object({
        code: (0, _zod.z).string(),
        message: (0, _zod.z).string()
    }).optional()
}), V = (0, _zod.z).object({
    method: (0, _zod.z).literal("personal_sign"),
    data: (0, _zod.z).object({
        signature: (0, _zod.z).string(),
        encoding: (0, _zod.z).literal("hex")
    })
}), $ = (0, _zod.z).object({
    method: (0, _zod.z).literal("secp256k1_sign"),
    data: (0, _zod.z).object({
        signature: v,
        encoding: (0, _zod.z).literal("hex")
    })
}), R = (0, _zod.z).object({
    method: (0, _zod.z).literal("eth_signTypedData_v4"),
    data: (0, _zod.z).object({
        signature: (0, _zod.z).string(),
        encoding: (0, _zod.z).literal("hex")
    })
}), Z = (0, _zod.z).object({
    method: (0, _zod.z).literal("exportPrivateKey"),
    data: (0, _exportMjs.PrivateKeyExportInput)
}), F = (0, _zod.z).object({
    data: (0, _zod.z).object({
        signature: v,
        encoding: (0, _zod.z).literal("hex")
    }).optional(),
    error: (0, _zod.z).object({
        code: (0, _zod.z).string(),
        message: (0, _zod.z).string()
    }).optional()
}).strict(), G = (0, _zod.z).discriminatedUnion("method", [
    W,
    B,
    K,
    L,
    N,
    V,
    $,
    R,
    Z
]), H = (0, _zod.z).object({
    display_name: (0, _zod.z).string().optional(),
    public_key: (0, _zod.z).string(),
    role: u.optional()
}), J = (0, _zod.z).literal("cosmos"), Q = (0, _zod.z).literal("stellar"), X = (0, _zod.z).literal("sui"), Y = (0, _zod.z).union([
    J,
    Q,
    X
]), tt = (0, _zod.z).union([
    (0, _zod.z).literal("solana"),
    (0, _zod.z).literal("ethereum")
]), et = (0, _zod.z).union([
    Y,
    tt
]), it = (0, _zod.z).object({
    id: (0, _zod.z).string(),
    address: (0, _zod.z).string(),
    public_key: (0, _zod.z).string().optional(),
    created_at: (0, _zod.z).number(),
    exported_at: (0, _zod.z).number().nullable(),
    chain_type: et,
    policy_ids: (0, _zod.z).array((0, _zod.z).string()),
    authorization_threshold: (0, _zod.z).number().optional(),
    additional_signers: (0, _zod.z).array((0, _zod.z).object({
        signer_id: (0, _zod.z).string().cuid2(),
        override_policy_ids: (0, _zod.z).array((0, _zod.z).string()).optional()
    })),
    owner_id: (0, _zod.z).string().cuid2().nullable()
}), at = (0, _zod.z).string().cuid2(), rt = (0, _zod.z).string(), nt = (0, _zod.z).object({
    public_key: rt
}).strict(), ot = {
    owner: nt.nullable().optional(),
    owner_id: at.nullable().optional()
}, st = (0, _zod.z).array((0, _zod.z).string().cuid2()).max(1, "Only one policy ID can be set").optional(), lt = (0, _zod.z).array((0, _zod.z).object({
    signer_id: at,
    override_policy_ids: st
}).strict()), dt = (0, _zod.z).object({
    chain_type: et,
    policy_ids: st,
    authorization_key_ids: (0, _zod.z).array((0, _zod.z).string()).optional(),
    authorization_threshold: (0, _zod.z).number().optional(),
    additional_signers: lt.optional(),
    ...ot
}).strict(), ct = dt.refine((t)=>{
    let e = void 0 !== t.authorization_key_ids || void 0 !== t.authorization_threshold, i = void 0 !== t.additional_signers;
    return !e || !i;
}, "Please provide either additional_signers or authorization_key_ids, not both").refine((t)=>void 0 === t.authorization_threshold || t.authorization_threshold >= 1 && t.authorization_key_ids && t.authorization_threshold <= t.authorization_key_ids.length, {
    message: "If specified, authorization_threshold must be an integer between 1 and the length of authorization_key_ids."
}).refine((t)=>!t.owner || !t.owner_id, {
    message: "Only one of owner or owner_id can be provided."
}).catch((t)=>{
    throw new (0, _apiBase.InvalidInputError)(t.error.message, (0, _apiBase.PrivyErrorCode).INVALID_DATA);
}), gt = (0, _zod.z).object({
    id: (0, _zod.z).string(),
    chain_type: et,
    address: (0, _zod.z).string(),
    authorization_threshold: (0, _zod.z).number().optional()
}), pt = (0, _zod.z).object({
    wallet_id: (0, _zod.z).string({
        required_error: "Wallet ID must be provided",
        invalid_type_error: "Wallet ID is not a valid string"
    }).min(1)
}).catch(({ error: t })=>{
    throw new (0, _apiBase.InvalidInputError)(t.message, (0, _apiBase.PrivyErrorCode).INVALID_DATA);
}), ht = (0, _zod.z).enum([
    "usdc",
    "eth"
]), mt = (0, _zod.z).enum([
    "ethereum",
    "arbitrum",
    "base",
    "linea",
    "optimism",
    "zksync_era"
]), _t = (0, _zod.z).enum([
    "usd"
]), ut = (0, _zod.z).object({
    asset: (0, _zod.z).union([
        ht,
        (0, _zod.z).array(ht).max(10)
    ]),
    chain: (0, _zod.z).union([
        mt,
        (0, _zod.z).array(mt).max(10)
    ]),
    include_currency: _t.optional()
}), bt = (0, _zod.z).object({
    chain: mt,
    asset: ht,
    raw_value: (0, _zod.z).string(),
    raw_value_decimals: (0, _zod.z).number(),
    display_values: (0, _zod.z).record((0, _zod.z).union([
        ht,
        _t
    ]), (0, _zod.z).string())
}), yt = (0, _zod.z).object({
    balances: (0, _zod.z).array(bt.refine((t)=>t.asset in t.display_values, {
        message: "display_values must include the asset as a key",
        path: [
            "display_values"
        ]
    }))
}), jt = (0, _zod.z).object({
    id: (0, _zod.z).string()
}), vt = (0, _zod.z).object({
    id: (0, _zod.z).string(),
    display_name: (0, _zod.z).string().nullable(),
    public_key: (0, _zod.z).string(),
    role: u,
    created_at: (0, _zod.z).number()
}), zt = (0, _zod.z).object({
    id: (0, _zod.z).string(),
    display_name: (0, _zod.z).string().nullable(),
    public_key: (0, _zod.z).string(),
    created_at: (0, _zod.z).number()
}), ft = (0, _apiMjs.Pagination).extend({
    chain_type: et.optional()
}).strict(), xt = (0, _zod.z).object({
    policy_ids: st,
    authorization_key_ids: (0, _zod.z).array((0, _zod.z).string()).optional(),
    authorization_threshold: (0, _zod.z).number().optional(),
    additional_signers: lt.optional()
}).strict().superRefine((t, e)=>{
    Object.values(t).every((t)=>null == t) && e.addIssue({
        code: "custom",
        message: "At least one field must be provided"
    }), void 0 !== t.authorization_threshold && 0 !== t.authorization_threshold && (t.authorization_threshold < 0 && e.addIssue({
        code: "custom",
        path: [
            "authorization_threshold"
        ],
        message: "`authorization_threshold` must be non-negative if specified."
    }), void 0 === t.authorization_key_ids && e.addIssue({
        code: "custom",
        path: [
            "authorization_key_ids"
        ],
        message: "An array of `authorization_key_ids` must be provided for a non-zero `authorization_threshold`."
    }), t.authorization_key_ids && t.authorization_threshold > t.authorization_key_ids.length && e.addIssue({
        code: "custom",
        path: [
            "authorization_threshold"
        ],
        message: "`authorization_threshold` must be non-negative if specified."
    }));
}), kt = (0, _apiMjs.Pagination).extend({
    chain: (0, _zod.z).literal("base"),
    asset: (0, _zod.z).union([
        ht,
        (0, _zod.z).array(ht).max(2)
    ])
}).strict(), wt = (0, _zod.z).object({
    type: (0, _zod.z).literal("transfer_sent"),
    sender: (0, _zod.z).string(),
    sender_privy_user_id: (0, _zod.z).string().nullable(),
    recipient: (0, _zod.z).string(),
    recipient_privy_user_id: (0, _zod.z).string().nullable()
}).strict().merge(bt), It = (0, _zod.z).object({
    type: (0, _zod.z).literal("transfer_received"),
    sender: (0, _zod.z).string(),
    sender_privy_user_id: (0, _zod.z).string().nullable(),
    recipient: (0, _zod.z).string(),
    recipient_privy_user_id: (0, _zod.z).string().nullable()
}).strict().merge(bt), Dt = (0, _zod.z).discriminatedUnion("type", [
    wt,
    It
]), At = (0, _transactionMjs.BaseTransactionResponse).extend({
    details: Dt.nullable()
}), Tt = At.extend({
    privy_transaction_id: (0, _zod.z).string(),
    wallet_id: (0, _zod.z).string()
}), Pt = (0, _zod.z).object({
    transactions: (0, _zod.z).array(Tt),
    next_cursor: (0, _zod.z).string().nullable()
});

},{"zod":"fOFdH","@privy-io/api-base":"lvLPC","../api.mjs":"bMsze","../core.mjs":"9c2nU","../transaction.mjs":"kzolK","./export.mjs":"3JZvH","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kzolK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseTransactionResponse", ()=>a);
parcelHelpers.export(exports, "TransactionIdFromPath", ()=>o);
parcelHelpers.export(exports, "TransactionResponse", ()=>n);
parcelHelpers.export(exports, "TransactionStatus", ()=>i);
var _zod = require("zod");
var _apiBase = require("@privy-io/api-base");
const i = (0, _zod.z).enum([
    "broadcasted",
    "confirmed",
    "delayed",
    "execution_reverted",
    "failed"
]), a = (0, _zod.z).object({
    caip2: (0, _zod.z).string(),
    transaction_hash: (0, _zod.z).string().nullable(),
    status: i,
    created_at: (0, _zod.z).number()
}), n = a.extend({
    id: (0, _zod.z).string(),
    wallet_id: (0, _zod.z).string()
}), o = (0, _zod.z).object({
    transaction_id: (0, _zod.z).string({
        required_error: "Transaction ID must be provided",
        invalid_type_error: "Transaction ID is not a valid string"
    }).min(1)
}).catch(({ error: r })=>{
    throw new (0, _apiBase.InvalidInputError)(r.message, (0, _apiBase.PrivyErrorCode).INVALID_DATA);
});

},{"zod":"fOFdH","@privy-io/api-base":"lvLPC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3JZvH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PrivateKeyExportInput", ()=>r);
parcelHelpers.export(exports, "PrivateKeyExportResponse", ()=>i);
var _zod = require("zod");
let n = /^[A-Za-z0-9+/=]+$/, t = (0, _zod.z).union([
    (0, _zod.z).string().regex(/^-----BEGIN PUBLIC KEY-----\n[A-Za-z0-9+/=\n]+-----END PUBLIC KEY-----\n$/, "Invalid PEM format. Must be in format: -----BEGIN PUBLIC KEY-----\\n<base64>\\n-----END PUBLIC KEY-----\\n").refine((e)=>{
        let t = e.replace("-----BEGIN PUBLIC KEY-----\n", "").replace("\n-----END PUBLIC KEY-----\n", "").replace(/\n/g, "");
        return n.test(t);
    }, "Invalid base64 content in PEM"),
    (0, _zod.z).string().regex(n, "Invalid base64-encoded DER format")
]);
const r = (0, _zod.z).object({
    encryption_type: (0, _zod.z).literal("HPKE"),
    recipient_public_key: t
}).strict(), i = (0, _zod.z).object({
    encryption_type: (0, _zod.z).literal("HPKE"),
    ciphertext: (0, _zod.z).string().base64(),
    encapsulated_key: (0, _zod.z).string()
});

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ApSkO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OAuthAuthenticateRecoveryResponse", ()=>c);
parcelHelpers.export(exports, "OAuthCallbackICloudExpoInput", ()=>a);
parcelHelpers.export(exports, "OAuthCallbackICloudExpoResponse", ()=>d);
parcelHelpers.export(exports, "OAuthInitICloudRecoveryInput", ()=>s);
parcelHelpers.export(exports, "OAuthInitRecoveryInput", ()=>_);
parcelHelpers.export(exports, "RecoveryConfigurationICloudInput", ()=>p);
parcelHelpers.export(exports, "RecoveryConfigurationICloudResponse", ()=>y);
parcelHelpers.export(exports, "RecoveryKeyMaterialInput", ()=>i);
parcelHelpers.export(exports, "RecoveryKeyMaterialResponse", ()=>n);
var _zod = require("zod");
var _apiBase = require("@privy-io/api-base");
var _objectMjs = require("./object.mjs");
const i = (0, _zod.z).object({
    chain_type: (0, _zod.z).string().optional()
}), n = (0, _zod.z).object({
    recovery_type: (0, _zod.z).enum([
        "user_passcode_derived_recovery_key",
        "privy_passcode_derived_recovery_key",
        "privy_generated_recovery_key",
        "google_drive_recovery_secret",
        "icloud_recovery_secret"
    ]),
    recovery_key_derivation_salt: (0, _zod.z).string(),
    recovery_code: (0, _zod.z).string(),
    recovery_key: (0, _zod.z).string(),
    file_id: (0, _zod.z).string(),
    icloud_record_name: (0, _zod.z).string()
}), c = (0, _zod.z).object({
    access_token: (0, _zod.z).string()
}), _ = (0, _zod.z).object({
    redirect_to: (0, _zod.z).string({
        required_error: "Please provide a redirect_to value."
    }),
    token: (0, _zod.z).string().optional(),
    state_code: (0, _zod.z).string().optional(),
    code_challenge: (0, _zod.z).string().optional()
}), s = (0, _zod.z).object({
    client_type: (0, _zod.z).enum([
        "web",
        "expo-ios"
    ])
}), a = (0, _zod.z).object({
    ckWebAuthToken: (0, _zod.z).string()
}).transform((e)=>({
        ckWebAuthToken: e.ckWebAuthToken
    })).catch(()=>{
    throw new (0, _apiBase.UnauthorizedError)("Missing ckWebAuthToken.", (0, _apiBase.PrivyErrorCode).INVALID_DATA);
}), d = (0, _objectMjs.EmptyObject), p = (0, _zod.z).object({
    client_type: (0, _zod.z).enum([
        "web",
        "expo-ios"
    ])
}), y = (0, _zod.z).object({
    api_token: (0, _zod.z).string(),
    container_identifier: (0, _zod.z).string(),
    environment: (0, _zod.z).string()
});

},{"zod":"fOFdH","@privy-io/api-base":"lvLPC","./object.mjs":"8CKI2","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5su1k":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthenticateSiweInput", ()=>i);
parcelHelpers.export(exports, "SiweAddressInput", ()=>o);
parcelHelpers.export(exports, "SiweInitInput", ()=>m);
parcelHelpers.export(exports, "SiweInput", ()=>a);
parcelHelpers.export(exports, "SiweNonce", ()=>d);
parcelHelpers.export(exports, "SmartWalletSiweInput", ()=>s);
parcelHelpers.export(exports, "TransferSiweInput", ()=>g);
var _zod = require("zod");
var _accountTransferMjs = require("./account-transfer.mjs");
var _coreMjs = require("./core.mjs");
var _smartWalletConfigMjs = require("./smart-wallet-config.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
var _smartWalletsMjs = require("../constants/smart-wallets.mjs");
const a = (0, _zod.z).object({
    message: (0, _zod.z).string({
        invalid_type_error: "Invalid SIWE message"
    }),
    signature: (0, _zod.z).string({
        invalid_type_error: "Invalid SIWE signature"
    }),
    chainId: (0, _zod.z).string().max(41).nullable().default(null),
    walletClientType: (0, _zod.z).string().max(64).nullable().default(null),
    connectorType: (0, _zod.z).string().max(64).nullable().default(null)
}), s = (0, _zod.z).object({
    message: (0, _zod.z).string({
        invalid_type_error: "Invalid SIWE message"
    }),
    signature: (0, _zod.z).string({
        invalid_type_error: "Invalid SIWE signature"
    }),
    smart_wallet_type: (0, _smartWalletConfigMjs.SmartWalletProvider)
}), i = a.merge((0, _coreMjs.AuthenticateMode)), o = (0, _zod.z).object({
    address: (0, _coreMjs.WalletAddress)
}), m = (0, _zod.z).object({
    address: (0, _coreMjs.WalletAddress).optional(),
    token: (0, _zod.z).string().optional()
}), d = (0, _zod.z).object({
    nonce: (0, _zod.z).string(),
    address: (0, _zod.z).string(),
    expires_at: (0, _zod.z).string()
}), g = (0, _accountTransferMjs.BaseAccountTransferInput).extend({
    address: (0, _coreMjs.WalletAddress),
    chainId: (0, _zod.z).string().max(41).nullable().default(null),
    walletClientType: (0, _zod.z).string().max(64).nullable().default(null),
    connectorType: (0, _zod.z).string().max(64).nullable().default(null)
});

},{"zod":"fOFdH","./account-transfer.mjs":"f44i0","./core.mjs":"9c2nU","./smart-wallet-config.mjs":"eeJcS","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","../constants/smart-wallets.mjs":"hQh54","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7aeJj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthenticateSiwsInput", ()=>i);
parcelHelpers.export(exports, "SiwsAddressInput", ()=>s);
parcelHelpers.export(exports, "SiwsInitInput", ()=>o);
parcelHelpers.export(exports, "SiwsInput", ()=>r);
parcelHelpers.export(exports, "SiwsNonce", ()=>a);
var _zod = require("zod");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
const r = (0, _zod.z).object({
    message: (0, _zod.z).string({
        invalid_type_error: "Invalid SIWS message"
    }),
    signature: (0, _zod.z).string({
        invalid_type_error: "Invalid SIWS signature"
    }),
    walletClientType: (0, _zod.z).string().max(64).nullable().default(null),
    connectorType: (0, _zod.z).string().max(64).nullable().default(null),
    message_type: (0, _zod.z).enum([
        "transaction",
        "plain"
    ]).optional()
}), i = r.merge((0, _coreMjs.AuthenticateMode)), s = (0, _zod.z).object({
    address: (0, _coreMjs.SolanaWalletAddress)
}), o = (0, _zod.z).object({
    address: (0, _coreMjs.SolanaWalletAddress),
    token: (0, _zod.z).string().optional()
}), a = (0, _zod.z).object({
    nonce: (0, _zod.z).string(),
    address: (0, _zod.z).string(),
    expires_at: (0, _zod.z).string()
});

},{"zod":"fOFdH","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kBaGG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthenticatePhoneInput", ()=>p);
parcelHelpers.export(exports, "PasswordlessSmsPhoneInput", ()=>b);
parcelHelpers.export(exports, "TransferPhoneInput", ()=>I);
parcelHelpers.export(exports, "UnlinkPhoneInput", ()=>h);
parcelHelpers.export(exports, "UpdatePhoneInput", ()=>a);
parcelHelpers.export(exports, "VerifyPhoneInput", ()=>i);
var _zod = require("zod");
var _apiBase = require("@privy-io/api-base");
var _accountTransferMjs = require("./account-transfer.mjs");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
const i = (0, _zod.z).object({
    code: (0, _coreMjs.PasswordlessCode).catch(()=>{
        throw new (0, _apiBase.LegacyInvalidInputError)("Invalid SMS verification code", (0, _apiBase.PrivyErrorCode).INVALID_CREDENTIALS);
    }),
    phoneNumber: (0, _coreMjs.PhoneNumber).catch(()=>{
        throw new (0, _apiBase.LegacyInvalidInputError)("Invalid phone number", (0, _apiBase.PrivyErrorCode).INVALID_CREDENTIALS);
    })
}), p = i.merge((0, _coreMjs.AuthenticateMode)), b = (0, _zod.z).object({
    phoneNumber: (0, _coreMjs.PhoneNumber).catch(()=>{
        throw new (0, _apiBase.LegacyInvalidInputError)("Invalid phone number, not formatted correctly", (0, _apiBase.PrivyErrorCode).INVALID_DATA);
    }),
    token: (0, _zod.z).string().optional()
}), h = (0, _zod.z).object({
    phoneNumber: (0, _coreMjs.PhoneNumber)
}), a = (0, _zod.z).object({
    old_phone_number: (0, _coreMjs.PhoneNumber),
    new_phone_number: (0, _coreMjs.PhoneNumber),
    code: (0, _coreMjs.PasswordlessCode)
}), I = (0, _accountTransferMjs.BaseAccountTransferInput).extend({
    phoneNumber: (0, _coreMjs.PhoneNumber)
});

},{"zod":"fOFdH","@privy-io/api-base":"lvLPC","./account-transfer.mjs":"f44i0","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9hZ0j":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TelegramAuthResult", ()=>e);
parcelHelpers.export(exports, "TelegramAuthenticateInput", ()=>n);
parcelHelpers.export(exports, "TelegramLinkInput", ()=>i);
parcelHelpers.export(exports, "TelegramUnlinkInput", ()=>s);
parcelHelpers.export(exports, "TelegramWebAppData", ()=>a);
parcelHelpers.export(exports, "TransferTelegramInput", ()=>p);
var _zod = require("zod");
var _zodDefault = parcelHelpers.interopDefault(_zod);
var _accountTransferMjs = require("./account-transfer.mjs");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
const e = (0, _zodDefault.default).object({
    id: (0, _zodDefault.default).coerce.number(),
    first_name: (0, _zodDefault.default).string(),
    auth_date: (0, _zodDefault.default).coerce.number(),
    hash: (0, _zodDefault.default).string(),
    username: (0, _zodDefault.default).string().optional(),
    last_name: (0, _zodDefault.default).string().optional(),
    photo_url: (0, _zodDefault.default).string().optional()
}), a = (0, _zodDefault.default).object({
    query_id: (0, _zodDefault.default).string().optional(),
    auth_date: (0, _zodDefault.default).coerce.number(),
    hash: (0, _zodDefault.default).string(),
    user: (0, _zodDefault.default).string(),
    chat_instance: (0, _zodDefault.default).string().optional(),
    chat_type: (0, _zodDefault.default).string().optional(),
    start_param: (0, _zodDefault.default).string().optional(),
    signature: (0, _zodDefault.default).string().optional()
}), n = (0, _zodDefault.default).object({
    captcha_token: (0, _zodDefault.default).string().optional(),
    telegram_auth_result: e.optional(),
    telegram_web_app_data: a.optional()
}).merge((0, _coreMjs.AuthenticateMode)), i = n, s = (0, _zodDefault.default).object({
    telegram_user_id: (0, _zodDefault.default).string()
}), p = (0, _accountTransferMjs.BaseAccountTransferInput).extend({
    telegram_auth_result: e.optional(),
    telegram_web_app_data: a.optional()
});

},{"zod":"fOFdH","./account-transfer.mjs":"f44i0","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jAErm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OptionalRefreshTokenInput", ()=>t);
parcelHelpers.export(exports, "RefreshTokenInput", ()=>r);
var _zod = require("zod");
const r = (0, _zod.z).object({
    refresh_token: (0, _zod.z).string()
}), t = r.partial();

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lAuQp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CreateKeyQuorumInput", ()=>r);
parcelHelpers.export(exports, "KeyQuorumIdFromPath", ()=>o);
parcelHelpers.export(exports, "UpdateKeyQuorumInput", ()=>t);
var _zod = require("zod");
const o = (0, _zod.z).object({
    key_quorum_id: (0, _zod.z).string({
        required_error: "Key quorum ID must be provided",
        invalid_type_error: "Key quorum ID is not a valid string"
    }).cuid2()
}), r = (0, _zod.z).object({
    public_keys: (0, _zod.z).array((0, _zod.z).string()).min(1),
    authorization_threshold: (0, _zod.z).number().min(1).optional(),
    display_name: (0, _zod.z).string().max(50).optional()
}).strict(), t = (0, _zod.z).object({
    public_keys: (0, _zod.z).array((0, _zod.z).string()).optional(),
    authorization_threshold: (0, _zod.z).number().optional(),
    display_name: (0, _zod.z).string().max(50).optional()
}).strict().refine(({ public_keys: i, authorization_threshold: o, display_name: r })=>void 0 !== i || void 0 !== o || void 0 !== r, "Must provide at least one of public_keys, authorization_threshold, or display_name");

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f1j5h":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UserSignersAuthenticateInput", ()=>m);
parcelHelpers.export(exports, "UserSignersAuthenticateResponse", ()=>p);
parcelHelpers.export(exports, "WalletsWithRecoveryRequest", ()=>a);
parcelHelpers.export(exports, "WalletsWithRecoveryResponse", ()=>n);
var _zod = require("zod");
var _userImportMjs = require("../user-import.mjs");
var _walletsMjs = require("./wallets.mjs");
var _coreMjs = require("../core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
var _embeddedWalletCreationMjs = require("../embedded-wallet-creation.mjs");
var _userMjs = require("../user.mjs");
var _smartWalletConfigMjs = require("../smart-wallet-config.mjs");
var _smartWalletsMjs = require("../../constants/smart-wallets.mjs");
var _apiBase = require("@privy-io/api-base");
var _apiMjs = require("../api.mjs");
var _transactionMjs = require("../transaction.mjs");
var _exportMjs = require("./export.mjs");
let s = (0, _walletsMjs.BaseWalletApiCreateInput).omit({
    owner: !0,
    owner_id: !0,
    additional_signers: !0,
    authorization_key_ids: !0,
    authorization_threshold: !0
});
const a = (0, _zod.z).object({
    wallets: (0, _zod.z).array(s),
    primary_signer: (0, _zod.z).object({
        subject_id: (0, _zod.z).string()
    }).strict(),
    recovery_user: (0, _zod.z).object({
        linked_accounts: (0, _zod.z).array((0, _zod.z).union([
            (0, _userImportMjs.ImportEmailAccountInput),
            (0, _userImportMjs.ImportCustomJwtAccountInput)
        ])).min(1).max(2).refine((e)=>{
            if (2 === e.length) {
                let t = e.filter((e)=>"email" === e.type), r = e.filter((e)=>"custom_auth" === e.type);
                return 1 === t.length && 1 === r.length;
            }
            return !0;
        }, {
            message: "Must have either one email and one custom JWT account, or one of each"
        })
    }).strict()
}).strict(), n = (0, _zod.z).object({
    wallets: (0, _zod.z).array((0, _walletsMjs.WalletResponse)),
    recovery_user_id: (0, _zod.z).string()
}).strict(), m = (0, _zod.z).object({
    user_jwt: (0, _zod.z).string({
        required_error: "User JWT must be provided",
        invalid_type_error: "User JWT must be a string"
    }),
    encryption_type: (0, _zod.z).literal("HPKE"),
    recipient_public_key: (0, _zod.z).string({
        required_error: "Recipient public key must be provided",
        invalid_type_error: "Recipient public key must be a string"
    })
}).strict(), p = (0, _zod.z).object({
    encrypted_authorization_key: (0, _zod.z).object({
        encryption_type: (0, _zod.z).literal("HPKE"),
        encapsulated_key: (0, _zod.z).string(),
        ciphertext: (0, _zod.z).string()
    }),
    expires_at: (0, _zod.z).number(),
    wallets: (0, _zod.z).array((0, _walletsMjs.WalletResponse))
}).strict();

},{"zod":"fOFdH","../user-import.mjs":"59IXl","./wallets.mjs":"eUydR","../core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","../embedded-wallet-creation.mjs":"gHPYA","../user.mjs":"59vYa","../smart-wallet-config.mjs":"eeJcS","../../constants/smart-wallets.mjs":"hQh54","@privy-io/api-base":"lvLPC","../api.mjs":"bMsze","../transaction.mjs":"kzolK","./export.mjs":"3JZvH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"59IXl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CreateEmbeddedWalletUserImportInput", ()=>y);
parcelHelpers.export(exports, "CreateWalletInput", ()=>U);
parcelHelpers.export(exports, "EmbeddedWalletCreationInputUnion", ()=>Z);
parcelHelpers.export(exports, "ImportAppleAccountInput", ()=>w);
parcelHelpers.export(exports, "ImportCustomJwtAccountInput", ()=>I);
parcelHelpers.export(exports, "ImportDiscordAccountInput", ()=>h);
parcelHelpers.export(exports, "ImportEmailAccountInput", ()=>i);
parcelHelpers.export(exports, "ImportFarcasterAccountInput", ()=>x);
parcelHelpers.export(exports, "ImportGithubAccountInput", ()=>p);
parcelHelpers.export(exports, "ImportGoogleAccountInput", ()=>m);
parcelHelpers.export(exports, "ImportInstagramAccountInput", ()=>_);
parcelHelpers.export(exports, "ImportLinkedInAccountInput", ()=>A);
parcelHelpers.export(exports, "ImportManyUsersInput", ()=>C);
parcelHelpers.export(exports, "ImportPhoneAccountInput", ()=>l);
parcelHelpers.export(exports, "ImportSpotifyAccountInput", ()=>g);
parcelHelpers.export(exports, "ImportTelegramAccountInput", ()=>k);
parcelHelpers.export(exports, "ImportTiktokAccountInput", ()=>b);
parcelHelpers.export(exports, "ImportTwitterAccountInput", ()=>d);
parcelHelpers.export(exports, "ImportUserInput", ()=>v);
parcelHelpers.export(exports, "ImportWalletAccountInput", ()=>u);
parcelHelpers.export(exports, "LinkedAccountInput", ()=>f);
parcelHelpers.export(exports, "WalletCreateUserInput", ()=>$);
var _zod = require("zod");
var _coreMjs = require("./core.mjs");
var _embeddedWalletCreationMjs = require("./embedded-wallet-creation.mjs");
var _userMjs = require("./user.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
var _walletsMjs = require("./wallet-api/wallets.mjs");
var _apiBase = require("@privy-io/api-base");
var _apiMjs = require("./api.mjs");
var _transactionMjs = require("./transaction.mjs");
var _exportMjs = require("./wallet-api/export.mjs");
var _smartWalletConfigMjs = require("./smart-wallet-config.mjs");
var _smartWalletsMjs = require("../constants/smart-wallets.mjs");
const u = (0, _zod.z).object({
    type: (0, _zod.z).literal("wallet"),
    address: (0, _zod.z).union([
        (0, _coreMjs.WalletAddress),
        (0, _coreMjs.SolanaWalletAddress)
    ]),
    chain_type: (0, _zod.z).enum([
        "ethereum",
        "solana"
    ])
}), i = (0, _zod.z).object({
    type: (0, _zod.z).literal("email"),
    address: (0, _coreMjs.Email)
}), l = (0, _zod.z).object({
    type: (0, _zod.z).literal("phone"),
    number: (0, _coreMjs.PhoneNumber)
}), m = (0, _zod.z).object({
    type: (0, _zod.z).literal("google_oauth"),
    subject: (0, _zod.z).string().regex(/^[\x00-\x7F]{1,256}$/),
    email: (0, _coreMjs.Email),
    name: (0, _zod.z).string()
}).strict(), d = (0, _zod.z).object({
    type: (0, _zod.z).literal("twitter_oauth"),
    subject: (0, _zod.z).string().regex(/^[\x00-\x7F]{1,256}$/),
    name: (0, _zod.z).string().min(1).max(50),
    username: (0, _zod.z).string().regex(/^[0-9a-zA-Z|\_]{1,15}$/),
    profile_picture_url: (0, _zod.z).string().url().refine((e)=>e.startsWith("https://abs.twimg.com/sticky/default_profile_images/") || e.startsWith("https://pbs.twimg.com/profile_images/")).optional()
}).strict(), h = (0, _zod.z).object({
    type: (0, _zod.z).literal("discord_oauth"),
    subject: (0, _zod.z).string().regex(/^[\x00-\x7F]{1,256}$/),
    username: (0, _zod.z).string().regex(/^(?!discord|everyone|here)[0-9a-zA-Z_.]{2,32}(?:#(?:[0-9]{4}|0))?$/).transform((e)=>e.includes("#") ? e : `${e}#0`),
    email: (0, _coreMjs.Email).optional()
}).strict(), g = (0, _zod.z).object({
    type: (0, _zod.z).literal("spotify_oauth"),
    subject: (0, _zod.z).string(),
    name: (0, _zod.z).string().optional(),
    email: (0, _coreMjs.Email).optional()
}).strict(), p = (0, _zod.z).object({
    type: (0, _zod.z).literal("github_oauth"),
    subject: (0, _zod.z).string().regex(/^[\x00-\x7F]{1,256}$/),
    username: (0, _zod.z).string().regex(/^[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*$/).max(39),
    name: (0, _zod.z).string().optional(),
    email: (0, _coreMjs.Email).optional()
}).strict(), _ = (0, _zod.z).object({
    type: (0, _zod.z).literal("instagram_oauth"),
    subject: (0, _zod.z).string().regex(/^[\x00-\x7F]{1,256}$/),
    username: (0, _zod.z).string().regex(/^(?!instagram|everyone|here)[0-9a-zA-Z._]{2,32}$/)
}).strict(), b = (0, _zod.z).object({
    type: (0, _zod.z).literal("tiktok_oauth"),
    subject: (0, _zod.z).string().regex(/^[\x00-\x7F]{1,256}$/),
    username: (0, _zod.z).string().regex(/^(?!tiktok|everyone|here)[0-9a-zA-Z]{2,32}$/),
    name: (0, _zod.z).string().min(1).max(30).nullable()
}).strict(), A = (0, _zod.z).object({
    type: (0, _zod.z).literal("linkedin_oauth"),
    subject: (0, _zod.z).string().regex(/^[\x00-\x7F]{1,256}$/),
    name: (0, _zod.z).string().optional(),
    email: (0, _coreMjs.Email).optional(),
    vanityName: (0, _zod.z).string().optional()
}).strict(), w = (0, _zod.z).object({
    type: (0, _zod.z).literal("apple_oauth"),
    subject: (0, _zod.z).string().regex(/^[\x00-\x7F]{1,256}$/),
    email: (0, _coreMjs.Email).optional()
}).strict(), x = (0, _zod.z).object({
    type: (0, _zod.z).literal("farcaster"),
    fid: (0, _zod.z).number().int(),
    owner_address: (0, _coreMjs.WalletAddress),
    username: (0, _zod.z).string().max(256).optional(),
    display_name: (0, _zod.z).string().max(32).optional(),
    bio: (0, _zod.z).string().max(256).optional(),
    profile_picture_url: (0, _zod.z).string().max(256).optional(),
    homepage_url: (0, _zod.z).string().max(256).optional()
}).strict(), k = (0, _zod.z).object({
    type: (0, _zod.z).literal("telegram"),
    telegram_user_id: (0, _zod.z).string().min(1).max(255),
    first_name: (0, _zod.z).string().max(255).optional(),
    last_name: (0, _zod.z).string().max(255).optional(),
    username: (0, _zod.z).string().max(255).optional(),
    photo_url: (0, _zod.z).string().max(255).optional()
}).strict(), I = (0, _zod.z).object({
    type: (0, _zod.z).literal("custom_auth"),
    custom_user_id: (0, _zod.z).string().min(1).max(256)
}).strict(), f = (0, _zod.z).discriminatedUnion("type", [
    u,
    i,
    l,
    m,
    d,
    h,
    p,
    g,
    _,
    b,
    w,
    A,
    x,
    k,
    I
]);
let j = f.array().min(1).transform((e)=>{
    let t = {
        emailAccounts: [],
        phoneAccounts: [],
        ethereumAccounts: [],
        solanaAccounts: [],
        googleAccounts: [],
        twitterAccounts: [],
        discordAccounts: [],
        githubAccounts: [],
        spotifyAccounts: [],
        instagramAccounts: [],
        tiktokAccounts: [],
        linkedinAccounts: [],
        appleAccounts: [],
        farcasterAccounts: [],
        telegramAccounts: [],
        customJwtAccounts: []
    };
    for (let s of e)switch(s.type){
        case "wallet":
            "ethereum" === s.chain_type && t.ethereumAccounts.push(s), "solana" === s.chain_type && t.solanaAccounts.push(s);
            break;
        case "email":
            t.emailAccounts.push(s);
            break;
        case "phone":
            t.phoneAccounts.push(s);
            break;
        case "google_oauth":
            t.googleAccounts.push(s);
            break;
        case "twitter_oauth":
            t.twitterAccounts.push(s);
            break;
        case "discord_oauth":
            t.discordAccounts.push(s);
            break;
        case "github_oauth":
            t.githubAccounts.push(s);
            break;
        case "spotify_oauth":
            t.spotifyAccounts.push(s);
            break;
        case "instagram_oauth":
            t.instagramAccounts.push(s);
            break;
        case "tiktok_oauth":
            t.tiktokAccounts.push(s);
            break;
        case "linkedin_oauth":
            t.linkedinAccounts.push(s);
            break;
        case "apple_oauth":
            t.appleAccounts.push(s);
            break;
        case "farcaster":
            t.farcasterAccounts.push(s);
            break;
        case "telegram":
            t.telegramAccounts.push(s);
            break;
        case "custom_auth":
            t.customJwtAccounts.push(s);
    }
    return t;
}).superRefine((t, s)=>{
    t.emailAccounts && t.emailAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one email account."
    }), t.phoneAccounts && t.phoneAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one phone number account."
    }), t.googleAccounts && t.googleAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one Google account."
    }), t.linkedinAccounts && t.linkedinAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one LinkedIn account."
    }), t.twitterAccounts && t.twitterAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one Twitter account."
    }), t.discordAccounts && t.discordAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one Discord account."
    }), t.githubAccounts && t.githubAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one GitHub account."
    }), t.tiktokAccounts && t.tiktokAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one Tiktok account."
    }), t.spotifyAccounts && t.spotifyAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one Spotify account."
    }), t.instagramAccounts && t.instagramAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one Instagram account."
    }), t.appleAccounts && t.appleAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one Apple account."
    }), t.farcasterAccounts && t.farcasterAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one Farcaster account."
    }), t.telegramAccounts && t.telegramAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one Telegram account."
    }), t.customJwtAccounts && t.customJwtAccounts.length > 0 && (t.customJwtAccounts.length > 1 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User cannot have more than one custom JWT account."
    }), t.ethereumAccounts.length + t.emailAccounts.length + t.phoneAccounts.length + t.appleAccounts.length + t.discordAccounts.length + t.githubAccounts.length + t.googleAccounts.length + t.spotifyAccounts.length + t.instagramAccounts.length + t.linkedinAccounts.length + t.twitterAccounts.length + t.tiktokAccounts.length + t.telegramAccounts.length + t.farcasterAccounts.length !== 0 && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "User with custom JWT account cannot be imported with other linked accounts."
    }));
});
const y = (0, _zod.z).object({
    create_embedded_wallet: (0, _zod.z).boolean().optional(),
    create_n_embedded_wallets: (0, _zod.z).number().min(1).max(10).optional(),
    create_n_ethereum_wallets: (0, _zod.z).number().min(1).max(10).optional(),
    create_ethereum_wallet: (0, _zod.z).boolean().optional(),
    create_solana_wallet: (0, _zod.z).boolean().optional(),
    create_ethereum_smart_wallet: (0, _zod.z).boolean().optional()
}).strict(), Z = (0, _embeddedWalletCreationMjs.EmbeddedWalletCreationInput).merge(y), v = Z.extend({
    linked_accounts: j,
    custom_metadata: (0, _userMjs.CustomMetadata).optional()
}).superRefine((t, s)=>{
    void 0 !== t.create_embedded_wallet && void 0 !== t.create_n_ethereum_wallets && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "create_embedded_wallet is deprecated, use create_ethereum_wallet instead"
    }), void 0 !== t.create_ethereum_wallet && void 0 !== t.create_n_embedded_wallets && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "create_n_embedded_wallets is deprecated, use create_n_ethereum_wallets instead"
    }), t.create_ethereum_smart_wallet && !t.create_ethereum_wallet && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "create_ethereum_smart_wallet requires create_ethereum_wallet to be true"
    });
}), C = (0, _zod.z).object({
    users: v.array().max(20)
}), U = (0, _zod.z).object({
    create_ethereum_wallet: (0, _zod.z).boolean().optional(),
    number_of_ethereum_wallets_to_create: (0, _zod.z).number().min(1).max(10).optional(),
    create_ethereum_smart_wallet: (0, _zod.z).boolean().optional(),
    create_solana_wallet: (0, _zod.z).boolean().optional()
}).strict();
const $ = (0, _embeddedWalletCreationMjs.EmbeddedWalletCreationInput).merge(U).extend({
    user_id: (0, _coreMjs.UserId)
}).superRefine((t, s)=>{
    t.create_ethereum_smart_wallet && !t.create_ethereum_wallet && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "create_ethereum_smart_wallet requires create_ethereum_wallet to be true"
    }), !t.create_ethereum_wallet && t.number_of_ethereum_wallets_to_create && s.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "create_ethereum_wallet must be true if number_of_ethereum_wallets_to_create is specified"
    });
});

},{"zod":"fOFdH","./core.mjs":"9c2nU","./embedded-wallet-creation.mjs":"gHPYA","./user.mjs":"59vYa","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","./wallet-api/wallets.mjs":"eUydR","@privy-io/api-base":"lvLPC","./api.mjs":"bMsze","./transaction.mjs":"kzolK","./wallet-api/export.mjs":"3JZvH","./smart-wallet-config.mjs":"eeJcS","../constants/smart-wallets.mjs":"hQh54","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gHPYA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmbeddedWalletCreationInput", ()=>r);
parcelHelpers.export(exports, "WalletCreationInput", ()=>a);
var _zod = require("zod");
var _walletsMjs = require("./wallet-api/wallets.mjs");
var _apiBase = require("@privy-io/api-base");
var _apiMjs = require("./api.mjs");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
var _transactionMjs = require("./transaction.mjs");
var _exportMjs = require("./wallet-api/export.mjs");
const a = (0, _zod.z).object({
    additional_signers: (0, _walletsMjs.AdditionalSignerInput).optional(),
    policy_ids: (0, _walletsMjs.PolicyInput),
    chain_type: (0, _zod.z).union([
        (0, _zod.z).literal("solana"),
        (0, _zod.z).literal("ethereum")
    ]),
    create_smart_wallet: (0, _zod.z).boolean().optional()
}).strict(), r = (0, _zod.z).object({
    wallets: (0, _zod.z).array(a).optional(),
    create_direct_signer: (0, _zod.z).boolean().optional()
}).strict();

},{"zod":"fOFdH","./wallet-api/wallets.mjs":"eUydR","@privy-io/api-base":"lvLPC","./api.mjs":"bMsze","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","./transaction.mjs":"kzolK","./wallet-api/export.mjs":"3JZvH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8mLHk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DelegatedActionsConsentInput", ()=>t);
parcelHelpers.export(exports, "WalletApiRevokeResponse", ()=>r);
var _zod = require("zod");
const t = (0, _zod.z).object({
    encrypted_tee_share: (0, _zod.z).string(),
    app_share: (0, _zod.z).string(),
    delegated_addresses: (0, _zod.z).array((0, _zod.z).object({
        chain_type: (0, _zod.z).union([
            (0, _zod.z).literal("solana"),
            (0, _zod.z).literal("ethereum")
        ]),
        address: (0, _zod.z).string(),
        wallet_index: (0, _zod.z).number().default(0)
    }))
}), r = (0, _zod.z).object({
    message: (0, _zod.z).string()
});

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"45AoS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TransactionScanningInput", ()=>o);
parcelHelpers.export(exports, "TransactionScanningResponse", ()=>b);
var _zod = require("zod");
const o = (0, _zod.z).object({
    chain_id: (0, _zod.z).string(),
    metadata: (0, _zod.z).object({
        domain: (0, _zod.z).string()
    }),
    request: (0, _zod.z).object({
        method: (0, _zod.z).string(),
        params: (0, _zod.z).array((0, _zod.z).any())
    })
});
let i = (0, _zod.z).object({
    status: (0, _zod.z).literal("Error"),
    error: (0, _zod.z).string()
}), a = (0, _zod.z).object({
    status: (0, _zod.z).literal("Success"),
    result_type: (0, _zod.z).string()
}), r = (0, _zod.z).discriminatedUnion("status", [
    i,
    a
]), n = (0, _zod.z).object({
    type: (0, _zod.z).string().optional(),
    symbol: (0, _zod.z).string().optional(),
    logo_url: (0, _zod.z).string().optional(),
    name: (0, _zod.z).string().optional()
}), s = (0, _zod.z).object({
    value: (0, _zod.z).string().optional(),
    usd_price: (0, _zod.z).string().optional()
}), e = (0, _zod.z).object({
    asset: n,
    in: (0, _zod.z).array(s),
    out: (0, _zod.z).array(s)
}), l = (0, _zod.z).object({
    asset: n,
    spenders: (0, _zod.z).record((0, _zod.z).string(), s)
}), c = (0, _zod.z).object({
    function_selector: (0, _zod.z).string(),
    function_signature: (0, _zod.z).string().optional(),
    function_declaration: (0, _zod.z).string().optional()
}), g = (0, _zod.z).object({
    from: (0, _zod.z).string().optional(),
    to: (0, _zod.z).string().optional(),
    value: (0, _zod.z).string().optional(),
    data: (0, _zod.z).string().optional(),
    gas: (0, _zod.z).string().optional(),
    gas_price: (0, _zod.z).string().optional(),
    block_tag: (0, _zod.z).string().optional(),
    chain: (0, _zod.z).string().optional(),
    calldata: c.optional()
}), p = (0, _zod.z).object({
    status: (0, _zod.z).literal("Error"),
    error: (0, _zod.z).string()
}), u = (0, _zod.z).object({
    status: (0, _zod.z).literal("Success"),
    params: g.optional(),
    assets_diffs: (0, _zod.z).array(e),
    exposures: (0, _zod.z).array(l)
}), d = (0, _zod.z).discriminatedUnion("status", [
    p,
    u
]);
const b = (0, _zod.z).object({
    validation: r,
    simulation: d
});

},{"zod":"fOFdH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5DCvG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TestAccountIdFromPath", ()=>e);
var _zod = require("zod");
var _apiBase = require("@privy-io/api-base");
const e = (0, _zod.z).object({
    test_account_id: (0, _zod.z).string({
        required_error: "Test account ID must be provided",
        invalid_type_error: "Test account ID is not a valid string"
    }).min(1)
}).catch(({ error: r })=>{
    throw new (0, _apiBase.InvalidInputError)(r.message, (0, _apiBase.PrivyErrorCode).INVALID_DATA);
});

},{"zod":"fOFdH","@privy-io/api-base":"lvLPC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3STEX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AuthenticationEvent", ()=>a);
parcelHelpers.export(exports, "EventType", ()=>e);
parcelHelpers.export(exports, "EventTypes", ()=>t);
parcelHelpers.export(exports, "FundsTransferEvent", ()=>r);
parcelHelpers.export(exports, "MfaEvent", ()=>d);
parcelHelpers.export(exports, "PrivateKeyExportedEvent", ()=>c);
parcelHelpers.export(exports, "TransactionEvent", ()=>n);
const e = {
    UserCreated: "user.created",
    UserAuthenticated: "user.authenticated",
    UserLinkedAccount: "user.linked_account",
    UserUnlinkedAccount: "user.unlinked_account",
    UserUpdatedAccount: "user.updated_account",
    UserTransferredAccount: "user.transferred_account",
    UserWalletCreated: "user.wallet_created",
    TransactionBroadcasted: "transaction.broadcasted",
    TransactionConfirmed: "transaction.confirmed",
    TransactionExecutionReverted: "transaction.execution_reverted",
    TransactionDelayed: "transaction.delayed",
    FundsDeposited: "wallet.funds_deposited",
    FundsWithdrawn: "wallet.funds_withdrawn",
    MfaEnabled: "mfa.enabled",
    MfaDisabled: "mfa.disabled",
    PrivateKeyExport: "wallet.private_key_export",
    WalletRecoverySetup: "wallet.recovery_setup",
    WalletRecovered: "wallet.recovered"
}, t = Object.values(e), a = [
    e.UserCreated,
    e.UserAuthenticated,
    e.UserLinkedAccount,
    e.UserUnlinkedAccount,
    e.UserUpdatedAccount
], n = [
    e.TransactionBroadcasted,
    e.TransactionConfirmed,
    e.TransactionExecutionReverted,
    e.TransactionDelayed
], r = [
    e.FundsDeposited,
    e.FundsWithdrawn
], d = [
    e.MfaEnabled,
    e.MfaDisabled
], c = [
    e.PrivateKeyExport
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fa6e5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EMBEDDED_WALLET_RECOVERY_TYPES", ()=>e);
const e = [
    "user_passcode_derived_recovery_key",
    "privy_passcode_derived_recovery_key",
    "privy_generated_recovery_key",
    "google_drive_recovery_secret",
    "icloud_recovery_secret",
    "recovery_encryption_key"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a1J95":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BridgeBusinessAssociatedPerson", ()=>g);
parcelHelpers.export(exports, "BridgeKycAddress", ()=>m);
parcelHelpers.export(exports, "BridgeKycData", ()=>l);
parcelHelpers.export(exports, "BridgeKycDocument", ()=>c);
parcelHelpers.export(exports, "BridgeKycIdentifyingInformation", ()=>p);
parcelHelpers.export(exports, "BridgeKycInput", ()=>h);
parcelHelpers.export(exports, "BridgeKycLinkResponse", ()=>y);
parcelHelpers.export(exports, "BridgeRegulatedActivity", ()=>d);
parcelHelpers.export(exports, "BridgeTradedListings", ()=>_);
parcelHelpers.export(exports, "FiatAccountAddress", ()=>v);
parcelHelpers.export(exports, "FiatAccountIbanData", ()=>w);
parcelHelpers.export(exports, "FiatAccountSwiftData", ()=>Y);
parcelHelpers.export(exports, "FiatAccountUsAccountData", ()=>k);
parcelHelpers.export(exports, "FiatCurrency", ()=>f);
parcelHelpers.export(exports, "FiatPaymentRail", ()=>D);
parcelHelpers.export(exports, "GetOnrampFiatAccountStatusInput", ()=>j);
parcelHelpers.export(exports, "GetOnrampFiatAccountsResponse", ()=>x);
parcelHelpers.export(exports, "GetOnrampKycStatusInput", ()=>o);
parcelHelpers.export(exports, "GetOnrampKycStatusResponse", ()=>s);
parcelHelpers.export(exports, "GetOnrampTermsOfServiceStatusInput", ()=>r);
parcelHelpers.export(exports, "ListFiatTransactionsInput", ()=>A);
parcelHelpers.export(exports, "ListFiatTransactionsResponse", ()=>R);
parcelHelpers.export(exports, "OfframpInput", ()=>$);
parcelHelpers.export(exports, "OfframpResponse", ()=>z);
parcelHelpers.export(exports, "OnrampAsset", ()=>C);
parcelHelpers.export(exports, "OnrampChain", ()=>M);
parcelHelpers.export(exports, "OnrampFiatAccountInput", ()=>I);
parcelHelpers.export(exports, "OnrampFiatAccountResponse", ()=>q);
parcelHelpers.export(exports, "OnrampInput", ()=>W);
parcelHelpers.export(exports, "OnrampKycInput", ()=>u);
parcelHelpers.export(exports, "OnrampKycResponse", ()=>b);
parcelHelpers.export(exports, "OnrampKycStatus", ()=>a);
parcelHelpers.export(exports, "OnrampProvider", ()=>n);
parcelHelpers.export(exports, "OnrampResponse", ()=>Z);
parcelHelpers.export(exports, "OnrampTermsOfServiceStatusResponse", ()=>e);
parcelHelpers.export(exports, "OnrampTransferStatus", ()=>U);
var _zod = require("zod");
var _coreMjs = require("./core.mjs");
var _bs58 = require("bs58");
var _max = require("libphonenumber-js/max");
var _viem = require("viem");
const n = (0, _zod.z).enum([
    "bridge",
    "bridge-sandbox"
]), r = (0, _zod.z).object({
    provider: n
}), e = (0, _zod.z).union([
    (0, _zod.z).object({
        status: (0, _zod.z).literal("completed")
    }),
    (0, _zod.z).object({
        status: (0, _zod.z).literal("incomplete"),
        url: (0, _zod.z).string()
    })
]), a = (0, _zod.z).enum([
    "not_found",
    "active",
    "awaiting_questionnaire",
    "awaiting_ubo",
    "incomplete",
    "not_started",
    "offboarded",
    "paused",
    "rejected",
    "under_review"
]), o = (0, _zod.z).object({
    provider: n
}), s = (0, _zod.z).object({
    user_id: (0, _zod.z).string(),
    provider_user_id: (0, _zod.z).string().optional(),
    status: a
}), m = (0, _zod.z).object({
    street_line_1: (0, _zod.z).string().trim().min(1),
    street_line_2: (0, _zod.z).string().trim().min(1).optional(),
    city: (0, _zod.z).string().trim().min(1),
    subdivision: (0, _zod.z).string().trim().min(1).max(3),
    postal_code: (0, _zod.z).string().trim().min(1).optional(),
    country: (0, _zod.z).string().trim().min(3).max(3)
}), p = (0, _zod.z).object({
    type: (0, _zod.z).string(),
    issuing_country: (0, _zod.z).string().trim().min(3).max(3),
    number: (0, _zod.z).string().optional(),
    description: (0, _zod.z).string().optional(),
    expiration: (0, _zod.z).string().optional(),
    image_front: (0, _zod.z).string().optional(),
    image_back: (0, _zod.z).string().optional()
}), c = (0, _zod.z).object({
    purposes: (0, _zod.z).array((0, _zod.z).string().trim().min(1)).min(1),
    file: (0, _zod.z).string().trim().min(1),
    description: (0, _zod.z).string().trim().min(1).optional()
}), d = (0, _zod.z).object({
    regulated_activities_description: (0, _zod.z).string().trim().min(1),
    primary_regulatory_authority_country: (0, _zod.z).string().trim().min(1),
    primary_regulatory_authority_name: (0, _zod.z).string().trim().min(1),
    license_number: (0, _zod.z).string().trim().min(1)
}), g = (0, _zod.z).object({
    first_name: (0, _zod.z).string().trim().min(1).max(1024),
    last_name: (0, _zod.z).string().trim().min(1).max(1024),
    email: (0, _zod.z).string().trim().min(1).max(1024).email(),
    residential_address: m.passthrough(),
    birth_date: (0, _zod.z).string().trim().min(10).max(10),
    has_ownership: (0, _zod.z).boolean(),
    has_control: (0, _zod.z).boolean(),
    is_signer: (0, _zod.z).boolean(),
    identifying_information: (0, _zod.z).array(p.passthrough()).min(1),
    middle_name: (0, _zod.z).string().trim().min(1).max(1024).optional(),
    transliterated_first_name: (0, _zod.z).string().trim().min(1).max(256).optional(),
    transliterated_middle_name: (0, _zod.z).string().trim().min(1).max(256).optional(),
    transliterated_last_name: (0, _zod.z).string().trim().min(1).max(256).optional(),
    phone: (0, _zod.z).string().trim().min(2).max(18).startsWith("+").optional(),
    transliterated_residential_address: m.passthrough().optional(),
    is_director: (0, _zod.z).boolean().optional(),
    title: (0, _zod.z).string().trim().min(1).max(1024).optional(),
    ownership_percentage: (0, _zod.z).number().int().optional(),
    relationship_established_at: (0, _zod.z).string().trim().min(10).max(10).optional(),
    nationality: (0, _zod.z).string().min(3).max(3).optional(),
    verified_selfie_at: (0, _zod.z).string().optional(),
    completed_customer_safety_check_at: (0, _zod.z).string().optional(),
    documents: (0, _zod.z).array(c.passthrough()).optional()
}), _ = (0, _zod.z).object({
    market_identifier_code: (0, _zod.z).string().trim().min(1),
    stock_number: (0, _zod.z).string().trim(),
    ticket: (0, _zod.z).string().trim()
}), l = (0, _zod.z).object({
    type: (0, _zod.z).literal("individual"),
    first_name: (0, _zod.z).string().trim().min(1).max(1024),
    last_name: (0, _zod.z).string().trim().min(1).max(1024),
    email: (0, _zod.z).string().trim().min(1).max(1024).email(),
    residential_address: m.passthrough(),
    birth_date: (0, _zod.z).string().trim().min(10).max(10),
    identifying_information: (0, _zod.z).array(p.passthrough()).min(1),
    ofac_screen: (0, _zod.z).object({
        screened_at: (0, _zod.z).string().regex(/^\d{4}-\d{2}-\d{2}$/, "Invalid date format (YYYY-MM-DD)"),
        result: (0, _zod.z).enum([
            "passed"
        ])
    }).optional(),
    kyc_screen: (0, _zod.z).object({
        screened_at: (0, _zod.z).string().regex(/^\d{4}-\d{2}-\d{2}$/, "Invalid date format (YYYY-MM-DD)"),
        result: (0, _zod.z).enum([
            "passed"
        ])
    }).optional(),
    signed_agreement_id: (0, _zod.z).string().trim().min(1).max(1024).optional(),
    middle_name: (0, _zod.z).string().trim().min(1).max(1024).optional(),
    transliterated_first_name: (0, _zod.z).string().trim().min(1).max(256).optional(),
    transliterated_middle_name: (0, _zod.z).string().trim().min(1).max(256).optional(),
    transliterated_last_name: (0, _zod.z).string().trim().min(1).max(256).optional(),
    phone: (0, _zod.z).string().trim().min(2).max(18).startsWith("+").optional(),
    transliterated_residential_address: m.passthrough().optional(),
    endorsements: (0, _zod.z).array((0, _zod.z).string()).optional(),
    account_purpose: (0, _zod.z).string().optional(),
    account_purpose_other: (0, _zod.z).string().optional(),
    employment_status: (0, _zod.z).string().optional(),
    expected_monthly_payments_usd: (0, _zod.z).string().optional(),
    acting_as_intermediary: (0, _zod.z).string().optional(),
    most_recent_occupation: (0, _zod.z).string().optional(),
    source_of_funds: (0, _zod.z).string().optional(),
    nationality: (0, _zod.z).string().min(3).max(3).optional(),
    verified_selfie_at: (0, _zod.z).string().optional(),
    completed_customer_safety_check_at: (0, _zod.z).string().optional(),
    documents: (0, _zod.z).array(c.passthrough()).optional(),
    has_signed_terms_of_service: (0, _zod.z).boolean().optional()
}), u = (0, _zod.z).discriminatedUnion("provider", [
    (0, _zod.z).object({
        provider: (0, _zod.z).literal("bridge"),
        data: l.passthrough()
    }),
    (0, _zod.z).object({
        provider: (0, _zod.z).literal("bridge-sandbox"),
        data: l.passthrough()
    })
]), b = (0, _zod.z).object({
    user_id: (0, _zod.z).string(),
    provider_user_id: (0, _zod.z).string().optional(),
    status: a
}), h = (0, _zod.z).object({
    provider: n,
    full_name: (0, _zod.z).string().optional(),
    email: (0, _zod.z).string().email(),
    type: (0, _zod.z).enum([
        "individual",
        "business"
    ]).optional(),
    endorsements: (0, _zod.z).array((0, _zod.z).enum([
        "sepa"
    ])).optional(),
    redirect_uri: (0, _zod.z).string().optional()
}).passthrough(), y = (0, _zod.z).object({
    id: (0, _zod.z).string(),
    customer_id: (0, _zod.z).string(),
    full_name: (0, _zod.z).string(),
    email: (0, _zod.z).string(),
    kyc_link: (0, _zod.z).string(),
    kyc_status: (0, _zod.z).enum([
        "not_started",
        "pending",
        "incomplete",
        "awaiting_ubo",
        "manual_review",
        "under_review",
        "approved",
        "rejected"
    ]),
    rejection_reasons: (0, _zod.z).array((0, _zod.z).object({
        developer_reason: (0, _zod.z).string(),
        reason: (0, _zod.z).string(),
        created_at: (0, _zod.z).string()
    })),
    tos_link: (0, _zod.z).string(),
    tos_status: (0, _zod.z).enum([
        "pending",
        "approved"
    ]),
    persona_inquiry_type: (0, _zod.z).string().optional(),
    created_at: (0, _zod.z).string()
}), f = (0, _zod.z).enum([
    "usd",
    "eur"
]), j = (0, _zod.z).object({
    provider: n
}), x = (0, _zod.z).object({
    accounts: (0, _zod.z).array((0, _zod.z).object({
        id: (0, _zod.z).string(),
        bank_name: (0, _zod.z).string().optional(),
        currency: (0, _zod.z).string(),
        account_type: (0, _zod.z).string(),
        last_4: (0, _zod.z).string().optional()
    }))
}), v = (0, _zod.z).object({
    street_line_1: (0, _zod.z).string().trim().min(1),
    street_line_2: (0, _zod.z).string().trim().min(1).optional(),
    city: (0, _zod.z).string().trim().min(1),
    postal_code: (0, _zod.z).string().trim().min(1).optional(),
    country: (0, _zod.z).string().trim().min(3).max(3),
    state: (0, _zod.z).string().trim().min(1).max(3).optional()
}), k = (0, _zod.z).object({
    account_number: (0, _zod.z).string().trim().min(1),
    routing_number: (0, _zod.z).string().trim().min(9).max(9),
    checking_or_savings: (0, _zod.z).enum([
        "checking",
        "savings"
    ]).optional()
}), w = (0, _zod.z).object({
    account_number: (0, _zod.z).string().trim().min(1),
    bic: (0, _zod.z).string().trim().min(1),
    country: (0, _zod.z).string().trim().min(3).max(3)
}), Y = (0, _zod.z).object({
    address: v,
    category: (0, _zod.z).enum([
        "client",
        "parent_company",
        "subsidiary",
        "supplier"
    ]),
    purpose_of_funds: (0, _zod.z).array((0, _zod.z).enum([
        "intra_group_transfer",
        "invoice_for_goods_and_services"
    ])).min(1),
    short_business_description: (0, _zod.z).string().trim().min(1),
    account: w
}), I = (0, _zod.z).object({
    provider: n,
    account_owner_name: (0, _zod.z).string().trim().min(3).max(256),
    bank_name: (0, _zod.z).string().trim().min(3).max(256).optional(),
    currency: f,
    iban: w.passthrough().optional(),
    account: k.passthrough().optional(),
    swift: Y.passthrough().optional(),
    address: v.passthrough().optional(),
    first_name: (0, _zod.z).string().trim().min(1).max(1024).optional(),
    last_name: (0, _zod.z).string().trim().min(1).max(1024).optional()
}).passthrough().superRefine((i, n)=>{
    i.account || i.iban || i.swift || n.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "At least one of account, iban, or swift is required"
    }), !i.iban || i.first_name && i.last_name || n.addIssue({
        code: (0, _zod.z).ZodIssueCode.custom,
        message: "first_name and last_name are required when iban is provided"
    });
}), q = (0, _zod.z).object({
    id: (0, _zod.z).string(),
    bank_name: (0, _zod.z).string().optional(),
    currency: (0, _zod.z).string(),
    account_type: (0, _zod.z).string(),
    last_4: (0, _zod.z).string().optional()
}), D = (0, _zod.z).enum([
    "sepa",
    "ach_push",
    "wire"
]), M = (0, _zod.z).enum([
    "ethereum",
    "base",
    "arbitrum",
    "polygon",
    "optimism"
]), C = (0, _zod.z).enum([
    "usdc"
]), U = (0, _zod.z).enum([
    "awaiting_funds",
    "in_review",
    "funds_received",
    "payment_submitted",
    "payment_processed",
    "canceled",
    "error",
    "undeliverable",
    "returned",
    "refunded"
]), W = (0, _zod.z).object({
    amount: (0, _zod.z).string().trim().min(1),
    provider: n,
    source: (0, _zod.z).object({
        payment_rail: D,
        currency: f
    }).passthrough(),
    destination: (0, _zod.z).object({
        chain: M,
        currency: C,
        to_address: (0, _coreMjs.WalletAddress)
    }).passthrough()
}).passthrough(), Z = (0, _zod.z).object({
    id: (0, _zod.z).string(),
    status: U,
    deposit_instructions: (0, _zod.z).object({
        amount: (0, _zod.z).string(),
        currency: f,
        payment_rail: D,
        deposit_message: (0, _zod.z).string().optional(),
        bank_name: (0, _zod.z).string().optional(),
        bank_account_number: (0, _zod.z).string().optional(),
        bank_routing_number: (0, _zod.z).string().optional(),
        bank_beneficiary_name: (0, _zod.z).string().optional(),
        bank_beneficiary_address: (0, _zod.z).string().optional(),
        bank_address: (0, _zod.z).string().optional(),
        iban: (0, _zod.z).string().optional(),
        bic: (0, _zod.z).string().optional(),
        account_holder_name: (0, _zod.z).string().optional()
    })
}), $ = (0, _zod.z).object({
    amount: (0, _zod.z).string().trim().min(1),
    provider: n,
    source: (0, _zod.z).object({
        currency: C,
        chain: M,
        from_address: (0, _coreMjs.WalletAddress)
    }).passthrough(),
    destination: (0, _zod.z).object({
        currency: f,
        payment_rail: D,
        external_account_id: (0, _zod.z).string().uuid()
    }).passthrough()
}).passthrough(), z = (0, _zod.z).object({
    id: (0, _zod.z).string(),
    status: U,
    deposit_instructions: (0, _zod.z).object({
        amount: (0, _zod.z).string(),
        currency: C,
        chain: M,
        to_address: (0, _zod.z).string(),
        from_address: (0, _zod.z).string()
    })
}), A = (0, _zod.z).object({
    provider: n
}).passthrough(), R = (0, _zod.z).object({
    transactions: (0, _zod.z).array((0, _zod.z).discriminatedUnion("type", [
        (0, _zod.z).object({
            type: (0, _zod.z).literal("onramp"),
            created_at: (0, _zod.z).string(),
            destination: (0, _zod.z).object({
                chain: (0, _zod.z).string(),
                currency: (0, _zod.z).string(),
                address: (0, _zod.z).string(),
                privy_user_id: (0, _zod.z).string().optional()
            }),
            receipt: (0, _zod.z).object({
                final_amount: (0, _zod.z).string(),
                transaction_hash: (0, _zod.z).string().optional()
            }).optional(),
            is_sandbox: (0, _zod.z).boolean()
        }).extend(Z.shape),
        (0, _zod.z).object({
            type: (0, _zod.z).literal("offramp"),
            created_at: (0, _zod.z).string(),
            destination: (0, _zod.z).object({
                payment_rail: (0, _zod.z).string(),
                currency: (0, _zod.z).string(),
                external_account_id: (0, _zod.z).string()
            }),
            receipt: (0, _zod.z).object({
                final_amount: (0, _zod.z).string(),
                transaction_hash: (0, _zod.z).string().optional()
            }).optional(),
            is_sandbox: (0, _zod.z).boolean()
        }).extend(z.shape)
    ]))
});

},{"zod":"fOFdH","./core.mjs":"9c2nU","bs58":"7AN9k","libphonenumber-js/max":"3PQfh","viem":"8jaSh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9drw3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>t);
var _publicApi = require("@privy-io/public-api");
var _tokenMjs = require("../Token.mjs");
var _jose = require("jose");
class t {
    async updateOnCrossAppAuthentication(r, e) {
        let s = e.access_token, i = t.providerAccessTokenStorageKey(r);
        await this._storage.put(i, s);
    }
    async getProviderAccessToken(r) {
        let s = t.providerAccessTokenStorageKey(r), i = await this._storage.get(s);
        if ("string" != typeof i) return null;
        try {
            if (new (0, _tokenMjs.Token)(i).isExpired()) throw Error("JWT is expired");
            return i;
        } catch  {
            return await this._storage.del(s), null;
        }
    }
    async getCrossAppConnections() {
        return await this._privyInternal.fetch((0, _publicApi.GetCrossAppConnections), {
            params: {
                app_id: this._privyInternal.appId
            }
        });
    }
    constructor(r, e){
        this._privyInternal = r, this._storage = e;
    }
}
t.providerAccessTokenStorageKey = (r)=>`privy:cross-app:${r}`;

},{"@privy-io/public-api":"3ZXNH","../Token.mjs":"kjSV6","jose":"80NDr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kjSV6":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Token", ()=>t);
var _jose = require("jose");
class t {
    static parse(e) {
        try {
            return new t(e);
        } catch (e) {
            return null;
        }
    }
    get subject() {
        return this._decoded.sub;
    }
    get expiration() {
        return this._decoded.exp;
    }
    get issuer() {
        return this._decoded.iss;
    }
    get audience() {
        return this._decoded.aud;
    }
    isExpired(e = 0) {
        return Date.now() >= 1e3 * (this.expiration - e);
    }
    constructor(t){
        this.value = t, this._decoded = _jose.decodeJwt(t);
    }
}

},{"jose":"80NDr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"80NDr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compactDecrypt", ()=>(0, _decryptJs.compactDecrypt));
parcelHelpers.export(exports, "flattenedDecrypt", ()=>(0, _decryptJs1.flattenedDecrypt));
parcelHelpers.export(exports, "generalDecrypt", ()=>(0, _decryptJs2.generalDecrypt));
parcelHelpers.export(exports, "GeneralEncrypt", ()=>(0, _encryptJs.GeneralEncrypt));
parcelHelpers.export(exports, "compactVerify", ()=>(0, _verifyJs.compactVerify));
parcelHelpers.export(exports, "flattenedVerify", ()=>(0, _verifyJs1.flattenedVerify));
parcelHelpers.export(exports, "generalVerify", ()=>(0, _verifyJs2.generalVerify));
parcelHelpers.export(exports, "jwtVerify", ()=>(0, _verifyJs3.jwtVerify));
parcelHelpers.export(exports, "jwtDecrypt", ()=>(0, _decryptJs3.jwtDecrypt));
parcelHelpers.export(exports, "CompactEncrypt", ()=>(0, _encryptJs1.CompactEncrypt));
parcelHelpers.export(exports, "FlattenedEncrypt", ()=>(0, _encryptJs2.FlattenedEncrypt));
parcelHelpers.export(exports, "CompactSign", ()=>(0, _signJs.CompactSign));
parcelHelpers.export(exports, "FlattenedSign", ()=>(0, _signJs1.FlattenedSign));
parcelHelpers.export(exports, "GeneralSign", ()=>(0, _signJs2.GeneralSign));
parcelHelpers.export(exports, "SignJWT", ()=>(0, _signJs3.SignJWT));
parcelHelpers.export(exports, "EncryptJWT", ()=>(0, _encryptJs3.EncryptJWT));
parcelHelpers.export(exports, "calculateJwkThumbprint", ()=>(0, _thumbprintJs.calculateJwkThumbprint));
parcelHelpers.export(exports, "calculateJwkThumbprintUri", ()=>(0, _thumbprintJs.calculateJwkThumbprintUri));
parcelHelpers.export(exports, "EmbeddedJWK", ()=>(0, _embeddedJs.EmbeddedJWK));
parcelHelpers.export(exports, "createLocalJWKSet", ()=>(0, _localJs.createLocalJWKSet));
parcelHelpers.export(exports, "createRemoteJWKSet", ()=>(0, _remoteJs.createRemoteJWKSet));
parcelHelpers.export(exports, "UnsecuredJWT", ()=>(0, _unsecuredJs.UnsecuredJWT));
parcelHelpers.export(exports, "exportPKCS8", ()=>(0, _exportJs.exportPKCS8));
parcelHelpers.export(exports, "exportSPKI", ()=>(0, _exportJs.exportSPKI));
parcelHelpers.export(exports, "exportJWK", ()=>(0, _exportJs.exportJWK));
parcelHelpers.export(exports, "importSPKI", ()=>(0, _importJs.importSPKI));
parcelHelpers.export(exports, "importPKCS8", ()=>(0, _importJs.importPKCS8));
parcelHelpers.export(exports, "importX509", ()=>(0, _importJs.importX509));
parcelHelpers.export(exports, "importJWK", ()=>(0, _importJs.importJWK));
parcelHelpers.export(exports, "decodeProtectedHeader", ()=>(0, _decodeProtectedHeaderJs.decodeProtectedHeader));
parcelHelpers.export(exports, "decodeJwt", ()=>(0, _decodeJwtJs.decodeJwt));
parcelHelpers.export(exports, "generateKeyPair", ()=>(0, _generateKeyPairJs.generateKeyPair));
parcelHelpers.export(exports, "generateSecret", ()=>(0, _generateSecretJs.generateSecret));
parcelHelpers.export(exports, "cryptoRuntime", ()=>(0, _runtimeJsDefault.default));
parcelHelpers.export(exports, "errors", ()=>_errorsJs);
parcelHelpers.export(exports, "base64url", ()=>_base64UrlJs);
var _decryptJs = require("./jwe/compact/decrypt.js");
var _decryptJs1 = require("./jwe/flattened/decrypt.js");
var _decryptJs2 = require("./jwe/general/decrypt.js");
var _encryptJs = require("./jwe/general/encrypt.js");
var _verifyJs = require("./jws/compact/verify.js");
var _verifyJs1 = require("./jws/flattened/verify.js");
var _verifyJs2 = require("./jws/general/verify.js");
var _verifyJs3 = require("./jwt/verify.js");
var _decryptJs3 = require("./jwt/decrypt.js");
var _encryptJs1 = require("./jwe/compact/encrypt.js");
var _encryptJs2 = require("./jwe/flattened/encrypt.js");
var _signJs = require("./jws/compact/sign.js");
var _signJs1 = require("./jws/flattened/sign.js");
var _signJs2 = require("./jws/general/sign.js");
var _signJs3 = require("./jwt/sign.js");
var _encryptJs3 = require("./jwt/encrypt.js");
var _thumbprintJs = require("./jwk/thumbprint.js");
var _embeddedJs = require("./jwk/embedded.js");
var _localJs = require("./jwks/local.js");
var _remoteJs = require("./jwks/remote.js");
var _unsecuredJs = require("./jwt/unsecured.js");
var _exportJs = require("./key/export.js");
var _importJs = require("./key/import.js");
var _decodeProtectedHeaderJs = require("./util/decode_protected_header.js");
var _decodeJwtJs = require("./util/decode_jwt.js");
var _errorsJs = require("./util/errors.js");
var _generateKeyPairJs = require("./key/generate_key_pair.js");
var _generateSecretJs = require("./key/generate_secret.js");
var _base64UrlJs = require("./util/base64url.js");
var _runtimeJs = require("./util/runtime.js");
var _runtimeJsDefault = parcelHelpers.interopDefault(_runtimeJs);

},{"./jwe/compact/decrypt.js":"aRaar","./jwe/flattened/decrypt.js":"jGuls","./jwe/general/decrypt.js":"iYOzJ","./jwe/general/encrypt.js":"93WLj","./jws/compact/verify.js":"e1sJY","./jws/flattened/verify.js":"9kMwY","./jws/general/verify.js":"afsWj","./jwt/verify.js":"6mf3t","./jwt/decrypt.js":"zT60K","./jwe/compact/encrypt.js":"jV286","./jwe/flattened/encrypt.js":"46C8R","./jws/compact/sign.js":"h85r4","./jws/flattened/sign.js":"k3wVp","./jws/general/sign.js":"fdViL","./jwt/sign.js":"2xK9f","./jwt/encrypt.js":"jJPUI","./jwk/thumbprint.js":"1LCWm","./jwk/embedded.js":"8aDeU","./jwks/local.js":"jpAM0","./jwks/remote.js":"gnekA","./jwt/unsecured.js":"b7LxK","./key/export.js":"04SHK","./key/import.js":"gu3Vs","./util/decode_protected_header.js":"3o6CH","./util/decode_jwt.js":"jHDLT","./util/errors.js":"drZrx","./key/generate_key_pair.js":"9auQ1","./key/generate_secret.js":"glscP","./util/base64url.js":"414VB","./util/runtime.js":"fbS2R","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aRaar":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compactDecrypt", ()=>compactDecrypt);
var _decryptJs = require("../flattened/decrypt.js");
var _errorsJs = require("../../util/errors.js");
var _bufferUtilsJs = require("../../lib/buffer_utils.js");
async function compactDecrypt(jwe, key, options) {
    if (jwe instanceof Uint8Array) jwe = (0, _bufferUtilsJs.decoder).decode(jwe);
    if (typeof jwe !== 'string') throw new (0, _errorsJs.JWEInvalid)('Compact JWE must be a string or Uint8Array');
    const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length } = jwe.split('.');
    if (length !== 5) throw new (0, _errorsJs.JWEInvalid)('Invalid Compact JWE');
    const decrypted = await (0, _decryptJs.flattenedDecrypt)({
        ciphertext,
        iv: iv || undefined,
        protected: protectedHeader || undefined,
        tag: tag || undefined,
        encrypted_key: encryptedKey || undefined
    }, key, options);
    const result = {
        plaintext: decrypted.plaintext,
        protectedHeader: decrypted.protectedHeader
    };
    if (typeof key === 'function') return {
        ...result,
        key: decrypted.key
    };
    return result;
}

},{"../flattened/decrypt.js":"jGuls","../../util/errors.js":"drZrx","../../lib/buffer_utils.js":"6CiRi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jGuls":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flattenedDecrypt", ()=>flattenedDecrypt);
var _base64UrlJs = require("../../runtime/base64url.js");
var _decryptJs = require("../../runtime/decrypt.js");
var _decryptJsDefault = parcelHelpers.interopDefault(_decryptJs);
var _zlibJs = require("../../runtime/zlib.js");
var _errorsJs = require("../../util/errors.js");
var _isDisjointJs = require("../../lib/is_disjoint.js");
var _isDisjointJsDefault = parcelHelpers.interopDefault(_isDisjointJs);
var _isObjectJs = require("../../lib/is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _decryptKeyManagementJs = require("../../lib/decrypt_key_management.js");
var _decryptKeyManagementJsDefault = parcelHelpers.interopDefault(_decryptKeyManagementJs);
var _bufferUtilsJs = require("../../lib/buffer_utils.js");
var _cekJs = require("../../lib/cek.js");
var _cekJsDefault = parcelHelpers.interopDefault(_cekJs);
var _validateCritJs = require("../../lib/validate_crit.js");
var _validateCritJsDefault = parcelHelpers.interopDefault(_validateCritJs);
var _validateAlgorithmsJs = require("../../lib/validate_algorithms.js");
var _validateAlgorithmsJsDefault = parcelHelpers.interopDefault(_validateAlgorithmsJs);
async function flattenedDecrypt(jwe, key, options) {
    var _a;
    if (!(0, _isObjectJsDefault.default)(jwe)) throw new (0, _errorsJs.JWEInvalid)('Flattened JWE must be an object');
    if (jwe.protected === undefined && jwe.header === undefined && jwe.unprotected === undefined) throw new (0, _errorsJs.JWEInvalid)('JOSE Header missing');
    if (typeof jwe.iv !== 'string') throw new (0, _errorsJs.JWEInvalid)('JWE Initialization Vector missing or incorrect type');
    if (typeof jwe.ciphertext !== 'string') throw new (0, _errorsJs.JWEInvalid)('JWE Ciphertext missing or incorrect type');
    if (typeof jwe.tag !== 'string') throw new (0, _errorsJs.JWEInvalid)('JWE Authentication Tag missing or incorrect type');
    if (jwe.protected !== undefined && typeof jwe.protected !== 'string') throw new (0, _errorsJs.JWEInvalid)('JWE Protected Header incorrect type');
    if (jwe.encrypted_key !== undefined && typeof jwe.encrypted_key !== 'string') throw new (0, _errorsJs.JWEInvalid)('JWE Encrypted Key incorrect type');
    if (jwe.aad !== undefined && typeof jwe.aad !== 'string') throw new (0, _errorsJs.JWEInvalid)('JWE AAD incorrect type');
    if (jwe.header !== undefined && !(0, _isObjectJsDefault.default)(jwe.header)) throw new (0, _errorsJs.JWEInvalid)('JWE Shared Unprotected Header incorrect type');
    if (jwe.unprotected !== undefined && !(0, _isObjectJsDefault.default)(jwe.unprotected)) throw new (0, _errorsJs.JWEInvalid)('JWE Per-Recipient Unprotected Header incorrect type');
    let parsedProt;
    if (jwe.protected) try {
        const protectedHeader = (0, _base64UrlJs.decode)(jwe.protected);
        parsedProt = JSON.parse((0, _bufferUtilsJs.decoder).decode(protectedHeader));
    } catch (_b) {
        throw new (0, _errorsJs.JWEInvalid)('JWE Protected Header is invalid');
    }
    if (!(0, _isDisjointJsDefault.default)(parsedProt, jwe.header, jwe.unprotected)) throw new (0, _errorsJs.JWEInvalid)('JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint');
    const joseHeader = {
        ...parsedProt,
        ...jwe.header,
        ...jwe.unprotected
    };
    (0, _validateCritJsDefault.default)((0, _errorsJs.JWEInvalid), new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    if (joseHeader.zip !== undefined) {
        if (!parsedProt || !parsedProt.zip) throw new (0, _errorsJs.JWEInvalid)('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
        if (joseHeader.zip !== 'DEF') throw new (0, _errorsJs.JOSENotSupported)('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
    }
    const { alg, enc } = joseHeader;
    if (typeof alg !== 'string' || !alg) throw new (0, _errorsJs.JWEInvalid)('missing JWE Algorithm (alg) in JWE Header');
    if (typeof enc !== 'string' || !enc) throw new (0, _errorsJs.JWEInvalid)('missing JWE Encryption Algorithm (enc) in JWE Header');
    const keyManagementAlgorithms = options && (0, _validateAlgorithmsJsDefault.default)('keyManagementAlgorithms', options.keyManagementAlgorithms);
    const contentEncryptionAlgorithms = options && (0, _validateAlgorithmsJsDefault.default)('contentEncryptionAlgorithms', options.contentEncryptionAlgorithms);
    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) throw new (0, _errorsJs.JOSEAlgNotAllowed)('"alg" (Algorithm) Header Parameter not allowed');
    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) throw new (0, _errorsJs.JOSEAlgNotAllowed)('"enc" (Encryption Algorithm) Header Parameter not allowed');
    let encryptedKey;
    if (jwe.encrypted_key !== undefined) try {
        encryptedKey = (0, _base64UrlJs.decode)(jwe.encrypted_key);
    } catch (_c) {
        throw new (0, _errorsJs.JWEInvalid)('Failed to base64url decode the encrypted_key');
    }
    let resolvedKey = false;
    if (typeof key === 'function') {
        key = await key(parsedProt, jwe);
        resolvedKey = true;
    }
    let cek;
    try {
        cek = await (0, _decryptKeyManagementJsDefault.default)(alg, key, encryptedKey, joseHeader, options);
    } catch (err) {
        if (err instanceof TypeError || err instanceof (0, _errorsJs.JWEInvalid) || err instanceof (0, _errorsJs.JOSENotSupported)) throw err;
        cek = (0, _cekJsDefault.default)(enc);
    }
    let iv;
    let tag;
    try {
        iv = (0, _base64UrlJs.decode)(jwe.iv);
    } catch (_d) {
        throw new (0, _errorsJs.JWEInvalid)('Failed to base64url decode the iv');
    }
    try {
        tag = (0, _base64UrlJs.decode)(jwe.tag);
    } catch (_e) {
        throw new (0, _errorsJs.JWEInvalid)('Failed to base64url decode the tag');
    }
    const protectedHeader = (0, _bufferUtilsJs.encoder).encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : '');
    let additionalData;
    if (jwe.aad !== undefined) additionalData = (0, _bufferUtilsJs.concat)(protectedHeader, (0, _bufferUtilsJs.encoder).encode('.'), (0, _bufferUtilsJs.encoder).encode(jwe.aad));
    else additionalData = protectedHeader;
    let ciphertext;
    try {
        ciphertext = (0, _base64UrlJs.decode)(jwe.ciphertext);
    } catch (_f) {
        throw new (0, _errorsJs.JWEInvalid)('Failed to base64url decode the ciphertext');
    }
    let plaintext = await (0, _decryptJsDefault.default)(enc, cek, ciphertext, iv, tag, additionalData);
    if (joseHeader.zip === 'DEF') plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || (0, _zlibJs.inflate))(plaintext);
    const result = {
        plaintext
    };
    if (jwe.protected !== undefined) result.protectedHeader = parsedProt;
    if (jwe.aad !== undefined) try {
        result.additionalAuthenticatedData = (0, _base64UrlJs.decode)(jwe.aad);
    } catch (_g) {
        throw new (0, _errorsJs.JWEInvalid)('Failed to base64url decode the aad');
    }
    if (jwe.unprotected !== undefined) result.sharedUnprotectedHeader = jwe.unprotected;
    if (jwe.header !== undefined) result.unprotectedHeader = jwe.header;
    if (resolvedKey) return {
        ...result,
        key
    };
    return result;
}

},{"../../runtime/base64url.js":"hmfX7","../../runtime/decrypt.js":"80xlZ","../../runtime/zlib.js":"kghzC","../../util/errors.js":"drZrx","../../lib/is_disjoint.js":"8SDOv","../../lib/is_object.js":"6AeNj","../../lib/decrypt_key_management.js":"lvL7L","../../lib/buffer_utils.js":"6CiRi","../../lib/cek.js":"3wQoI","../../lib/validate_crit.js":"czux9","../../lib/validate_algorithms.js":"5vOPm","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hmfX7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encodeBase64", ()=>encodeBase64);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decodeBase64", ()=>decodeBase64);
parcelHelpers.export(exports, "decode", ()=>decode);
var _bufferUtilsJs = require("../lib/buffer_utils.js");
const encodeBase64 = (input)=>{
    let unencoded = input;
    if (typeof unencoded === 'string') unencoded = (0, _bufferUtilsJs.encoder).encode(unencoded);
    const CHUNK_SIZE = 0x8000;
    const arr = [];
    for(let i = 0; i < unencoded.length; i += CHUNK_SIZE)arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
    return btoa(arr.join(''));
};
const encode = (input)=>{
    return encodeBase64(input).replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
};
const decodeBase64 = (encoded)=>{
    const binary = atob(encoded);
    const bytes = new Uint8Array(binary.length);
    for(let i = 0; i < binary.length; i++)bytes[i] = binary.charCodeAt(i);
    return bytes;
};
const decode = (input)=>{
    let encoded = input;
    if (encoded instanceof Uint8Array) encoded = (0, _bufferUtilsJs.decoder).decode(encoded);
    encoded = encoded.replace(/-/g, '+').replace(/_/g, '/').replace(/\s/g, '');
    try {
        return decodeBase64(encoded);
    } catch (_a) {
        throw new TypeError('The input to be decoded is not correctly encoded.');
    }
};

},{"../lib/buffer_utils.js":"6CiRi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6CiRi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encoder", ()=>encoder);
parcelHelpers.export(exports, "decoder", ()=>decoder);
parcelHelpers.export(exports, "concat", ()=>concat);
parcelHelpers.export(exports, "p2s", ()=>p2s);
parcelHelpers.export(exports, "uint64be", ()=>uint64be);
parcelHelpers.export(exports, "uint32be", ()=>uint32be);
parcelHelpers.export(exports, "lengthAndInput", ()=>lengthAndInput);
parcelHelpers.export(exports, "concatKdf", ()=>concatKdf);
var _digestJs = require("../runtime/digest.js");
var _digestJsDefault = parcelHelpers.interopDefault(_digestJs);
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const MAX_INT32 = 2 ** 32;
function concat(...buffers) {
    const size = buffers.reduce((acc, { length })=>acc + length, 0);
    const buf = new Uint8Array(size);
    let i = 0;
    buffers.forEach((buffer)=>{
        buf.set(buffer, i);
        i += buffer.length;
    });
    return buf;
}
function p2s(alg, p2sInput) {
    return concat(encoder.encode(alg), new Uint8Array([
        0
    ]), p2sInput);
}
function writeUInt32BE(buf, value, offset) {
    if (value < 0 || value >= MAX_INT32) throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
    buf.set([
        value >>> 24,
        value >>> 16,
        value >>> 8,
        value & 0xff
    ], offset);
}
function uint64be(value) {
    const high = Math.floor(value / MAX_INT32);
    const low = value % MAX_INT32;
    const buf = new Uint8Array(8);
    writeUInt32BE(buf, high, 0);
    writeUInt32BE(buf, low, 4);
    return buf;
}
function uint32be(value) {
    const buf = new Uint8Array(4);
    writeUInt32BE(buf, value);
    return buf;
}
function lengthAndInput(input) {
    return concat(uint32be(input.length), input);
}
async function concatKdf(secret, bits, value) {
    const iterations = Math.ceil((bits >> 3) / 32);
    const res = new Uint8Array(iterations * 32);
    for(let iter = 0; iter < iterations; iter++){
        const buf = new Uint8Array(4 + secret.length + value.length);
        buf.set(uint32be(iter + 1));
        buf.set(secret, 4);
        buf.set(value, 4 + secret.length);
        res.set(await (0, _digestJsDefault.default)('sha256', buf), iter * 32);
    }
    return res.slice(0, bits >> 3);
}

},{"../runtime/digest.js":"fDsy9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fDsy9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
const digest = async (algorithm, data)=>{
    const subtleDigest = `SHA-${algorithm.slice(-3)}`;
    return new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.digest(subtleDigest, data));
};
exports.default = digest;

},{"./webcrypto.js":"crCKY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"crCKY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isCryptoKey", ()=>isCryptoKey);
exports.default = crypto;
const isCryptoKey = (key)=>key instanceof CryptoKey;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"80xlZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bufferUtilsJs = require("../lib/buffer_utils.js");
var _checkIvLengthJs = require("../lib/check_iv_length.js");
var _checkIvLengthJsDefault = parcelHelpers.interopDefault(_checkIvLengthJs);
var _checkCekLengthJs = require("./check_cek_length.js");
var _checkCekLengthJsDefault = parcelHelpers.interopDefault(_checkCekLengthJs);
var _timingSafeEqualJs = require("./timing_safe_equal.js");
var _timingSafeEqualJsDefault = parcelHelpers.interopDefault(_timingSafeEqualJs);
var _errorsJs = require("../util/errors.js");
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _cryptoKeyJs = require("../lib/crypto_key.js");
var _invalidKeyInputJs = require("../lib/invalid_key_input.js");
var _invalidKeyInputJsDefault = parcelHelpers.interopDefault(_invalidKeyInputJs);
var _isKeyLikeJs = require("./is_key_like.js");
async function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
    if (!(cek instanceof Uint8Array)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(cek, 'Uint8Array'));
    const keySize = parseInt(enc.slice(1, 4), 10);
    const encKey = await (0, _webcryptoJsDefault.default).subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, [
        'decrypt'
    ]);
    const macKey = await (0, _webcryptoJsDefault.default).subtle.importKey('raw', cek.subarray(0, keySize >> 3), {
        hash: `SHA-${keySize << 1}`,
        name: 'HMAC'
    }, false, [
        'sign'
    ]);
    const macData = (0, _bufferUtilsJs.concat)(aad, iv, ciphertext, (0, _bufferUtilsJs.uint64be)(aad.length << 3));
    const expectedTag = new Uint8Array((await (0, _webcryptoJsDefault.default).subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));
    let macCheckPassed;
    try {
        macCheckPassed = (0, _timingSafeEqualJsDefault.default)(tag, expectedTag);
    } catch (_a) {}
    if (!macCheckPassed) throw new (0, _errorsJs.JWEDecryptionFailed)();
    let plaintext;
    try {
        plaintext = new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.decrypt({
            iv,
            name: 'AES-CBC'
        }, encKey, ciphertext));
    } catch (_b) {}
    if (!plaintext) throw new (0, _errorsJs.JWEDecryptionFailed)();
    return plaintext;
}
async function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
    let encKey;
    if (cek instanceof Uint8Array) encKey = await (0, _webcryptoJsDefault.default).subtle.importKey('raw', cek, 'AES-GCM', false, [
        'decrypt'
    ]);
    else {
        (0, _cryptoKeyJs.checkEncCryptoKey)(cek, enc, 'decrypt');
        encKey = cek;
    }
    try {
        return new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.decrypt({
            additionalData: aad,
            iv,
            name: 'AES-GCM',
            tagLength: 128
        }, encKey, (0, _bufferUtilsJs.concat)(ciphertext, tag)));
    } catch (_a) {
        throw new (0, _errorsJs.JWEDecryptionFailed)();
    }
}
const decrypt = async (enc, cek, ciphertext, iv, tag, aad)=>{
    if (!(0, _webcryptoJs.isCryptoKey)(cek) && !(cek instanceof Uint8Array)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(cek, ...(0, _isKeyLikeJs.types), 'Uint8Array'));
    (0, _checkIvLengthJsDefault.default)(enc, iv);
    switch(enc){
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            if (cek instanceof Uint8Array) (0, _checkCekLengthJsDefault.default)(cek, parseInt(enc.slice(-3), 10));
            return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            if (cek instanceof Uint8Array) (0, _checkCekLengthJsDefault.default)(cek, parseInt(enc.slice(1, 4), 10));
            return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);
        default:
            throw new (0, _errorsJs.JOSENotSupported)('Unsupported JWE Content Encryption Algorithm');
    }
};
exports.default = decrypt;

},{"../lib/buffer_utils.js":"6CiRi","../lib/check_iv_length.js":"dubN1","./check_cek_length.js":"gAO1L","./timing_safe_equal.js":"948rw","../util/errors.js":"drZrx","./webcrypto.js":"crCKY","../lib/crypto_key.js":"547bG","../lib/invalid_key_input.js":"hHcMf","./is_key_like.js":"aRx6e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dubN1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _errorsJs = require("../util/errors.js");
var _ivJs = require("./iv.js");
const checkIvLength = (enc, iv)=>{
    if (iv.length << 3 !== (0, _ivJs.bitLength)(enc)) throw new (0, _errorsJs.JWEInvalid)('Invalid Initialization Vector length');
};
exports.default = checkIvLength;

},{"../util/errors.js":"drZrx","./iv.js":"7ae98","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"drZrx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JOSEError", ()=>JOSEError);
parcelHelpers.export(exports, "JWTClaimValidationFailed", ()=>JWTClaimValidationFailed);
parcelHelpers.export(exports, "JWTExpired", ()=>JWTExpired);
parcelHelpers.export(exports, "JOSEAlgNotAllowed", ()=>JOSEAlgNotAllowed);
parcelHelpers.export(exports, "JOSENotSupported", ()=>JOSENotSupported);
parcelHelpers.export(exports, "JWEDecryptionFailed", ()=>JWEDecryptionFailed);
parcelHelpers.export(exports, "JWEDecompressionFailed", ()=>JWEDecompressionFailed);
parcelHelpers.export(exports, "JWEInvalid", ()=>JWEInvalid);
parcelHelpers.export(exports, "JWSInvalid", ()=>JWSInvalid);
parcelHelpers.export(exports, "JWTInvalid", ()=>JWTInvalid);
parcelHelpers.export(exports, "JWKInvalid", ()=>JWKInvalid);
parcelHelpers.export(exports, "JWKSInvalid", ()=>JWKSInvalid);
parcelHelpers.export(exports, "JWKSNoMatchingKey", ()=>JWKSNoMatchingKey);
parcelHelpers.export(exports, "JWKSMultipleMatchingKeys", ()=>JWKSMultipleMatchingKeys);
parcelHelpers.export(exports, "JWKSTimeout", ()=>JWKSTimeout);
parcelHelpers.export(exports, "JWSSignatureVerificationFailed", ()=>JWSSignatureVerificationFailed);
class JOSEError extends Error {
    static get code() {
        return 'ERR_JOSE_GENERIC';
    }
    constructor(message){
        var _a;
        super(message);
        this.code = 'ERR_JOSE_GENERIC';
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 || _a.call(Error, this, this.constructor);
    }
}
class JWTClaimValidationFailed extends JOSEError {
    static get code() {
        return 'ERR_JWT_CLAIM_VALIDATION_FAILED';
    }
    constructor(message, claim = 'unspecified', reason = 'unspecified'){
        super(message);
        this.code = 'ERR_JWT_CLAIM_VALIDATION_FAILED';
        this.claim = claim;
        this.reason = reason;
    }
}
class JWTExpired extends JOSEError {
    static get code() {
        return 'ERR_JWT_EXPIRED';
    }
    constructor(message, claim = 'unspecified', reason = 'unspecified'){
        super(message);
        this.code = 'ERR_JWT_EXPIRED';
        this.claim = claim;
        this.reason = reason;
    }
}
class JOSEAlgNotAllowed extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JOSE_ALG_NOT_ALLOWED';
    }
    static get code() {
        return 'ERR_JOSE_ALG_NOT_ALLOWED';
    }
}
class JOSENotSupported extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JOSE_NOT_SUPPORTED';
    }
    static get code() {
        return 'ERR_JOSE_NOT_SUPPORTED';
    }
}
class JWEDecryptionFailed extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JWE_DECRYPTION_FAILED';
        this.message = 'decryption operation failed';
    }
    static get code() {
        return 'ERR_JWE_DECRYPTION_FAILED';
    }
}
class JWEDecompressionFailed extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JWE_DECOMPRESSION_FAILED';
        this.message = 'decompression operation failed';
    }
    static get code() {
        return 'ERR_JWE_DECOMPRESSION_FAILED';
    }
}
class JWEInvalid extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JWE_INVALID';
    }
    static get code() {
        return 'ERR_JWE_INVALID';
    }
}
class JWSInvalid extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JWS_INVALID';
    }
    static get code() {
        return 'ERR_JWS_INVALID';
    }
}
class JWTInvalid extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JWT_INVALID';
    }
    static get code() {
        return 'ERR_JWT_INVALID';
    }
}
class JWKInvalid extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JWK_INVALID';
    }
    static get code() {
        return 'ERR_JWK_INVALID';
    }
}
class JWKSInvalid extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JWKS_INVALID';
    }
    static get code() {
        return 'ERR_JWKS_INVALID';
    }
}
class JWKSNoMatchingKey extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JWKS_NO_MATCHING_KEY';
        this.message = 'no applicable key found in the JSON Web Key Set';
    }
    static get code() {
        return 'ERR_JWKS_NO_MATCHING_KEY';
    }
}
class JWKSMultipleMatchingKeys extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
        this.message = 'multiple matching keys found in the JSON Web Key Set';
    }
    static get code() {
        return 'ERR_JWKS_MULTIPLE_MATCHING_KEYS';
    }
}
Symbol.asyncIterator;
class JWKSTimeout extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JWKS_TIMEOUT';
        this.message = 'request timed out';
    }
    static get code() {
        return 'ERR_JWKS_TIMEOUT';
    }
}
class JWSSignatureVerificationFailed extends JOSEError {
    constructor(){
        super(...arguments);
        this.code = 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
        this.message = 'signature verification failed';
    }
    static get code() {
        return 'ERR_JWS_SIGNATURE_VERIFICATION_FAILED';
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7ae98":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bitLength", ()=>bitLength);
var _errorsJs = require("../util/errors.js");
var _randomJs = require("../runtime/random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
function bitLength(alg) {
    switch(alg){
        case 'A128GCM':
        case 'A128GCMKW':
        case 'A192GCM':
        case 'A192GCMKW':
        case 'A256GCM':
        case 'A256GCMKW':
            return 96;
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            return 128;
        default:
            throw new (0, _errorsJs.JOSENotSupported)(`Unsupported JWE Algorithm: ${alg}`);
    }
}
exports.default = (alg)=>(0, _randomJsDefault.default)(new Uint8Array(bitLength(alg) >> 3));

},{"../util/errors.js":"drZrx","../runtime/random.js":"2Msed","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2Msed":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
exports.default = (0, _webcryptoJsDefault.default).getRandomValues.bind((0, _webcryptoJsDefault.default));

},{"./webcrypto.js":"crCKY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gAO1L":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _errorsJs = require("../util/errors.js");
const checkCekLength = (cek, expected)=>{
    const actual = cek.byteLength << 3;
    if (actual !== expected) throw new (0, _errorsJs.JWEInvalid)(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
};
exports.default = checkCekLength;

},{"../util/errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"948rw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const timingSafeEqual = (a, b)=>{
    if (!(a instanceof Uint8Array)) throw new TypeError('First argument must be a buffer');
    if (!(b instanceof Uint8Array)) throw new TypeError('Second argument must be a buffer');
    if (a.length !== b.length) throw new TypeError('Input buffers must have the same length');
    const len = a.length;
    let out = 0;
    let i = -1;
    while(++i < len)out |= a[i] ^ b[i];
    return out === 0;
};
exports.default = timingSafeEqual;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"547bG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checkSigCryptoKey", ()=>checkSigCryptoKey);
parcelHelpers.export(exports, "checkEncCryptoKey", ()=>checkEncCryptoKey);
function unusable(name, prop = 'algorithm.name') {
    return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
    return algorithm.name === name;
}
function getHashLength(hash) {
    return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
    switch(alg){
        case 'ES256':
            return 'P-256';
        case 'ES384':
            return 'P-384';
        case 'ES512':
            return 'P-521';
        default:
            throw new Error('unreachable');
    }
}
function checkUsage(key, usages) {
    if (usages.length && !usages.some((expected)=>key.usages.includes(expected))) {
        let msg = 'CryptoKey does not support this operation, its usages must include ';
        if (usages.length > 2) {
            const last = usages.pop();
            msg += `one of ${usages.join(', ')}, or ${last}.`;
        } else if (usages.length === 2) msg += `one of ${usages[0]} or ${usages[1]}.`;
        else msg += `${usages[0]}.`;
        throw new TypeError(msg);
    }
}
function checkSigCryptoKey(key, alg, ...usages) {
    switch(alg){
        case 'HS256':
        case 'HS384':
        case 'HS512':
            {
                if (!isAlgorithm(key.algorithm, 'HMAC')) throw unusable('HMAC');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        case 'RS256':
        case 'RS384':
        case 'RS512':
            {
                if (!isAlgorithm(key.algorithm, 'RSASSA-PKCS1-v1_5')) throw unusable('RSASSA-PKCS1-v1_5');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        case 'PS256':
        case 'PS384':
        case 'PS512':
            {
                if (!isAlgorithm(key.algorithm, 'RSA-PSS')) throw unusable('RSA-PSS');
                const expected = parseInt(alg.slice(2), 10);
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        case 'EdDSA':
            if (key.algorithm.name !== 'Ed25519' && key.algorithm.name !== 'Ed448') throw unusable('Ed25519 or Ed448');
            break;
        case 'ES256':
        case 'ES384':
        case 'ES512':
            {
                if (!isAlgorithm(key.algorithm, 'ECDSA')) throw unusable('ECDSA');
                const expected = getNamedCurve(alg);
                const actual = key.algorithm.namedCurve;
                if (actual !== expected) throw unusable(expected, 'algorithm.namedCurve');
                break;
            }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}
function checkEncCryptoKey(key, alg, ...usages) {
    switch(alg){
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            {
                if (!isAlgorithm(key.algorithm, 'AES-GCM')) throw unusable('AES-GCM');
                const expected = parseInt(alg.slice(1, 4), 10);
                const actual = key.algorithm.length;
                if (actual !== expected) throw unusable(expected, 'algorithm.length');
                break;
            }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
            {
                if (!isAlgorithm(key.algorithm, 'AES-KW')) throw unusable('AES-KW');
                const expected = parseInt(alg.slice(1, 4), 10);
                const actual = key.algorithm.length;
                if (actual !== expected) throw unusable(expected, 'algorithm.length');
                break;
            }
        case 'ECDH':
            switch(key.algorithm.name){
                case 'ECDH':
                case 'X25519':
                case 'X448':
                    break;
                default:
                    throw unusable('ECDH, X25519, or X448');
            }
            break;
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW':
            if (!isAlgorithm(key.algorithm, 'PBKDF2')) throw unusable('PBKDF2');
            break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            {
                if (!isAlgorithm(key.algorithm, 'RSA-OAEP')) throw unusable('RSA-OAEP');
                const expected = parseInt(alg.slice(9), 10) || 1;
                const actual = getHashLength(key.algorithm.hash);
                if (actual !== expected) throw unusable(`SHA-${expected}`, 'algorithm.hash');
                break;
            }
        default:
            throw new TypeError('CryptoKey does not support this operation');
    }
    checkUsage(key, usages);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hHcMf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "withAlg", ()=>withAlg);
function message(msg, actual, ...types) {
    if (types.length > 2) {
        const last = types.pop();
        msg += `one of type ${types.join(', ')}, or ${last}.`;
    } else if (types.length === 2) msg += `one of type ${types[0]} or ${types[1]}.`;
    else msg += `of type ${types[0]}.`;
    if (actual == null) msg += ` Received ${actual}`;
    else if (typeof actual === 'function' && actual.name) msg += ` Received function ${actual.name}`;
    else if (typeof actual === 'object' && actual != null) {
        if (actual.constructor && actual.constructor.name) msg += ` Received an instance of ${actual.constructor.name}`;
    }
    return msg;
}
exports.default = (actual, ...types)=>{
    return message('Key must be ', actual, ...types);
};
function withAlg(alg, actual, ...types) {
    return message(`Key for the ${alg} algorithm must be `, actual, ...types);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aRx6e":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "types", ()=>types);
var _webcryptoJs = require("./webcrypto.js");
exports.default = (key)=>{
    return (0, _webcryptoJs.isCryptoKey)(key);
};
const types = [
    'CryptoKey'
];

},{"./webcrypto.js":"crCKY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kghzC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "inflate", ()=>inflate);
parcelHelpers.export(exports, "deflate", ()=>deflate);
var _errorsJs = require("../util/errors.js");
const inflate = async ()=>{
    throw new (0, _errorsJs.JOSENotSupported)('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.');
};
const deflate = async ()=>{
    throw new (0, _errorsJs.JOSENotSupported)('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.');
};

},{"../util/errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8SDOv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const isDisjoint = (...headers)=>{
    const sources = headers.filter(Boolean);
    if (sources.length === 0 || sources.length === 1) return true;
    let acc;
    for (const header of sources){
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
            acc = new Set(parameters);
            continue;
        }
        for (const parameter of parameters){
            if (acc.has(parameter)) return false;
            acc.add(parameter);
        }
    }
    return true;
};
exports.default = isDisjoint;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6AeNj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>isObject);
function isObjectLike(value) {
    return typeof value === 'object' && value !== null;
}
function isObject(input) {
    if (!isObjectLike(input) || Object.prototype.toString.call(input) !== '[object Object]') return false;
    if (Object.getPrototypeOf(input) === null) return true;
    let proto = input;
    while(Object.getPrototypeOf(proto) !== null)proto = Object.getPrototypeOf(proto);
    return Object.getPrototypeOf(input) === proto;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lvL7L":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _aeskwJs = require("../runtime/aeskw.js");
var _ecdhesJs = require("../runtime/ecdhes.js");
var _pbes2KwJs = require("../runtime/pbes2kw.js");
var _rsaesJs = require("../runtime/rsaes.js");
var _base64UrlJs = require("../runtime/base64url.js");
var _errorsJs = require("../util/errors.js");
var _cekJs = require("../lib/cek.js");
var _importJs = require("../key/import.js");
var _checkKeyTypeJs = require("./check_key_type.js");
var _checkKeyTypeJsDefault = parcelHelpers.interopDefault(_checkKeyTypeJs);
var _isObjectJs = require("./is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _aesgcmkwJs = require("./aesgcmkw.js");
async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
    (0, _checkKeyTypeJsDefault.default)(alg, key, 'decrypt');
    switch(alg){
        case 'dir':
            if (encryptedKey !== undefined) throw new (0, _errorsJs.JWEInvalid)('Encountered unexpected JWE Encrypted Key');
            return key;
        case 'ECDH-ES':
            if (encryptedKey !== undefined) throw new (0, _errorsJs.JWEInvalid)('Encountered unexpected JWE Encrypted Key');
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
            {
                if (!(0, _isObjectJsDefault.default)(joseHeader.epk)) throw new (0, _errorsJs.JWEInvalid)(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
                if (!_ecdhesJs.ecdhAllowed(key)) throw new (0, _errorsJs.JOSENotSupported)('ECDH with the provided key is not allowed or not supported by your javascript runtime');
                const epk = await (0, _importJs.importJWK)(joseHeader.epk, alg);
                let partyUInfo;
                let partyVInfo;
                if (joseHeader.apu !== undefined) {
                    if (typeof joseHeader.apu !== 'string') throw new (0, _errorsJs.JWEInvalid)(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
                    try {
                        partyUInfo = (0, _base64UrlJs.decode)(joseHeader.apu);
                    } catch (_a) {
                        throw new (0, _errorsJs.JWEInvalid)('Failed to base64url decode the apu');
                    }
                }
                if (joseHeader.apv !== undefined) {
                    if (typeof joseHeader.apv !== 'string') throw new (0, _errorsJs.JWEInvalid)(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
                    try {
                        partyVInfo = (0, _base64UrlJs.decode)(joseHeader.apv);
                    } catch (_b) {
                        throw new (0, _errorsJs.JWEInvalid)('Failed to base64url decode the apv');
                    }
                }
                const sharedSecret = await _ecdhesJs.deriveKey(epk, key, alg === 'ECDH-ES' ? joseHeader.enc : alg, alg === 'ECDH-ES' ? (0, _cekJs.bitLength)(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
                if (alg === 'ECDH-ES') return sharedSecret;
                if (encryptedKey === undefined) throw new (0, _errorsJs.JWEInvalid)('JWE Encrypted Key missing');
                return (0, _aeskwJs.unwrap)(alg.slice(-6), sharedSecret, encryptedKey);
            }
        case 'RSA1_5':
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            if (encryptedKey === undefined) throw new (0, _errorsJs.JWEInvalid)('JWE Encrypted Key missing');
            return (0, _rsaesJs.decrypt)(alg, key, encryptedKey);
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW':
            {
                if (encryptedKey === undefined) throw new (0, _errorsJs.JWEInvalid)('JWE Encrypted Key missing');
                if (typeof joseHeader.p2c !== 'number') throw new (0, _errorsJs.JWEInvalid)(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
                const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 10000;
                if (joseHeader.p2c > p2cLimit) throw new (0, _errorsJs.JWEInvalid)(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
                if (typeof joseHeader.p2s !== 'string') throw new (0, _errorsJs.JWEInvalid)(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
                let p2s;
                try {
                    p2s = (0, _base64UrlJs.decode)(joseHeader.p2s);
                } catch (_c) {
                    throw new (0, _errorsJs.JWEInvalid)('Failed to base64url decode the p2s');
                }
                return (0, _pbes2KwJs.decrypt)(alg, key, encryptedKey, joseHeader.p2c, p2s);
            }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
            if (encryptedKey === undefined) throw new (0, _errorsJs.JWEInvalid)('JWE Encrypted Key missing');
            return (0, _aeskwJs.unwrap)(alg, key, encryptedKey);
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW':
            {
                if (encryptedKey === undefined) throw new (0, _errorsJs.JWEInvalid)('JWE Encrypted Key missing');
                if (typeof joseHeader.iv !== 'string') throw new (0, _errorsJs.JWEInvalid)(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
                if (typeof joseHeader.tag !== 'string') throw new (0, _errorsJs.JWEInvalid)(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
                let iv;
                try {
                    iv = (0, _base64UrlJs.decode)(joseHeader.iv);
                } catch (_d) {
                    throw new (0, _errorsJs.JWEInvalid)('Failed to base64url decode the iv');
                }
                let tag;
                try {
                    tag = (0, _base64UrlJs.decode)(joseHeader.tag);
                } catch (_e) {
                    throw new (0, _errorsJs.JWEInvalid)('Failed to base64url decode the tag');
                }
                return (0, _aesgcmkwJs.unwrap)(alg, key, encryptedKey, iv, tag);
            }
        default:
            throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
}
exports.default = decryptKeyManagement;

},{"../runtime/aeskw.js":"iEW9A","../runtime/ecdhes.js":"9Kf4C","../runtime/pbes2kw.js":"2SPYY","../runtime/rsaes.js":"d5vYq","../runtime/base64url.js":"hmfX7","../util/errors.js":"drZrx","../lib/cek.js":"3wQoI","../key/import.js":"gu3Vs","./check_key_type.js":"kziQH","./is_object.js":"6AeNj","./aesgcmkw.js":"jiF4B","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iEW9A":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wrap", ()=>wrap);
parcelHelpers.export(exports, "unwrap", ()=>unwrap);
var _bogusJs = require("./bogus.js");
var _bogusJsDefault = parcelHelpers.interopDefault(_bogusJs);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _cryptoKeyJs = require("../lib/crypto_key.js");
var _invalidKeyInputJs = require("../lib/invalid_key_input.js");
var _invalidKeyInputJsDefault = parcelHelpers.interopDefault(_invalidKeyInputJs);
var _isKeyLikeJs = require("./is_key_like.js");
function checkKeySize(key, alg) {
    if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) throw new TypeError(`Invalid key size for alg: ${alg}`);
}
function getCryptoKey(key, alg, usage) {
    if ((0, _webcryptoJs.isCryptoKey)(key)) {
        (0, _cryptoKeyJs.checkEncCryptoKey)(key, alg, usage);
        return key;
    }
    if (key instanceof Uint8Array) return (0, _webcryptoJsDefault.default).subtle.importKey('raw', key, 'AES-KW', true, [
        usage
    ]);
    throw new TypeError((0, _invalidKeyInputJsDefault.default)(key, ...(0, _isKeyLikeJs.types), 'Uint8Array'));
}
const wrap = async (alg, key, cek)=>{
    const cryptoKey = await getCryptoKey(key, alg, 'wrapKey');
    checkKeySize(cryptoKey, alg);
    const cryptoKeyCek = await (0, _webcryptoJsDefault.default).subtle.importKey('raw', cek, ...(0, _bogusJsDefault.default));
    return new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.wrapKey('raw', cryptoKeyCek, cryptoKey, 'AES-KW'));
};
const unwrap = async (alg, key, encryptedKey)=>{
    const cryptoKey = await getCryptoKey(key, alg, 'unwrapKey');
    checkKeySize(cryptoKey, alg);
    const cryptoKeyCek = await (0, _webcryptoJsDefault.default).subtle.unwrapKey('raw', encryptedKey, cryptoKey, 'AES-KW', ...(0, _bogusJsDefault.default));
    return new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.exportKey('raw', cryptoKeyCek));
};

},{"./bogus.js":"ftBoP","./webcrypto.js":"crCKY","../lib/crypto_key.js":"547bG","../lib/invalid_key_input.js":"hHcMf","./is_key_like.js":"aRx6e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ftBoP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const bogusWebCrypto = [
    {
        hash: 'SHA-256',
        name: 'HMAC'
    },
    true,
    [
        'sign'
    ]
];
exports.default = bogusWebCrypto;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9Kf4C":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "deriveKey", ()=>deriveKey);
parcelHelpers.export(exports, "generateEpk", ()=>generateEpk);
parcelHelpers.export(exports, "ecdhAllowed", ()=>ecdhAllowed);
var _bufferUtilsJs = require("../lib/buffer_utils.js");
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _cryptoKeyJs = require("../lib/crypto_key.js");
var _invalidKeyInputJs = require("../lib/invalid_key_input.js");
var _invalidKeyInputJsDefault = parcelHelpers.interopDefault(_invalidKeyInputJs);
var _isKeyLikeJs = require("./is_key_like.js");
async function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
    if (!(0, _webcryptoJs.isCryptoKey)(publicKey)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(publicKey, ...(0, _isKeyLikeJs.types)));
    (0, _cryptoKeyJs.checkEncCryptoKey)(publicKey, 'ECDH');
    if (!(0, _webcryptoJs.isCryptoKey)(privateKey)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(privateKey, ...(0, _isKeyLikeJs.types)));
    (0, _cryptoKeyJs.checkEncCryptoKey)(privateKey, 'ECDH', 'deriveBits');
    const value = (0, _bufferUtilsJs.concat)((0, _bufferUtilsJs.lengthAndInput)((0, _bufferUtilsJs.encoder).encode(algorithm)), (0, _bufferUtilsJs.lengthAndInput)(apu), (0, _bufferUtilsJs.lengthAndInput)(apv), (0, _bufferUtilsJs.uint32be)(keyLength));
    let length;
    if (publicKey.algorithm.name === 'X25519') length = 256;
    else if (publicKey.algorithm.name === 'X448') length = 448;
    else length = Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3;
    const sharedSecret = new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.deriveBits({
        name: publicKey.algorithm.name,
        public: publicKey
    }, privateKey, length));
    return (0, _bufferUtilsJs.concatKdf)(sharedSecret, keyLength, value);
}
async function generateEpk(key) {
    if (!(0, _webcryptoJs.isCryptoKey)(key)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(key, ...(0, _isKeyLikeJs.types)));
    return (0, _webcryptoJsDefault.default).subtle.generateKey(key.algorithm, true, [
        'deriveBits'
    ]);
}
function ecdhAllowed(key) {
    if (!(0, _webcryptoJs.isCryptoKey)(key)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(key, ...(0, _isKeyLikeJs.types)));
    return [
        'P-256',
        'P-384',
        'P-521'
    ].includes(key.algorithm.namedCurve) || key.algorithm.name === 'X25519' || key.algorithm.name === 'X448';
}

},{"../lib/buffer_utils.js":"6CiRi","./webcrypto.js":"crCKY","../lib/crypto_key.js":"547bG","../lib/invalid_key_input.js":"hHcMf","./is_key_like.js":"aRx6e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2SPYY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encrypt", ()=>encrypt);
parcelHelpers.export(exports, "decrypt", ()=>decrypt);
var _randomJs = require("./random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
var _bufferUtilsJs = require("../lib/buffer_utils.js");
var _base64UrlJs = require("./base64url.js");
var _aeskwJs = require("./aeskw.js");
var _checkP2SJs = require("../lib/check_p2s.js");
var _checkP2SJsDefault = parcelHelpers.interopDefault(_checkP2SJs);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _cryptoKeyJs = require("../lib/crypto_key.js");
var _invalidKeyInputJs = require("../lib/invalid_key_input.js");
var _invalidKeyInputJsDefault = parcelHelpers.interopDefault(_invalidKeyInputJs);
var _isKeyLikeJs = require("./is_key_like.js");
function getCryptoKey(key, alg) {
    if (key instanceof Uint8Array) return (0, _webcryptoJsDefault.default).subtle.importKey('raw', key, 'PBKDF2', false, [
        'deriveBits'
    ]);
    if ((0, _webcryptoJs.isCryptoKey)(key)) {
        (0, _cryptoKeyJs.checkEncCryptoKey)(key, alg, 'deriveBits', 'deriveKey');
        return key;
    }
    throw new TypeError((0, _invalidKeyInputJsDefault.default)(key, ...(0, _isKeyLikeJs.types), 'Uint8Array'));
}
async function deriveKey(p2s, alg, p2c, key) {
    (0, _checkP2SJsDefault.default)(p2s);
    const salt = (0, _bufferUtilsJs.p2s)(alg, p2s);
    const keylen = parseInt(alg.slice(13, 16), 10);
    const subtleAlg = {
        hash: `SHA-${alg.slice(8, 11)}`,
        iterations: p2c,
        name: 'PBKDF2',
        salt
    };
    const wrapAlg = {
        length: keylen,
        name: 'AES-KW'
    };
    const cryptoKey = await getCryptoKey(key, alg);
    if (cryptoKey.usages.includes('deriveBits')) return new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.deriveBits(subtleAlg, cryptoKey, keylen));
    if (cryptoKey.usages.includes('deriveKey')) return (0, _webcryptoJsDefault.default).subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, [
        'wrapKey',
        'unwrapKey'
    ]);
    throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');
}
const encrypt = async (alg, key, cek, p2c = 2048, p2s = (0, _randomJsDefault.default)(new Uint8Array(16)))=>{
    const derived = await deriveKey(p2s, alg, p2c, key);
    const encryptedKey = await (0, _aeskwJs.wrap)(alg.slice(-6), derived, cek);
    return {
        encryptedKey,
        p2c,
        p2s: (0, _base64UrlJs.encode)(p2s)
    };
};
const decrypt = async (alg, key, encryptedKey, p2c, p2s)=>{
    const derived = await deriveKey(p2s, alg, p2c, key);
    return (0, _aeskwJs.unwrap)(alg.slice(-6), derived, encryptedKey);
};

},{"./random.js":"2Msed","../lib/buffer_utils.js":"6CiRi","./base64url.js":"hmfX7","./aeskw.js":"iEW9A","../lib/check_p2s.js":"jkgIv","./webcrypto.js":"crCKY","../lib/crypto_key.js":"547bG","../lib/invalid_key_input.js":"hHcMf","./is_key_like.js":"aRx6e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jkgIv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>checkP2s);
var _errorsJs = require("../util/errors.js");
function checkP2s(p2s) {
    if (!(p2s instanceof Uint8Array) || p2s.length < 8) throw new (0, _errorsJs.JWEInvalid)('PBES2 Salt Input must be 8 or more octets');
}

},{"../util/errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"d5vYq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encrypt", ()=>encrypt);
parcelHelpers.export(exports, "decrypt", ()=>decrypt);
var _subtleRsaesJs = require("./subtle_rsaes.js");
var _subtleRsaesJsDefault = parcelHelpers.interopDefault(_subtleRsaesJs);
var _bogusJs = require("./bogus.js");
var _bogusJsDefault = parcelHelpers.interopDefault(_bogusJs);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _cryptoKeyJs = require("../lib/crypto_key.js");
var _checkKeyLengthJs = require("./check_key_length.js");
var _checkKeyLengthJsDefault = parcelHelpers.interopDefault(_checkKeyLengthJs);
var _invalidKeyInputJs = require("../lib/invalid_key_input.js");
var _invalidKeyInputJsDefault = parcelHelpers.interopDefault(_invalidKeyInputJs);
var _isKeyLikeJs = require("./is_key_like.js");
const encrypt = async (alg, key, cek)=>{
    if (!(0, _webcryptoJs.isCryptoKey)(key)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(key, ...(0, _isKeyLikeJs.types)));
    (0, _cryptoKeyJs.checkEncCryptoKey)(key, alg, 'encrypt', 'wrapKey');
    (0, _checkKeyLengthJsDefault.default)(alg, key);
    if (key.usages.includes('encrypt')) return new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.encrypt((0, _subtleRsaesJsDefault.default)(alg), key, cek));
    if (key.usages.includes('wrapKey')) {
        const cryptoKeyCek = await (0, _webcryptoJsDefault.default).subtle.importKey('raw', cek, ...(0, _bogusJsDefault.default));
        return new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.wrapKey('raw', cryptoKeyCek, key, (0, _subtleRsaesJsDefault.default)(alg)));
    }
    throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation');
};
const decrypt = async (alg, key, encryptedKey)=>{
    if (!(0, _webcryptoJs.isCryptoKey)(key)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(key, ...(0, _isKeyLikeJs.types)));
    (0, _cryptoKeyJs.checkEncCryptoKey)(key, alg, 'decrypt', 'unwrapKey');
    (0, _checkKeyLengthJsDefault.default)(alg, key);
    if (key.usages.includes('decrypt')) return new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.decrypt((0, _subtleRsaesJsDefault.default)(alg), key, encryptedKey));
    if (key.usages.includes('unwrapKey')) {
        const cryptoKeyCek = await (0, _webcryptoJsDefault.default).subtle.unwrapKey('raw', encryptedKey, key, (0, _subtleRsaesJsDefault.default)(alg), ...(0, _bogusJsDefault.default));
        return new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.exportKey('raw', cryptoKeyCek));
    }
    throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation');
};

},{"./subtle_rsaes.js":"ao8Zf","./bogus.js":"ftBoP","./webcrypto.js":"crCKY","../lib/crypto_key.js":"547bG","./check_key_length.js":"5tUbx","../lib/invalid_key_input.js":"hHcMf","./is_key_like.js":"aRx6e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ao8Zf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>subtleRsaEs);
var _errorsJs = require("../util/errors.js");
function subtleRsaEs(alg) {
    switch(alg){
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            return 'RSA-OAEP';
        default:
            throw new (0, _errorsJs.JOSENotSupported)(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

},{"../util/errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5tUbx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = (alg, key)=>{
    if (alg.startsWith('RS') || alg.startsWith('PS')) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== 'number' || modulusLength < 2048) throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3wQoI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bitLength", ()=>bitLength);
var _errorsJs = require("../util/errors.js");
var _randomJs = require("../runtime/random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
function bitLength(alg) {
    switch(alg){
        case 'A128GCM':
            return 128;
        case 'A192GCM':
            return 192;
        case 'A256GCM':
        case 'A128CBC-HS256':
            return 256;
        case 'A192CBC-HS384':
            return 384;
        case 'A256CBC-HS512':
            return 512;
        default:
            throw new (0, _errorsJs.JOSENotSupported)(`Unsupported JWE Algorithm: ${alg}`);
    }
}
exports.default = (alg)=>(0, _randomJsDefault.default)(new Uint8Array(bitLength(alg) >> 3));

},{"../util/errors.js":"drZrx","../runtime/random.js":"2Msed","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gu3Vs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "importSPKI", ()=>importSPKI);
parcelHelpers.export(exports, "importX509", ()=>importX509);
parcelHelpers.export(exports, "importPKCS8", ()=>importPKCS8);
parcelHelpers.export(exports, "importJWK", ()=>importJWK);
var _base64UrlJs = require("../runtime/base64url.js");
var _asn1Js = require("../runtime/asn1.js");
var _jwkToKeyJs = require("../runtime/jwk_to_key.js");
var _jwkToKeyJsDefault = parcelHelpers.interopDefault(_jwkToKeyJs);
var _errorsJs = require("../util/errors.js");
var _isObjectJs = require("../lib/is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
async function importSPKI(spki, alg, options) {
    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) throw new TypeError('"spki" must be SPKI formatted string');
    return (0, _asn1Js.fromSPKI)(spki, alg, options);
}
async function importX509(x509, alg, options) {
    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) throw new TypeError('"x509" must be X.509 formatted string');
    return (0, _asn1Js.fromX509)(x509, alg, options);
}
async function importPKCS8(pkcs8, alg, options) {
    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
    return (0, _asn1Js.fromPKCS8)(pkcs8, alg, options);
}
async function importJWK(jwk, alg, octAsKeyObject) {
    var _a;
    if (!(0, _isObjectJsDefault.default)(jwk)) throw new TypeError('JWK must be an object');
    alg || (alg = jwk.alg);
    switch(jwk.kty){
        case 'oct':
            if (typeof jwk.k !== 'string' || !jwk.k) throw new TypeError('missing "k" (Key Value) Parameter value');
            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
            if (octAsKeyObject) return (0, _jwkToKeyJsDefault.default)({
                ...jwk,
                alg,
                ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false
            });
            return (0, _base64UrlJs.decode)(jwk.k);
        case 'RSA':
            if (jwk.oth !== undefined) throw new (0, _errorsJs.JOSENotSupported)('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
        case 'EC':
        case 'OKP':
            return (0, _jwkToKeyJsDefault.default)({
                ...jwk,
                alg
            });
        default:
            throw new (0, _errorsJs.JOSENotSupported)('Unsupported "kty" (Key Type) Parameter value');
    }
}

},{"../runtime/base64url.js":"hmfX7","../runtime/asn1.js":"2EEbo","../runtime/jwk_to_key.js":"a41gV","../util/errors.js":"drZrx","../lib/is_object.js":"6AeNj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2EEbo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toSPKI", ()=>toSPKI);
parcelHelpers.export(exports, "toPKCS8", ()=>toPKCS8);
parcelHelpers.export(exports, "fromPKCS8", ()=>fromPKCS8);
parcelHelpers.export(exports, "fromSPKI", ()=>fromSPKI);
parcelHelpers.export(exports, "fromX509", ()=>fromX509);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _invalidKeyInputJs = require("../lib/invalid_key_input.js");
var _invalidKeyInputJsDefault = parcelHelpers.interopDefault(_invalidKeyInputJs);
var _base64UrlJs = require("./base64url.js");
var _formatPemJs = require("../lib/format_pem.js");
var _formatPemJsDefault = parcelHelpers.interopDefault(_formatPemJs);
var _errorsJs = require("../util/errors.js");
var _isKeyLikeJs = require("./is_key_like.js");
const genericExport = async (keyType, keyFormat, key)=>{
    if (!(0, _webcryptoJs.isCryptoKey)(key)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(key, ...(0, _isKeyLikeJs.types)));
    if (!key.extractable) throw new TypeError('CryptoKey is not extractable');
    if (key.type !== keyType) throw new TypeError(`key is not a ${keyType} key`);
    return (0, _formatPemJsDefault.default)((0, _base64UrlJs.encodeBase64)(new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);
};
const toSPKI = (key)=>{
    return genericExport('public', 'spki', key);
};
const toPKCS8 = (key)=>{
    return genericExport('private', 'pkcs8', key);
};
const findOid = (keyData, oid, from = 0)=>{
    if (from === 0) {
        oid.unshift(oid.length);
        oid.unshift(0x06);
    }
    let i = keyData.indexOf(oid[0], from);
    if (i === -1) return false;
    const sub = keyData.subarray(i, i + oid.length);
    if (sub.length !== oid.length) return false;
    return sub.every((value, index)=>value === oid[index]) || findOid(keyData, oid, i + 1);
};
const getNamedCurve = (keyData)=>{
    switch(true){
        case findOid(keyData, [
            0x2a,
            0x86,
            0x48,
            0xce,
            0x3d,
            0x03,
            0x01,
            0x07
        ]):
            return 'P-256';
        case findOid(keyData, [
            0x2b,
            0x81,
            0x04,
            0x00,
            0x22
        ]):
            return 'P-384';
        case findOid(keyData, [
            0x2b,
            0x81,
            0x04,
            0x00,
            0x23
        ]):
            return 'P-521';
        case findOid(keyData, [
            0x2b,
            0x65,
            0x6e
        ]):
            return 'X25519';
        case findOid(keyData, [
            0x2b,
            0x65,
            0x6f
        ]):
            return 'X448';
        case findOid(keyData, [
            0x2b,
            0x65,
            0x70
        ]):
            return 'Ed25519';
        case findOid(keyData, [
            0x2b,
            0x65,
            0x71
        ]):
            return 'Ed448';
        default:
            throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported EC Key Curve or OKP Key Sub Type');
    }
};
const genericImport = async (replace, keyFormat, pem, alg, options)=>{
    var _a;
    let algorithm;
    let keyUsages;
    const keyData = new Uint8Array(atob(pem.replace(replace, '')).split('').map((c)=>c.charCodeAt(0)));
    const isPublic = keyFormat === 'spki';
    switch(alg){
        case 'PS256':
        case 'PS384':
        case 'PS512':
            algorithm = {
                name: 'RSA-PSS',
                hash: `SHA-${alg.slice(-3)}`
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        case 'RS256':
        case 'RS384':
        case 'RS512':
            algorithm = {
                name: 'RSASSA-PKCS1-v1_5',
                hash: `SHA-${alg.slice(-3)}`
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            algorithm = {
                name: 'RSA-OAEP',
                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
            };
            keyUsages = isPublic ? [
                'encrypt',
                'wrapKey'
            ] : [
                'decrypt',
                'unwrapKey'
            ];
            break;
        case 'ES256':
            algorithm = {
                name: 'ECDSA',
                namedCurve: 'P-256'
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        case 'ES384':
            algorithm = {
                name: 'ECDSA',
                namedCurve: 'P-384'
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        case 'ES512':
            algorithm = {
                name: 'ECDSA',
                namedCurve: 'P-521'
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
            {
                const namedCurve = getNamedCurve(keyData);
                algorithm = namedCurve.startsWith('P-') ? {
                    name: 'ECDH',
                    namedCurve
                } : {
                    name: namedCurve
                };
                keyUsages = isPublic ? [] : [
                    'deriveBits'
                ];
                break;
            }
        case 'EdDSA':
            algorithm = {
                name: getNamedCurve(keyData)
            };
            keyUsages = isPublic ? [
                'verify'
            ] : [
                'sign'
            ];
            break;
        default:
            throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported "alg" (Algorithm) value');
    }
    return (0, _webcryptoJsDefault.default).subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
};
const fromPKCS8 = (pem, alg, options)=>{
    return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, 'pkcs8', pem, alg, options);
};
const fromSPKI = (pem, alg, options)=>{
    return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, 'spki', pem, alg, options);
};
function getElement(seq) {
    let result = [];
    let next = 0;
    while(next < seq.length){
        let nextPart = parseElement(seq.subarray(next));
        result.push(nextPart);
        next += nextPart.byteLength;
    }
    return result;
}
function parseElement(bytes) {
    let position = 0;
    let tag = bytes[0] & 0x1f;
    position++;
    if (tag === 0x1f) {
        tag = 0;
        while(bytes[position] >= 0x80){
            tag = tag * 128 + bytes[position] - 0x80;
            position++;
        }
        tag = tag * 128 + bytes[position] - 0x80;
        position++;
    }
    let length = 0;
    if (bytes[position] < 0x80) {
        length = bytes[position];
        position++;
    } else if (length === 0x80) {
        length = 0;
        while(bytes[position + length] !== 0 || bytes[position + length + 1] !== 0){
            if (length > bytes.byteLength) throw new TypeError('invalid indefinite form length');
            length++;
        }
        const byteLength = position + length + 2;
        return {
            byteLength,
            contents: bytes.subarray(position, position + length),
            raw: bytes.subarray(0, byteLength)
        };
    } else {
        let numberOfDigits = bytes[position] & 0x7f;
        position++;
        length = 0;
        for(let i = 0; i < numberOfDigits; i++){
            length = length * 256 + bytes[position];
            position++;
        }
    }
    const byteLength = position + length;
    return {
        byteLength,
        contents: bytes.subarray(position, byteLength),
        raw: bytes.subarray(0, byteLength)
    };
}
function spkiFromX509(buf) {
    const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);
    return (0, _base64UrlJs.encodeBase64)(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);
}
function getSPKI(x509) {
    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, '');
    const raw = (0, _base64UrlJs.decodeBase64)(pem);
    return (0, _formatPemJsDefault.default)(spkiFromX509(raw), 'PUBLIC KEY');
}
const fromX509 = (pem, alg, options)=>{
    let spki;
    try {
        spki = getSPKI(pem);
    } catch (cause) {
        throw new TypeError('Failed to parse the X.509 certificate', {
            cause
        });
    }
    return fromSPKI(spki, alg, options);
};

},{"./webcrypto.js":"crCKY","../lib/invalid_key_input.js":"hHcMf","./base64url.js":"hmfX7","../lib/format_pem.js":"gWatt","../util/errors.js":"drZrx","./is_key_like.js":"aRx6e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gWatt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = (b64, descriptor)=>{
    const newlined = (b64.match(/.{1,64}/g) || []).join('\n');
    return `-----BEGIN ${descriptor}-----\n${newlined}\n-----END ${descriptor}-----`;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"a41gV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _errorsJs = require("../util/errors.js");
var _base64UrlJs = require("./base64url.js");
function subtleMapping(jwk) {
    let algorithm;
    let keyUsages;
    switch(jwk.kty){
        case 'oct':
            switch(jwk.alg){
                case 'HS256':
                case 'HS384':
                case 'HS512':
                    algorithm = {
                        name: 'HMAC',
                        hash: `SHA-${jwk.alg.slice(-3)}`
                    };
                    keyUsages = [
                        'sign',
                        'verify'
                    ];
                    break;
                case 'A128CBC-HS256':
                case 'A192CBC-HS384':
                case 'A256CBC-HS512':
                    throw new (0, _errorsJs.JOSENotSupported)(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
                case 'A128GCM':
                case 'A192GCM':
                case 'A256GCM':
                case 'A128GCMKW':
                case 'A192GCMKW':
                case 'A256GCMKW':
                    algorithm = {
                        name: 'AES-GCM'
                    };
                    keyUsages = [
                        'encrypt',
                        'decrypt'
                    ];
                    break;
                case 'A128KW':
                case 'A192KW':
                case 'A256KW':
                    algorithm = {
                        name: 'AES-KW'
                    };
                    keyUsages = [
                        'wrapKey',
                        'unwrapKey'
                    ];
                    break;
                case 'PBES2-HS256+A128KW':
                case 'PBES2-HS384+A192KW':
                case 'PBES2-HS512+A256KW':
                    algorithm = {
                        name: 'PBKDF2'
                    };
                    keyUsages = [
                        'deriveBits'
                    ];
                    break;
                default:
                    throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            break;
        case 'RSA':
            switch(jwk.alg){
                case 'PS256':
                case 'PS384':
                case 'PS512':
                    algorithm = {
                        name: 'RSA-PSS',
                        hash: `SHA-${jwk.alg.slice(-3)}`
                    };
                    keyUsages = jwk.d ? [
                        'sign'
                    ] : [
                        'verify'
                    ];
                    break;
                case 'RS256':
                case 'RS384':
                case 'RS512':
                    algorithm = {
                        name: 'RSASSA-PKCS1-v1_5',
                        hash: `SHA-${jwk.alg.slice(-3)}`
                    };
                    keyUsages = jwk.d ? [
                        'sign'
                    ] : [
                        'verify'
                    ];
                    break;
                case 'RSA-OAEP':
                case 'RSA-OAEP-256':
                case 'RSA-OAEP-384':
                case 'RSA-OAEP-512':
                    algorithm = {
                        name: 'RSA-OAEP',
                        hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
                    };
                    keyUsages = jwk.d ? [
                        'decrypt',
                        'unwrapKey'
                    ] : [
                        'encrypt',
                        'wrapKey'
                    ];
                    break;
                default:
                    throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            break;
        case 'EC':
            switch(jwk.alg){
                case 'ES256':
                    algorithm = {
                        name: 'ECDSA',
                        namedCurve: 'P-256'
                    };
                    keyUsages = jwk.d ? [
                        'sign'
                    ] : [
                        'verify'
                    ];
                    break;
                case 'ES384':
                    algorithm = {
                        name: 'ECDSA',
                        namedCurve: 'P-384'
                    };
                    keyUsages = jwk.d ? [
                        'sign'
                    ] : [
                        'verify'
                    ];
                    break;
                case 'ES512':
                    algorithm = {
                        name: 'ECDSA',
                        namedCurve: 'P-521'
                    };
                    keyUsages = jwk.d ? [
                        'sign'
                    ] : [
                        'verify'
                    ];
                    break;
                case 'ECDH-ES':
                case 'ECDH-ES+A128KW':
                case 'ECDH-ES+A192KW':
                case 'ECDH-ES+A256KW':
                    algorithm = {
                        name: 'ECDH',
                        namedCurve: jwk.crv
                    };
                    keyUsages = jwk.d ? [
                        'deriveBits'
                    ] : [];
                    break;
                default:
                    throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            break;
        case 'OKP':
            switch(jwk.alg){
                case 'EdDSA':
                    algorithm = {
                        name: jwk.crv
                    };
                    keyUsages = jwk.d ? [
                        'sign'
                    ] : [
                        'verify'
                    ];
                    break;
                case 'ECDH-ES':
                case 'ECDH-ES+A128KW':
                case 'ECDH-ES+A192KW':
                case 'ECDH-ES+A256KW':
                    algorithm = {
                        name: jwk.crv
                    };
                    keyUsages = jwk.d ? [
                        'deriveBits'
                    ] : [];
                    break;
                default:
                    throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
            }
            break;
        default:
            throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
    }
    return {
        algorithm,
        keyUsages
    };
}
const parse = async (jwk)=>{
    var _a, _b;
    if (!jwk.alg) throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
    const { algorithm, keyUsages } = subtleMapping(jwk);
    const rest = [
        algorithm,
        (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,
        (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages
    ];
    if (algorithm.name === 'PBKDF2') return (0, _webcryptoJsDefault.default).subtle.importKey('raw', (0, _base64UrlJs.decode)(jwk.k), ...rest);
    const keyData = {
        ...jwk
    };
    delete keyData.alg;
    delete keyData.use;
    return (0, _webcryptoJsDefault.default).subtle.importKey('jwk', keyData, ...rest);
};
exports.default = parse;

},{"./webcrypto.js":"crCKY","../util/errors.js":"drZrx","./base64url.js":"hmfX7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kziQH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _invalidKeyInputJs = require("./invalid_key_input.js");
var _isKeyLikeJs = require("../runtime/is_key_like.js");
var _isKeyLikeJsDefault = parcelHelpers.interopDefault(_isKeyLikeJs);
const symmetricTypeCheck = (alg, key)=>{
    if (key instanceof Uint8Array) return;
    if (!(0, _isKeyLikeJsDefault.default)(key)) throw new TypeError((0, _invalidKeyInputJs.withAlg)(alg, key, ...(0, _isKeyLikeJs.types), 'Uint8Array'));
    if (key.type !== 'secret') throw new TypeError(`${(0, _isKeyLikeJs.types).join(' or ')} instances for symmetric algorithms must be of type "secret"`);
};
const asymmetricTypeCheck = (alg, key, usage)=>{
    if (!(0, _isKeyLikeJsDefault.default)(key)) throw new TypeError((0, _invalidKeyInputJs.withAlg)(alg, key, ...(0, _isKeyLikeJs.types)));
    if (key.type === 'secret') throw new TypeError(`${(0, _isKeyLikeJs.types).join(' or ')} instances for asymmetric algorithms must not be of type "secret"`);
    if (usage === 'sign' && key.type === 'public') throw new TypeError(`${(0, _isKeyLikeJs.types).join(' or ')} instances for asymmetric algorithm signing must be of type "private"`);
    if (usage === 'decrypt' && key.type === 'public') throw new TypeError(`${(0, _isKeyLikeJs.types).join(' or ')} instances for asymmetric algorithm decryption must be of type "private"`);
    if (key.algorithm && usage === 'verify' && key.type === 'private') throw new TypeError(`${(0, _isKeyLikeJs.types).join(' or ')} instances for asymmetric algorithm verifying must be of type "public"`);
    if (key.algorithm && usage === 'encrypt' && key.type === 'private') throw new TypeError(`${(0, _isKeyLikeJs.types).join(' or ')} instances for asymmetric algorithm encryption must be of type "public"`);
};
const checkKeyType = (alg, key, usage)=>{
    const symmetric = alg.startsWith('HS') || alg === 'dir' || alg.startsWith('PBES2') || /^A\d{3}(?:GCM)?KW$/.test(alg);
    if (symmetric) symmetricTypeCheck(alg, key);
    else asymmetricTypeCheck(alg, key, usage);
};
exports.default = checkKeyType;

},{"./invalid_key_input.js":"hHcMf","../runtime/is_key_like.js":"aRx6e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jiF4B":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "wrap", ()=>wrap);
parcelHelpers.export(exports, "unwrap", ()=>unwrap);
var _encryptJs = require("../runtime/encrypt.js");
var _encryptJsDefault = parcelHelpers.interopDefault(_encryptJs);
var _decryptJs = require("../runtime/decrypt.js");
var _decryptJsDefault = parcelHelpers.interopDefault(_decryptJs);
var _ivJs = require("./iv.js");
var _ivJsDefault = parcelHelpers.interopDefault(_ivJs);
var _base64UrlJs = require("../runtime/base64url.js");
async function wrap(alg, key, cek, iv) {
    const jweAlgorithm = alg.slice(0, 7);
    iv || (iv = (0, _ivJsDefault.default)(jweAlgorithm));
    const { ciphertext: encryptedKey, tag } = await (0, _encryptJsDefault.default)(jweAlgorithm, cek, key, iv, new Uint8Array(0));
    return {
        encryptedKey,
        iv: (0, _base64UrlJs.encode)(iv),
        tag: (0, _base64UrlJs.encode)(tag)
    };
}
async function unwrap(alg, key, encryptedKey, iv, tag) {
    const jweAlgorithm = alg.slice(0, 7);
    return (0, _decryptJsDefault.default)(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
}

},{"../runtime/encrypt.js":"4qqfM","../runtime/decrypt.js":"80xlZ","./iv.js":"7ae98","../runtime/base64url.js":"hmfX7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4qqfM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _bufferUtilsJs = require("../lib/buffer_utils.js");
var _checkIvLengthJs = require("../lib/check_iv_length.js");
var _checkIvLengthJsDefault = parcelHelpers.interopDefault(_checkIvLengthJs);
var _checkCekLengthJs = require("./check_cek_length.js");
var _checkCekLengthJsDefault = parcelHelpers.interopDefault(_checkCekLengthJs);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _cryptoKeyJs = require("../lib/crypto_key.js");
var _invalidKeyInputJs = require("../lib/invalid_key_input.js");
var _invalidKeyInputJsDefault = parcelHelpers.interopDefault(_invalidKeyInputJs);
var _errorsJs = require("../util/errors.js");
var _isKeyLikeJs = require("./is_key_like.js");
async function cbcEncrypt(enc, plaintext, cek, iv, aad) {
    if (!(cek instanceof Uint8Array)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(cek, 'Uint8Array'));
    const keySize = parseInt(enc.slice(1, 4), 10);
    const encKey = await (0, _webcryptoJsDefault.default).subtle.importKey('raw', cek.subarray(keySize >> 3), 'AES-CBC', false, [
        'encrypt'
    ]);
    const macKey = await (0, _webcryptoJsDefault.default).subtle.importKey('raw', cek.subarray(0, keySize >> 3), {
        hash: `SHA-${keySize << 1}`,
        name: 'HMAC'
    }, false, [
        'sign'
    ]);
    const ciphertext = new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.encrypt({
        iv,
        name: 'AES-CBC'
    }, encKey, plaintext));
    const macData = (0, _bufferUtilsJs.concat)(aad, iv, ciphertext, (0, _bufferUtilsJs.uint64be)(aad.length << 3));
    const tag = new Uint8Array((await (0, _webcryptoJsDefault.default).subtle.sign('HMAC', macKey, macData)).slice(0, keySize >> 3));
    return {
        ciphertext,
        tag
    };
}
async function gcmEncrypt(enc, plaintext, cek, iv, aad) {
    let encKey;
    if (cek instanceof Uint8Array) encKey = await (0, _webcryptoJsDefault.default).subtle.importKey('raw', cek, 'AES-GCM', false, [
        'encrypt'
    ]);
    else {
        (0, _cryptoKeyJs.checkEncCryptoKey)(cek, enc, 'encrypt');
        encKey = cek;
    }
    const encrypted = new Uint8Array(await (0, _webcryptoJsDefault.default).subtle.encrypt({
        additionalData: aad,
        iv,
        name: 'AES-GCM',
        tagLength: 128
    }, encKey, plaintext));
    const tag = encrypted.slice(-16);
    const ciphertext = encrypted.slice(0, -16);
    return {
        ciphertext,
        tag
    };
}
const encrypt = async (enc, plaintext, cek, iv, aad)=>{
    if (!(0, _webcryptoJs.isCryptoKey)(cek) && !(cek instanceof Uint8Array)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(cek, ...(0, _isKeyLikeJs.types), 'Uint8Array'));
    (0, _checkIvLengthJsDefault.default)(enc, iv);
    switch(enc){
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            if (cek instanceof Uint8Array) (0, _checkCekLengthJsDefault.default)(cek, parseInt(enc.slice(-3), 10));
            return cbcEncrypt(enc, plaintext, cek, iv, aad);
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            if (cek instanceof Uint8Array) (0, _checkCekLengthJsDefault.default)(cek, parseInt(enc.slice(1, 4), 10));
            return gcmEncrypt(enc, plaintext, cek, iv, aad);
        default:
            throw new (0, _errorsJs.JOSENotSupported)('Unsupported JWE Content Encryption Algorithm');
    }
};
exports.default = encrypt;

},{"../lib/buffer_utils.js":"6CiRi","../lib/check_iv_length.js":"dubN1","./check_cek_length.js":"gAO1L","./webcrypto.js":"crCKY","../lib/crypto_key.js":"547bG","../lib/invalid_key_input.js":"hHcMf","../util/errors.js":"drZrx","./is_key_like.js":"aRx6e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"czux9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _errorsJs = require("../util/errors.js");
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
    if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
    if (!protectedHeader || protectedHeader.crit === undefined) return new Set();
    if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input)=>typeof input !== 'string' || input.length === 0)) throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
    let recognized;
    if (recognizedOption !== undefined) recognized = new Map([
        ...Object.entries(recognizedOption),
        ...recognizedDefault.entries()
    ]);
    else recognized = recognizedDefault;
    for (const parameter of protectedHeader.crit){
        if (!recognized.has(parameter)) throw new (0, _errorsJs.JOSENotSupported)(`Extension Header Parameter "${parameter}" is not recognized`);
        if (joseHeader[parameter] === undefined) throw new Err(`Extension Header Parameter "${parameter}" is missing`);
        else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
    return new Set(protectedHeader.crit);
}
exports.default = validateCrit;

},{"../util/errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5vOPm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const validateAlgorithms = (option, algorithms)=>{
    if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s)=>typeof s !== 'string'))) throw new TypeError(`"${option}" option must be an array of strings`);
    if (!algorithms) return undefined;
    return new Set(algorithms);
};
exports.default = validateAlgorithms;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iYOzJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "generalDecrypt", ()=>generalDecrypt);
var _decryptJs = require("../flattened/decrypt.js");
var _errorsJs = require("../../util/errors.js");
var _isObjectJs = require("../../lib/is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
async function generalDecrypt(jwe, key, options) {
    if (!(0, _isObjectJsDefault.default)(jwe)) throw new (0, _errorsJs.JWEInvalid)('General JWE must be an object');
    if (!Array.isArray(jwe.recipients) || !jwe.recipients.every((0, _isObjectJsDefault.default))) throw new (0, _errorsJs.JWEInvalid)('JWE Recipients missing or incorrect type');
    if (!jwe.recipients.length) throw new (0, _errorsJs.JWEInvalid)('JWE Recipients has no members');
    for (const recipient of jwe.recipients)try {
        return await (0, _decryptJs.flattenedDecrypt)({
            aad: jwe.aad,
            ciphertext: jwe.ciphertext,
            encrypted_key: recipient.encrypted_key,
            header: recipient.header,
            iv: jwe.iv,
            protected: jwe.protected,
            tag: jwe.tag,
            unprotected: jwe.unprotected
        }, key, options);
    } catch (_a) {}
    throw new (0, _errorsJs.JWEDecryptionFailed)();
}

},{"../flattened/decrypt.js":"jGuls","../../util/errors.js":"drZrx","../../lib/is_object.js":"6AeNj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"93WLj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GeneralEncrypt", ()=>GeneralEncrypt);
var _encryptJs = require("../flattened/encrypt.js");
var _errorsJs = require("../../util/errors.js");
var _cekJs = require("../../lib/cek.js");
var _cekJsDefault = parcelHelpers.interopDefault(_cekJs);
var _isDisjointJs = require("../../lib/is_disjoint.js");
var _isDisjointJsDefault = parcelHelpers.interopDefault(_isDisjointJs);
var _encryptKeyManagementJs = require("../../lib/encrypt_key_management.js");
var _encryptKeyManagementJsDefault = parcelHelpers.interopDefault(_encryptKeyManagementJs);
var _base64UrlJs = require("../../runtime/base64url.js");
var _validateCritJs = require("../../lib/validate_crit.js");
var _validateCritJsDefault = parcelHelpers.interopDefault(_validateCritJs);
class IndividualRecipient {
    constructor(enc, key, options){
        this.parent = enc;
        this.key = key;
        this.options = options;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) throw new TypeError('setUnprotectedHeader can only be called once');
        this.unprotectedHeader = unprotectedHeader;
        return this;
    }
    addRecipient(...args) {
        return this.parent.addRecipient(...args);
    }
    encrypt(...args) {
        return this.parent.encrypt(...args);
    }
    done() {
        return this.parent;
    }
}
class GeneralEncrypt {
    constructor(plaintext){
        this._recipients = [];
        this._plaintext = plaintext;
    }
    addRecipient(key, options) {
        const recipient = new IndividualRecipient(this, key, {
            crit: options === null || options === void 0 ? void 0 : options.crit
        });
        this._recipients.push(recipient);
        return recipient;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) throw new TypeError('setProtectedHeader can only be called once');
        this._protectedHeader = protectedHeader;
        return this;
    }
    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._unprotectedHeader) throw new TypeError('setSharedUnprotectedHeader can only be called once');
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
    }
    setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
    }
    async encrypt(options) {
        var _a, _b, _c;
        if (!this._recipients.length) throw new (0, _errorsJs.JWEInvalid)('at least one recipient must be added');
        options = {
            deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw
        };
        if (this._recipients.length === 1) {
            const [recipient] = this._recipients;
            const flattened = await new (0, _encryptJs.FlattenedEncrypt)(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, {
                ...recipient.options,
                ...options
            });
            let jwe = {
                ciphertext: flattened.ciphertext,
                iv: flattened.iv,
                recipients: [
                    {}
                ],
                tag: flattened.tag
            };
            if (flattened.aad) jwe.aad = flattened.aad;
            if (flattened.protected) jwe.protected = flattened.protected;
            if (flattened.unprotected) jwe.unprotected = flattened.unprotected;
            if (flattened.encrypted_key) jwe.recipients[0].encrypted_key = flattened.encrypted_key;
            if (flattened.header) jwe.recipients[0].header = flattened.header;
            return jwe;
        }
        let enc;
        for(let i = 0; i < this._recipients.length; i++){
            const recipient = this._recipients[i];
            if (!(0, _isDisjointJsDefault.default)(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) throw new (0, _errorsJs.JWEInvalid)('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');
            const joseHeader = {
                ...this._protectedHeader,
                ...this._unprotectedHeader,
                ...recipient.unprotectedHeader
            };
            const { alg } = joseHeader;
            if (typeof alg !== 'string' || !alg) throw new (0, _errorsJs.JWEInvalid)('JWE "alg" (Algorithm) Header Parameter missing or invalid');
            if (alg === 'dir' || alg === 'ECDH-ES') throw new (0, _errorsJs.JWEInvalid)('"dir" and "ECDH-ES" alg may only be used with a single recipient');
            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) throw new (0, _errorsJs.JWEInvalid)('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
            if (!enc) enc = joseHeader.enc;
            else if (enc !== joseHeader.enc) throw new (0, _errorsJs.JWEInvalid)('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
            (0, _validateCritJsDefault.default)((0, _errorsJs.JWEInvalid), new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
            if (joseHeader.zip !== undefined) {
                if (!this._protectedHeader || !this._protectedHeader.zip) throw new (0, _errorsJs.JWEInvalid)('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
        }
        const cek = (0, _cekJsDefault.default)(enc);
        let jwe = {
            ciphertext: '',
            iv: '',
            recipients: [],
            tag: ''
        };
        for(let i = 0; i < this._recipients.length; i++){
            const recipient = this._recipients[i];
            const target = {};
            jwe.recipients.push(target);
            const joseHeader = {
                ...this._protectedHeader,
                ...this._unprotectedHeader,
                ...recipient.unprotectedHeader
            };
            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;
            if (i === 0) {
                const flattened = await new (0, _encryptJs.FlattenedEncrypt)(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({
                    p2c
                }).encrypt(recipient.key, {
                    ...recipient.options,
                    ...options,
                    [(0, _encryptJs.unprotected)]: true
                });
                jwe.ciphertext = flattened.ciphertext;
                jwe.iv = flattened.iv;
                jwe.tag = flattened.tag;
                if (flattened.aad) jwe.aad = flattened.aad;
                if (flattened.protected) jwe.protected = flattened.protected;
                if (flattened.unprotected) jwe.unprotected = flattened.unprotected;
                target.encrypted_key = flattened.encrypted_key;
                if (flattened.header) target.header = flattened.header;
                continue;
            }
            const { encryptedKey, parameters } = await (0, _encryptKeyManagementJsDefault.default)(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, {
                p2c
            });
            target.encrypted_key = (0, _base64UrlJs.encode)(encryptedKey);
            if (recipient.unprotectedHeader || parameters) target.header = {
                ...recipient.unprotectedHeader,
                ...parameters
            };
        }
        return jwe;
    }
}

},{"../flattened/encrypt.js":"46C8R","../../util/errors.js":"drZrx","../../lib/cek.js":"3wQoI","../../lib/is_disjoint.js":"8SDOv","../../lib/encrypt_key_management.js":"5ts3H","../../runtime/base64url.js":"hmfX7","../../lib/validate_crit.js":"czux9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"46C8R":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unprotected", ()=>unprotected);
parcelHelpers.export(exports, "FlattenedEncrypt", ()=>FlattenedEncrypt);
var _base64UrlJs = require("../../runtime/base64url.js");
var _encryptJs = require("../../runtime/encrypt.js");
var _encryptJsDefault = parcelHelpers.interopDefault(_encryptJs);
var _zlibJs = require("../../runtime/zlib.js");
var _ivJs = require("../../lib/iv.js");
var _ivJsDefault = parcelHelpers.interopDefault(_ivJs);
var _encryptKeyManagementJs = require("../../lib/encrypt_key_management.js");
var _encryptKeyManagementJsDefault = parcelHelpers.interopDefault(_encryptKeyManagementJs);
var _errorsJs = require("../../util/errors.js");
var _isDisjointJs = require("../../lib/is_disjoint.js");
var _isDisjointJsDefault = parcelHelpers.interopDefault(_isDisjointJs);
var _bufferUtilsJs = require("../../lib/buffer_utils.js");
var _validateCritJs = require("../../lib/validate_crit.js");
var _validateCritJsDefault = parcelHelpers.interopDefault(_validateCritJs);
const unprotected = Symbol();
class FlattenedEncrypt {
    constructor(plaintext){
        if (!(plaintext instanceof Uint8Array)) throw new TypeError('plaintext must be an instance of Uint8Array');
        this._plaintext = plaintext;
    }
    setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) throw new TypeError('setKeyManagementParameters can only be called once');
        this._keyManagementParameters = parameters;
        return this;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) throw new TypeError('setProtectedHeader can only be called once');
        this._protectedHeader = protectedHeader;
        return this;
    }
    setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) throw new TypeError('setSharedUnprotectedHeader can only be called once');
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) throw new TypeError('setUnprotectedHeader can only be called once');
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
    }
    setContentEncryptionKey(cek) {
        if (this._cek) throw new TypeError('setContentEncryptionKey can only be called once');
        this._cek = cek;
        return this;
    }
    setInitializationVector(iv) {
        if (this._iv) throw new TypeError('setInitializationVector can only be called once');
        this._iv = iv;
        return this;
    }
    async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) throw new (0, _errorsJs.JWEInvalid)('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');
        if (!(0, _isDisjointJsDefault.default)(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) throw new (0, _errorsJs.JWEInvalid)('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...this._sharedUnprotectedHeader
        };
        (0, _validateCritJsDefault.default)((0, _errorsJs.JWEInvalid), new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== undefined) {
            if (!this._protectedHeader || !this._protectedHeader.zip) throw new (0, _errorsJs.JWEInvalid)('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            if (joseHeader.zip !== 'DEF') throw new (0, _errorsJs.JOSENotSupported)('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== 'string' || !alg) throw new (0, _errorsJs.JWEInvalid)('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        if (typeof enc !== 'string' || !enc) throw new (0, _errorsJs.JWEInvalid)('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        let encryptedKey;
        if (alg === 'dir') {
            if (this._cek) throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');
        } else if (alg === 'ECDH-ES') {
            if (this._cek) throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');
        }
        let cek;
        {
            let parameters;
            ({ cek, encryptedKey, parameters } = await (0, _encryptKeyManagementJsDefault.default)(alg, enc, key, this._cek, this._keyManagementParameters));
            if (parameters) {
                if (options && unprotected in options) {
                    if (!this._unprotectedHeader) this.setUnprotectedHeader(parameters);
                    else this._unprotectedHeader = {
                        ...this._unprotectedHeader,
                        ...parameters
                    };
                } else if (!this._protectedHeader) this.setProtectedHeader(parameters);
                else this._protectedHeader = {
                    ...this._protectedHeader,
                    ...parameters
                };
            }
        }
        this._iv || (this._iv = (0, _ivJsDefault.default)(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) protectedHeader = (0, _bufferUtilsJs.encoder).encode((0, _base64UrlJs.encode)(JSON.stringify(this._protectedHeader)));
        else protectedHeader = (0, _bufferUtilsJs.encoder).encode('');
        if (this._aad) {
            aadMember = (0, _base64UrlJs.encode)(this._aad);
            additionalData = (0, _bufferUtilsJs.concat)(protectedHeader, (0, _bufferUtilsJs.encoder).encode('.'), (0, _bufferUtilsJs.encoder).encode(aadMember));
        } else additionalData = protectedHeader;
        let ciphertext;
        let tag;
        if (joseHeader.zip === 'DEF') {
            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || (0, _zlibJs.deflate))(this._plaintext);
            ({ ciphertext, tag } = await (0, _encryptJsDefault.default)(enc, deflated, cek, this._iv, additionalData));
        } else ({ ciphertext, tag } = await (0, _encryptJsDefault.default)(enc, this._plaintext, cek, this._iv, additionalData));
        const jwe = {
            ciphertext: (0, _base64UrlJs.encode)(ciphertext),
            iv: (0, _base64UrlJs.encode)(this._iv),
            tag: (0, _base64UrlJs.encode)(tag)
        };
        if (encryptedKey) jwe.encrypted_key = (0, _base64UrlJs.encode)(encryptedKey);
        if (aadMember) jwe.aad = aadMember;
        if (this._protectedHeader) jwe.protected = (0, _bufferUtilsJs.decoder).decode(protectedHeader);
        if (this._sharedUnprotectedHeader) jwe.unprotected = this._sharedUnprotectedHeader;
        if (this._unprotectedHeader) jwe.header = this._unprotectedHeader;
        return jwe;
    }
}

},{"../../runtime/base64url.js":"hmfX7","../../runtime/encrypt.js":"4qqfM","../../runtime/zlib.js":"kghzC","../../lib/iv.js":"7ae98","../../lib/encrypt_key_management.js":"5ts3H","../../util/errors.js":"drZrx","../../lib/is_disjoint.js":"8SDOv","../../lib/buffer_utils.js":"6CiRi","../../lib/validate_crit.js":"czux9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5ts3H":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _aeskwJs = require("../runtime/aeskw.js");
var _ecdhesJs = require("../runtime/ecdhes.js");
var _pbes2KwJs = require("../runtime/pbes2kw.js");
var _rsaesJs = require("../runtime/rsaes.js");
var _base64UrlJs = require("../runtime/base64url.js");
var _cekJs = require("../lib/cek.js");
var _cekJsDefault = parcelHelpers.interopDefault(_cekJs);
var _errorsJs = require("../util/errors.js");
var _exportJs = require("../key/export.js");
var _checkKeyTypeJs = require("./check_key_type.js");
var _checkKeyTypeJsDefault = parcelHelpers.interopDefault(_checkKeyTypeJs);
var _aesgcmkwJs = require("./aesgcmkw.js");
async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
    let encryptedKey;
    let parameters;
    let cek;
    (0, _checkKeyTypeJsDefault.default)(alg, key, 'encrypt');
    switch(alg){
        case 'dir':
            cek = key;
            break;
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
            {
                if (!_ecdhesJs.ecdhAllowed(key)) throw new (0, _errorsJs.JOSENotSupported)('ECDH with the provided key is not allowed or not supported by your javascript runtime');
                const { apu, apv } = providedParameters;
                let { epk: ephemeralKey } = providedParameters;
                ephemeralKey || (ephemeralKey = (await _ecdhesJs.generateEpk(key)).privateKey);
                const { x, y, crv, kty } = await (0, _exportJs.exportJWK)(ephemeralKey);
                const sharedSecret = await _ecdhesJs.deriveKey(key, ephemeralKey, alg === 'ECDH-ES' ? enc : alg, alg === 'ECDH-ES' ? (0, _cekJs.bitLength)(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
                parameters = {
                    epk: {
                        x,
                        crv,
                        kty
                    }
                };
                if (kty === 'EC') parameters.epk.y = y;
                if (apu) parameters.apu = (0, _base64UrlJs.encode)(apu);
                if (apv) parameters.apv = (0, _base64UrlJs.encode)(apv);
                if (alg === 'ECDH-ES') {
                    cek = sharedSecret;
                    break;
                }
                cek = providedCek || (0, _cekJsDefault.default)(enc);
                const kwAlg = alg.slice(-6);
                encryptedKey = await (0, _aeskwJs.wrap)(kwAlg, sharedSecret, cek);
                break;
            }
        case 'RSA1_5':
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            cek = providedCek || (0, _cekJsDefault.default)(enc);
            encryptedKey = await (0, _rsaesJs.encrypt)(alg, key, cek);
            break;
        case 'PBES2-HS256+A128KW':
        case 'PBES2-HS384+A192KW':
        case 'PBES2-HS512+A256KW':
            {
                cek = providedCek || (0, _cekJsDefault.default)(enc);
                const { p2c, p2s } = providedParameters;
                ({ encryptedKey, ...parameters } = await (0, _pbes2KwJs.encrypt)(alg, key, cek, p2c, p2s));
                break;
            }
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
            cek = providedCek || (0, _cekJsDefault.default)(enc);
            encryptedKey = await (0, _aeskwJs.wrap)(alg, key, cek);
            break;
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW':
            {
                cek = providedCek || (0, _cekJsDefault.default)(enc);
                const { iv } = providedParameters;
                ({ encryptedKey, ...parameters } = await (0, _aesgcmkwJs.wrap)(alg, key, cek, iv));
                break;
            }
        default:
            throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
    return {
        cek,
        encryptedKey,
        parameters
    };
}
exports.default = encryptKeyManagement;

},{"../runtime/aeskw.js":"iEW9A","../runtime/ecdhes.js":"9Kf4C","../runtime/pbes2kw.js":"2SPYY","../runtime/rsaes.js":"d5vYq","../runtime/base64url.js":"hmfX7","../lib/cek.js":"3wQoI","../util/errors.js":"drZrx","../key/export.js":"04SHK","./check_key_type.js":"kziQH","./aesgcmkw.js":"jiF4B","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"04SHK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "exportSPKI", ()=>exportSPKI);
parcelHelpers.export(exports, "exportPKCS8", ()=>exportPKCS8);
parcelHelpers.export(exports, "exportJWK", ()=>exportJWK);
var _asn1Js = require("../runtime/asn1.js");
var _keyToJwkJs = require("../runtime/key_to_jwk.js");
var _keyToJwkJsDefault = parcelHelpers.interopDefault(_keyToJwkJs);
async function exportSPKI(key) {
    return (0, _asn1Js.toSPKI)(key);
}
async function exportPKCS8(key) {
    return (0, _asn1Js.toPKCS8)(key);
}
async function exportJWK(key) {
    return (0, _keyToJwkJsDefault.default)(key);
}

},{"../runtime/asn1.js":"2EEbo","../runtime/key_to_jwk.js":"guLeD","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"guLeD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _invalidKeyInputJs = require("../lib/invalid_key_input.js");
var _invalidKeyInputJsDefault = parcelHelpers.interopDefault(_invalidKeyInputJs);
var _base64UrlJs = require("./base64url.js");
var _isKeyLikeJs = require("./is_key_like.js");
const keyToJWK = async (key)=>{
    if (key instanceof Uint8Array) return {
        kty: 'oct',
        k: (0, _base64UrlJs.encode)(key)
    };
    if (!(0, _webcryptoJs.isCryptoKey)(key)) throw new TypeError((0, _invalidKeyInputJsDefault.default)(key, ...(0, _isKeyLikeJs.types), 'Uint8Array'));
    if (!key.extractable) throw new TypeError('non-extractable CryptoKey cannot be exported as a JWK');
    const { ext, key_ops, alg, use, ...jwk } = await (0, _webcryptoJsDefault.default).subtle.exportKey('jwk', key);
    return jwk;
};
exports.default = keyToJWK;

},{"./webcrypto.js":"crCKY","../lib/invalid_key_input.js":"hHcMf","./base64url.js":"hmfX7","./is_key_like.js":"aRx6e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e1sJY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "compactVerify", ()=>compactVerify);
var _verifyJs = require("../flattened/verify.js");
var _errorsJs = require("../../util/errors.js");
var _bufferUtilsJs = require("../../lib/buffer_utils.js");
async function compactVerify(jws, key, options) {
    if (jws instanceof Uint8Array) jws = (0, _bufferUtilsJs.decoder).decode(jws);
    if (typeof jws !== 'string') throw new (0, _errorsJs.JWSInvalid)('Compact JWS must be a string or Uint8Array');
    const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split('.');
    if (length !== 3) throw new (0, _errorsJs.JWSInvalid)('Invalid Compact JWS');
    const verified = await (0, _verifyJs.flattenedVerify)({
        payload,
        protected: protectedHeader,
        signature
    }, key, options);
    const result = {
        payload: verified.payload,
        protectedHeader: verified.protectedHeader
    };
    if (typeof key === 'function') return {
        ...result,
        key: verified.key
    };
    return result;
}

},{"../flattened/verify.js":"9kMwY","../../util/errors.js":"drZrx","../../lib/buffer_utils.js":"6CiRi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9kMwY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flattenedVerify", ()=>flattenedVerify);
var _base64UrlJs = require("../../runtime/base64url.js");
var _verifyJs = require("../../runtime/verify.js");
var _verifyJsDefault = parcelHelpers.interopDefault(_verifyJs);
var _errorsJs = require("../../util/errors.js");
var _bufferUtilsJs = require("../../lib/buffer_utils.js");
var _isDisjointJs = require("../../lib/is_disjoint.js");
var _isDisjointJsDefault = parcelHelpers.interopDefault(_isDisjointJs);
var _isObjectJs = require("../../lib/is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _checkKeyTypeJs = require("../../lib/check_key_type.js");
var _checkKeyTypeJsDefault = parcelHelpers.interopDefault(_checkKeyTypeJs);
var _validateCritJs = require("../../lib/validate_crit.js");
var _validateCritJsDefault = parcelHelpers.interopDefault(_validateCritJs);
var _validateAlgorithmsJs = require("../../lib/validate_algorithms.js");
var _validateAlgorithmsJsDefault = parcelHelpers.interopDefault(_validateAlgorithmsJs);
async function flattenedVerify(jws, key, options) {
    var _a;
    if (!(0, _isObjectJsDefault.default)(jws)) throw new (0, _errorsJs.JWSInvalid)('Flattened JWS must be an object');
    if (jws.protected === undefined && jws.header === undefined) throw new (0, _errorsJs.JWSInvalid)('Flattened JWS must have either of the "protected" or "header" members');
    if (jws.protected !== undefined && typeof jws.protected !== 'string') throw new (0, _errorsJs.JWSInvalid)('JWS Protected Header incorrect type');
    if (jws.payload === undefined) throw new (0, _errorsJs.JWSInvalid)('JWS Payload missing');
    if (typeof jws.signature !== 'string') throw new (0, _errorsJs.JWSInvalid)('JWS Signature missing or incorrect type');
    if (jws.header !== undefined && !(0, _isObjectJsDefault.default)(jws.header)) throw new (0, _errorsJs.JWSInvalid)('JWS Unprotected Header incorrect type');
    let parsedProt = {};
    if (jws.protected) try {
        const protectedHeader = (0, _base64UrlJs.decode)(jws.protected);
        parsedProt = JSON.parse((0, _bufferUtilsJs.decoder).decode(protectedHeader));
    } catch (_b) {
        throw new (0, _errorsJs.JWSInvalid)('JWS Protected Header is invalid');
    }
    if (!(0, _isDisjointJsDefault.default)(parsedProt, jws.header)) throw new (0, _errorsJs.JWSInvalid)('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
    const joseHeader = {
        ...parsedProt,
        ...jws.header
    };
    const extensions = (0, _validateCritJsDefault.default)((0, _errorsJs.JWSInvalid), new Map([
        [
            'b64',
            true
        ]
    ]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
    let b64 = true;
    if (extensions.has('b64')) {
        b64 = parsedProt.b64;
        if (typeof b64 !== 'boolean') throw new (0, _errorsJs.JWSInvalid)('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
    const { alg } = joseHeader;
    if (typeof alg !== 'string' || !alg) throw new (0, _errorsJs.JWSInvalid)('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    const algorithms = options && (0, _validateAlgorithmsJsDefault.default)('algorithms', options.algorithms);
    if (algorithms && !algorithms.has(alg)) throw new (0, _errorsJs.JOSEAlgNotAllowed)('"alg" (Algorithm) Header Parameter not allowed');
    if (b64) {
        if (typeof jws.payload !== 'string') throw new (0, _errorsJs.JWSInvalid)('JWS Payload must be a string');
    } else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) throw new (0, _errorsJs.JWSInvalid)('JWS Payload must be a string or an Uint8Array instance');
    let resolvedKey = false;
    if (typeof key === 'function') {
        key = await key(parsedProt, jws);
        resolvedKey = true;
    }
    (0, _checkKeyTypeJsDefault.default)(alg, key, 'verify');
    const data = (0, _bufferUtilsJs.concat)((0, _bufferUtilsJs.encoder).encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), (0, _bufferUtilsJs.encoder).encode('.'), typeof jws.payload === 'string' ? (0, _bufferUtilsJs.encoder).encode(jws.payload) : jws.payload);
    let signature;
    try {
        signature = (0, _base64UrlJs.decode)(jws.signature);
    } catch (_c) {
        throw new (0, _errorsJs.JWSInvalid)('Failed to base64url decode the signature');
    }
    const verified = await (0, _verifyJsDefault.default)(alg, key, signature, data);
    if (!verified) throw new (0, _errorsJs.JWSSignatureVerificationFailed)();
    let payload;
    if (b64) try {
        payload = (0, _base64UrlJs.decode)(jws.payload);
    } catch (_d) {
        throw new (0, _errorsJs.JWSInvalid)('Failed to base64url decode the payload');
    }
    else if (typeof jws.payload === 'string') payload = (0, _bufferUtilsJs.encoder).encode(jws.payload);
    else payload = jws.payload;
    const result = {
        payload
    };
    if (jws.protected !== undefined) result.protectedHeader = parsedProt;
    if (jws.header !== undefined) result.unprotectedHeader = jws.header;
    if (resolvedKey) return {
        ...result,
        key
    };
    return result;
}

},{"../../runtime/base64url.js":"hmfX7","../../runtime/verify.js":"bAXhY","../../util/errors.js":"drZrx","../../lib/buffer_utils.js":"6CiRi","../../lib/is_disjoint.js":"8SDOv","../../lib/is_object.js":"6AeNj","../../lib/check_key_type.js":"kziQH","../../lib/validate_crit.js":"czux9","../../lib/validate_algorithms.js":"5vOPm","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bAXhY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _subtleDsaJs = require("./subtle_dsa.js");
var _subtleDsaJsDefault = parcelHelpers.interopDefault(_subtleDsaJs);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _checkKeyLengthJs = require("./check_key_length.js");
var _checkKeyLengthJsDefault = parcelHelpers.interopDefault(_checkKeyLengthJs);
var _getSignVerifyKeyJs = require("./get_sign_verify_key.js");
var _getSignVerifyKeyJsDefault = parcelHelpers.interopDefault(_getSignVerifyKeyJs);
const verify = async (alg, key, signature, data)=>{
    const cryptoKey = await (0, _getSignVerifyKeyJsDefault.default)(alg, key, 'verify');
    (0, _checkKeyLengthJsDefault.default)(alg, cryptoKey);
    const algorithm = (0, _subtleDsaJsDefault.default)(alg, cryptoKey.algorithm);
    try {
        return await (0, _webcryptoJsDefault.default).subtle.verify(algorithm, cryptoKey, signature, data);
    } catch (_a) {
        return false;
    }
};
exports.default = verify;

},{"./subtle_dsa.js":"91W6q","./webcrypto.js":"crCKY","./check_key_length.js":"5tUbx","./get_sign_verify_key.js":"cq6Qr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"91W6q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>subtleDsa);
var _errorsJs = require("../util/errors.js");
function subtleDsa(alg, algorithm) {
    const hash = `SHA-${alg.slice(-3)}`;
    switch(alg){
        case 'HS256':
        case 'HS384':
        case 'HS512':
            return {
                hash,
                name: 'HMAC'
            };
        case 'PS256':
        case 'PS384':
        case 'PS512':
            return {
                hash,
                name: 'RSA-PSS',
                saltLength: alg.slice(-3) >> 3
            };
        case 'RS256':
        case 'RS384':
        case 'RS512':
            return {
                hash,
                name: 'RSASSA-PKCS1-v1_5'
            };
        case 'ES256':
        case 'ES384':
        case 'ES512':
            return {
                hash,
                name: 'ECDSA',
                namedCurve: algorithm.namedCurve
            };
        case 'EdDSA':
            return {
                name: algorithm.name
            };
        default:
            throw new (0, _errorsJs.JOSENotSupported)(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
    }
}

},{"../util/errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cq6Qr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getCryptoKey);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _cryptoKeyJs = require("../lib/crypto_key.js");
var _invalidKeyInputJs = require("../lib/invalid_key_input.js");
var _invalidKeyInputJsDefault = parcelHelpers.interopDefault(_invalidKeyInputJs);
var _isKeyLikeJs = require("./is_key_like.js");
function getCryptoKey(alg, key, usage) {
    if ((0, _webcryptoJs.isCryptoKey)(key)) {
        (0, _cryptoKeyJs.checkSigCryptoKey)(key, alg, usage);
        return key;
    }
    if (key instanceof Uint8Array) {
        if (!alg.startsWith('HS')) throw new TypeError((0, _invalidKeyInputJsDefault.default)(key, ...(0, _isKeyLikeJs.types)));
        return (0, _webcryptoJsDefault.default).subtle.importKey('raw', key, {
            hash: `SHA-${alg.slice(-3)}`,
            name: 'HMAC'
        }, false, [
            usage
        ]);
    }
    throw new TypeError((0, _invalidKeyInputJsDefault.default)(key, ...(0, _isKeyLikeJs.types), 'Uint8Array'));
}

},{"./webcrypto.js":"crCKY","../lib/crypto_key.js":"547bG","../lib/invalid_key_input.js":"hHcMf","./is_key_like.js":"aRx6e","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"afsWj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "generalVerify", ()=>generalVerify);
var _verifyJs = require("../flattened/verify.js");
var _errorsJs = require("../../util/errors.js");
var _isObjectJs = require("../../lib/is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
async function generalVerify(jws, key, options) {
    if (!(0, _isObjectJsDefault.default)(jws)) throw new (0, _errorsJs.JWSInvalid)('General JWS must be an object');
    if (!Array.isArray(jws.signatures) || !jws.signatures.every((0, _isObjectJsDefault.default))) throw new (0, _errorsJs.JWSInvalid)('JWS Signatures missing or incorrect type');
    for (const signature of jws.signatures)try {
        return await (0, _verifyJs.flattenedVerify)({
            header: signature.header,
            payload: jws.payload,
            protected: signature.protected,
            signature: signature.signature
        }, key, options);
    } catch (_a) {}
    throw new (0, _errorsJs.JWSSignatureVerificationFailed)();
}

},{"../flattened/verify.js":"9kMwY","../../util/errors.js":"drZrx","../../lib/is_object.js":"6AeNj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6mf3t":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jwtVerify", ()=>jwtVerify);
var _verifyJs = require("../jws/compact/verify.js");
var _jwtClaimsSetJs = require("../lib/jwt_claims_set.js");
var _jwtClaimsSetJsDefault = parcelHelpers.interopDefault(_jwtClaimsSetJs);
var _errorsJs = require("../util/errors.js");
async function jwtVerify(jwt, key, options) {
    var _a;
    const verified = await (0, _verifyJs.compactVerify)(jwt, key, options);
    if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes('b64')) && verified.protectedHeader.b64 === false) throw new (0, _errorsJs.JWTInvalid)('JWTs MUST NOT use unencoded payload');
    const payload = (0, _jwtClaimsSetJsDefault.default)(verified.protectedHeader, verified.payload, options);
    const result = {
        payload,
        protectedHeader: verified.protectedHeader
    };
    if (typeof key === 'function') return {
        ...result,
        key: verified.key
    };
    return result;
}

},{"../jws/compact/verify.js":"e1sJY","../lib/jwt_claims_set.js":"bz6vN","../util/errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bz6vN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _errorsJs = require("../util/errors.js");
var _bufferUtilsJs = require("./buffer_utils.js");
var _epochJs = require("./epoch.js");
var _epochJsDefault = parcelHelpers.interopDefault(_epochJs);
var _secsJs = require("./secs.js");
var _secsJsDefault = parcelHelpers.interopDefault(_secsJs);
var _isObjectJs = require("./is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
const normalizeTyp = (value)=>value.toLowerCase().replace(/^application\//, '');
const checkAudiencePresence = (audPayload, audOption)=>{
    if (typeof audPayload === 'string') return audOption.includes(audPayload);
    if (Array.isArray(audPayload)) return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
    return false;
};
exports.default = (protectedHeader, encodedPayload, options = {})=>{
    const { typ } = options;
    if (typ && (typeof protectedHeader.typ !== 'string' || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) throw new (0, _errorsJs.JWTClaimValidationFailed)('unexpected "typ" JWT header value', 'typ', 'check_failed');
    let payload;
    try {
        payload = JSON.parse((0, _bufferUtilsJs.decoder).decode(encodedPayload));
    } catch (_a) {}
    if (!(0, _isObjectJsDefault.default)(payload)) throw new (0, _errorsJs.JWTInvalid)('JWT Claims Set must be a top-level JSON object');
    const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
    if (maxTokenAge !== undefined) requiredClaims.push('iat');
    if (audience !== undefined) requiredClaims.push('aud');
    if (subject !== undefined) requiredClaims.push('sub');
    if (issuer !== undefined) requiredClaims.push('iss');
    for (const claim of new Set(requiredClaims.reverse())){
        if (!(claim in payload)) throw new (0, _errorsJs.JWTClaimValidationFailed)(`missing required "${claim}" claim`, claim, 'missing');
    }
    if (issuer && !(Array.isArray(issuer) ? issuer : [
        issuer
    ]).includes(payload.iss)) throw new (0, _errorsJs.JWTClaimValidationFailed)('unexpected "iss" claim value', 'iss', 'check_failed');
    if (subject && payload.sub !== subject) throw new (0, _errorsJs.JWTClaimValidationFailed)('unexpected "sub" claim value', 'sub', 'check_failed');
    if (audience && !checkAudiencePresence(payload.aud, typeof audience === 'string' ? [
        audience
    ] : audience)) throw new (0, _errorsJs.JWTClaimValidationFailed)('unexpected "aud" claim value', 'aud', 'check_failed');
    let tolerance;
    switch(typeof options.clockTolerance){
        case 'string':
            tolerance = (0, _secsJsDefault.default)(options.clockTolerance);
            break;
        case 'number':
            tolerance = options.clockTolerance;
            break;
        case 'undefined':
            tolerance = 0;
            break;
        default:
            throw new TypeError('Invalid clockTolerance option type');
    }
    const { currentDate } = options;
    const now = (0, _epochJsDefault.default)(currentDate || new Date());
    if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== 'number') throw new (0, _errorsJs.JWTClaimValidationFailed)('"iat" claim must be a number', 'iat', 'invalid');
    if (payload.nbf !== undefined) {
        if (typeof payload.nbf !== 'number') throw new (0, _errorsJs.JWTClaimValidationFailed)('"nbf" claim must be a number', 'nbf', 'invalid');
        if (payload.nbf > now + tolerance) throw new (0, _errorsJs.JWTClaimValidationFailed)('"nbf" claim timestamp check failed', 'nbf', 'check_failed');
    }
    if (payload.exp !== undefined) {
        if (typeof payload.exp !== 'number') throw new (0, _errorsJs.JWTClaimValidationFailed)('"exp" claim must be a number', 'exp', 'invalid');
        if (payload.exp <= now - tolerance) throw new (0, _errorsJs.JWTExpired)('"exp" claim timestamp check failed', 'exp', 'check_failed');
    }
    if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === 'number' ? maxTokenAge : (0, _secsJsDefault.default)(maxTokenAge);
        if (age - tolerance > max) throw new (0, _errorsJs.JWTExpired)('"iat" claim timestamp check failed (too far in the past)', 'iat', 'check_failed');
        if (age < 0 - tolerance) throw new (0, _errorsJs.JWTClaimValidationFailed)('"iat" claim timestamp check failed (it should be in the past)', 'iat', 'check_failed');
    }
    return payload;
};

},{"../util/errors.js":"drZrx","./buffer_utils.js":"6CiRi","./epoch.js":"1Jyqm","./secs.js":"iCDy8","./is_object.js":"6AeNj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1Jyqm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = (date)=>Math.floor(date.getTime() / 1000);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iCDy8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
exports.default = (str)=>{
    const matched = REGEX.exec(str);
    if (!matched) throw new TypeError('Invalid time period format');
    const value = parseFloat(matched[1]);
    const unit = matched[2].toLowerCase();
    switch(unit){
        case 'sec':
        case 'secs':
        case 'second':
        case 'seconds':
        case 's':
            return Math.round(value);
        case 'minute':
        case 'minutes':
        case 'min':
        case 'mins':
        case 'm':
            return Math.round(value * minute);
        case 'hour':
        case 'hours':
        case 'hr':
        case 'hrs':
        case 'h':
            return Math.round(value * hour);
        case 'day':
        case 'days':
        case 'd':
            return Math.round(value * day);
        case 'week':
        case 'weeks':
        case 'w':
            return Math.round(value * week);
        default:
            return Math.round(value * year);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"zT60K":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "jwtDecrypt", ()=>jwtDecrypt);
var _decryptJs = require("../jwe/compact/decrypt.js");
var _jwtClaimsSetJs = require("../lib/jwt_claims_set.js");
var _jwtClaimsSetJsDefault = parcelHelpers.interopDefault(_jwtClaimsSetJs);
var _errorsJs = require("../util/errors.js");
async function jwtDecrypt(jwt, key, options) {
    const decrypted = await (0, _decryptJs.compactDecrypt)(jwt, key, options);
    const payload = (0, _jwtClaimsSetJsDefault.default)(decrypted.protectedHeader, decrypted.plaintext, options);
    const { protectedHeader } = decrypted;
    if (protectedHeader.iss !== undefined && protectedHeader.iss !== payload.iss) throw new (0, _errorsJs.JWTClaimValidationFailed)('replicated "iss" claim header parameter mismatch', 'iss', 'mismatch');
    if (protectedHeader.sub !== undefined && protectedHeader.sub !== payload.sub) throw new (0, _errorsJs.JWTClaimValidationFailed)('replicated "sub" claim header parameter mismatch', 'sub', 'mismatch');
    if (protectedHeader.aud !== undefined && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) throw new (0, _errorsJs.JWTClaimValidationFailed)('replicated "aud" claim header parameter mismatch', 'aud', 'mismatch');
    const result = {
        payload,
        protectedHeader
    };
    if (typeof key === 'function') return {
        ...result,
        key: decrypted.key
    };
    return result;
}

},{"../jwe/compact/decrypt.js":"aRaar","../lib/jwt_claims_set.js":"bz6vN","../util/errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jV286":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CompactEncrypt", ()=>CompactEncrypt);
var _encryptJs = require("../flattened/encrypt.js");
class CompactEncrypt {
    constructor(plaintext){
        this._flattened = new (0, _encryptJs.FlattenedEncrypt)(plaintext);
    }
    setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
    }
    setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
    }
    async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [
            jwe.protected,
            jwe.encrypted_key,
            jwe.iv,
            jwe.ciphertext,
            jwe.tag
        ].join('.');
    }
}

},{"../flattened/encrypt.js":"46C8R","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h85r4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CompactSign", ()=>CompactSign);
var _signJs = require("../flattened/sign.js");
class CompactSign {
    constructor(payload){
        this._flattened = new (0, _signJs.FlattenedSign)(payload);
    }
    setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
    }
    async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === undefined) throw new TypeError('use the flattened module for creating JWS with b64: false');
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
    }
}

},{"../flattened/sign.js":"k3wVp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"k3wVp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FlattenedSign", ()=>FlattenedSign);
var _base64UrlJs = require("../../runtime/base64url.js");
var _signJs = require("../../runtime/sign.js");
var _signJsDefault = parcelHelpers.interopDefault(_signJs);
var _isDisjointJs = require("../../lib/is_disjoint.js");
var _isDisjointJsDefault = parcelHelpers.interopDefault(_isDisjointJs);
var _errorsJs = require("../../util/errors.js");
var _bufferUtilsJs = require("../../lib/buffer_utils.js");
var _checkKeyTypeJs = require("../../lib/check_key_type.js");
var _checkKeyTypeJsDefault = parcelHelpers.interopDefault(_checkKeyTypeJs);
var _validateCritJs = require("../../lib/validate_crit.js");
var _validateCritJsDefault = parcelHelpers.interopDefault(_validateCritJs);
class FlattenedSign {
    constructor(payload){
        if (!(payload instanceof Uint8Array)) throw new TypeError('payload must be an instance of Uint8Array');
        this._payload = payload;
    }
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) throw new TypeError('setProtectedHeader can only be called once');
        this._protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) throw new TypeError('setUnprotectedHeader can only be called once');
        this._unprotectedHeader = unprotectedHeader;
        return this;
    }
    async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) throw new (0, _errorsJs.JWSInvalid)('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');
        if (!(0, _isDisjointJsDefault.default)(this._protectedHeader, this._unprotectedHeader)) throw new (0, _errorsJs.JWSInvalid)('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');
        const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader
        };
        const extensions = (0, _validateCritJsDefault.default)((0, _errorsJs.JWSInvalid), new Map([
            [
                'b64',
                true
            ]
        ]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has('b64')) {
            b64 = this._protectedHeader.b64;
            if (typeof b64 !== 'boolean') throw new (0, _errorsJs.JWSInvalid)('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
        }
        const { alg } = joseHeader;
        if (typeof alg !== 'string' || !alg) throw new (0, _errorsJs.JWSInvalid)('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        (0, _checkKeyTypeJsDefault.default)(alg, key, 'sign');
        let payload = this._payload;
        if (b64) payload = (0, _bufferUtilsJs.encoder).encode((0, _base64UrlJs.encode)(payload));
        let protectedHeader;
        if (this._protectedHeader) protectedHeader = (0, _bufferUtilsJs.encoder).encode((0, _base64UrlJs.encode)(JSON.stringify(this._protectedHeader)));
        else protectedHeader = (0, _bufferUtilsJs.encoder).encode('');
        const data = (0, _bufferUtilsJs.concat)(protectedHeader, (0, _bufferUtilsJs.encoder).encode('.'), payload);
        const signature = await (0, _signJsDefault.default)(alg, key, data);
        const jws = {
            signature: (0, _base64UrlJs.encode)(signature),
            payload: ''
        };
        if (b64) jws.payload = (0, _bufferUtilsJs.decoder).decode(payload);
        if (this._unprotectedHeader) jws.header = this._unprotectedHeader;
        if (this._protectedHeader) jws.protected = (0, _bufferUtilsJs.decoder).decode(protectedHeader);
        return jws;
    }
}

},{"../../runtime/base64url.js":"hmfX7","../../runtime/sign.js":"7Cw3j","../../lib/is_disjoint.js":"8SDOv","../../util/errors.js":"drZrx","../../lib/buffer_utils.js":"6CiRi","../../lib/check_key_type.js":"kziQH","../../lib/validate_crit.js":"czux9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7Cw3j":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _subtleDsaJs = require("./subtle_dsa.js");
var _subtleDsaJsDefault = parcelHelpers.interopDefault(_subtleDsaJs);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _checkKeyLengthJs = require("./check_key_length.js");
var _checkKeyLengthJsDefault = parcelHelpers.interopDefault(_checkKeyLengthJs);
var _getSignVerifyKeyJs = require("./get_sign_verify_key.js");
var _getSignVerifyKeyJsDefault = parcelHelpers.interopDefault(_getSignVerifyKeyJs);
const sign = async (alg, key, data)=>{
    const cryptoKey = await (0, _getSignVerifyKeyJsDefault.default)(alg, key, 'sign');
    (0, _checkKeyLengthJsDefault.default)(alg, cryptoKey);
    const signature = await (0, _webcryptoJsDefault.default).subtle.sign((0, _subtleDsaJsDefault.default)(alg, cryptoKey.algorithm), cryptoKey, data);
    return new Uint8Array(signature);
};
exports.default = sign;

},{"./subtle_dsa.js":"91W6q","./webcrypto.js":"crCKY","./check_key_length.js":"5tUbx","./get_sign_verify_key.js":"cq6Qr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fdViL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "GeneralSign", ()=>GeneralSign);
var _signJs = require("../flattened/sign.js");
var _errorsJs = require("../../util/errors.js");
class IndividualSignature {
    constructor(sig, key, options){
        this.parent = sig;
        this.key = key;
        this.options = options;
    }
    setProtectedHeader(protectedHeader) {
        if (this.protectedHeader) throw new TypeError('setProtectedHeader can only be called once');
        this.protectedHeader = protectedHeader;
        return this;
    }
    setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) throw new TypeError('setUnprotectedHeader can only be called once');
        this.unprotectedHeader = unprotectedHeader;
        return this;
    }
    addSignature(...args) {
        return this.parent.addSignature(...args);
    }
    sign(...args) {
        return this.parent.sign(...args);
    }
    done() {
        return this.parent;
    }
}
class GeneralSign {
    constructor(payload){
        this._signatures = [];
        this._payload = payload;
    }
    addSignature(key, options) {
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
    }
    async sign() {
        if (!this._signatures.length) throw new (0, _errorsJs.JWSInvalid)('at least one signature must be added');
        const jws = {
            signatures: [],
            payload: ''
        };
        for(let i = 0; i < this._signatures.length; i++){
            const signature = this._signatures[i];
            const flattened = new (0, _signJs.FlattenedSign)(this._payload);
            flattened.setProtectedHeader(signature.protectedHeader);
            flattened.setUnprotectedHeader(signature.unprotectedHeader);
            const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
            if (i === 0) jws.payload = payload;
            else if (jws.payload !== payload) throw new (0, _errorsJs.JWSInvalid)('inconsistent use of JWS Unencoded Payload (RFC7797)');
            jws.signatures.push(rest);
        }
        return jws;
    }
}

},{"../flattened/sign.js":"k3wVp","../../util/errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2xK9f":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SignJWT", ()=>SignJWT);
var _signJs = require("../jws/compact/sign.js");
var _errorsJs = require("../util/errors.js");
var _bufferUtilsJs = require("../lib/buffer_utils.js");
var _produceJs = require("./produce.js");
class SignJWT extends (0, _produceJs.ProduceJWT) {
    setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
    }
    async sign(key, options) {
        var _a;
        const sig = new (0, _signJs.CompactSign)((0, _bufferUtilsJs.encoder).encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) && this._protectedHeader.crit.includes('b64') && this._protectedHeader.b64 === false) throw new (0, _errorsJs.JWTInvalid)('JWTs MUST NOT use unencoded payload');
        return sig.sign(key, options);
    }
}

},{"../jws/compact/sign.js":"h85r4","../util/errors.js":"drZrx","../lib/buffer_utils.js":"6CiRi","./produce.js":"l8xt5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l8xt5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ProduceJWT", ()=>ProduceJWT);
var _epochJs = require("../lib/epoch.js");
var _epochJsDefault = parcelHelpers.interopDefault(_epochJs);
var _isObjectJs = require("../lib/is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _secsJs = require("../lib/secs.js");
var _secsJsDefault = parcelHelpers.interopDefault(_secsJs);
class ProduceJWT {
    constructor(payload){
        if (!(0, _isObjectJsDefault.default)(payload)) throw new TypeError('JWT Claims Set MUST be an object');
        this._payload = payload;
    }
    setIssuer(issuer) {
        this._payload = {
            ...this._payload,
            iss: issuer
        };
        return this;
    }
    setSubject(subject) {
        this._payload = {
            ...this._payload,
            sub: subject
        };
        return this;
    }
    setAudience(audience) {
        this._payload = {
            ...this._payload,
            aud: audience
        };
        return this;
    }
    setJti(jwtId) {
        this._payload = {
            ...this._payload,
            jti: jwtId
        };
        return this;
    }
    setNotBefore(input) {
        if (typeof input === 'number') this._payload = {
            ...this._payload,
            nbf: input
        };
        else this._payload = {
            ...this._payload,
            nbf: (0, _epochJsDefault.default)(new Date()) + (0, _secsJsDefault.default)(input)
        };
        return this;
    }
    setExpirationTime(input) {
        if (typeof input === 'number') this._payload = {
            ...this._payload,
            exp: input
        };
        else this._payload = {
            ...this._payload,
            exp: (0, _epochJsDefault.default)(new Date()) + (0, _secsJsDefault.default)(input)
        };
        return this;
    }
    setIssuedAt(input) {
        if (typeof input === 'undefined') this._payload = {
            ...this._payload,
            iat: (0, _epochJsDefault.default)(new Date())
        };
        else this._payload = {
            ...this._payload,
            iat: input
        };
        return this;
    }
}

},{"../lib/epoch.js":"1Jyqm","../lib/is_object.js":"6AeNj","../lib/secs.js":"iCDy8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jJPUI":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EncryptJWT", ()=>EncryptJWT);
var _encryptJs = require("../jwe/compact/encrypt.js");
var _bufferUtilsJs = require("../lib/buffer_utils.js");
var _produceJs = require("./produce.js");
class EncryptJWT extends (0, _produceJs.ProduceJWT) {
    setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) throw new TypeError('setProtectedHeader can only be called once');
        this._protectedHeader = protectedHeader;
        return this;
    }
    setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) throw new TypeError('setKeyManagementParameters can only be called once');
        this._keyManagementParameters = parameters;
        return this;
    }
    setContentEncryptionKey(cek) {
        if (this._cek) throw new TypeError('setContentEncryptionKey can only be called once');
        this._cek = cek;
        return this;
    }
    setInitializationVector(iv) {
        if (this._iv) throw new TypeError('setInitializationVector can only be called once');
        this._iv = iv;
        return this;
    }
    replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
    }
    replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
    }
    replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
    }
    async encrypt(key, options) {
        const enc = new (0, _encryptJs.CompactEncrypt)((0, _bufferUtilsJs.encoder).encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) this._protectedHeader = {
            ...this._protectedHeader,
            iss: this._payload.iss
        };
        if (this._replicateSubjectAsHeader) this._protectedHeader = {
            ...this._protectedHeader,
            sub: this._payload.sub
        };
        if (this._replicateAudienceAsHeader) this._protectedHeader = {
            ...this._protectedHeader,
            aud: this._payload.aud
        };
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) enc.setInitializationVector(this._iv);
        if (this._cek) enc.setContentEncryptionKey(this._cek);
        if (this._keyManagementParameters) enc.setKeyManagementParameters(this._keyManagementParameters);
        return enc.encrypt(key, options);
    }
}

},{"../jwe/compact/encrypt.js":"jV286","../lib/buffer_utils.js":"6CiRi","./produce.js":"l8xt5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1LCWm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "calculateJwkThumbprint", ()=>calculateJwkThumbprint);
parcelHelpers.export(exports, "calculateJwkThumbprintUri", ()=>calculateJwkThumbprintUri);
var _digestJs = require("../runtime/digest.js");
var _digestJsDefault = parcelHelpers.interopDefault(_digestJs);
var _base64UrlJs = require("../runtime/base64url.js");
var _errorsJs = require("../util/errors.js");
var _bufferUtilsJs = require("../lib/buffer_utils.js");
var _isObjectJs = require("../lib/is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
const check = (value, description)=>{
    if (typeof value !== 'string' || !value) throw new (0, _errorsJs.JWKInvalid)(`${description} missing or invalid`);
};
async function calculateJwkThumbprint(jwk, digestAlgorithm) {
    if (!(0, _isObjectJsDefault.default)(jwk)) throw new TypeError('JWK must be an object');
    digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = 'sha256';
    if (digestAlgorithm !== 'sha256' && digestAlgorithm !== 'sha384' && digestAlgorithm !== 'sha512') throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
    let components;
    switch(jwk.kty){
        case 'EC':
            check(jwk.crv, '"crv" (Curve) Parameter');
            check(jwk.x, '"x" (X Coordinate) Parameter');
            check(jwk.y, '"y" (Y Coordinate) Parameter');
            components = {
                crv: jwk.crv,
                kty: jwk.kty,
                x: jwk.x,
                y: jwk.y
            };
            break;
        case 'OKP':
            check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
            check(jwk.x, '"x" (Public Key) Parameter');
            components = {
                crv: jwk.crv,
                kty: jwk.kty,
                x: jwk.x
            };
            break;
        case 'RSA':
            check(jwk.e, '"e" (Exponent) Parameter');
            check(jwk.n, '"n" (Modulus) Parameter');
            components = {
                e: jwk.e,
                kty: jwk.kty,
                n: jwk.n
            };
            break;
        case 'oct':
            check(jwk.k, '"k" (Key Value) Parameter');
            components = {
                k: jwk.k,
                kty: jwk.kty
            };
            break;
        default:
            throw new (0, _errorsJs.JOSENotSupported)('"kty" (Key Type) Parameter missing or unsupported');
    }
    const data = (0, _bufferUtilsJs.encoder).encode(JSON.stringify(components));
    return (0, _base64UrlJs.encode)(await (0, _digestJsDefault.default)(digestAlgorithm, data));
}
async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
    digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = 'sha256';
    const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
    return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
}

},{"../runtime/digest.js":"fDsy9","../runtime/base64url.js":"hmfX7","../util/errors.js":"drZrx","../lib/buffer_utils.js":"6CiRi","../lib/is_object.js":"6AeNj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8aDeU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmbeddedJWK", ()=>EmbeddedJWK);
var _importJs = require("../key/import.js");
var _isObjectJs = require("../lib/is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _errorsJs = require("../util/errors.js");
async function EmbeddedJWK(protectedHeader, token) {
    const joseHeader = {
        ...protectedHeader,
        ...token === null || token === void 0 ? void 0 : token.header
    };
    if (!(0, _isObjectJsDefault.default)(joseHeader.jwk)) throw new (0, _errorsJs.JWSInvalid)('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
    const key = await (0, _importJs.importJWK)({
        ...joseHeader.jwk,
        ext: true
    }, joseHeader.alg, true);
    if (key instanceof Uint8Array || key.type !== 'public') throw new (0, _errorsJs.JWSInvalid)('"jwk" (JSON Web Key) Header Parameter must be a public key');
    return key;
}

},{"../key/import.js":"gu3Vs","../lib/is_object.js":"6AeNj","../util/errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jpAM0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isJWKSLike", ()=>isJWKSLike);
parcelHelpers.export(exports, "LocalJWKSet", ()=>LocalJWKSet);
parcelHelpers.export(exports, "createLocalJWKSet", ()=>createLocalJWKSet);
var _importJs = require("../key/import.js");
var _errorsJs = require("../util/errors.js");
var _isObjectJs = require("../lib/is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
function getKtyFromAlg(alg) {
    switch(typeof alg === 'string' && alg.slice(0, 2)){
        case 'RS':
        case 'PS':
            return 'RSA';
        case 'ES':
            return 'EC';
        case 'Ed':
            return 'OKP';
        default:
            throw new (0, _errorsJs.JOSENotSupported)('Unsupported "alg" value for a JSON Web Key Set');
    }
}
function isJWKSLike(jwks) {
    return jwks && typeof jwks === 'object' && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
    return (0, _isObjectJsDefault.default)(key);
}
function clone(obj) {
    if (typeof structuredClone === 'function') return structuredClone(obj);
    return JSON.parse(JSON.stringify(obj));
}
class LocalJWKSet {
    constructor(jwks){
        this._cached = new WeakMap();
        if (!isJWKSLike(jwks)) throw new (0, _errorsJs.JWKSInvalid)('JSON Web Key Set malformed');
        this._jwks = clone(jwks);
    }
    async getKey(protectedHeader, token) {
        const { alg, kid } = {
            ...protectedHeader,
            ...token === null || token === void 0 ? void 0 : token.header
        };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk)=>{
            let candidate = kty === jwk.kty;
            if (candidate && typeof kid === 'string') candidate = kid === jwk.kid;
            if (candidate && typeof jwk.alg === 'string') candidate = alg === jwk.alg;
            if (candidate && typeof jwk.use === 'string') candidate = jwk.use === 'sig';
            if (candidate && Array.isArray(jwk.key_ops)) candidate = jwk.key_ops.includes('verify');
            if (candidate && alg === 'EdDSA') candidate = jwk.crv === 'Ed25519' || jwk.crv === 'Ed448';
            if (candidate) switch(alg){
                case 'ES256':
                    candidate = jwk.crv === 'P-256';
                    break;
                case 'ES256K':
                    candidate = jwk.crv === 'secp256k1';
                    break;
                case 'ES384':
                    candidate = jwk.crv === 'P-384';
                    break;
                case 'ES512':
                    candidate = jwk.crv === 'P-521';
                    break;
            }
            return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) throw new (0, _errorsJs.JWKSNoMatchingKey)();
        else if (length !== 1) {
            const error = new (0, _errorsJs.JWKSMultipleMatchingKeys)();
            const { _cached } = this;
            error[Symbol.asyncIterator] = async function*() {
                for (const jwk of candidates)try {
                    yield await importWithAlgCache(_cached, jwk, alg);
                } catch (_a) {
                    continue;
                }
            };
            throw error;
        }
        return importWithAlgCache(this._cached, jwk, alg);
    }
}
async function importWithAlgCache(cache, jwk, alg) {
    const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
    if (cached[alg] === undefined) {
        const key = await (0, _importJs.importJWK)({
            ...jwk,
            ext: true
        }, alg);
        if (key instanceof Uint8Array || key.type !== 'public') throw new (0, _errorsJs.JWKSInvalid)('JSON Web Key Set members must be public keys');
        cached[alg] = key;
    }
    return cached[alg];
}
function createLocalJWKSet(jwks) {
    const set = new LocalJWKSet(jwks);
    return async function(protectedHeader, token) {
        return set.getKey(protectedHeader, token);
    };
}

},{"../key/import.js":"gu3Vs","../util/errors.js":"drZrx","../lib/is_object.js":"6AeNj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gnekA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createRemoteJWKSet", ()=>createRemoteJWKSet);
var _fetchJwksJs = require("../runtime/fetch_jwks.js");
var _fetchJwksJsDefault = parcelHelpers.interopDefault(_fetchJwksJs);
var _errorsJs = require("../util/errors.js");
var _localJs = require("./local.js");
function isCloudflareWorkers() {
    return typeof WebSocketPair !== 'undefined' || typeof navigator !== 'undefined' && navigator.userAgent === 'Cloudflare-Workers' || typeof EdgeRuntime !== 'undefined' && EdgeRuntime === 'vercel';
}
class RemoteJWKSet extends (0, _localJs.LocalJWKSet) {
    constructor(url, options){
        super({
            keys: []
        });
        this._jwks = undefined;
        if (!(url instanceof URL)) throw new TypeError('url must be an instance of URL');
        this._url = new URL(url.href);
        this._options = {
            agent: options === null || options === void 0 ? void 0 : options.agent,
            headers: options === null || options === void 0 ? void 0 : options.headers
        };
        this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5000;
        this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === 'number' ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 30000;
        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === 'number' ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 600000;
    }
    coolingDown() {
        return typeof this._jwksTimestamp === 'number' ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
    }
    fresh() {
        return typeof this._jwksTimestamp === 'number' ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
    }
    async getKey(protectedHeader, token) {
        if (!this._jwks || !this.fresh()) await this.reload();
        try {
            return await super.getKey(protectedHeader, token);
        } catch (err) {
            if (err instanceof (0, _errorsJs.JWKSNoMatchingKey)) {
                if (this.coolingDown() === false) {
                    await this.reload();
                    return super.getKey(protectedHeader, token);
                }
            }
            throw err;
        }
    }
    async reload() {
        if (this._pendingFetch && isCloudflareWorkers()) this._pendingFetch = undefined;
        this._pendingFetch || (this._pendingFetch = (0, _fetchJwksJsDefault.default)(this._url, this._timeoutDuration, this._options).then((json)=>{
            if (!(0, _localJs.isJWKSLike)(json)) throw new (0, _errorsJs.JWKSInvalid)('JSON Web Key Set malformed');
            this._jwks = {
                keys: json.keys
            };
            this._jwksTimestamp = Date.now();
            this._pendingFetch = undefined;
        }).catch((err)=>{
            this._pendingFetch = undefined;
            throw err;
        }));
        await this._pendingFetch;
    }
}
function createRemoteJWKSet(url, options) {
    const set = new RemoteJWKSet(url, options);
    return async function(protectedHeader, token) {
        return set.getKey(protectedHeader, token);
    };
}

},{"../runtime/fetch_jwks.js":"evXMh","../util/errors.js":"drZrx","./local.js":"jpAM0","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"evXMh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _errorsJs = require("../util/errors.js");
const fetchJwks = async (url, timeout, options)=>{
    let controller;
    let id;
    let timedOut = false;
    if (typeof AbortController === 'function') {
        controller = new AbortController();
        id = setTimeout(()=>{
            timedOut = true;
            controller.abort();
        }, timeout);
    }
    const response = await fetch(url.href, {
        signal: controller ? controller.signal : undefined,
        redirect: 'manual',
        headers: options.headers
    }).catch((err)=>{
        if (timedOut) throw new (0, _errorsJs.JWKSTimeout)();
        throw err;
    });
    if (id !== undefined) clearTimeout(id);
    if (response.status !== 200) throw new (0, _errorsJs.JOSEError)('Expected 200 OK from the JSON Web Key Set HTTP response');
    try {
        return await response.json();
    } catch (_a) {
        throw new (0, _errorsJs.JOSEError)('Failed to parse the JSON Web Key Set HTTP response as JSON');
    }
};
exports.default = fetchJwks;

},{"../util/errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b7LxK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnsecuredJWT", ()=>UnsecuredJWT);
var _base64UrlJs = require("../runtime/base64url.js");
var _bufferUtilsJs = require("../lib/buffer_utils.js");
var _errorsJs = require("../util/errors.js");
var _jwtClaimsSetJs = require("../lib/jwt_claims_set.js");
var _jwtClaimsSetJsDefault = parcelHelpers.interopDefault(_jwtClaimsSetJs);
var _produceJs = require("./produce.js");
class UnsecuredJWT extends (0, _produceJs.ProduceJWT) {
    encode() {
        const header = _base64UrlJs.encode(JSON.stringify({
            alg: 'none'
        }));
        const payload = _base64UrlJs.encode(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
    }
    static decode(jwt, options) {
        if (typeof jwt !== 'string') throw new (0, _errorsJs.JWTInvalid)('Unsecured JWT must be a string');
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split('.');
        if (length !== 3 || signature !== '') throw new (0, _errorsJs.JWTInvalid)('Invalid Unsecured JWT');
        let header;
        try {
            header = JSON.parse((0, _bufferUtilsJs.decoder).decode(_base64UrlJs.decode(encodedHeader)));
            if (header.alg !== 'none') throw new Error();
        } catch (_a) {
            throw new (0, _errorsJs.JWTInvalid)('Invalid Unsecured JWT');
        }
        const payload = (0, _jwtClaimsSetJsDefault.default)(header, _base64UrlJs.decode(encodedPayload), options);
        return {
            payload,
            header
        };
    }
}

},{"../runtime/base64url.js":"hmfX7","../lib/buffer_utils.js":"6CiRi","../util/errors.js":"drZrx","../lib/jwt_claims_set.js":"bz6vN","./produce.js":"l8xt5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3o6CH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeProtectedHeader", ()=>decodeProtectedHeader);
var _base64UrlJs = require("./base64url.js");
var _bufferUtilsJs = require("../lib/buffer_utils.js");
var _isObjectJs = require("../lib/is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
function decodeProtectedHeader(token) {
    let protectedB64u;
    if (typeof token === 'string') {
        const parts = token.split('.');
        if (parts.length === 3 || parts.length === 5) [protectedB64u] = parts;
    } else if (typeof token === 'object' && token) {
        if ('protected' in token) protectedB64u = token.protected;
        else throw new TypeError('Token does not contain a Protected Header');
    }
    try {
        if (typeof protectedB64u !== 'string' || !protectedB64u) throw new Error();
        const result = JSON.parse((0, _bufferUtilsJs.decoder).decode((0, _base64UrlJs.decode)(protectedB64u)));
        if (!(0, _isObjectJsDefault.default)(result)) throw new Error();
        return result;
    } catch (_a) {
        throw new TypeError('Invalid Token or Protected Header formatting');
    }
}

},{"./base64url.js":"414VB","../lib/buffer_utils.js":"6CiRi","../lib/is_object.js":"6AeNj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"414VB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
var _base64UrlJs = require("../runtime/base64url.js");
const encode = _base64UrlJs.encode;
const decode = _base64UrlJs.decode;

},{"../runtime/base64url.js":"hmfX7","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jHDLT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeJwt", ()=>decodeJwt);
var _base64UrlJs = require("./base64url.js");
var _bufferUtilsJs = require("../lib/buffer_utils.js");
var _isObjectJs = require("../lib/is_object.js");
var _isObjectJsDefault = parcelHelpers.interopDefault(_isObjectJs);
var _errorsJs = require("./errors.js");
function decodeJwt(jwt) {
    if (typeof jwt !== 'string') throw new (0, _errorsJs.JWTInvalid)('JWTs must use Compact JWS serialization, JWT must be a string');
    const { 1: payload, length } = jwt.split('.');
    if (length === 5) throw new (0, _errorsJs.JWTInvalid)('Only JWTs using Compact JWS serialization can be decoded');
    if (length !== 3) throw new (0, _errorsJs.JWTInvalid)('Invalid JWT');
    if (!payload) throw new (0, _errorsJs.JWTInvalid)('JWTs must contain a payload');
    let decoded;
    try {
        decoded = (0, _base64UrlJs.decode)(payload);
    } catch (_a) {
        throw new (0, _errorsJs.JWTInvalid)('Failed to base64url decode the payload');
    }
    let result;
    try {
        result = JSON.parse((0, _bufferUtilsJs.decoder).decode(decoded));
    } catch (_b) {
        throw new (0, _errorsJs.JWTInvalid)('Failed to parse the decoded payload as JSON');
    }
    if (!(0, _isObjectJsDefault.default)(result)) throw new (0, _errorsJs.JWTInvalid)('Invalid JWT Claims Set');
    return result;
}

},{"./base64url.js":"414VB","../lib/buffer_utils.js":"6CiRi","../lib/is_object.js":"6AeNj","./errors.js":"drZrx","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9auQ1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "generateKeyPair", ()=>generateKeyPair);
var _generateJs = require("../runtime/generate.js");
async function generateKeyPair(alg, options) {
    return (0, _generateJs.generateKeyPair)(alg, options);
}

},{"../runtime/generate.js":"jJUio","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jJUio":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "generateSecret", ()=>generateSecret);
parcelHelpers.export(exports, "generateKeyPair", ()=>generateKeyPair);
var _webcryptoJs = require("./webcrypto.js");
var _webcryptoJsDefault = parcelHelpers.interopDefault(_webcryptoJs);
var _errorsJs = require("../util/errors.js");
var _randomJs = require("./random.js");
var _randomJsDefault = parcelHelpers.interopDefault(_randomJs);
async function generateSecret(alg, options) {
    var _a;
    let length;
    let algorithm;
    let keyUsages;
    switch(alg){
        case 'HS256':
        case 'HS384':
        case 'HS512':
            length = parseInt(alg.slice(-3), 10);
            algorithm = {
                name: 'HMAC',
                hash: `SHA-${length}`,
                length
            };
            keyUsages = [
                'sign',
                'verify'
            ];
            break;
        case 'A128CBC-HS256':
        case 'A192CBC-HS384':
        case 'A256CBC-HS512':
            length = parseInt(alg.slice(-3), 10);
            return (0, _randomJsDefault.default)(new Uint8Array(length >> 3));
        case 'A128KW':
        case 'A192KW':
        case 'A256KW':
            length = parseInt(alg.slice(1, 4), 10);
            algorithm = {
                name: 'AES-KW',
                length
            };
            keyUsages = [
                'wrapKey',
                'unwrapKey'
            ];
            break;
        case 'A128GCMKW':
        case 'A192GCMKW':
        case 'A256GCMKW':
        case 'A128GCM':
        case 'A192GCM':
        case 'A256GCM':
            length = parseInt(alg.slice(1, 4), 10);
            algorithm = {
                name: 'AES-GCM',
                length
            };
            keyUsages = [
                'encrypt',
                'decrypt'
            ];
            break;
        default:
            throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
    return (0, _webcryptoJsDefault.default).subtle.generateKey(algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
}
function getModulusLengthOption(options) {
    var _a;
    const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;
    if (typeof modulusLength !== 'number' || modulusLength < 2048) throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used');
    return modulusLength;
}
async function generateKeyPair(alg, options) {
    var _a, _b, _c;
    let algorithm;
    let keyUsages;
    switch(alg){
        case 'PS256':
        case 'PS384':
        case 'PS512':
            algorithm = {
                name: 'RSA-PSS',
                hash: `SHA-${alg.slice(-3)}`,
                publicExponent: new Uint8Array([
                    0x01,
                    0x00,
                    0x01
                ]),
                modulusLength: getModulusLengthOption(options)
            };
            keyUsages = [
                'sign',
                'verify'
            ];
            break;
        case 'RS256':
        case 'RS384':
        case 'RS512':
            algorithm = {
                name: 'RSASSA-PKCS1-v1_5',
                hash: `SHA-${alg.slice(-3)}`,
                publicExponent: new Uint8Array([
                    0x01,
                    0x00,
                    0x01
                ]),
                modulusLength: getModulusLengthOption(options)
            };
            keyUsages = [
                'sign',
                'verify'
            ];
            break;
        case 'RSA-OAEP':
        case 'RSA-OAEP-256':
        case 'RSA-OAEP-384':
        case 'RSA-OAEP-512':
            algorithm = {
                name: 'RSA-OAEP',
                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,
                publicExponent: new Uint8Array([
                    0x01,
                    0x00,
                    0x01
                ]),
                modulusLength: getModulusLengthOption(options)
            };
            keyUsages = [
                'decrypt',
                'unwrapKey',
                'encrypt',
                'wrapKey'
            ];
            break;
        case 'ES256':
            algorithm = {
                name: 'ECDSA',
                namedCurve: 'P-256'
            };
            keyUsages = [
                'sign',
                'verify'
            ];
            break;
        case 'ES384':
            algorithm = {
                name: 'ECDSA',
                namedCurve: 'P-384'
            };
            keyUsages = [
                'sign',
                'verify'
            ];
            break;
        case 'ES512':
            algorithm = {
                name: 'ECDSA',
                namedCurve: 'P-521'
            };
            keyUsages = [
                'sign',
                'verify'
            ];
            break;
        case 'EdDSA':
            keyUsages = [
                'sign',
                'verify'
            ];
            const crv = (_a = options === null || options === void 0 ? void 0 : options.crv) !== null && _a !== void 0 ? _a : 'Ed25519';
            switch(crv){
                case 'Ed25519':
                case 'Ed448':
                    algorithm = {
                        name: crv
                    };
                    break;
                default:
                    throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported crv option provided');
            }
            break;
        case 'ECDH-ES':
        case 'ECDH-ES+A128KW':
        case 'ECDH-ES+A192KW':
        case 'ECDH-ES+A256KW':
            {
                keyUsages = [
                    'deriveKey',
                    'deriveBits'
                ];
                const crv = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : 'P-256';
                switch(crv){
                    case 'P-256':
                    case 'P-384':
                    case 'P-521':
                        algorithm = {
                            name: 'ECDH',
                            namedCurve: crv
                        };
                        break;
                    case 'X25519':
                    case 'X448':
                        algorithm = {
                            name: crv
                        };
                        break;
                    default:
                        throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448');
                }
                break;
            }
        default:
            throw new (0, _errorsJs.JOSENotSupported)('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
    }
    return (0, _webcryptoJsDefault.default).subtle.generateKey(algorithm, (_c = options === null || options === void 0 ? void 0 : options.extractable) !== null && _c !== void 0 ? _c : false, keyUsages);
}

},{"./webcrypto.js":"crCKY","../util/errors.js":"drZrx","./random.js":"2Msed","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"glscP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "generateSecret", ()=>generateSecret);
var _generateJs = require("../runtime/generate.js");
async function generateSecret(alg, options) {
    return (0, _generateJs.generateSecret)(alg, options);
}

},{"../runtime/generate.js":"jJUio","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fbS2R":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _runtimeJs = require("../runtime/runtime.js");
var _runtimeJsDefault = parcelHelpers.interopDefault(_runtimeJs);
exports.default = (0, _runtimeJsDefault.default);

},{"../runtime/runtime.js":"32Jr2","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"32Jr2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = 'WebCryptoAPI';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ffX00":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>t);
var _publicApi = require("@privy-io/public-api");
class t {
    async revoke() {
        await this._privyInternal.fetch((0, _publicApi.WalletsRevoke), {});
    }
    constructor(r){
        this._privyInternal = r;
    }
}

},{"@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1f6Fu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>y);
var _chains = require("@privy-io/chains");
var _errorMjs = require("../Error.mjs");
var _embeddedBitcoinWalletProviderMjs = require("../embedded/EmbeddedBitcoinWalletProvider.mjs");
var _errorsMjs = require("../embedded/errors.mjs");
var _walletCreateMjs = require("../embedded/stack/walletCreate.mjs");
var _indexMjs = require("../embedded/utils/index.mjs");
var _unifiedWalletMjs = require("../wallet-api/unified-wallet.mjs");
var _embeddedWalletProxyMjs = require("../embedded/EmbeddedWalletProxy.mjs");
var _embeddedWalletProviderMjs = require("../embedded/EmbeddedWalletProvider.mjs");
var _embeddedSolanaWalletProviderMjs = require("../embedded/EmbeddedSolanaWalletProvider.mjs");
var _typesMjs = require("../embedded/types.mjs");
var _createMjs = require("../wallet-api/create.mjs");
var _publicApi = require("@privy-io/public-api");
var _abstractSigner = require("@ethersproject/abstract-signer");
var _providers = require("@ethersproject/providers");
var _arbitrumMjs = require("../embedded/gas/arbitrum.mjs");
var _bignumber = require("@ethersproject/bignumber");
var _ethersMjs = require("../embedded/utils/ethers.mjs");
var _bscMjs = require("../embedded/gas/bsc.mjs");
var _opStackMjs = require("../embedded/gas/op-stack.mjs");
var _contracts = require("@ethersproject/contracts");
var _transactions = require("@ethersproject/transactions");
var _polygonMjs = require("../embedded/gas/polygon.mjs");
var _units = require("@ethersproject/units");
var _fetchRetry = require("fetch-retry");
var _gasMjs = require("../embedded/utils/gas.mjs");
var _sleepMjs = require("../utils/sleep.mjs");
var _eventCallbackQueueMjs = require("../embedded/EventCallbackQueue.mjs");
var _withMfaMjs = require("../embedded/withMfa.mjs");
var _eventemitter3 = require("eventemitter3");
var _methodsMjs = require("../embedded/methods.mjs");
var _walletRpcMjs = require("../embedded/stack/walletRpc.mjs");
var _encodingsMjs = require("../utils/encodings.mjs");
var _rpcMjs = require("../wallet-api/rpc.mjs");
var _canonicalize = require("canonicalize");
var _walletApiEthTransactionMjs = require("../embedded/stack/wallet-api-eth-transaction.mjs");
var _walletApiEthTypedDataMjs = require("../embedded/stack/wallet-api-eth-typed-data.mjs");
var _getWalletPublicKeyFromTransactionMjs = require("../solana/getWalletPublicKeyFromTransaction.mjs");
var _isVersionedTransactionMjs = require("../solana/isVersionedTransaction.mjs");
class y {
    setMessagePoster(e) {
        this._proxy = new (0, _embeddedWalletProxyMjs.EmbeddedWalletProxy)(e, this._mfaPromises), this._mfa.setProxy(this._proxy);
    }
    async signWithUserSigner(e) {
        if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
        let r = await this._privyInternal.getAccessToken();
        if (!r) throw new (0, _errorMjs.PrivyClientError)({
            error: "User must be logged in to sign a message with the user signer",
            code: "user_signer_sign_error"
        });
        let { signature: o } = await this._proxy.signWithUserSigner({
            accessToken: r,
            message: e.message
        });
        return {
            signature: o
        };
    }
    async add(e) {
        if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
        if ("user-controlled-server-wallets-only" === this._privyInternal.config?.embedded_wallet_config.mode) throw new (0, _errorMjs.PrivyClientError)({
            error: "This feature is not yet enabled for your application, please contact support",
            code: "embedded_wallet_creation_error"
        });
        let r = await this._privyInternal.getAccessToken();
        if (!r) throw new (0, _errorMjs.PrivyClientError)({
            error: "User must be logged in to create an embedded wallet",
            code: "embedded_wallet_creation_error"
        });
        await this._proxy.addWallet({
            accessToken: r,
            ...e
        });
        let { user: o } = await this._privyInternal.refreshSession();
        return {
            user: o
        };
    }
    async getBitcoinProvider({ wallet: e, entropyId: r, entropyIdVerifier: t, recoveryPassword: i, recoveryAccessToken: d, recoverySecretOverride: s }) {
        if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
        if (!await this._privyInternal.getAccessToken()) throw Error("User must be logged in to create an embedded wallet");
        return (0, _unifiedWalletMjs.isUnifiedWallet)(e) || await this._load({
            entropyId: r,
            entropyIdVerifier: t,
            wallet: e,
            recoveryPassword: i,
            recoveryAccessToken: d,
            recoverySecretOverride: s
        }), new (0, _embeddedBitcoinWalletProviderMjs.EmbeddedBitcoinWalletProvider)({
            account: e,
            privyInternal: this._privyInternal,
            proxy: this._proxy,
            entropyId: r,
            entropyIdVerifier: t
        });
    }
    async create({ password: e, recoveryMethod: r, recoveryToken: o, recoveryKey: i, recoverySecretOverride: s, iCloudRecordNameOverride: a, solanaAccount: n, skipCallbacks: c }) {
        if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
        if ("user-controlled-server-wallets-only" === this._privyInternal.config?.embedded_wallet_config.mode) {
            if (r && !r.startsWith("privy")) throw new (0, _errorMjs.PrivyClientError)({
                error: "User-controlled server wallets do not support custom recovery methods",
                code: "embedded_wallet_creation_error"
            });
            await (0, _walletCreateMjs.walletCreate)({
                context: {
                    app: this._appApi,
                    fetchPrivyRoute: (...e)=>this._privyInternal.fetch(...e),
                    getCompiledPath: (...e)=>this._privyInternal.getPath(...e)
                },
                chainType: "ethereum"
            });
        } else {
            let t;
            if (t = r || (e ? "user-passcode" : "privy"), e && "string" != typeof e) throw Error("Invalid recovery password, must be a string");
            if ("privy" === t && this._privyInternal.config?.embedded_wallet_config.require_user_password_on_create) throw Error("Password not provided yet is required by App configuration");
            let d = await this._privyInternal.getAccessToken();
            if (!d) throw Error("User must be logged in to create an embedded wallet");
            let { address: c } = await this._proxy.create({
                accessToken: d,
                recoveryMethod: t,
                recoveryKey: i,
                recoveryPassword: e,
                recoveryAccessToken: o,
                recoverySecretOverride: s,
                iCloudRecordNameOverride: a,
                solanaAddress: n?.address
            });
            if (!c) throw Error("Failed to create wallet");
        }
        return await this._privyInternal.refreshSession(c);
    }
    async createSolana(e) {
        if (!this._proxy) throw new (0, _errorMjs.PrivyClientError)({
            error: "Embedded wallet proxy not initialized",
            code: "embedded_wallet_creation_error"
        });
        if ("user-controlled-server-wallets-only" === this._privyInternal.config?.embedded_wallet_config.mode) await (0, _walletCreateMjs.walletCreate)({
            context: {
                app: this._appApi,
                fetchPrivyRoute: (...e)=>this._privyInternal.fetch(...e),
                getCompiledPath: (...e)=>this._privyInternal.getPath(...e)
            },
            chainType: "solana"
        });
        else {
            let r = await this._privyInternal.getAccessToken();
            if (!r) throw new (0, _errorMjs.PrivyClientError)({
                error: "User must be logged in to create an embedded wallet",
                code: "embedded_wallet_creation_error"
            });
            e?.ethereumAccount && await this.getProvider(e.ethereumAccount);
            let { publicKey: o } = await this._proxy.createSolana({
                accessToken: r,
                ethereumAddress: e?.ethereumAccount?.address
            });
            if (!o) throw new (0, _errorMjs.PrivyClientError)({
                error: "Failed to create wallet",
                code: "embedded_wallet_creation_error"
            });
        }
        return await this._privyInternal.refreshSession();
    }
    async delegateWallets({ delegatedWallets: e, rootWallet: r }) {
        if (!this._proxy) throw new (0, _errorMjs.PrivyClientError)({
            error: "Embedded wallet proxy not initialized",
            code: "embedded_wallet_creation_error"
        });
        let o = await this._privyInternal.getAccessToken();
        if (!o) throw new (0, _errorMjs.PrivyClientError)({
            error: "User must be logged in to create an embedded wallet",
            code: "embedded_wallet_creation_error"
        });
        await this._proxy.delegateWallets({
            accessToken: o,
            delegatedWallets: e,
            rootWallet: r
        });
    }
    async getProvider(e, r, t, o, i) {
        if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
        return (0, _unifiedWalletMjs.isUnifiedWallet)(e) || await this._load({
            wallet: e,
            entropyId: e.address,
            entropyIdVerifier: "ethereum-address-verifier",
            recoveryPassword: r,
            recoveryKey: i,
            recoveryAccessToken: t,
            recoverySecretOverride: o
        }), new (0, _embeddedWalletProviderMjs.EmbeddedWalletProvider)({
            account: e,
            entropyId: e.address,
            entropyIdVerifier: "ethereum-address-verifier",
            privyInternal: this._privyInternal,
            chains: this._chains,
            walletProxy: this._proxy,
            appApi: this._appApi
        });
    }
    async getEthereumProvider({ wallet: e, entropyId: r, entropyIdVerifier: t, recoveryPassword: o, recoveryAccessToken: i, recoverySecretOverride: d, recoveryKey: s, onNeedsRecovery: n }) {
        if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
        if (!await this._privyInternal.getAccessToken()) throw Error("User must be logged in to create an embedded wallet");
        return (0, _unifiedWalletMjs.isUnifiedWallet)(e) || (!n || o || i || d || s) && await this._load({
            entropyId: r,
            entropyIdVerifier: t,
            wallet: e,
            recoveryPassword: o,
            recoveryAccessToken: i,
            recoverySecretOverride: d,
            recoveryKey: s
        }), new (0, _embeddedWalletProviderMjs.EmbeddedWalletProvider)({
            account: e,
            entropyId: r,
            entropyIdVerifier: "ethereum-address-verifier",
            privyInternal: this._privyInternal,
            chains: this._chains,
            walletProxy: this._proxy,
            onNeedsRecovery: n,
            appApi: this._appApi
        });
    }
    async getSolanaProvider(e, r, o, i, d, s, n) {
        if (!this._proxy) throw new (0, _errorMjs.PrivyClientError)({
            error: "Embedded wallet proxy not initialized",
            code: "embedded_wallet_webview_not_loaded"
        });
        return (0, _unifiedWalletMjs.isUnifiedWallet)(e) || (!n || i || d || s) && await this._load({
            wallet: e,
            entropyId: r,
            entropyIdVerifier: o,
            recoveryPassword: i,
            recoveryAccessToken: d,
            recoverySecretOverride: s
        }), new (0, _embeddedSolanaWalletProviderMjs.EmbeddedSolanaWalletProvider)({
            account: e,
            privyInternal: this._privyInternal,
            proxy: this._proxy,
            entropyId: r,
            entropyIdVerifier: o,
            onNeedsRecovery: n,
            app: this._appApi
        });
    }
    async setRecovery(e) {
        let { wallet: r, ...o } = e;
        if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
        if ((0, _unifiedWalletMjs.isUnifiedWallet)(r)) throw new (0, _errorMjs.PrivyClientError)({
            error: "This wallet does not support setting recovery methods",
            code: "unsupported_recovery_method"
        });
        (0, _indexMjs.throwIfInvalidRecoveryUpgradePath)({
            currentRecoveryMethod: r.recovery_method,
            upgradeToRecoveryMethod: "icloud-native" === o.recoveryMethod ? "icloud" : o.recoveryMethod
        }), await this._load("solana" === r.chain_type ? {
            wallet: r,
            entropyId: r.address,
            entropyIdVerifier: "solana-address-verifier"
        } : {
            wallet: r,
            entropyId: r.address,
            entropyIdVerifier: "ethereum-address-verifier"
        });
        let i = await this._privyInternal.getAccessToken();
        if (!i) throw Error("User must be logged in to interact with embedded wallets");
        let d = r.recovery_method;
        this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_started", {
            address: r.address,
            target_recovery_method: o.recoveryMethod,
            existing_recovery_method: d
        });
        try {
            let e;
            if ("user-passcode" === o.recoveryMethod) e = {
                recoveryMethod: "user-passcode",
                recoveryPassword: o.password
            };
            else if ("google-drive" === o.recoveryMethod) e = {
                recoveryMethod: "google-drive",
                recoveryAccessToken: o.recoveryAccessToken
            };
            else if ("icloud" === o.recoveryMethod) e = {
                recoveryMethod: "icloud",
                recoveryAccessToken: o.recoveryAccessToken
            };
            else if ("icloud-native" === o.recoveryMethod) e = {
                recoveryMethod: "icloud-native",
                iCloudRecordNameOverride: o.iCloudRecordNameOverride,
                recoverySecretOverride: o.recoverySecretOverride
            };
            else if ("recovery-encryption-key" === o.recoveryMethod) e = {
                recoveryMethod: "recovery-encryption-key",
                recoveryKey: o.recoveryKey
            };
            else {
                if ("privy" !== o.recoveryMethod) throw Error(`Unknown recovery method: ${o.recoveryMethod}`);
                e = {
                    recoveryMethod: "privy"
                };
            }
            await this._proxy.setRecovery({
                accessToken: i,
                entropyId: r.address,
                entropyIdVerifier: "solana" === r.chain_type ? "solana-address-verifier" : "ethereum-address-verifier",
                ...e
            }), this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_completed", {
                address: r.address,
                target_recovery_method: o.recoveryMethod,
                existing_recovery_method: d
            });
            let { user: t } = await this._privyInternal.refreshSession();
            return {
                user: t,
                provider: "ethereum" !== r.chain_type ? null : new (0, _embeddedWalletProviderMjs.EmbeddedWalletProvider)({
                    account: r,
                    entropyId: r.address,
                    entropyIdVerifier: "ethereum-address-verifier",
                    privyInternal: this._privyInternal,
                    chains: this._chains,
                    walletProxy: this._proxy,
                    appApi: this._appApi
                })
            };
        } catch (e) {
            throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_set_recovery_failed", {
                address: r.address,
                recovery_method: r.recovery_method,
                error: e instanceof Error ? e.message : "Unable to recover wallet"
            }), e;
        }
    }
    getURL() {
        let e = new URL(`${this._privyInternal.baseUrl}/apps/${this._privyInternal.appId}/embedded-wallets`);
        return this._privyInternal.caid && e.searchParams.append("caid", this._privyInternal.caid), this._privyInternal.appClientId && e.searchParams.append("client_id", this._privyInternal.appClientId), e.href;
    }
    get chains() {
        return this._chains;
    }
    onMessage(e) {
        if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
        return this._proxy.handleEmbeddedWalletMessages(e);
    }
    reload() {
        this._proxy ? this._proxy.reload() : console.warn("Attempted to reload proxy before initialized");
    }
    async ping(e) {
        try {
            if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
            return await this._proxy.ping(e), !0;
        } catch (e) {
            return console.error(e), !1;
        }
    }
    async _load({ entropyId: e, entropyIdVerifier: r, wallet: t, recoveryPassword: o, recoveryKey: d, recoveryAccessToken: s, recoverySecretOverride: a }) {
        if (!this._proxy) throw Error("Embedded wallet proxy not initialized");
        let n = await this._privyInternal.getAccessToken();
        if (!n) throw Error("User must be logged in to interact with embedded wallets");
        try {
            return await this._proxy.connect({
                accessToken: n,
                entropyId: e,
                entropyIdVerifier: r
            }), e;
        } catch (c) {
            if ((0, _errorsMjs.errorIndicatesRecoveryIsNeeded)(c)) try {
                if ("privy" === t.recovery_method) {
                    this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started", {
                        address: t.address,
                        recovery_method: t.recovery_method
                    });
                    let o = await this._proxy.recover({
                        accessToken: n,
                        entropyId: e,
                        entropyIdVerifier: r
                    });
                    return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed", {
                        address: t.address,
                        recovery_method: t.recovery_method
                    }), o.entropyId;
                }
                if ("user-passcode" === t.recovery_method && o) {
                    this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started", {
                        address: t.address,
                        recovery_method: t.recovery_method
                    });
                    let i = await this._proxy.recover({
                        accessToken: n,
                        recoveryPassword: o,
                        entropyId: e,
                        entropyIdVerifier: r
                    });
                    return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed", {
                        address: t.address,
                        recovery_method: t.recovery_method
                    }), i.entropyId;
                }
                if ([
                    "google-drive",
                    "icloud"
                ].includes(t.recovery_method) && s) {
                    this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started", {
                        address: t.address,
                        recovery_method: t.recovery_method
                    });
                    let o = await this._proxy.recover({
                        accessToken: n,
                        recoveryAccessToken: s,
                        entropyId: e,
                        entropyIdVerifier: r
                    });
                    return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed", {
                        address: t.address,
                        recovery_method: t.recovery_method
                    }), o.entropyId;
                }
                if ("icloud" === t.recovery_method && a) {
                    this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started", {
                        address: t.address,
                        recovery_method: "icloud-native"
                    });
                    let o = await this._proxy.recover({
                        accessToken: n,
                        recoverySecretOverride: a,
                        entropyId: e,
                        entropyIdVerifier: r
                    });
                    return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed", {
                        address: t.address,
                        recovery_method: "icloud-native"
                    }), o.entropyId;
                }
                if ("recovery-encryption-key" === t.recovery_method && d) {
                    this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_started", {
                        address: t.address,
                        recovery_method: t.recovery_method
                    });
                    let o = await this._proxy.recover({
                        accessToken: n,
                        recoveryKey: d,
                        entropyId: e,
                        entropyIdVerifier: r
                    });
                    return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_completed", {
                        address: t.address,
                        recovery_method: t.recovery_method
                    }), o.entropyId;
                }
            } catch (r) {
                throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_recovery_failed", {
                    address: t.address,
                    recovery_method: t.recovery_method,
                    error: r instanceof Error ? r.message : `Unable to recover wallet: ${e}`
                }), r;
            }
            throw c;
        }
    }
    constructor(t, o, i, d, s, a){
        if (this._chains = Array.from((0, _chains.DEFAULT_SUPPORTED_CHAINS)), this._privyInternal = t, o && (this._proxy = new (0, _embeddedWalletProxyMjs.EmbeddedWalletProxy)(o, s), d.setProxy(this._proxy)), i) {
            let e = (0, _chains.dedupeSupportedChains)(i);
            this._chains = e;
        }
        this._mfa = d, this._mfaPromises = s, this._appApi = a;
    }
}

},{"@privy-io/chains":"9r5Tr","../Error.mjs":"kMDGn","../embedded/EmbeddedBitcoinWalletProvider.mjs":"6WUGX","../embedded/errors.mjs":"imCDj","../embedded/stack/walletCreate.mjs":"9hdqK","../embedded/utils/index.mjs":"2aCHs","../wallet-api/unified-wallet.mjs":"5BZHk","../embedded/EmbeddedWalletProxy.mjs":"gocS8","../embedded/EmbeddedWalletProvider.mjs":"3vejn","../embedded/EmbeddedSolanaWalletProvider.mjs":"4XBtJ","../embedded/types.mjs":"47MbA","../wallet-api/create.mjs":"hBTEu","@privy-io/public-api":"3ZXNH","@ethersproject/abstract-signer":"bq0ju","@ethersproject/providers":"8k75m","../embedded/gas/arbitrum.mjs":"hCPYQ","@ethersproject/bignumber":"gSTRF","../embedded/utils/ethers.mjs":"1PLH5","../embedded/gas/bsc.mjs":"hbFMz","../embedded/gas/op-stack.mjs":"KVI98","@ethersproject/contracts":"26Zqo","@ethersproject/transactions":"lqSCl","../embedded/gas/polygon.mjs":"4wW2T","@ethersproject/units":"4X8jY","fetch-retry":"knqh8","../embedded/utils/gas.mjs":"bzO8p","../utils/sleep.mjs":"kvTiu","../embedded/EventCallbackQueue.mjs":"4FEdR","../embedded/withMfa.mjs":"1qfQQ","eventemitter3":"8mZjp","../embedded/methods.mjs":"28Nn8","../embedded/stack/walletRpc.mjs":"i6bqj","../utils/encodings.mjs":"cllJf","../wallet-api/rpc.mjs":"fTVkX","canonicalize":"jVWhK","../embedded/stack/wallet-api-eth-transaction.mjs":"aQkVZ","../embedded/stack/wallet-api-eth-typed-data.mjs":"8pORF","../solana/getWalletPublicKeyFromTransaction.mjs":"gDAuD","../solana/isVersionedTransaction.mjs":"4CmTh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9r5Tr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addPrivyRpcToChain", ()=>(0, _addPrivyRpcToChainMjs.addPrivyRpcToChain));
parcelHelpers.export(exports, "addToDefaultChains", ()=>(0, _addChainToDefaultChainsMjs.addToDefaultChains));
parcelHelpers.export(exports, "DEFAULT_SUPPORTED_CHAINS", ()=>(0, _defaultSupportedChainsMjs.DEFAULT_SUPPORTED_CHAINS));
parcelHelpers.export(exports, "DEFAULT_SUPPORTED_CHAIN_IDS", ()=>(0, _defaultSupportedChainsMjs.DEFAULT_SUPPORTED_CHAIN_IDS));
parcelHelpers.export(exports, "addRpcUrlOverrideToChain", ()=>(0, _addRpcUrlOverrideToChainMjs.addRpcUrlOverrideToChain));
parcelHelpers.export(exports, "dedupeSupportedChains", ()=>(0, _dedupeSupportedChainsMjs.dedupeSupportedChains));
parcelHelpers.export(exports, "getSupportedChainById", ()=>(0, _getSupportedChainByIdMjs.getSupportedChainById));
parcelHelpers.export(exports, "arbitrum", ()=>(0, _arbitrumMjs.arbitrum));
parcelHelpers.export(exports, "arbitrumSepolia", ()=>(0, _arbitrumSepoliaMjs.arbitrumSepolia));
parcelHelpers.export(exports, "avalanche", ()=>(0, _avalancheMjs.avalanche));
parcelHelpers.export(exports, "avalancheFuji", ()=>(0, _avalancheFujiMjs.avalancheFuji));
parcelHelpers.export(exports, "base", ()=>(0, _baseMjs.base));
parcelHelpers.export(exports, "baseSepolia", ()=>(0, _baseSepoliaMjs.baseSepolia));
parcelHelpers.export(exports, "celo", ()=>(0, _celoMjs.celo));
parcelHelpers.export(exports, "linea", ()=>(0, _lineaMjs.linea));
parcelHelpers.export(exports, "mainnet", ()=>(0, _mainnetMjs.mainnet));
parcelHelpers.export(exports, "optimism", ()=>(0, _optimismMjs.optimism));
parcelHelpers.export(exports, "optimismSepolia", ()=>(0, _optimismSepoliaMjs.optimismSepolia));
parcelHelpers.export(exports, "polygon", ()=>(0, _polygonMjs.polygon));
parcelHelpers.export(exports, "polygonAmoy", ()=>(0, _polygonAmoyMjs.polygonAmoy));
parcelHelpers.export(exports, "sepolia", ()=>(0, _sepoliaMjs.sepolia));
parcelHelpers.export(exports, "zora", ()=>(0, _zoraMjs.zora));
parcelHelpers.export(exports, "zoraSepolia", ()=>(0, _zoraSepoliaMjs.zoraSepolia));
parcelHelpers.export(exports, "zoraTestnet", ()=>(0, _zoraTestnetMjs.zoraTestnet));
parcelHelpers.export(exports, "VERSION", ()=>e);
var _addPrivyRpcToChainMjs = require("./ethereum/add-privy-rpc-to-chain.mjs");
var _addChainToDefaultChainsMjs = require("./ethereum/add-chain-to-default-chains.mjs");
var _defaultSupportedChainsMjs = require("./ethereum/default-supported-chains.mjs");
var _addRpcUrlOverrideToChainMjs = require("./ethereum/add-rpc-url-override-to-chain.mjs");
var _dedupeSupportedChainsMjs = require("./ethereum/dedupe-supported-chains.mjs");
var _getSupportedChainByIdMjs = require("./ethereum/get-supported-chain-by-id.mjs");
var _arbitrumMjs = require("./ethereum/definitions/arbitrum.mjs");
var _arbitrumSepoliaMjs = require("./ethereum/definitions/arbitrumSepolia.mjs");
var _avalancheMjs = require("./ethereum/definitions/avalanche.mjs");
var _avalancheFujiMjs = require("./ethereum/definitions/avalancheFuji.mjs");
var _baseMjs = require("./ethereum/definitions/base.mjs");
var _baseSepoliaMjs = require("./ethereum/definitions/baseSepolia.mjs");
var _celoMjs = require("./ethereum/definitions/celo.mjs");
var _lineaMjs = require("./ethereum/definitions/linea.mjs");
var _mainnetMjs = require("./ethereum/definitions/mainnet.mjs");
var _optimismMjs = require("./ethereum/definitions/optimism.mjs");
var _optimismSepoliaMjs = require("./ethereum/definitions/optimismSepolia.mjs");
var _polygonMjs = require("./ethereum/definitions/polygon.mjs");
var _polygonAmoyMjs = require("./ethereum/definitions/polygonAmoy.mjs");
var _sepoliaMjs = require("./ethereum/definitions/sepolia.mjs");
var _zoraMjs = require("./ethereum/definitions/zora.mjs");
var _zoraSepoliaMjs = require("./ethereum/definitions/zoraSepolia.mjs");
var _zoraTestnetMjs = require("./ethereum/definitions/zoraTestnet.mjs");
var _berachainArtioMjs = require("./ethereum/definitions/berachainArtio.mjs");
var _celoAlfajoresMjs = require("./ethereum/definitions/celoAlfajores.mjs");
var _filecoinMjs = require("./ethereum/definitions/filecoin.mjs");
var _filecoinCalibrationMjs = require("./ethereum/definitions/filecoinCalibration.mjs");
var _garnetHoleskyMjs = require("./ethereum/definitions/garnetHolesky.mjs");
var _holeskyMjs = require("./ethereum/definitions/holesky.mjs");
var _lineaTestnetMjs = require("./ethereum/definitions/lineaTestnet.mjs");
var _luksoMjs = require("./ethereum/definitions/lukso.mjs");
var _redstoneMjs = require("./ethereum/definitions/redstone.mjs");
const e = "0.0.1";

},{"./ethereum/add-privy-rpc-to-chain.mjs":"5azcy","./ethereum/add-chain-to-default-chains.mjs":"eVsJl","./ethereum/default-supported-chains.mjs":"7nIbb","./ethereum/add-rpc-url-override-to-chain.mjs":"kqZsc","./ethereum/dedupe-supported-chains.mjs":"tqSaU","./ethereum/get-supported-chain-by-id.mjs":"9J0i8","./ethereum/definitions/arbitrum.mjs":"7wBPm","./ethereum/definitions/arbitrumSepolia.mjs":"b8vUj","./ethereum/definitions/avalanche.mjs":"8Bkhx","./ethereum/definitions/avalancheFuji.mjs":"p8WN1","./ethereum/definitions/base.mjs":"8Hirp","./ethereum/definitions/baseSepolia.mjs":"f8HHS","./ethereum/definitions/celo.mjs":"h0ctr","./ethereum/definitions/linea.mjs":"kVqZ0","./ethereum/definitions/mainnet.mjs":"93HFt","./ethereum/definitions/optimism.mjs":"eBEjl","./ethereum/definitions/optimismSepolia.mjs":"iDoPk","./ethereum/definitions/polygon.mjs":"ek0Ug","./ethereum/definitions/polygonAmoy.mjs":"7r7So","./ethereum/definitions/sepolia.mjs":"9ZzSL","./ethereum/definitions/zora.mjs":"l3slW","./ethereum/definitions/zoraSepolia.mjs":"1N4jv","./ethereum/definitions/zoraTestnet.mjs":"gQSa3","./ethereum/definitions/berachainArtio.mjs":"5IMi1","./ethereum/definitions/celoAlfajores.mjs":"dU5OA","./ethereum/definitions/filecoin.mjs":"jzd4V","./ethereum/definitions/filecoinCalibration.mjs":"1SWKd","./ethereum/definitions/garnetHolesky.mjs":"bOJzF","./ethereum/definitions/holesky.mjs":"ftMli","./ethereum/definitions/lineaTestnet.mjs":"aoTfs","./ethereum/definitions/lukso.mjs":"ckozR","./ethereum/definitions/redstone.mjs":"4OWhl","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5azcy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addPrivyRpcToChain", ()=>r);
function r(r, p) {
    return {
        ...r,
        rpcUrls: {
            ...r.rpcUrls,
            privy: {
                http: [
                    p
                ]
            }
        }
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eVsJl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addToDefaultChains", ()=>t);
var _defaultSupportedChainsMjs = require("./default-supported-chains.mjs");
var _arbitrumMjs = require("./definitions/arbitrum.mjs");
var _arbitrumSepoliaMjs = require("./definitions/arbitrumSepolia.mjs");
var _avalancheMjs = require("./definitions/avalanche.mjs");
var _avalancheFujiMjs = require("./definitions/avalancheFuji.mjs");
var _baseMjs = require("./definitions/base.mjs");
var _baseSepoliaMjs = require("./definitions/baseSepolia.mjs");
var _berachainArtioMjs = require("./definitions/berachainArtio.mjs");
var _celoMjs = require("./definitions/celo.mjs");
var _celoAlfajoresMjs = require("./definitions/celoAlfajores.mjs");
var _filecoinMjs = require("./definitions/filecoin.mjs");
var _filecoinCalibrationMjs = require("./definitions/filecoinCalibration.mjs");
var _garnetHoleskyMjs = require("./definitions/garnetHolesky.mjs");
var _holeskyMjs = require("./definitions/holesky.mjs");
var _lineaMjs = require("./definitions/linea.mjs");
var _lineaTestnetMjs = require("./definitions/lineaTestnet.mjs");
var _luksoMjs = require("./definitions/lukso.mjs");
var _mainnetMjs = require("./definitions/mainnet.mjs");
var _optimismMjs = require("./definitions/optimism.mjs");
var _optimismSepoliaMjs = require("./definitions/optimismSepolia.mjs");
var _polygonMjs = require("./definitions/polygon.mjs");
var _polygonAmoyMjs = require("./definitions/polygonAmoy.mjs");
var _redstoneMjs = require("./definitions/redstone.mjs");
var _sepoliaMjs = require("./definitions/sepolia.mjs");
var _zoraMjs = require("./definitions/zora.mjs");
var _zoraSepoliaMjs = require("./definitions/zoraSepolia.mjs");
var _zoraTestnetMjs = require("./definitions/zoraTestnet.mjs");
function t(t) {
    let n = t.filter((o)=>!(0, _defaultSupportedChainsMjs.DEFAULT_SUPPORTED_CHAIN_IDS).has(o.id));
    return (0, _defaultSupportedChainsMjs.DEFAULT_SUPPORTED_CHAINS).concat(n);
}

},{"./default-supported-chains.mjs":"7nIbb","./definitions/arbitrum.mjs":"7wBPm","./definitions/arbitrumSepolia.mjs":"b8vUj","./definitions/avalanche.mjs":"8Bkhx","./definitions/avalancheFuji.mjs":"p8WN1","./definitions/base.mjs":"8Hirp","./definitions/baseSepolia.mjs":"f8HHS","./definitions/berachainArtio.mjs":"5IMi1","./definitions/celo.mjs":"h0ctr","./definitions/celoAlfajores.mjs":"dU5OA","./definitions/filecoin.mjs":"jzd4V","./definitions/filecoinCalibration.mjs":"1SWKd","./definitions/garnetHolesky.mjs":"bOJzF","./definitions/holesky.mjs":"ftMli","./definitions/linea.mjs":"kVqZ0","./definitions/lineaTestnet.mjs":"aoTfs","./definitions/lukso.mjs":"ckozR","./definitions/mainnet.mjs":"93HFt","./definitions/optimism.mjs":"eBEjl","./definitions/optimismSepolia.mjs":"iDoPk","./definitions/polygon.mjs":"ek0Ug","./definitions/polygonAmoy.mjs":"7r7So","./definitions/redstone.mjs":"4OWhl","./definitions/sepolia.mjs":"9ZzSL","./definitions/zora.mjs":"l3slW","./definitions/zoraSepolia.mjs":"1N4jv","./definitions/zoraTestnet.mjs":"gQSa3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7nIbb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_SUPPORTED_CHAINS", ()=>w);
parcelHelpers.export(exports, "DEFAULT_SUPPORTED_CHAIN_IDS", ()=>x);
var _arbitrumMjs = require("./definitions/arbitrum.mjs");
var _arbitrumSepoliaMjs = require("./definitions/arbitrumSepolia.mjs");
var _avalancheMjs = require("./definitions/avalanche.mjs");
var _avalancheFujiMjs = require("./definitions/avalancheFuji.mjs");
var _baseMjs = require("./definitions/base.mjs");
var _baseSepoliaMjs = require("./definitions/baseSepolia.mjs");
var _berachainArtioMjs = require("./definitions/berachainArtio.mjs");
var _celoMjs = require("./definitions/celo.mjs");
var _celoAlfajoresMjs = require("./definitions/celoAlfajores.mjs");
var _filecoinMjs = require("./definitions/filecoin.mjs");
var _filecoinCalibrationMjs = require("./definitions/filecoinCalibration.mjs");
var _garnetHoleskyMjs = require("./definitions/garnetHolesky.mjs");
var _holeskyMjs = require("./definitions/holesky.mjs");
var _lineaMjs = require("./definitions/linea.mjs");
var _lineaTestnetMjs = require("./definitions/lineaTestnet.mjs");
var _luksoMjs = require("./definitions/lukso.mjs");
var _mainnetMjs = require("./definitions/mainnet.mjs");
var _optimismMjs = require("./definitions/optimism.mjs");
var _optimismSepoliaMjs = require("./definitions/optimismSepolia.mjs");
var _polygonMjs = require("./definitions/polygon.mjs");
var _polygonAmoyMjs = require("./definitions/polygonAmoy.mjs");
var _redstoneMjs = require("./definitions/redstone.mjs");
var _sepoliaMjs = require("./definitions/sepolia.mjs");
var _zoraMjs = require("./definitions/zora.mjs");
var _zoraSepoliaMjs = require("./definitions/zoraSepolia.mjs");
var _zoraTestnetMjs = require("./definitions/zoraTestnet.mjs");
const w = [
    (0, _mainnetMjs.mainnet),
    (0, _sepoliaMjs.sepolia),
    (0, _holeskyMjs.holesky),
    (0, _arbitrumMjs.arbitrum),
    (0, _arbitrumSepoliaMjs.arbitrumSepolia),
    (0, _optimismMjs.optimism),
    (0, _optimismSepoliaMjs.optimismSepolia),
    (0, _polygonMjs.polygon),
    (0, _polygonAmoyMjs.polygonAmoy),
    (0, _celoMjs.celo),
    (0, _celoAlfajoresMjs.celoAlfajores),
    (0, _filecoinMjs.filecoin),
    (0, _filecoinCalibrationMjs.filecoinCalibration),
    (0, _baseMjs.base),
    (0, _baseSepoliaMjs.baseSepolia),
    (0, _berachainArtioMjs.berachainArtio),
    (0, _luksoMjs.lukso),
    (0, _lineaMjs.linea),
    (0, _lineaTestnetMjs.lineaTestnet),
    (0, _avalancheMjs.avalanche),
    (0, _avalancheFujiMjs.avalancheFuji),
    (0, _zoraMjs.zora),
    (0, _zoraTestnetMjs.zoraTestnet),
    (0, _zoraSepoliaMjs.zoraSepolia),
    (0, _redstoneMjs.redstone),
    (0, _garnetHoleskyMjs.garnetHolesky)
], x = new Set(w.map((i)=>i.id));

},{"./definitions/arbitrum.mjs":"7wBPm","./definitions/arbitrumSepolia.mjs":"b8vUj","./definitions/avalanche.mjs":"8Bkhx","./definitions/avalancheFuji.mjs":"p8WN1","./definitions/base.mjs":"8Hirp","./definitions/baseSepolia.mjs":"f8HHS","./definitions/berachainArtio.mjs":"5IMi1","./definitions/celo.mjs":"h0ctr","./definitions/celoAlfajores.mjs":"dU5OA","./definitions/filecoin.mjs":"jzd4V","./definitions/filecoinCalibration.mjs":"1SWKd","./definitions/garnetHolesky.mjs":"bOJzF","./definitions/holesky.mjs":"ftMli","./definitions/linea.mjs":"kVqZ0","./definitions/lineaTestnet.mjs":"aoTfs","./definitions/lukso.mjs":"ckozR","./definitions/mainnet.mjs":"93HFt","./definitions/optimism.mjs":"eBEjl","./definitions/optimismSepolia.mjs":"iDoPk","./definitions/polygon.mjs":"ek0Ug","./definitions/polygonAmoy.mjs":"7r7So","./definitions/redstone.mjs":"4OWhl","./definitions/sepolia.mjs":"9ZzSL","./definitions/zora.mjs":"l3slW","./definitions/zoraSepolia.mjs":"1N4jv","./definitions/zoraTestnet.mjs":"gQSa3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7wBPm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arbitrum", ()=>t);
const t = {
    id: 42161,
    name: "Arbitrum One",
    network: "arbitrum",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        privy: {
            http: [
                "https://arbitrum-mainnet.rpc.privy.systems"
            ]
        },
        alchemy: {
            http: [
                "https://arb-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://arb-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://arbitrum-mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://arbitrum-mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://arb1.arbitrum.io/rpc"
            ]
        },
        public: {
            http: [
                "https://arb1.arbitrum.io/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Arbiscan",
            url: "https://arbiscan.io"
        },
        default: {
            name: "Arbiscan",
            url: "https://arbiscan.io"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"b8vUj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "arbitrumSepolia", ()=>r);
const r = {
    id: 421614,
    name: "Arbitrum Sepolia",
    network: "arbitrum-sepolia",
    nativeCurrency: {
        name: "Arbitrum Sepolia Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        privy: {
            http: [
                "https://arbitrum-sepolia.rpc.privy.systems"
            ]
        },
        default: {
            http: [
                "https://sepolia-rollup.arbitrum.io/rpc"
            ]
        },
        public: {
            http: [
                "https://sepolia-rollup.arbitrum.io/rpc"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://sepolia-explorer.arbitrum.io"
        }
    },
    testnet: !0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8Bkhx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "avalanche", ()=>a);
const a = {
    id: 43114,
    name: "Avalanche",
    network: "avalanche",
    nativeCurrency: {
        decimals: 18,
        name: "Avalanche",
        symbol: "AVAX"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.avax.network/ext/bc/C/rpc"
            ]
        },
        public: {
            http: [
                "https://api.avax.network/ext/bc/C/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SnowTrace",
            url: "https://snowtrace.io"
        },
        default: {
            name: "SnowTrace",
            url: "https://snowtrace.io"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"p8WN1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "avalancheFuji", ()=>t);
const t = {
    id: 43113,
    name: "Avalanche Fuji",
    network: "avalanche-fuji",
    nativeCurrency: {
        decimals: 18,
        name: "Avalanche Fuji",
        symbol: "AVAX"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.avax-test.network/ext/bc/C/rpc"
            ]
        },
        public: {
            http: [
                "https://api.avax-test.network/ext/bc/C/rpc"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "SnowTrace",
            url: "https://testnet.snowtrace.io"
        },
        default: {
            name: "SnowTrace",
            url: "https://testnet.snowtrace.io"
        }
    },
    testnet: !0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8Hirp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base", ()=>t);
const t = {
    id: 8453,
    network: "base",
    name: "Base",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        privy: {
            http: [
                "https://base-mainnet.rpc.privy.systems"
            ]
        },
        blast: {
            http: [
                "https://base-mainnet.blastapi.io"
            ],
            webSocket: [
                "wss://base-mainnet.blastapi.io"
            ]
        },
        default: {
            http: [
                "https://mainnet.base.org"
            ]
        },
        public: {
            http: [
                "https://mainnet.base.org"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Basescan",
            url: "https://basescan.org"
        },
        default: {
            name: "Basescan",
            url: "https://basescan.org"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f8HHS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "baseSepolia", ()=>e);
const e = {
    id: 84532,
    network: "base-sepolia",
    name: "Base Sepolia",
    nativeCurrency: {
        name: "Sepolia Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        privy: {
            http: [
                "https://base-sepolia.rpc.privy.systems"
            ]
        },
        default: {
            http: [
                "https://sepolia.base.org"
            ]
        },
        public: {
            http: [
                "https://sepolia.base.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://base-sepolia.blockscout.com"
        }
    },
    testnet: !0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5IMi1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "berachainArtio", ()=>t);
const t = {
    id: 80085,
    network: "berachain-artio",
    name: "Berachain Artio",
    nativeCurrency: {
        name: "BERA",
        symbol: "BERA",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://berachain-artio.rpc.privy.systems"
            ]
        },
        public: {
            http: [
                "https://berachain-artio.rpc.privy.systems"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Beratrail",
            url: "https://artio.beratrail.io"
        }
    },
    testnet: !0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"h0ctr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "celo", ()=>e);
const e = {
    id: 42220,
    name: "Celo Mainnet",
    network: "celo",
    nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "CELO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://forno.celo.org"
            ]
        },
        infura: {
            http: [
                "https://celo-mainnet.infura.io/v3"
            ]
        },
        public: {
            http: [
                "https://forno.celo.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Celo Explorer",
            url: "https://explorer.celo.org/mainnet"
        },
        etherscan: {
            name: "CeloScan",
            url: "https://celoscan.io"
        }
    },
    testnet: !1
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dU5OA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "celoAlfajores", ()=>e);
const e = {
    id: 44787,
    name: "Celo Alfajores Testnet",
    network: "celo-alfajores",
    nativeCurrency: {
        decimals: 18,
        name: "CELO",
        symbol: "CELO"
    },
    rpcUrls: {
        default: {
            http: [
                "https://alfajores-forno.celo-testnet.org"
            ]
        },
        infura: {
            http: [
                "https://celo-alfajores.infura.io/v3"
            ]
        },
        public: {
            http: [
                "https://alfajores-forno.celo-testnet.org"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Celo Explorer",
            url: "https://explorer.celo.org/alfajores"
        },
        etherscan: {
            name: "CeloScan",
            url: "https://alfajores.celoscan.io/"
        }
    },
    testnet: !0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jzd4V":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filecoin", ()=>i);
const i = {
    id: 314,
    name: "Filecoin - Mainnet",
    network: "filecoin-mainnet",
    nativeCurrency: {
        decimals: 18,
        name: "filecoin",
        symbol: "FIL"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.node.glif.io/rpc/v1"
            ]
        },
        public: {
            http: [
                "https://api.node.glif.io/rpc/v1"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Filfox",
            url: "https://filfox.info/en"
        },
        filscan: {
            name: "Filscan",
            url: "https://filscan.io"
        },
        filscout: {
            name: "Filscout",
            url: "https://filscout.io/en"
        },
        glif: {
            name: "Glif",
            url: "https://explorer.glif.io"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1SWKd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filecoinCalibration", ()=>i);
const i = {
    id: 314159,
    name: "Filecoin - Calibration testnet",
    network: "filecoin-calibration",
    nativeCurrency: {
        decimals: 18,
        name: "testnet filecoin",
        symbol: "tFIL"
    },
    rpcUrls: {
        default: {
            http: [
                "https://api.calibration.node.glif.io/rpc/v1"
            ]
        },
        public: {
            http: [
                "https://api.calibration.node.glif.io/rpc/v1"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Filscan",
            url: "https://calibration.filscan.io"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bOJzF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "garnetHolesky", ()=>t);
const t = {
    id: 17069,
    name: "Garnet Holesky",
    network: "garnet-holesky",
    nativeCurrency: {
        name: "ETH",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.garnetchain.com"
            ]
        },
        public: {
            http: [
                "https://rpc.garnetchain.com"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://explorer.garnetchain.com"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ftMli":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "holesky", ()=>e);
const e = {
    id: 17e3,
    name: "Holesky",
    network: "holesky",
    nativeCurrency: {
        name: "ETH",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://ethereum-holesky.publicnode.com"
            ]
        },
        public: {
            http: [
                "https://ethereum-holesky.publicnode.com"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "EtherScan",
            url: "https://holesky.etherscan.io"
        },
        default: {
            name: "EtherScan",
            url: "https://holesky.etherscan.io"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kVqZ0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "linea", ()=>e);
const e = {
    id: 59144,
    network: "linea-mainnet",
    name: "Linea Mainnet",
    nativeCurrency: {
        name: "Linea Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.linea.build"
            ],
            webSocket: [
                "wss://rpc.linea.build"
            ]
        },
        public: {
            http: [
                "https://rpc.linea.build"
            ],
            webSocket: [
                "wss://rpc.linea.build"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Etherscan",
            url: "https://lineascan.build"
        },
        etherscan: {
            name: "Etherscan",
            url: "https://lineascan.build"
        }
    },
    testnet: !1
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aoTfs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lineaTestnet", ()=>e);
const e = {
    id: 59140,
    network: "linea-testnet",
    name: "Linea Goerli Testnet",
    nativeCurrency: {
        name: "Linea Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        infura: {
            http: [
                "https://linea-goerli.infura.io/v3"
            ],
            webSocket: [
                "wss://linea-goerli.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://rpc.goerli.linea.build"
            ],
            webSocket: [
                "wss://rpc.goerli.linea.build"
            ]
        },
        public: {
            http: [
                "https://rpc.goerli.linea.build"
            ],
            webSocket: [
                "wss://rpc.goerli.linea.build"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Etherscan",
            url: "https://goerli.lineascan.build"
        },
        etherscan: {
            name: "Etherscan",
            url: "https://goerli.lineascan.build"
        }
    },
    testnet: !0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ckozR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "lukso", ()=>e);
const e = {
    id: 42,
    network: "lukso",
    name: "LUKSO",
    nativeCurrency: {
        name: "LUKSO",
        symbol: "LYX",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.mainnet.lukso.network"
            ],
            webSocket: [
                "wss://ws-rpc.mainnet.lukso.network"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "LUKSO Mainnet Explorer",
            url: "https://explorer.execution.mainnet.lukso.network"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"93HFt":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mainnet", ()=>t);
const t = {
    id: 1,
    network: "homestead",
    name: "Ethereum",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        privy: {
            http: [
                "https://mainnet.rpc.privy.systems"
            ]
        },
        alchemy: {
            http: [
                "https://eth-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://eth-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://cloudflare-eth.com"
            ]
        },
        public: {
            http: [
                "https://cloudflare-eth.com"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://etherscan.io"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eBEjl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "optimism", ()=>t);
const t = {
    id: 10,
    name: "OP Mainnet",
    network: "optimism",
    nativeCurrency: {
        name: "Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        privy: {
            http: [
                "https://optimism-mainnet.rpc.privy.systems"
            ]
        },
        alchemy: {
            http: [
                "https://opt-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://opt-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://optimism-mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://optimism-mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://mainnet.optimism.io"
            ]
        },
        public: {
            http: [
                "https://mainnet.optimism.io"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://optimistic.etherscan.io"
        },
        default: {
            name: "Optimism Explorer",
            url: "https://explorer.optimism.io"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iDoPk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "optimismSepolia", ()=>t);
const t = {
    id: 11155420,
    name: "Optimism Sepolia",
    network: "optimism-sepolia",
    nativeCurrency: {
        name: "Sepolia Ether",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        privy: {
            http: [
                "https://optimism-sepolia.rpc.privy.systems"
            ]
        },
        default: {
            http: [
                "https://sepolia.optimism.io"
            ]
        },
        public: {
            http: [
                "https://sepolia.optimism.io"
            ]
        },
        infura: {
            http: [
                "https://optimism-sepolia.infura.io/v3"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://optimism-sepolia.blockscout.com"
        }
    },
    testnet: !0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ek0Ug":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "polygon", ()=>o);
const o = {
    id: 137,
    name: "Polygon Mainnet",
    network: "polygon",
    nativeCurrency: {
        name: "POL",
        symbol: "POL",
        decimals: 18
    },
    rpcUrls: {
        privy: {
            http: [
                "https://polygon-mainnet.rpc.privy.systems"
            ]
        },
        alchemy: {
            http: [
                "https://polygon-mainnet.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://polygon-mainnet.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://polygon-mainnet.infura.io/v3"
            ],
            webSocket: [
                "wss://polygon-mainnet.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://polygon-rpc.com"
            ]
        },
        public: {
            http: [
                "https://polygon-rpc.com"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "PolygonScan",
            url: "https://polygonscan.com"
        },
        default: {
            name: "PolygonScan",
            url: "https://polygonscan.com"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7r7So":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "polygonAmoy", ()=>o);
const o = {
    id: 80002,
    name: "Polygon Amoy",
    network: "polygon-amoy",
    nativeCurrency: {
        name: "POL",
        symbol: "POL",
        decimals: 18
    },
    rpcUrls: {
        privy: {
            http: [
                "https://polygon-amoy.rpc.privy.systems"
            ]
        },
        infura: {
            http: [
                "https://polygon-amoy.infura.io/v3"
            ],
            webSocket: [
                "wss://polygon-amoy.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://rpc-amoy.polygon.technology"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "OK LINK",
            url: "https://www.oklink.com/amoy"
        }
    },
    testnet: !0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4OWhl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "redstone", ()=>e);
const e = {
    id: 690,
    name: "Redstone",
    network: "redstone",
    nativeCurrency: {
        name: "ETH",
        symbol: "ETH",
        decimals: 18
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.redstonechain.com"
            ]
        },
        public: {
            http: [
                "https://rpc.redstonechain.com"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Blockscout",
            url: "https://explorer.redstone.xyz/"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9ZzSL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sepolia", ()=>e);
const e = {
    id: 11155111,
    network: "sepolia",
    name: "Sepolia",
    nativeCurrency: {
        name: "Sepolia Ether",
        symbol: "SEP",
        decimals: 18
    },
    rpcUrls: {
        privy: {
            http: [
                "https://sepolia.rpc.privy.systems"
            ]
        },
        alchemy: {
            http: [
                "https://eth-sepolia.g.alchemy.com/v2"
            ],
            webSocket: [
                "wss://eth-sepolia.g.alchemy.com/v2"
            ]
        },
        infura: {
            http: [
                "https://sepolia.infura.io/v3"
            ],
            webSocket: [
                "wss://sepolia.infura.io/ws/v3"
            ]
        },
        default: {
            http: [
                "https://rpc.sepolia.org"
            ]
        },
        public: {
            http: [
                "https://rpc.sepolia.org"
            ]
        }
    },
    blockExplorers: {
        etherscan: {
            name: "Etherscan",
            url: "https://sepolia.etherscan.io"
        },
        default: {
            name: "Etherscan",
            url: "https://sepolia.etherscan.io"
        }
    },
    testnet: !0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l3slW":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zora", ()=>r);
const r = {
    id: 7777777,
    name: "Zora",
    network: "zora",
    nativeCurrency: {
        decimals: 18,
        name: "Ether",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "https://rpc.zora.energy"
            ],
            webSocket: [
                "wss://rpc.zora.energy"
            ]
        },
        public: {
            http: [
                "https://rpc.zora.energy"
            ],
            webSocket: [
                "wss://rpc.zora.energy"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Explorer",
            url: "https://explorer.zora.energy"
        }
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1N4jv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zoraSepolia", ()=>e);
const e = {
    id: 999999999,
    name: "Zora Sepolia",
    network: "zora-sepolia",
    nativeCurrency: {
        decimals: 18,
        name: "Zora Sepolia",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "https://sepolia.rpc.zora.energy"
            ],
            webSocket: [
                "wss://sepolia.rpc.zora.energy"
            ]
        },
        public: {
            http: [
                "https://sepolia.rpc.zora.energy"
            ],
            webSocket: [
                "wss://sepolia.rpc.zora.energy"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Zora Sepolia Explorer",
            url: "https://sepolia.explorer.zora.energy/"
        }
    },
    testnet: !0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gQSa3":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zoraTestnet", ()=>e);
const e = {
    id: 999,
    name: "Zora Goerli Testnet",
    network: "zora-testnet",
    nativeCurrency: {
        decimals: 18,
        name: "Zora Goerli",
        symbol: "ETH"
    },
    rpcUrls: {
        default: {
            http: [
                "https://testnet.rpc.zora.energy"
            ],
            webSocket: [
                "wss://testnet.rpc.zora.energy"
            ]
        },
        public: {
            http: [
                "https://testnet.rpc.zora.energy"
            ],
            webSocket: [
                "wss://testnet.rpc.zora.energy"
            ]
        }
    },
    blockExplorers: {
        default: {
            name: "Explorer",
            url: "https://testnet.explorer.zora.energy"
        }
    },
    testnet: !0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kqZsc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "addRpcUrlOverrideToChain", ()=>r);
function r(r, t) {
    return {
        ...r,
        rpcUrls: {
            ...r.rpcUrls,
            privyWalletOverride: {
                http: [
                    t
                ]
            }
        }
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"tqSaU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "dedupeSupportedChains", ()=>t);
var _addPrivyRpcToChainMjs = require("./add-privy-rpc-to-chain.mjs");
var _defaultSupportedChainsMjs = require("./default-supported-chains.mjs");
var _arbitrumMjs = require("./definitions/arbitrum.mjs");
var _arbitrumSepoliaMjs = require("./definitions/arbitrumSepolia.mjs");
var _avalancheMjs = require("./definitions/avalanche.mjs");
var _avalancheFujiMjs = require("./definitions/avalancheFuji.mjs");
var _baseMjs = require("./definitions/base.mjs");
var _baseSepoliaMjs = require("./definitions/baseSepolia.mjs");
var _berachainArtioMjs = require("./definitions/berachainArtio.mjs");
var _celoMjs = require("./definitions/celo.mjs");
var _celoAlfajoresMjs = require("./definitions/celoAlfajores.mjs");
var _filecoinMjs = require("./definitions/filecoin.mjs");
var _filecoinCalibrationMjs = require("./definitions/filecoinCalibration.mjs");
var _garnetHoleskyMjs = require("./definitions/garnetHolesky.mjs");
var _holeskyMjs = require("./definitions/holesky.mjs");
var _lineaMjs = require("./definitions/linea.mjs");
var _lineaTestnetMjs = require("./definitions/lineaTestnet.mjs");
var _luksoMjs = require("./definitions/lukso.mjs");
var _mainnetMjs = require("./definitions/mainnet.mjs");
var _optimismMjs = require("./definitions/optimism.mjs");
var _optimismSepoliaMjs = require("./definitions/optimismSepolia.mjs");
var _polygonMjs = require("./definitions/polygon.mjs");
var _polygonAmoyMjs = require("./definitions/polygonAmoy.mjs");
var _redstoneMjs = require("./definitions/redstone.mjs");
var _sepoliaMjs = require("./definitions/sepolia.mjs");
var _zoraMjs = require("./definitions/zora.mjs");
var _zoraSepoliaMjs = require("./definitions/zoraSepolia.mjs");
var _zoraTestnetMjs = require("./definitions/zoraTestnet.mjs");
const t = (t)=>t.map((t)=>{
        if (t.rpcUrls.privyWalletOverride) return t;
        let n = (0, _defaultSupportedChainsMjs.DEFAULT_SUPPORTED_CHAINS).find((i)=>i.id === t.id), s = n?.rpcUrls.privy?.http[0];
        return s ? (0, _addPrivyRpcToChainMjs.addPrivyRpcToChain)(t, s) : t;
    });

},{"./add-privy-rpc-to-chain.mjs":"5azcy","./default-supported-chains.mjs":"7nIbb","./definitions/arbitrum.mjs":"7wBPm","./definitions/arbitrumSepolia.mjs":"b8vUj","./definitions/avalanche.mjs":"8Bkhx","./definitions/avalancheFuji.mjs":"p8WN1","./definitions/base.mjs":"8Hirp","./definitions/baseSepolia.mjs":"f8HHS","./definitions/berachainArtio.mjs":"5IMi1","./definitions/celo.mjs":"h0ctr","./definitions/celoAlfajores.mjs":"dU5OA","./definitions/filecoin.mjs":"jzd4V","./definitions/filecoinCalibration.mjs":"1SWKd","./definitions/garnetHolesky.mjs":"bOJzF","./definitions/holesky.mjs":"ftMli","./definitions/linea.mjs":"kVqZ0","./definitions/lineaTestnet.mjs":"aoTfs","./definitions/lukso.mjs":"ckozR","./definitions/mainnet.mjs":"93HFt","./definitions/optimism.mjs":"eBEjl","./definitions/optimismSepolia.mjs":"iDoPk","./definitions/polygon.mjs":"ek0Ug","./definitions/polygonAmoy.mjs":"7r7So","./definitions/redstone.mjs":"4OWhl","./definitions/sepolia.mjs":"9ZzSL","./definitions/zora.mjs":"l3slW","./definitions/zoraSepolia.mjs":"1N4jv","./definitions/zoraTestnet.mjs":"gQSa3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9J0i8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSupportedChainById", ()=>o);
var _defaultSupportedChainsMjs = require("./default-supported-chains.mjs");
var _arbitrumMjs = require("./definitions/arbitrum.mjs");
var _arbitrumSepoliaMjs = require("./definitions/arbitrumSepolia.mjs");
var _avalancheMjs = require("./definitions/avalanche.mjs");
var _avalancheFujiMjs = require("./definitions/avalancheFuji.mjs");
var _baseMjs = require("./definitions/base.mjs");
var _baseSepoliaMjs = require("./definitions/baseSepolia.mjs");
var _berachainArtioMjs = require("./definitions/berachainArtio.mjs");
var _celoMjs = require("./definitions/celo.mjs");
var _celoAlfajoresMjs = require("./definitions/celoAlfajores.mjs");
var _filecoinMjs = require("./definitions/filecoin.mjs");
var _filecoinCalibrationMjs = require("./definitions/filecoinCalibration.mjs");
var _garnetHoleskyMjs = require("./definitions/garnetHolesky.mjs");
var _holeskyMjs = require("./definitions/holesky.mjs");
var _lineaMjs = require("./definitions/linea.mjs");
var _lineaTestnetMjs = require("./definitions/lineaTestnet.mjs");
var _luksoMjs = require("./definitions/lukso.mjs");
var _mainnetMjs = require("./definitions/mainnet.mjs");
var _optimismMjs = require("./definitions/optimism.mjs");
var _optimismSepoliaMjs = require("./definitions/optimismSepolia.mjs");
var _polygonMjs = require("./definitions/polygon.mjs");
var _polygonAmoyMjs = require("./definitions/polygonAmoy.mjs");
var _redstoneMjs = require("./definitions/redstone.mjs");
var _sepoliaMjs = require("./definitions/sepolia.mjs");
var _zoraMjs = require("./definitions/zora.mjs");
var _zoraSepoliaMjs = require("./definitions/zoraSepolia.mjs");
var _zoraTestnetMjs = require("./definitions/zoraTestnet.mjs");
const o = (o)=>(0, _defaultSupportedChainsMjs.DEFAULT_SUPPORTED_CHAINS).find((i)=>i.id === o);

},{"./default-supported-chains.mjs":"7nIbb","./definitions/arbitrum.mjs":"7wBPm","./definitions/arbitrumSepolia.mjs":"b8vUj","./definitions/avalanche.mjs":"8Bkhx","./definitions/avalancheFuji.mjs":"p8WN1","./definitions/base.mjs":"8Hirp","./definitions/baseSepolia.mjs":"f8HHS","./definitions/berachainArtio.mjs":"5IMi1","./definitions/celo.mjs":"h0ctr","./definitions/celoAlfajores.mjs":"dU5OA","./definitions/filecoin.mjs":"jzd4V","./definitions/filecoinCalibration.mjs":"1SWKd","./definitions/garnetHolesky.mjs":"bOJzF","./definitions/holesky.mjs":"ftMli","./definitions/linea.mjs":"kVqZ0","./definitions/lineaTestnet.mjs":"aoTfs","./definitions/lukso.mjs":"ckozR","./definitions/mainnet.mjs":"93HFt","./definitions/optimism.mjs":"eBEjl","./definitions/optimismSepolia.mjs":"iDoPk","./definitions/polygon.mjs":"ek0Ug","./definitions/polygonAmoy.mjs":"7r7So","./definitions/redstone.mjs":"4OWhl","./definitions/sepolia.mjs":"9ZzSL","./definitions/zora.mjs":"l3slW","./definitions/zoraSepolia.mjs":"1N4jv","./definitions/zoraTestnet.mjs":"gQSa3","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kMDGn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MoonpayApiError", ()=>o);
parcelHelpers.export(exports, "PrivyApiError", ()=>r);
parcelHelpers.export(exports, "PrivyClientError", ()=>e);
parcelHelpers.export(exports, "createErrorFormatter", ()=>s);
parcelHelpers.export(exports, "errorIndicatesMfaCanceled", ()=>c);
class r extends Error {
    constructor({ error: r, code: e }){
        super(r), this.error = r, this.code = e;
    }
}
class e extends Error {
    constructor({ error: r, code: e }){
        super(r), this.code = e, this.error = r;
    }
}
class o extends Error {
    constructor({ error: r, code: e, response: o }){
        super(r), this.code = e, this.error = r, this.response = o;
    }
}
const s = (o)=>(s)=>o[s instanceof r || s instanceof e ? s.code : "unknown_error"] ?? o.default;
function c(r) {
    return r && "object" == typeof r && "code" in r && "mfa_canceled" === r.code;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6WUGX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmbeddedBitcoinWalletProvider", ()=>t);
var _errorMjs = require("../Error.mjs");
class t {
    async sign({ message: e }) {
        return await this.request({
            method: "sign",
            params: {
                message: new TextDecoder("utf8").decode(e)
            }
        });
    }
    async signTransaction({ psbt: e }) {
        return await this.request({
            method: "signTransaction",
            params: {
                psbt: e
            }
        });
    }
    async request(t) {
        if (!await this._privyInternal.getAccessToken()) throw new (0, _errorMjs.PrivyClientError)({
            error: "Missing access token",
            code: "attempted_rpc_call_before_logged_in"
        });
        return this.handleIFrameRpc(t);
    }
    async handleIFrameRpc(t) {
        try {
            let e = await this._privyInternal.getAccessToken();
            if (!e) throw Error("Missing access token. User must be authenticated.");
            return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started", {
                method: t.method,
                address: this._account.address
            }), (await this._proxy.rpcWallet({
                accessToken: e,
                request: t,
                entropyId: this._entropyId,
                entropyIdVerifier: this._entropyIdVerifier,
                hdWalletIndex: this._account.wallet_index,
                chainType: this._account.chain_type
            })).response.data;
        } catch (r) {
            console.error(r);
            let s = r instanceof Error ? r.message : "Unable to make wallet request";
            throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed", {
                method: t.method,
                address: this._account.address,
                error: s
            }), new (0, _errorMjs.PrivyClientError)({
                code: "embedded_wallet_request_error",
                error: s
            });
        }
    }
    toJSON() {
        return `PrivyEmbeddedBitcoinProvider { address: '${this._account.address}', request: [Function] }`;
    }
    constructor({ proxy: e, privyInternal: t, account: r, entropyId: s, entropyIdVerifier: a }){
        this._proxy = e, this._privyInternal = t, this._account = r, this._entropyId = s, this._entropyIdVerifier = a;
    }
}

},{"../Error.mjs":"kMDGn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"imCDj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmbeddedProviderError", ()=>d);
parcelHelpers.export(exports, "PrivyConnectorError", ()=>i);
parcelHelpers.export(exports, "PrivyEmbeddedWalletErrorCode", ()=>r);
parcelHelpers.export(exports, "PrivyError", ()=>s);
parcelHelpers.export(exports, "PrivyIframeError", ()=>o);
parcelHelpers.export(exports, "PrivyProviderRpcError", ()=>N);
parcelHelpers.export(exports, "ProviderErrors", ()=>n);
parcelHelpers.export(exports, "ProviderRpcError", ()=>a);
parcelHelpers.export(exports, "errorIndicatesMaxMfaRetries", ()=>c);
parcelHelpers.export(exports, "errorIndicatesMfaRateLimit", ()=>T);
parcelHelpers.export(exports, "errorIndicatesMfaTimeout", ()=>l);
parcelHelpers.export(exports, "errorIndicatesMfaVerificationFailed", ()=>u);
parcelHelpers.export(exports, "errorIndicatesRecoveryIsNeeded", ()=>E);
parcelHelpers.export(exports, "isPrivyIframeError", ()=>_);
var _typesMjs = require("./types.mjs");
var t, r = ((t = {}).MISSING_OR_INVALID_PRIVY_APP_ID = "missing_or_invalid_privy_app_id", t.MISSING_OR_INVALID_PRIVY_ACCOUNT_ID = "missing_or_invalid_privy_account_id", t.INVALID_DATA = "invalid_data", t.LINKED_TO_ANOTHER_USER = "linked_to_another_user", t.ALLOWLIST_REJECTED = "allowlist_rejected", t.OAUTH_USER_DENIED = "oauth_user_denied", t.UNKNOWN_AUTH_ERROR = "unknown_auth_error", t.USER_EXITED_AUTH_FLOW = "exited_auth_flow", t.MUST_BE_AUTHENTICATED = "must_be_authenticated", t.UNKNOWN_CONNECT_WALLET_ERROR = "unknown_connect_wallet_error", t.GENERIC_CONNECT_WALLET_ERROR = "generic_connect_wallet_error", t.CLIENT_REQUEST_TIMEOUT = "client_request_timeout", t.INVALID_CREDENTIALS = "invalid_credentials", t);
class s extends Error {
    toString() {
        return `${this.type}${this.privyErrorCode ? `-${this.privyErrorCode}` : ""}: ${this.message}${this.cause ? ` [cause: ${this.cause}]` : ""}`;
    }
    constructor(e, t, r){
        super(e), t instanceof Error && (this.cause = t), this.privyErrorCode = r;
    }
}
class a extends s {
    constructor(e, t, r){
        super(e), this.type = "provider_error", this.code = t, this.data = r;
    }
}
class o extends Error {
    constructor(e, t){
        super(t), this.type = e;
    }
}
class i extends s {
    constructor(e, t, r){
        super(e, t, r), this.type = "connector_error";
    }
}
class d extends Error {
    constructor(e, t, r){
        super(e), this.code = t, this.data = r;
    }
}
const n = {
    UNKNOWN_ERROR: {
        eipCode: 0,
        message: "Unknown error",
        detail: "Unknown error",
        retryable: !0
    },
    E4001_DEFAULT_USER_REJECTED_REQUEST: {
        eipCode: 4001,
        message: "User Rejected Request",
        detail: "The user rejected the request.",
        default: !0,
        retryable: !0
    },
    E4100_DEFAULT_UNAUTHORIZED: {
        eipCode: 4100,
        message: "Unauthorized",
        detail: "The requested method and/or account has not been authorized by the user.",
        default: !0,
        retryable: !1
    },
    E4200_DEFAULT_UNSUPPORTED_METHOD: {
        eipCode: 4200,
        message: "Unsupported Method",
        detail: "The Provider does not support the requested method.",
        default: !0,
        retryable: !1
    },
    E4900_DEFAULT_DISCONNECTED: {
        eipCode: 4900,
        message: "Disconnected",
        detail: "The Provider is disconnected from all chains.",
        default: !0,
        retryable: !0
    },
    E4901_DEFAULT_CHAIN_DISCONNECTED: {
        eipCode: 4901,
        message: "Chain Disconnected",
        detail: "The Provider is not connected to the requested chain.",
        default: !0,
        retryable: !0
    },
    E32700_DEFAULT_PARSE_ERROR: {
        eipCode: -32700,
        message: "Parse error",
        detail: "Invalid JSON",
        default: !0,
        retryable: !1
    },
    E32600_DEFAULT_INVALID_REQUEST: {
        eipCode: -32600,
        message: "Invalid request",
        detail: "JSON is not a valid request object",
        default: !0,
        retryable: !1
    },
    E32601_DEFAULT_METHOD_NOT_FOUND: {
        eipCode: -32601,
        message: "Method not found",
        detail: "Method does not exist",
        default: !0,
        retryable: !1
    },
    E32602_DEFAULT_INVALID_PARAMS: {
        eipCode: -32602,
        message: "Invalid params",
        detail: "Invalid method parameters",
        default: !0,
        retryable: !1
    },
    E32603_DEFAULT_INTERNAL_ERROR: {
        eipCode: -32603,
        message: "Internal error",
        detail: "Internal JSON-RPC error",
        default: !0,
        retryable: !0
    },
    E32000_DEFAULT_INVALID_INPUT: {
        eipCode: -32000,
        message: "Invalid input",
        detail: "Missing or invalid parameters",
        default: !0,
        retryable: !1
    },
    E32001_DEFAULT_RESOURCE_NOT_FOUND: {
        eipCode: -32001,
        message: "Resource not found",
        detail: "Requested resource not found",
        default: !0,
        retryable: !1
    },
    E32002_DEFAULT_RESOURCE_UNAVAILABLE: {
        eipCode: -32002,
        message: "Resource unavailable",
        detail: "Requested resource not available",
        default: !0,
        retryable: !0
    },
    E32003_DEFAULT_TRANSACTION_REJECTED: {
        eipCode: -32003,
        message: "Transaction rejected",
        detail: "Transaction creation failed",
        default: !0,
        retryable: !0
    },
    E32004_DEFAULT_METHOD_NOT_SUPPORTED: {
        eipCode: -32004,
        message: "Method not supported",
        detail: "Method is not implemented",
        default: !0,
        retryable: !1
    },
    E32005_DEFAULT_LIMIT_EXCEEDED: {
        eipCode: -32005,
        message: "Limit exceeded",
        detail: "Request exceeds defined limit",
        default: !0,
        retryable: !1
    },
    E32006_DEFAULT_JSON_RPC_VERSION_NOT_SUPPORTED: {
        eipCode: -32006,
        message: "JSON-RPC version not supported",
        detail: "Version of JSON-RPC protocol is not supported",
        default: !0,
        retryable: !1
    },
    E32002_CONNECTION_ALREADY_PENDING: {
        eipCode: -32002,
        message: "Connection request already pending",
        detail: "Don\u2019t see your wallet? Check your other browser windows.",
        retryable: !1
    },
    E32002_REQUEST_ALREADY_PENDING: {
        eipCode: -32002,
        message: "Resource request already pending",
        detail: "Don\u2019t see your wallet? Check your other browser windows.",
        retryable: !1
    },
    E32002_WALLET_LOCKED: {
        eipCode: -32002,
        message: "Wallet might be locked",
        detail: "Don\u2019t see your wallet? Check your other browser windows.",
        retryable: !1
    },
    E4001_USER_REJECTED_REQUEST: {
        eipCode: 4001,
        message: "Signature rejected",
        detail: "Please try signing again.",
        retryable: !0
    }
};
function _(t) {
    let r = t.type;
    return "string" == typeof r && (0, _typesMjs.PrivyIframeErrorTypes).includes(r);
}
function E(e) {
    return _(e) && "wallet_not_on_device" === e.type;
}
function l(e) {
    return _(e) && "mfa_timeout" === e.type;
}
function u(e) {
    return _(e) && "missing_or_invalid_mfa" === e.type;
}
function c(e) {
    return _(e) && "mfa_verification_max_attempts_reached" === e.type;
}
function T(e) {
    return _(e) && e.message.includes("code 429");
}
class N extends a {
    constructor(e){
        super(e.message, e.code, e.data);
        let t = Object.values(n).find((t)=>t.eipCode === e.code);
        this.details = t || n.UNKNOWN_ERROR, -32002 === e.code && (e.message?.includes("already pending for origin") ? e.message?.includes("wallet_requestPermissions") ? this.details = n.E32002_CONNECTION_ALREADY_PENDING : this.details = n.E32002_REQUEST_ALREADY_PENDING : e.message?.includes("Already processing") && e.message.includes("eth_requestAccounts") && (this.details = n.E32002_WALLET_LOCKED));
    }
}

},{"./types.mjs":"47MbA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"47MbA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PrivyIframeErrorTypes", ()=>t);
parcelHelpers.export(exports, "SUPPORTED_JSON_RPC_METHODS", ()=>e);
parcelHelpers.export(exports, "isSupportedRpcMethod", ()=>i);
parcelHelpers.export(exports, "isSupportedSolanaRpcMethod", ()=>s);
const e = [
    "eth_sign",
    "eth_populateTransactionRequest",
    "eth_signTransaction",
    "personal_sign",
    "eth_signTypedData_v4",
    "csw_signUserOperation",
    "secp256k1_sign"
], i = (i)=>e.includes(i);
let n = [
    "signMessage"
];
const s = (e)=>n.includes(e), t = [
    "error",
    "invalid_request_arguments",
    "wallet_not_on_device",
    "invalid_recovery_pin",
    "insufficient_funds",
    "mfa_timeout",
    "missing_or_invalid_mfa",
    "mfa_verification_max_attempts_reached"
];

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9hdqK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "walletCreate", ()=>t);
var _createMjs = require("../../wallet-api/create.mjs");
var _publicApi = require("@privy-io/public-api");
async function t({ context: t, chainType: e }) {
    return {
        wallet: await (0, _createMjs.create)(t, {
            request: {
                chain_type: e,
                owner_id: void 0
            }
        })
    };
}

},{"../../wallet-api/create.mjs":"hBTEu","@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hBTEu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>r);
var _publicApi = require("@privy-io/public-api");
async function r(r, { request: t }) {
    return await r.fetchPrivyRoute((0, _publicApi.WalletCreate), {
        body: t
    });
}

},{"@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2aCHs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getJsonRpcEndpointFromChain", ()=>h);
parcelHelpers.export(exports, "getJsonRpcProvider", ()=>u);
parcelHelpers.export(exports, "populateTransactionRequest", ()=>g);
parcelHelpers.export(exports, "throwIfInvalidRecoveryUpgradePath", ()=>v);
parcelHelpers.export(exports, "validateTransactionRequest", ()=>f);
var _abstractSigner = require("@ethersproject/abstract-signer");
var _providers = require("@ethersproject/providers");
var _errorsMjs = require("../errors.mjs");
var _arbitrumMjs = require("../gas/arbitrum.mjs");
var _bscMjs = require("../gas/bsc.mjs");
var _opStackMjs = require("../gas/op-stack.mjs");
var _polygonMjs = require("../gas/polygon.mjs");
var _gasMjs = require("./gas.mjs");
var _typesMjs = require("../types.mjs");
var _bignumber = require("@ethersproject/bignumber");
var _chains = require("@privy-io/chains");
var _ethersMjs = require("./ethers.mjs");
var _contracts = require("@ethersproject/contracts");
var _transactions = require("@ethersproject/transactions");
var _units = require("@ethersproject/units");
var _fetchRetry = require("fetch-retry");
const u = (r, i, p, s)=>{
    let o = Number(r), a = i.find((r)=>r.id === o);
    if (!a) throw new (0, _errorsMjs.PrivyConnectorError)(`Unsupported chainId ${r}`, 4901);
    return new (0, _providers.StaticJsonRpcProvider)(a.rpcUrls.privyWalletOverride && a.rpcUrls.privyWalletOverride.http[0] ? a.rpcUrls.privyWalletOverride.http[0] : p.rpcUrls && p.rpcUrls[o] ? p.rpcUrls[o] : a.rpcUrls.privy?.http[0] ? {
        url: a.rpcUrls.privy.http[0],
        headers: {
            "privy-app-id": s.appId
        }
    } : a.rpcUrls.public?.http[0] ? a.rpcUrls.public?.http[0] : a.rpcUrls.default?.http[0]);
}, h = (r, e, i)=>{
    let p, s = r.id, o = Number(r.id);
    if (r.rpcUrls.privyWalletOverride && r.rpcUrls.privyWalletOverride.http[0]) p = r.rpcUrls.privyWalletOverride.http[0];
    else if (e.rpcUrls && e.rpcUrls[o]) p = e.rpcUrls[o];
    else if (r.rpcUrls.privy?.http[0]) {
        let e = new URL(r.rpcUrls.privy.http[0]);
        e.searchParams.append("privyAppId", i), p = e.toString();
    } else p = r.rpcUrls.public?.http[0] ? r.rpcUrls.public.http[0] : r.rpcUrls.default?.http[0];
    if (!p) throw new (0, _errorsMjs.PrivyConnectorError)(`No RPC url found for ${s}`);
    return p;
};
function y(r) {
    return /^-?0x[a-f0-9]+$/i.test(r);
}
function f(r) {
    for (let e of [
        "gasLimit",
        "gasPrice",
        "value",
        "maxPriorityFeePerGas",
        "maxFeePerGas"
    ]){
        let t = r[e];
        if (void 0 !== t && !function(r) {
            let e = "number" == typeof r, t = "bigint" == typeof r, i = "string" == typeof r && y(r);
            return e || t || i;
        }(t)) throw Error(`Transaction request property '${e}' must be a valid number, bigint, or hex string representing a quantity`);
    }
    if ("number" != typeof r.chainId) throw Error("Transaction request property 'chainId' must be a number");
}
async function g(e, t, u) {
    if (t.chainId = Number(t.chainId), f(t), t.from || (t.from = e), !t.nonce) {
        let i = new (0, _abstractSigner.VoidSigner)(e, u);
        t.nonce = await i.getTransactionCount("pending");
    }
    return t.gasLimit || (t.gas ? (t.gasLimit = t.gas, delete t.gas) : t.gasLimit = await (0, _gasMjs.defaultGasLimit)(t, u)), "string" == typeof t.type && y(t.type) && (t.type = Number(t.type)), [
        23294,
        23295
    ].includes(t.chainId) && (t.type = 0), 0 === (t = (0, _polygonMjs.isPolygon)(t.chainId) ? await (0, _polygonMjs.defaultGasForPolygon)(t) : (0, _arbitrumMjs.isArbitrum)(t.chainId) ? await (0, _arbitrumMjs.defaultGasForArbitrum)(t, u) : (0, _opStackMjs.isOpStack)(t.chainId) ? await (0, _opStackMjs.defaultGasForOpStack)(t, u) : (0, _bscMjs.isBsc)(t.chainId) ? await (0, _bscMjs.defaultGasForBsc)(t, u) : await (0, _gasMjs.defaultGasForEvmChain)(t, u)).type && delete t.accessList, 2 !== t.type && (delete t.maxPriorityFeePerGas, delete t.maxFeePerGas), t;
}
function v({ currentRecoveryMethod: r, upgradeToRecoveryMethod: e }) {
    switch(r){
        case "privy":
        case "user-passcode":
        case "recovery-encryption-key":
            return !0;
        case "icloud":
        case "google-drive":
            if (r === e) throw Error("Cannot upgrade to the existing cloud platform");
            return !0;
        default:
            throw Error("Unknown recovery method");
    }
}

},{"@ethersproject/abstract-signer":"bq0ju","@ethersproject/providers":"8k75m","../errors.mjs":"imCDj","../gas/arbitrum.mjs":"hCPYQ","../gas/bsc.mjs":"hbFMz","../gas/op-stack.mjs":"KVI98","../gas/polygon.mjs":"4wW2T","./gas.mjs":"bzO8p","../types.mjs":"47MbA","@ethersproject/bignumber":"gSTRF","@privy-io/chains":"9r5Tr","./ethers.mjs":"1PLH5","@ethersproject/contracts":"26Zqo","@ethersproject/transactions":"lqSCl","@ethersproject/units":"4X8jY","fetch-retry":"knqh8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bq0ju":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Signer", ()=>Signer);
parcelHelpers.export(exports, "VoidSigner", ()=>VoidSigner);
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
const allowedTransactionKeys = [
    "accessList",
    "ccipReadEnabled",
    "chainId",
    "customData",
    "data",
    "from",
    "gasLimit",
    "gasPrice",
    "maxFeePerGas",
    "maxPriorityFeePerGas",
    "nonce",
    "to",
    "type",
    "value"
];
const forwardErrors = [
    (0, _logger.Logger).errors.INSUFFICIENT_FUNDS,
    (0, _logger.Logger).errors.NONCE_EXPIRED,
    (0, _logger.Logger).errors.REPLACEMENT_UNDERPRICED
];
class Signer {
    ///////////////////
    // Sub-classes MUST call super
    constructor(){
        logger.checkAbstract(new.target, Signer);
        (0, _properties.defineReadOnly)(this, "_isSigner", true);
    }
    ///////////////////
    // Sub-classes MAY override these
    getBalance(blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("getBalance");
            return yield this.provider.getBalance(this.getAddress(), blockTag);
        });
    }
    getTransactionCount(blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("getTransactionCount");
            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
        });
    }
    // Populates "from" if unspecified, and estimates the gas for the transaction
    estimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("estimateGas");
            const tx = yield (0, _properties.resolveProperties)(this.checkTransaction(transaction));
            return yield this.provider.estimateGas(tx);
        });
    }
    // Populates "from" if unspecified, and calls with the transaction
    call(transaction, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("call");
            const tx = yield (0, _properties.resolveProperties)(this.checkTransaction(transaction));
            return yield this.provider.call(tx, blockTag);
        });
    }
    // Populates all fields in a transaction, signs it and sends it to the network
    sendTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("sendTransaction");
            const tx = yield this.populateTransaction(transaction);
            const signedTx = yield this.signTransaction(tx);
            return yield this.provider.sendTransaction(signedTx);
        });
    }
    getChainId() {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("getChainId");
            const network = yield this.provider.getNetwork();
            return network.chainId;
        });
    }
    getGasPrice() {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("getGasPrice");
            return yield this.provider.getGasPrice();
        });
    }
    getFeeData() {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("getFeeData");
            return yield this.provider.getFeeData();
        });
    }
    resolveName(name) {
        return __awaiter(this, void 0, void 0, function*() {
            this._checkProvider("resolveName");
            return yield this.provider.resolveName(name);
        });
    }
    // Checks a transaction does not contain invalid keys and if
    // no "from" is provided, populates it.
    // - does NOT require a provider
    // - adds "from" is not present
    // - returns a COPY (safe to mutate the result)
    // By default called from: (overriding these prevents it)
    //   - call
    //   - estimateGas
    //   - populateTransaction (and therefor sendTransaction)
    checkTransaction(transaction) {
        for(const key in transaction)if (allowedTransactionKeys.indexOf(key) === -1) logger.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
        const tx = (0, _properties.shallowCopy)(transaction);
        if (tx.from == null) tx.from = this.getAddress();
        else // Make sure any provided address matches this signer
        tx.from = Promise.all([
            Promise.resolve(tx.from),
            this.getAddress()
        ]).then((result)=>{
            if (result[0].toLowerCase() !== result[1].toLowerCase()) logger.throwArgumentError("from address mismatch", "transaction", transaction);
            return result[0];
        });
        return tx;
    }
    // Populates ALL keys for a transaction and checks that "from" matches
    // this Signer. Should be used by sendTransaction but NOT by signTransaction.
    // By default called from: (overriding these prevents it)
    //   - sendTransaction
    //
    // Notes:
    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
    populateTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            const tx = yield (0, _properties.resolveProperties)(this.checkTransaction(transaction));
            if (tx.to != null) {
                tx.to = Promise.resolve(tx.to).then((to)=>__awaiter(this, void 0, void 0, function*() {
                        if (to == null) return null;
                        const address = yield this.resolveName(to);
                        if (address == null) logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                        return address;
                    }));
                // Prevent this error from causing an UnhandledPromiseException
                tx.to.catch((error)=>{});
            }
            // Do not allow mixing pre-eip-1559 and eip-1559 properties
            const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) logger.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) logger.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
            if ((tx.type === 2 || tx.type == null) && tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null) // Fully-formed EIP-1559 transaction (skip getFeeData)
            tx.type = 2;
            else if (tx.type === 0 || tx.type === 1) // Explicit Legacy or EIP-2930 transaction
            // Populate missing gasPrice
            {
                if (tx.gasPrice == null) tx.gasPrice = this.getGasPrice();
            } else {
                // We need to get fee data to determine things
                const feeData = yield this.getFeeData();
                if (tx.type == null) {
                    // We need to auto-detect the intended type of this transaction...
                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                        // The network supports EIP-1559!
                        // Upgrade transaction from null to eip-1559
                        tx.type = 2;
                        if (tx.gasPrice != null) {
                            // Using legacy gasPrice property on an eip-1559 network,
                            // so use gasPrice as both fee properties
                            const gasPrice = tx.gasPrice;
                            delete tx.gasPrice;
                            tx.maxFeePerGas = gasPrice;
                            tx.maxPriorityFeePerGas = gasPrice;
                        } else {
                            // Populate missing fee data
                            if (tx.maxFeePerGas == null) tx.maxFeePerGas = feeData.maxFeePerGas;
                            if (tx.maxPriorityFeePerGas == null) tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                        }
                    } else if (feeData.gasPrice != null) {
                        // Network doesn't support EIP-1559...
                        // ...but they are trying to use EIP-1559 properties
                        if (hasEip1559) logger.throwError("network does not support EIP-1559", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                            operation: "populateTransaction"
                        });
                        // Populate missing fee data
                        if (tx.gasPrice == null) tx.gasPrice = feeData.gasPrice;
                        // Explicitly set untyped transaction to legacy
                        tx.type = 0;
                    } else // getFeeData has failed us.
                    logger.throwError("failed to get consistent fee data", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                        operation: "signer.getFeeData"
                    });
                } else if (tx.type === 2) {
                    // Explicitly using EIP-1559
                    // Populate missing fee data
                    if (tx.maxFeePerGas == null) tx.maxFeePerGas = feeData.maxFeePerGas;
                    if (tx.maxPriorityFeePerGas == null) tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                }
            }
            if (tx.nonce == null) tx.nonce = this.getTransactionCount("pending");
            if (tx.gasLimit == null) tx.gasLimit = this.estimateGas(tx).catch((error)=>{
                if (forwardErrors.indexOf(error.code) >= 0) throw error;
                return logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", (0, _logger.Logger).errors.UNPREDICTABLE_GAS_LIMIT, {
                    error: error,
                    tx: tx
                });
            });
            if (tx.chainId == null) tx.chainId = this.getChainId();
            else tx.chainId = Promise.all([
                Promise.resolve(tx.chainId),
                this.getChainId()
            ]).then((results)=>{
                if (results[1] !== 0 && results[0] !== results[1]) logger.throwArgumentError("chainId address mismatch", "transaction", transaction);
                return results[0];
            });
            return yield (0, _properties.resolveProperties)(tx);
        });
    }
    ///////////////////
    // Sub-classes SHOULD leave these alone
    _checkProvider(operation) {
        if (!this.provider) logger.throwError("missing provider", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: operation || "_checkProvider"
        });
    }
    static isSigner(value) {
        return !!(value && value._isSigner);
    }
}
class VoidSigner extends Signer {
    constructor(address, provider){
        super();
        (0, _properties.defineReadOnly)(this, "address", address);
        (0, _properties.defineReadOnly)(this, "provider", provider || null);
    }
    getAddress() {
        return Promise.resolve(this.address);
    }
    _fail(message, operation) {
        return Promise.resolve().then(()=>{
            logger.throwError(message, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: operation
            });
        });
    }
    signMessage(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
    }
    signTransaction(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    }
    _signTypedData(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    }
    connect(provider) {
        return new VoidSigner(this.address, provider);
    }
}

},{"@ethersproject/properties":"2X633","@ethersproject/logger":"9rXfv","./_version":"lSdCr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2X633":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defineReadOnly", ()=>defineReadOnly);
// Crawl up the constructor chain to find a static method
parcelHelpers.export(exports, "getStatic", ()=>getStatic);
parcelHelpers.export(exports, "resolveProperties", ()=>resolveProperties);
parcelHelpers.export(exports, "checkProperties", ()=>checkProperties);
parcelHelpers.export(exports, "shallowCopy", ()=>shallowCopy);
parcelHelpers.export(exports, "deepCopy", ()=>deepCopy);
parcelHelpers.export(exports, "Description", ()=>Description);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false
    });
}
function getStatic(ctor, key) {
    for(let i = 0; i < 32; i++){
        if (ctor[key]) return ctor[key];
        if (!ctor.prototype || typeof ctor.prototype !== "object") break;
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
function resolveProperties(object) {
    return __awaiter(this, void 0, void 0, function*() {
        const promises = Object.keys(object).map((key)=>{
            const value = object[key];
            return Promise.resolve(value).then((v)=>({
                    key: key,
                    value: v
                }));
        });
        const results = yield Promise.all(promises);
        return results.reduce((accum, result)=>{
            accum[result.key] = result.value;
            return accum;
        }, {});
    });
}
function checkProperties(object, properties) {
    if (!object || typeof object !== "object") logger.throwArgumentError("invalid object", "object", object);
    Object.keys(object).forEach((key)=>{
        if (!properties[key]) logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
    });
}
function shallowCopy(object) {
    const result = {};
    for(const key in object)result[key] = object[key];
    return result;
}
const opaque = {
    bigint: true,
    boolean: true,
    "function": true,
    number: true,
    string: true
};
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof object]) return true;
    if (Array.isArray(object) || typeof object === "object") {
        if (!Object.isFrozen(object)) return false;
        const keys = Object.keys(object);
        for(let i = 0; i < keys.length; i++){
            let value = null;
            try {
                value = object[keys[i]];
            } catch (error) {
                continue;
            }
            if (!_isFrozen(value)) return false;
        }
        return true;
    }
    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) return object;
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) return Object.freeze(object.map((item)=>deepCopy(item)));
    if (typeof object === "object") {
        const result = {};
        for(const key in object){
            const value = object[key];
            if (value === undefined) continue;
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
class Description {
    constructor(info){
        for(const key in info)this[key] = deepCopy(info[key]);
    }
}

},{"@ethersproject/logger":"9rXfv","./_version":"ioYs8","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9rXfv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LogLevel", ()=>LogLevel);
parcelHelpers.export(exports, "ErrorCode", ()=>ErrorCode);
parcelHelpers.export(exports, "Logger", ()=>Logger);
var _version = require("./_version");
"use strict";
let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = {
    debug: 1,
    "default": 2,
    info: 2,
    warning: 3,
    error: 4,
    off: 5
};
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        [
            "NFD",
            "NFC",
            "NFKD",
            "NFKC"
        ].forEach((form)=>{
            try {
                if ("test".normalize(form) !== "test") throw new Error("bad normalize");
            } catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) throw new Error("missing " + missing.join(", "));
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) throw new Error("broken implementation");
    } catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function(LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function(ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ///////////////////
    // Interaction Errors
    // The user rejected the action, such as signing a message or sending
    // a transaction
    ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
    constructor(version){
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        if (_logLevel > LogLevels[level]) return;
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) return this.makeError("censored error", code, {});
        if (!code) code = Logger.errors.UNKNOWN_ERROR;
        if (!params) params = {};
        const messageDetails = [];
        Object.keys(params).forEach((key)=>{
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for(let i = 0; i < value.length; i++){
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                } else messageDetails.push(key + "=" + JSON.stringify(value));
            } catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch(code){
            case ErrorCode.NUMERIC_FAULT:
                {
                    url = "NUMERIC_FAULT";
                    const fault = message;
                    switch(fault){
                        case "overflow":
                        case "underflow":
                        case "division-by-zero":
                            url += "-" + fault;
                            break;
                        case "negative-power":
                        case "negative-width":
                            url += "-unsupported";
                            break;
                        case "unbound-bitwise-result":
                            url += "-unbound-result";
                            break;
                    }
                    break;
                }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
        if (messageDetails.length) message += " (" + messageDetails.join(", ") + ")";
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function(key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) return;
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) return;
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (message == null) message = "platform missing String.prototype.normalize";
        if (_normalizeError) this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: _normalizeError
        });
    }
    checkSafeUint53(value, message) {
        if (typeof value !== "number") return;
        if (message == null) message = "value not safe";
        if (value < 0 || value >= 0x1fffffffffffff) this.throwError(message, Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: value
        });
        if (value % 1) this.throwError(message, Logger.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: value
        });
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) message = ": " + message;
        else message = "";
        if (count < expectedCount) this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
            count: count,
            expectedCount: expectedCount
        });
        if (count > expectedCount) this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
            count: count,
            expectedCount: expectedCount
        });
    }
    checkNew(target, kind) {
        if (target === Object || target == null) this.throwError("missing new", Logger.errors.MISSING_NEW, {
            name: kind.name
        });
    }
    checkAbstract(target, kind) {
        if (target === kind) this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, {
            name: target.name,
            operation: "new"
        });
        else if (target === Object || target == null) this.throwError("missing new", Logger.errors.MISSING_NEW, {
            name: kind.name
        });
    }
    static globalLogger() {
        if (!_globalLogger) _globalLogger = new Logger((0, _version.version));
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
        });
        if (_permanentCensorErrors) {
            if (!censorship) return;
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

},{"./_version":"6R0Su","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6R0Su":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "logger/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ioYs8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "properties/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lSdCr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "abstract-signer/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8k75m":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
////////////////////////
// Exports
parcelHelpers.export(exports, "Provider", ()=>// Abstract Providers (or Abstract-ish)
    (0, _abstractProvider.Provider));
parcelHelpers.export(exports, "BaseProvider", ()=>(0, _baseProvider.BaseProvider));
parcelHelpers.export(exports, "Resolver", ()=>(0, _baseProvider.Resolver));
parcelHelpers.export(exports, "UrlJsonRpcProvider", ()=>(0, _urlJsonRpcProvider.UrlJsonRpcProvider));
parcelHelpers.export(exports, "FallbackProvider", ()=>///////////////////////
    // Concrete Providers
    (0, _fallbackProvider.FallbackProvider));
parcelHelpers.export(exports, "AlchemyProvider", ()=>(0, _alchemyProvider.AlchemyProvider));
parcelHelpers.export(exports, "AlchemyWebSocketProvider", ()=>(0, _alchemyProvider.AlchemyWebSocketProvider));
parcelHelpers.export(exports, "AnkrProvider", ()=>(0, _ankrProvider.AnkrProvider));
parcelHelpers.export(exports, "CloudflareProvider", ()=>(0, _cloudflareProvider.CloudflareProvider));
parcelHelpers.export(exports, "EtherscanProvider", ()=>(0, _etherscanProvider.EtherscanProvider));
parcelHelpers.export(exports, "InfuraProvider", ()=>(0, _infuraProvider.InfuraProvider));
parcelHelpers.export(exports, "InfuraWebSocketProvider", ()=>(0, _infuraProvider.InfuraWebSocketProvider));
parcelHelpers.export(exports, "JsonRpcProvider", ()=>(0, _jsonRpcProvider.JsonRpcProvider));
parcelHelpers.export(exports, "JsonRpcBatchProvider", ()=>(0, _jsonRpcBatchProvider.JsonRpcBatchProvider));
parcelHelpers.export(exports, "NodesmithProvider", ()=>(0, _nodesmithProvider.NodesmithProvider));
parcelHelpers.export(exports, "PocketProvider", ()=>(0, _pocketProvider.PocketProvider));
parcelHelpers.export(exports, "QuickNodeProvider", ()=>(0, _quicknodeProvider.QuickNodeProvider));
parcelHelpers.export(exports, "StaticJsonRpcProvider", ()=>(0, _urlJsonRpcProvider.StaticJsonRpcProvider));
parcelHelpers.export(exports, "Web3Provider", ()=>(0, _web3Provider.Web3Provider));
parcelHelpers.export(exports, "WebSocketProvider", ()=>(0, _websocketProvider.WebSocketProvider));
parcelHelpers.export(exports, "IpcProvider", ()=>(0, _ipcProvider.IpcProvider));
parcelHelpers.export(exports, "JsonRpcSigner", ()=>///////////////////////
    // Signer
    (0, _jsonRpcProvider.JsonRpcSigner));
parcelHelpers.export(exports, "getDefaultProvider", ()=>///////////////////////
    // Functions
    getDefaultProvider);
parcelHelpers.export(exports, "getNetwork", ()=>(0, _networks.getNetwork));
parcelHelpers.export(exports, "isCommunityResource", ()=>(0, _formatter.isCommunityResource));
parcelHelpers.export(exports, "isCommunityResourcable", ()=>(0, _formatter.isCommunityResourcable));
parcelHelpers.export(exports, "showThrottleMessage", ()=>(0, _formatter.showThrottleMessage));
parcelHelpers.export(exports, "Formatter", ()=>///////////////////////
    // Objects
    (0, _formatter.Formatter));
var _abstractProvider = require("@ethersproject/abstract-provider");
var _networks = require("@ethersproject/networks");
var _baseProvider = require("./base-provider");
var _alchemyProvider = require("./alchemy-provider");
var _ankrProvider = require("./ankr-provider");
var _cloudflareProvider = require("./cloudflare-provider");
var _etherscanProvider = require("./etherscan-provider");
var _fallbackProvider = require("./fallback-provider");
var _ipcProvider = require("./ipc-provider");
var _infuraProvider = require("./infura-provider");
var _jsonRpcProvider = require("./json-rpc-provider");
var _jsonRpcBatchProvider = require("./json-rpc-batch-provider");
var _nodesmithProvider = require("./nodesmith-provider");
var _pocketProvider = require("./pocket-provider");
var _quicknodeProvider = require("./quicknode-provider");
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
var _web3Provider = require("./web3-provider");
var _websocketProvider = require("./websocket-provider");
var _formatter = require("./formatter");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
////////////////////////
// Helper Functions
function getDefaultProvider(network, options) {
    if (network == null) network = "homestead";
    // If passed a URL, figure out the right type of provider based on the scheme
    if (typeof network === "string") {
        // @TODO: Add support for IpcProvider; maybe if it ends in ".ipc"?
        // Handle http and ws (and their secure variants)
        const match = network.match(/^(ws|http)s?:/i);
        if (match) switch(match[1].toLowerCase()){
            case "http":
            case "https":
                return new (0, _jsonRpcProvider.JsonRpcProvider)(network);
            case "ws":
            case "wss":
                return new (0, _websocketProvider.WebSocketProvider)(network);
            default:
                logger.throwArgumentError("unsupported URL scheme", "network", network);
        }
    }
    const n = (0, _networks.getNetwork)(network);
    if (!n || !n._defaultProvider) logger.throwError("unsupported getDefaultProvider network", (0, _logger.Logger).errors.NETWORK_ERROR, {
        operation: "getDefaultProvider",
        network: network
    });
    return n._defaultProvider({
        FallbackProvider: (0, _fallbackProvider.FallbackProvider),
        AlchemyProvider: (0, _alchemyProvider.AlchemyProvider),
        AnkrProvider: (0, _ankrProvider.AnkrProvider),
        CloudflareProvider: (0, _cloudflareProvider.CloudflareProvider),
        EtherscanProvider: (0, _etherscanProvider.EtherscanProvider),
        InfuraProvider: (0, _infuraProvider.InfuraProvider),
        JsonRpcProvider: (0, _jsonRpcProvider.JsonRpcProvider),
        NodesmithProvider: (0, _nodesmithProvider.NodesmithProvider),
        PocketProvider: (0, _pocketProvider.PocketProvider),
        QuickNodeProvider: (0, _quicknodeProvider.QuickNodeProvider),
        Web3Provider: (0, _web3Provider.Web3Provider),
        IpcProvider: (0, _ipcProvider.IpcProvider)
    }, options);
}

},{"@ethersproject/abstract-provider":"fYevg","@ethersproject/networks":"hQL7z","./base-provider":"8jgHV","./alchemy-provider":"anaZ0","./ankr-provider":"9bnQV","./cloudflare-provider":"j7paZ","./etherscan-provider":"hMPHR","./fallback-provider":"26sUb","./ipc-provider":"hO0gF","./infura-provider":"laas2","./json-rpc-provider":"9mdlH","./json-rpc-batch-provider":"dzx4I","./nodesmith-provider":"jxJf7","./pocket-provider":"kJNHs","./quicknode-provider":"1iGuq","./url-json-rpc-provider":"ecfF1","./web3-provider":"cat97","./websocket-provider":"82IGf","./formatter":"eHThO","@ethersproject/logger":"9rXfv","./_version":"bmrdP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fYevg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
//export type CallTransactionable = {
//    call(transaction: TransactionRequest): Promise<TransactionResponse>;
//};
parcelHelpers.export(exports, "ForkEvent", ()=>ForkEvent);
parcelHelpers.export(exports, "BlockForkEvent", ()=>BlockForkEvent);
parcelHelpers.export(exports, "TransactionForkEvent", ()=>TransactionForkEvent);
parcelHelpers.export(exports, "TransactionOrderForkEvent", ()=>TransactionOrderForkEvent);
///////////////////////////////
// Exported Abstracts
parcelHelpers.export(exports, "Provider", ()=>Provider);
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
class ForkEvent extends (0, _properties.Description) {
    static isForkEvent(value) {
        return !!(value && value._isForkEvent);
    }
}
class BlockForkEvent extends ForkEvent {
    constructor(blockHash, expiry){
        if (!(0, _bytes.isHexString)(blockHash, 32)) logger.throwArgumentError("invalid blockHash", "blockHash", blockHash);
        super({
            _isForkEvent: true,
            _isBlockForkEvent: true,
            expiry: expiry || 0,
            blockHash: blockHash
        });
    }
}
class TransactionForkEvent extends ForkEvent {
    constructor(hash, expiry){
        if (!(0, _bytes.isHexString)(hash, 32)) logger.throwArgumentError("invalid transaction hash", "hash", hash);
        super({
            _isForkEvent: true,
            _isTransactionForkEvent: true,
            expiry: expiry || 0,
            hash: hash
        });
    }
}
class TransactionOrderForkEvent extends ForkEvent {
    constructor(beforeHash, afterHash, expiry){
        if (!(0, _bytes.isHexString)(beforeHash, 32)) logger.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
        if (!(0, _bytes.isHexString)(afterHash, 32)) logger.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
        super({
            _isForkEvent: true,
            _isTransactionOrderForkEvent: true,
            expiry: expiry || 0,
            beforeHash: beforeHash,
            afterHash: afterHash
        });
    }
}
class Provider {
    constructor(){
        logger.checkAbstract(new.target, Provider);
        (0, _properties.defineReadOnly)(this, "_isProvider", true);
    }
    getFeeData() {
        return __awaiter(this, void 0, void 0, function*() {
            const { block, gasPrice } = yield (0, _properties.resolveProperties)({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch((error)=>{
                    // @TODO: Why is this now failing on Calaveras?
                    //console.log(error);
                    return null;
                })
            });
            let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
            if (block && block.baseFeePerGas) {
                // We may want to compute this more accurately in the future,
                // using the formula "check if the base fee is correct".
                // See: https://eips.ethereum.org/EIPS/eip-1559
                lastBaseFeePerGas = block.baseFeePerGas;
                maxPriorityFeePerGas = (0, _bignumber.BigNumber).from("1500000000");
                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
            }
            return {
                lastBaseFeePerGas,
                maxFeePerGas,
                maxPriorityFeePerGas,
                gasPrice
            };
        });
    }
    // Alias for "on"
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    // Alias for "off"
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
    static isProvider(value) {
        return !!(value && value._isProvider);
    }
}

},{"@ethersproject/bignumber":"gSTRF","@ethersproject/bytes":"5ReBN","@ethersproject/properties":"2X633","@ethersproject/logger":"9rXfv","./_version":"4VLWn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gSTRF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BigNumber", ()=>(0, _bignumber.BigNumber));
parcelHelpers.export(exports, "formatFixed", ()=>(0, _fixednumber.formatFixed));
parcelHelpers.export(exports, "FixedFormat", ()=>(0, _fixednumber.FixedFormat));
parcelHelpers.export(exports, "FixedNumber", ()=>(0, _fixednumber.FixedNumber));
parcelHelpers.export(exports, "parseFixed", ()=>(0, _fixednumber.parseFixed));
// Internal methods used by address
parcelHelpers.export(exports, "_base16To36", ()=>(0, _bignumber._base16To36));
parcelHelpers.export(exports, "_base36To16", ()=>(0, _bignumber._base36To16));
var _bignumber = require("./bignumber");
var _fixednumber = require("./fixednumber");

},{"./bignumber":"7nvDB","./fixednumber":"7PLOB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7nvDB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBigNumberish", ()=>isBigNumberish);
parcelHelpers.export(exports, "BigNumber", ()=>BigNumber);
// value should have no prefix
parcelHelpers.export(exports, "_base36To16", ()=>_base36To16);
// value should have no prefix
parcelHelpers.export(exports, "_base16To36", ()=>_base16To36);
/**
 *  BigNumber
 *
 *  A wrapper around the BN.js object. We use the BN.js library
 *  because it is used by elliptic, so it is required regardless.
 *
 */ var _bnJs = require("bn.js");
var _bnJsDefault = parcelHelpers.interopDefault(_bnJs);
var _bytes = require("@ethersproject/bytes");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var BN = (0, _bnJsDefault.default).BN;
const logger = new (0, _logger.Logger)((0, _version.version));
const _constructorGuard = {};
const MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
    return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || (0, _bytes.isHexString)(value) || typeof value === "bigint" || (0, _bytes.isBytes)(value));
}
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex){
        if (constructorGuard !== _constructorGuard) logger.throwError("cannot call constructor directly; use BigNumber.from", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
        });
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") return BigNumber.from(this._hex.substring(1));
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) throwFault("division-by-zero", "div");
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) throwFault("division-by-zero", "mod");
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) throwFault("negative-power", "pow");
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) throwFault("unbound-bitwise-result", "and");
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) throwFault("unbound-bitwise-result", "or");
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) throwFault("unbound-bitwise-result", "xor");
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) throwFault("negative-width", "mask");
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) throwFault("negative-width", "shl");
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) throwFault("negative-width", "shr");
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return this._hex[0] === "-";
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        } catch (error) {
            throwFault("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        } catch (e) {}
        return logger.throwError("this platform does not support BigInt", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            } else if (arguments[0] === 16) logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", (0, _logger.Logger).errors.UNEXPECTED_ARGUMENT, {});
            else logger.throwError("BigNumber.toString does not accept parameters", (0, _logger.Logger).errors.UNEXPECTED_ARGUMENT, {});
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return {
            type: "BigNumber",
            hex: this.toHexString()
        };
    }
    static from(value) {
        if (value instanceof BigNumber) return value;
        if (typeof value === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) return new BigNumber(_constructorGuard, toHex(value));
            if (value.match(/^-?[0-9]+$/)) return new BigNumber(_constructorGuard, toHex(new BN(value)));
            return logger.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof value === "number") {
            if (value % 1) throwFault("underflow", "BigNumber.from", value);
            if (value >= MAX_SAFE || value <= -MAX_SAFE) throwFault("overflow", "BigNumber.from", value);
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof anyValue === "bigint") return BigNumber.from(anyValue.toString());
        if ((0, _bytes.isBytes)(anyValue)) return BigNumber.from((0, _bytes.hexlify)(anyValue));
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof hex === "string") return BigNumber.from(hex);
            } else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") hex = anyValue.hex;
                if (typeof hex === "string") {
                    if ((0, _bytes.isHexString)(hex) || hex[0] === "-" && (0, _bytes.isHexString)(hex.substring(1))) return BigNumber.from(hex);
                }
            }
        }
        return logger.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof value !== "string") return toHex(value.toString(16));
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") logger.throwArgumentError("invalid hex", "value", value);
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") return value;
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") value = "0x" + value;
    // Normalize zero
    if (value === "0x") return "0x00";
    // Make the string even length
    if (value.length % 2) value = "0x0" + value.substring(2);
    // Trim to smallest even-length string
    while(value.length > 4 && value.substring(0, 4) === "0x00")value = "0x" + value.substring(4);
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") return new BN("-" + hex.substring(3), 16);
    return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
    const params = {
        fault: fault,
        operation: operation
    };
    if (value != null) params.value = value;
    return logger.throwError(fault, (0, _logger.Logger).errors.NUMERIC_FAULT, params);
}
function _base36To16(value) {
    return new BN(value, 36).toString(16);
}
function _base16To36(value) {
    return new BN(value, 16).toString(36);
}

},{"bn.js":"2x6os","@ethersproject/bytes":"5ReBN","@ethersproject/logger":"9rXfv","./_version":"i8qlg","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2x6os":[function(require,module,exports,__globalThis) {
(function(module1, exports) {
    'use strict';
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || 'Assertion failed');
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) return number;
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === 'le' || base === 'be') {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || 'be');
        }
    }
    if (typeof module1 === 'object') module1.exports = BN;
    else exports.BN = BN;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') Buffer = window.Buffer;
        else Buffer = require("bd440367abe2ded7").Buffer;
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) return true;
        return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === 'number') return this._initNumber(number, base, endian);
        if (typeof number === 'object') return this._initArray(number, base, endian);
        if (base === 'hex') base = 16;
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, '');
        var start = 0;
        if (number[0] === '-') {
            start++;
            this.negative = 1;
        }
        if (start < number.length) {
            if (base === 16) this._parseHex(number, start, endian);
            else {
                this._parseBase(number, base, start);
                if (endian === 'le') this._initArray(this.toArray(), base, endian);
            }
        }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== 'le') return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === 'number');
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        var j, w;
        var off = 0;
        if (endian === 'be') for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        else if (endian === 'le') for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
        return this._strip();
    };
    function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        // '0' - '9'
        if (c >= 48 && c <= 57) return c - 48;
        else if (c >= 65 && c <= 70) return c - 55;
        else if (c >= 97 && c <= 102) return c - 87;
        else assert(false, 'Invalid character in ' + string);
    }
    function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) r |= parseHex4Bits(string, index - 1) << 4;
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)this.words[i] = 0;
        // 24-bits chunks
        var off = 0;
        var j = 0;
        var w;
        if (endian === 'be') for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else off += 8;
        }
        else {
            var parseLength = number.length - start;
            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else off += 8;
            }
        }
        this._strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) b = c - 49 + 0xa;
            else if (c >= 17) b = c - 17 + 0xa;
            else b = c;
            assert(c >= 0 && b < mul, 'Invalid character');
            r += b;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)limbLen++;
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++)pow *= base;
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) this.words[0] += word;
            else this._iaddn(word);
        }
        this._strip();
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++)dest.words[i] = this.words[i];
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
        move(dest, this);
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size)this.words[this.length++] = 0;
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype._strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0)this.length--;
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) this.negative = 0;
        return this;
    };
    // Check Symbol.for because not everywhere where Symbol defined
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
    if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') try {
        BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
        BN.prototype.inspect = inspect;
    }
    else BN.prototype.inspect = inspect;
    function inspect() {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    }
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        '',
        '0',
        '00',
        '000',
        '0000',
        '00000',
        '000000',
        '0000000',
        '00000000',
        '000000000',
        '0000000000',
        '00000000000',
        '000000000000',
        '0000000000000',
        '00000000000000',
        '000000000000000',
        '0000000000000000',
        '00000000000000000',
        '000000000000000000',
        '0000000000000000000',
        '00000000000000000000',
        '000000000000000000000',
        '0000000000000000000000',
        '00000000000000000000000',
        '000000000000000000000000',
        '0000000000000000000000000'
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === 'hex') {
            out = '';
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
                if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;
                else out = word + out;
            }
            if (carry !== 0) out = carry.toString(16) + out;
            while(out.length % padding !== 0)out = '0' + out;
            if (this.negative !== 0) out = '-' + out;
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = '';
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modrn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;
                else out = r + out;
            }
            if (this.isZero()) out = '0' + out;
            while(out.length % padding !== 0)out = '0' + out;
            if (this.negative !== 0) out = '-' + out;
            return out;
        }
        assert(false, 'Base should be between 2 and 36');
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) ret += this.words[1] * 0x4000000;
        else if (this.length === 3 && this.words[2] === 0x01) // NOTE: at this stage it is known that the top bit is set
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
        else if (this.length > 2) assert(false, 'Number can only safely store up to 53 bits');
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
    };
    if (Buffer) BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
        if (ArrayType.allocUnsafe) return ArrayType.allocUnsafe(size);
        return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, 'byte array longer than desired length');
        assert(reqLength > 0, 'Requested array length <= 0');
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === 'le' ? 'LE' : 'BE';
        this['_toArrayLike' + postfix](res, byteLength);
        return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position++] = word & 0xff;
            if (position < res.length) res[position++] = word >> 8 & 0xff;
            if (position < res.length) res[position++] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position < res.length) res[position++] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position < res.length) {
            res[position++] = carry;
            while(position < res.length)res[position++] = 0;
        }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position--] = word & 0xff;
            if (position >= 0) res[position--] = word >> 8 & 0xff;
            if (position >= 0) res[position--] = word >> 16 & 0xff;
            if (shift === 6) {
                if (position >= 0) res[position--] = word >> 24 & 0xff;
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position >= 0) {
            res[position--] = carry;
            while(position >= 0)res[position--] = 0;
        }
    };
    if (Math.clz32) BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
    else BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) r++;
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 0x01;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) this.negative ^= 1;
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length)this.words[this.length++] = 0;
        for(var i = 0; i < num.length; i++)this.words[i] = this.words[i] | num.words[i];
        return this._strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) b = num;
        else b = this;
        for(var i = 0; i < b.length; i++)this.words[i] = this.words[i] & num.words[i];
        this.length = b.length;
        return this._strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++)this.words[i] = a.words[i] ^ b.words[i];
        if (this !== a) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = a.length;
        return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === 'number' && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) bytesNeeded--;
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++)this.words[i] = ~this.words[i] & 0x3ffffff;
        // Handle the residue
        if (bitsLeft > 0) this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        // And remove leading zeroes
        return this._strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === 'number' && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) this.words[off] = this.words[off] | 1 << wbit;
        else this.words[off] = this.words[off] & ~(1 << wbit);
        return this._strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) for(; i < a.length; i++)this.words[i] = a.words[i];
        this.length = Math.max(this.length, i);
        if (a !== this) this.negative = 1;
        return this._strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) out.words[k] = carry | 0;
        else out.length--;
        return out._strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) comb10MulTo = smallMulTo;
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) out.words[k] = carry;
        else out.length--;
        return out._strip();
    }
    function jumboMulTo(self, num, out) {
        // Temporary disable, see https://github.com/indutny/bn.js/issues/211
        // var fftm = new FFTM();
        // return fftm.mulp(self, num, out);
        return bigMulTo(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) res = comb10MulTo(this, num, out);
        else if (len < 63) res = smallMulTo(this, num, out);
        else if (len < 1024) res = bigMulTo(this, num, out);
        else res = jumboMulTo(this, num, out);
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++)t[i] = this.revBin(i, l, N);
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1)i++;
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) carry = 0;
            else carry = w / 0x4000000 | 0;
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i)rws[i] = 0;
        assert(carry === 0);
        assert((carry & -8192) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++)ph[i] = 0;
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--)this.words[i + s] = this.words[i];
            for(i = 0; i < s; i++)this.words[i] = 0;
            this.length += s;
        }
        return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === 'number' && bits >= 0);
        var h;
        if (hint) h = (hint - hint % 26) / 26;
        else h = 0;
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++)maskedWords.words[i] = this.words[i];
            maskedWords.length = s;
        }
        if (s === 0) ;
        else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++)this.words[i] = this.words[i + s];
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) maskedWords.words[maskedWords.length++] = carry;
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === 'number' && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, 'imaskn works only with positive numbers');
        if (this.length <= s) return this;
        if (r !== 0) s++;
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this._strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) this.words[i + 1] = 1;
            else this.words[i + 1]++;
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else // Carry
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
        return this._strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this._strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== 'mod') {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++)q.words[i] = 0;
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) q.words[m] = 1;
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) a.negative ^= 1;
            }
            if (q) q.words[j] = qj;
        }
        if (q) q._strip();
        a._strip();
        // Denormalize
        if (mode !== 'div' && shift !== 0) a.iushrn(shift);
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) return {
            div: new BN(0),
            mod: new BN(0)
        };
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== 'mod') div = res.div.neg();
            if (mode !== 'div') {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.iadd(num);
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== 'mod') div = res.div.neg();
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== 'div') {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) mod.isub(num);
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) return {
            div: new BN(0),
            mod: this
        };
        // Very short reduction
        if (num.length === 1) {
            if (mode === 'div') return {
                div: this.divn(num.words[0]),
                mod: null
            };
            if (mode === 'mod') return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, 'div', false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, 'mod', false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, 'mod', true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var p = 67108864 % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--)acc = (p * acc + (this.words[i] | 0)) % num;
        return isNegNum ? -acc : acc;
    };
    // WARNING: DEPRECATED
    BN.prototype.modn = function modn(num) {
        return this.modrn(num);
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) x = x.umod(p);
        else x = x.clone();
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) a = a.umod(p);
        else a = a.clone();
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) x1.iadd(delta);
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) x2.iadd(delta);
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) res = x1;
        else res = x2;
        if (res.cmpn(0) < 0) res.iadd(p);
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven())a.iushrn(1);
            while(b.isEven())b.iushrn(1);
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) break;
            a.isub(b);
        }while (true);
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === 'number');
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) res = 1;
        else {
            if (negative) num = -num;
            assert(num <= 0x3ffffff, 'Number is too big');
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) res = -1;
            else if (a > b) res = 1;
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        assert(this.negative === 0, 'red works only with positives');
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, 'fromRed works only with numbers in reduction context');
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, 'redAdd works only with red numbers');
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, 'redIAdd works only with red numbers');
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, 'redSub works only with red numbers');
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, 'redISub works only with red numbers');
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, 'redShl works only with red numbers');
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, 'redSqr works only with red numbers');
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, 'redISqr works only with red numbers');
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, 'redSqrt works only with red numbers');
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, 'redInvm works only with red numbers');
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, 'redNeg works only with red numbers');
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, 'redPow(normalNum)');
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) r.isub(this.p);
        else if (r.strip !== undefined) // r is a BN v4 instance
        r.strip();
        else // r is a BN v5 instance
        r._strip();
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++)output.words[i] = input.words[i];
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) input.length -= 10;
        else input.length -= 9;
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) num.length--;
        }
        return num;
    };
    function P224() {
        MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) num.words[num.length++] = carry;
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === 'k256') prime = new K256();
        else if (name === 'p224') prime = new P224();
        else if (name === 'p192') prime = new P192();
        else if (name === 'p25519') prime = new P25519();
        else throw new Error('Unknown prime ' + name);
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === 'string') {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), 'modulus must be greater than 1');
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, 'red works only with positives');
        assert(a.red, 'red works only with red numbers');
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, 'red works only with positives');
        assert(a.red && a.red === b.red, 'red works only with red numbers');
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) return a.clone();
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) res.isub(this.m);
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) res.iadd(this.m);
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0)z.redIAdd(nOne);
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++)tmp = tmp.redSqr();
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else return this.imod(inv);
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++)wnd[i] = this.mul(wnd[i - 1], a);
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) start = 26;
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) res = this.sqr(res);
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) this.shift += 26 - this.shift % 26;
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) res = u.isub(this.m);
        else if (u.cmpn(0) < 0) res = u.iadd(this.m);
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(module, this);

},{"bd440367abe2ded7":"eoH60"}],"eoH60":[function(require,module,exports,__globalThis) {
"use strict";

},{}],"5ReBN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isBytesLike", ()=>isBytesLike);
parcelHelpers.export(exports, "isBytes", ()=>isBytes);
parcelHelpers.export(exports, "arrayify", ()=>arrayify);
parcelHelpers.export(exports, "concat", ()=>concat);
parcelHelpers.export(exports, "stripZeros", ()=>stripZeros);
parcelHelpers.export(exports, "zeroPad", ()=>zeroPad);
parcelHelpers.export(exports, "isHexString", ()=>isHexString);
parcelHelpers.export(exports, "hexlify", ()=>hexlify);
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/ parcelHelpers.export(exports, "hexDataLength", ()=>hexDataLength);
parcelHelpers.export(exports, "hexDataSlice", ()=>hexDataSlice);
parcelHelpers.export(exports, "hexConcat", ()=>hexConcat);
parcelHelpers.export(exports, "hexValue", ()=>hexValue);
parcelHelpers.export(exports, "hexStripZeros", ()=>hexStripZeros);
parcelHelpers.export(exports, "hexZeroPad", ()=>hexZeroPad);
parcelHelpers.export(exports, "splitSignature", ()=>splitSignature);
parcelHelpers.export(exports, "joinSignature", ()=>joinSignature);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
///////////////////////////////
function isHexable(value) {
    return !!value.toHexString;
}
function addSlice(array) {
    if (array.slice) return array;
    array.slice = function() {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isBytesLike(value) {
    return isHexString(value) && !(value.length % 2) || isBytes(value);
}
function isInteger(value) {
    return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
    if (value == null) return false;
    if (value.constructor === Uint8Array) return true;
    if (typeof value === "string") return false;
    if (!isInteger(value.length) || value.length < 0) return false;
    for(let i = 0; i < value.length; i++){
        const v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) return false;
    }
    return true;
}
function arrayify(value, options) {
    if (!options) options = {};
    if (typeof value === "number") {
        logger.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while(value){
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) result.push(0);
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") value = "0x" + value;
    if (isHexable(value)) value = value.toHexString();
    if (isHexString(value)) {
        let hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") hex = "0" + hex;
            else if (options.hexPad === "right") hex += "0";
            else logger.throwArgumentError("hex data is odd-length", "value", value);
        }
        const result = [];
        for(let i = 0; i < hex.length; i += 2)result.push(parseInt(hex.substring(i, i + 2), 16));
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) return addSlice(new Uint8Array(value));
    return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
    const objects = items.map((item)=>arrayify(item));
    const length = objects.reduce((accum, item)=>accum + item.length, 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object)=>{
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
function stripZeros(value) {
    let result = arrayify(value);
    if (result.length === 0) return result;
    // Find the first non-zero entry
    let start = 0;
    while(start < result.length && result[start] === 0)start++;
    // If we started with zeros, strip them
    if (start) result = result.slice(start);
    return result;
}
function zeroPad(value, length) {
    value = arrayify(value);
    if (value.length > length) logger.throwArgumentError("value out of range", "value", arguments[0]);
    const result = new Uint8Array(length);
    result.set(value, length - value.length);
    return addSlice(result);
}
function isHexString(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;
    if (length && value.length !== 2 + 2 * length) return false;
    return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) options = {};
    if (typeof value === "number") {
        logger.checkSafeUint53(value, "invalid hexlify value");
        let hex = "";
        while(value){
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) hex = "0" + hex;
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof value === "bigint") {
        value = value.toString(16);
        if (value.length % 2) return "0x0" + value;
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") value = "0x" + value;
    if (isHexable(value)) return value.toHexString();
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") value = "0x0" + value.substring(2);
            else if (options.hexPad === "right") value += "0";
            else logger.throwArgumentError("hex data is odd-length", "value", value);
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        let result = "0x";
        for(let i = 0; i < value.length; i++){
            let v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger.throwArgumentError("invalid hexlify value", "value", value);
}
function hexDataLength(data) {
    if (typeof data !== "string") data = hexlify(data);
    else if (!isHexString(data) || data.length % 2) return null;
    return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
    if (typeof data !== "string") data = hexlify(data);
    else if (!isHexString(data) || data.length % 2) logger.throwArgumentError("invalid hexData", "value", data);
    offset = 2 + 2 * offset;
    if (endOffset != null) return "0x" + data.substring(offset, 2 + 2 * endOffset);
    return "0x" + data.substring(offset);
}
function hexConcat(items) {
    let result = "0x";
    items.forEach((item)=>{
        result += hexlify(item).substring(2);
    });
    return result;
}
function hexValue(value) {
    const trimmed = hexStripZeros(hexlify(value, {
        hexPad: "left"
    }));
    if (trimmed === "0x") return "0x0";
    return trimmed;
}
function hexStripZeros(value) {
    if (typeof value !== "string") value = hexlify(value);
    if (!isHexString(value)) logger.throwArgumentError("invalid hex string", "value", value);
    value = value.substring(2);
    let offset = 0;
    while(offset < value.length && value[offset] === "0")offset++;
    return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
    if (typeof value !== "string") value = hexlify(value);
    else if (!isHexString(value)) logger.throwArgumentError("invalid hex string", "value", value);
    if (value.length > 2 * length + 2) logger.throwArgumentError("value out of range", "value", arguments[1]);
    while(value.length < 2 * length + 2)value = "0x0" + value.substring(2);
    return value;
}
function splitSignature(signature) {
    const result = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0,
        yParityAndS: "0x",
        compact: "0x"
    };
    if (isBytesLike(signature)) {
        let bytes = arrayify(signature);
        // Get the r, s and v
        if (bytes.length === 64) {
            // EIP-2098; pull the v from the top bit of s and clear it
            result.v = 27 + (bytes[32] >> 7);
            bytes[32] &= 0x7f;
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
        } else if (bytes.length === 65) {
            result.r = hexlify(bytes.slice(0, 32));
            result.s = hexlify(bytes.slice(32, 64));
            result.v = bytes[64];
        } else logger.throwArgumentError("invalid signature string", "signature", signature);
        // Allow a recid to be used as the v
        if (result.v < 27) {
            if (result.v === 0 || result.v === 1) result.v += 27;
            else logger.throwArgumentError("signature invalid v byte", "signature", signature);
        }
        // Compute recoveryParam from v
        result.recoveryParam = 1 - result.v % 2;
        // Compute _vs from recoveryParam and s
        if (result.recoveryParam) bytes[32] |= 0x80;
        result._vs = hexlify(bytes.slice(32, 64));
    } else {
        result.r = signature.r;
        result.s = signature.s;
        result.v = signature.v;
        result.recoveryParam = signature.recoveryParam;
        result._vs = signature._vs;
        // If the _vs is available, use it to populate missing s, v and recoveryParam
        // and verify non-missing s, v and recoveryParam
        if (result._vs != null) {
            const vs = zeroPad(arrayify(result._vs), 32);
            result._vs = hexlify(vs);
            // Set or check the recid
            const recoveryParam = vs[0] >= 128 ? 1 : 0;
            if (result.recoveryParam == null) result.recoveryParam = recoveryParam;
            else if (result.recoveryParam !== recoveryParam) logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
            // Set or check the s
            vs[0] &= 0x7f;
            const s = hexlify(vs);
            if (result.s == null) result.s = s;
            else if (result.s !== s) logger.throwArgumentError("signature v mismatch _vs", "signature", signature);
        }
        // Use recid and v to populate each other
        if (result.recoveryParam == null) {
            if (result.v == null) logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
            else if (result.v === 0 || result.v === 1) result.recoveryParam = result.v;
            else result.recoveryParam = 1 - result.v % 2;
        } else if (result.v == null) result.v = 27 + result.recoveryParam;
        else {
            const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
            if (result.recoveryParam !== recId) logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
        }
        if (result.r == null || !isHexString(result.r)) logger.throwArgumentError("signature missing or invalid r", "signature", signature);
        else result.r = hexZeroPad(result.r, 32);
        if (result.s == null || !isHexString(result.s)) logger.throwArgumentError("signature missing or invalid s", "signature", signature);
        else result.s = hexZeroPad(result.s, 32);
        const vs = arrayify(result.s);
        if (vs[0] >= 128) logger.throwArgumentError("signature s out of range", "signature", signature);
        if (result.recoveryParam) vs[0] |= 0x80;
        const _vs = hexlify(vs);
        if (result._vs) {
            if (!isHexString(result._vs)) logger.throwArgumentError("signature invalid _vs", "signature", signature);
            result._vs = hexZeroPad(result._vs, 32);
        }
        // Set or check the _vs
        if (result._vs == null) result._vs = _vs;
        else if (result._vs !== _vs) logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
    }
    result.yParityAndS = result._vs;
    result.compact = result.r + result.yParityAndS.substring(2);
    return result;
}
function joinSignature(signature) {
    signature = splitSignature(signature);
    return hexlify(concat([
        signature.r,
        signature.s,
        signature.recoveryParam ? "0x1c" : "0x1b"
    ]));
}

},{"@ethersproject/logger":"9rXfv","./_version":"lPley","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lPley":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "bytes/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i8qlg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "bignumber/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7PLOB":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "formatFixed", ()=>formatFixed);
parcelHelpers.export(exports, "parseFixed", ()=>parseFixed);
parcelHelpers.export(exports, "FixedFormat", ()=>FixedFormat);
parcelHelpers.export(exports, "FixedNumber", ()=>FixedNumber);
var _bytes = require("@ethersproject/bytes");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _bignumber = require("./bignumber");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const _constructorGuard = {};
const Zero = (0, _bignumber.BigNumber).from(0);
const NegativeOne = (0, _bignumber.BigNumber).from(-1);
function throwFault(message, fault, operation, value) {
    const params = {
        fault: fault,
        operation: operation
    };
    if (value !== undefined) params.value = value;
    return logger.throwError(message, (0, _logger.Logger).errors.NUMERIC_FAULT, params);
}
// Constant to pull zeros from for multipliers
let zeros = "0";
while(zeros.length < 256)zeros += zeros;
// Returns a string "1" followed by decimal "0"s
function getMultiplier(decimals) {
    if (typeof decimals !== "number") try {
        decimals = (0, _bignumber.BigNumber).from(decimals).toNumber();
    } catch (e) {}
    if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) return "1" + zeros.substring(0, decimals);
    return logger.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
    if (decimals == null) decimals = 0;
    const multiplier = getMultiplier(decimals);
    // Make sure wei is a big number (convert as necessary)
    value = (0, _bignumber.BigNumber).from(value);
    const negative = value.lt(Zero);
    if (negative) value = value.mul(NegativeOne);
    let fraction = value.mod(multiplier).toString();
    while(fraction.length < multiplier.length - 1)fraction = "0" + fraction;
    // Strip training 0
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const whole = value.div(multiplier).toString();
    if (multiplier.length === 1) value = whole;
    else value = whole + "." + fraction;
    if (negative) value = "-" + value;
    return value;
}
function parseFixed(value, decimals) {
    if (decimals == null) decimals = 0;
    const multiplier = getMultiplier(decimals);
    if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) logger.throwArgumentError("invalid decimal value", "value", value);
    // Is it negative?
    const negative = value.substring(0, 1) === "-";
    if (negative) value = value.substring(1);
    if (value === ".") logger.throwArgumentError("missing value", "value", value);
    // Split it into a whole and fractional part
    const comps = value.split(".");
    if (comps.length > 2) logger.throwArgumentError("too many decimal points", "value", value);
    let whole = comps[0], fraction = comps[1];
    if (!whole) whole = "0";
    if (!fraction) fraction = "0";
    // Trim trailing zeros
    while(fraction[fraction.length - 1] === "0")fraction = fraction.substring(0, fraction.length - 1);
    // Check the fraction doesn't exceed our decimals size
    if (fraction.length > multiplier.length - 1) throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
    // If decimals is 0, we have an empty string for fraction
    if (fraction === "") fraction = "0";
    // Fully pad the string with zeros to get to wei
    while(fraction.length < multiplier.length - 1)fraction += "0";
    const wholeValue = (0, _bignumber.BigNumber).from(whole);
    const fractionValue = (0, _bignumber.BigNumber).from(fraction);
    let wei = wholeValue.mul(multiplier).add(fractionValue);
    if (negative) wei = wei.mul(NegativeOne);
    return wei;
}
class FixedFormat {
    constructor(constructorGuard, signed, width, decimals){
        if (constructorGuard !== _constructorGuard) logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
        });
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
    }
    static from(value) {
        if (value instanceof FixedFormat) return value;
        if (typeof value === "number") value = `fixed128x${value}`;
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof value === "string") {
            if (value === "fixed") ;
            else if (value === "ufixed") signed = false;
            else {
                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                if (!match) logger.throwArgumentError("invalid fixed format", "format", value);
                signed = match[1] !== "u";
                width = parseInt(match[2]);
                decimals = parseInt(match[3]);
            }
        } else if (value) {
            const check = (key, type, defaultValue)=>{
                if (value[key] == null) return defaultValue;
                if (typeof value[key] !== type) logger.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
                return value[key];
            };
            signed = check("signed", "boolean", signed);
            width = check("width", "number", width);
            decimals = check("decimals", "number", decimals);
        }
        if (width % 8) logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        if (decimals > 80) logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        return new FixedFormat(_constructorGuard, signed, width, decimals);
    }
}
class FixedNumber {
    constructor(constructorGuard, hex, value, format){
        if (constructorGuard !== _constructorGuard) logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
        });
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
    }
    _checkFormat(other) {
        if (this.format.name !== other.format.name) logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
    addUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
    }
    subUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
    }
    mulUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
    }
    divUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
    }
    floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) comps.push("0");
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) result = result.subUnsafe(ONE.toFormat(result.format));
        return result;
    }
    ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) comps.push("0");
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) result = result.addUnsafe(ONE.toFormat(result.format));
        return result;
    }
    // @TODO: Support other rounding algorithms
    round(decimals) {
        if (decimals == null) decimals = 0;
        // If we are already in range, we're done
        const comps = this.toString().split(".");
        if (comps.length === 1) comps.push("0");
        if (decimals < 0 || decimals > 80 || decimals % 1) logger.throwArgumentError("invalid decimal count", "decimals", decimals);
        if (comps[1].length <= decimals) return this;
        const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    }
    isZero() {
        return this._value === "0.0" || this._value === "0";
    }
    isNegative() {
        return this._value[0] === "-";
    }
    toString() {
        return this._value;
    }
    toHexString(width) {
        if (width == null) return this._hex;
        if (width % 8) logger.throwArgumentError("invalid byte width", "width", width);
        const hex = (0, _bignumber.BigNumber).from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return (0, _bytes.hexZeroPad)(hex, width / 8);
    }
    toUnsafeFloat() {
        return parseFloat(this.toString());
    }
    toFormat(format) {
        return FixedNumber.fromString(this._value, format);
    }
    static fromValue(value, decimals, format) {
        // If decimals looks more like a format, and there is no format, shift the parameters
        if (format == null && decimals != null && !(0, _bignumber.isBigNumberish)(decimals)) {
            format = decimals;
            decimals = null;
        }
        if (decimals == null) decimals = 0;
        if (format == null) format = "fixed";
        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
    }
    static fromString(value, format) {
        if (format == null) format = "fixed";
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) throwFault("unsigned value cannot be negative", "overflow", "value", value);
        let hex = null;
        if (fixedFormat.signed) hex = numeric.toTwos(fixedFormat.width).toHexString();
        else {
            hex = numeric.toHexString();
            hex = (0, _bytes.hexZeroPad)(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    }
    static fromBytes(value, format) {
        if (format == null) format = "fixed";
        const fixedFormat = FixedFormat.from(format);
        if ((0, _bytes.arrayify)(value).length > fixedFormat.width / 8) throw new Error("overflow");
        let numeric = (0, _bignumber.BigNumber).from(value);
        if (fixedFormat.signed) numeric = numeric.fromTwos(fixedFormat.width);
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    }
    static from(value, format) {
        if (typeof value === "string") return FixedNumber.fromString(value, format);
        if ((0, _bytes.isBytes)(value)) return FixedNumber.fromBytes(value, format);
        try {
            return FixedNumber.fromValue(value, 0, format);
        } catch (error) {
            // Allow NUMERIC_FAULT to bubble up
            if (error.code !== (0, _logger.Logger).errors.INVALID_ARGUMENT) throw error;
        }
        return logger.throwArgumentError("invalid FixedNumber value", "value", value);
    }
    static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
    }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");

},{"@ethersproject/bytes":"5ReBN","@ethersproject/logger":"9rXfv","./_version":"i8qlg","./bignumber":"7nvDB","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4VLWn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "abstract-provider/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hQL7z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 *  getNetwork
 *
 *  Converts a named common networks or chain ID (network ID) to a Network
 *  and verifies a network is a valid Network..
 */ parcelHelpers.export(exports, "getNetwork", ()=>getNetwork);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function isRenetworkable(value) {
    return value && typeof value.renetwork === "function";
}
function ethDefaultProvider(network) {
    const func = function(providers, options) {
        if (options == null) options = {};
        const providerList = [];
        if (providers.InfuraProvider && options.infura !== "-") try {
            providerList.push(new providers.InfuraProvider(network, options.infura));
        } catch (error) {}
        if (providers.EtherscanProvider && options.etherscan !== "-") try {
            providerList.push(new providers.EtherscanProvider(network, options.etherscan));
        } catch (error) {}
        if (providers.AlchemyProvider && options.alchemy !== "-") try {
            providerList.push(new providers.AlchemyProvider(network, options.alchemy));
        } catch (error) {}
        if (providers.PocketProvider && options.pocket !== "-") {
            // These networks are currently faulty on Pocket as their
            // network does not handle the Berlin hardfork, which is
            // live on these ones.
            // @TODO: This goes away once Pocket has upgraded their nodes
            const skip = [
                "goerli",
                "ropsten",
                "rinkeby",
                "sepolia"
            ];
            try {
                const provider = new providers.PocketProvider(network, options.pocket);
                if (provider.network && skip.indexOf(provider.network.name) === -1) providerList.push(provider);
            } catch (error) {}
        }
        if (providers.CloudflareProvider && options.cloudflare !== "-") try {
            providerList.push(new providers.CloudflareProvider(network));
        } catch (error) {}
        if (providers.AnkrProvider && options.ankr !== "-") try {
            const skip = [
                "ropsten"
            ];
            const provider = new providers.AnkrProvider(network, options.ankr);
            if (provider.network && skip.indexOf(provider.network.name) === -1) providerList.push(provider);
        } catch (error) {}
        if (providers.QuickNodeProvider && options.quicknode !== "-") try {
            providerList.push(new providers.QuickNodeProvider(network, options.quicknode));
        } catch (error) {}
        if (providerList.length === 0) return null;
        if (providers.FallbackProvider) {
            let quorum = 1;
            if (options.quorum != null) quorum = options.quorum;
            else if (network === "homestead") quorum = 2;
            return new providers.FallbackProvider(providerList, quorum);
        }
        return providerList[0];
    };
    func.renetwork = function(network) {
        return ethDefaultProvider(network);
    };
    return func;
}
function etcDefaultProvider(url, network) {
    const func = function(providers, options) {
        if (providers.JsonRpcProvider) return new providers.JsonRpcProvider(url, network);
        return null;
    };
    func.renetwork = function(network) {
        return etcDefaultProvider(url, network);
    };
    return func;
}
const homestead = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
// See: https://chainlist.org
const networks = {
    unspecified: {
        chainId: 0,
        name: "unspecified"
    },
    homestead: homestead,
    mainnet: homestead,
    morden: {
        chainId: 2,
        name: "morden"
    },
    ropsten: ropsten,
    testnet: ropsten,
    rinkeby: {
        chainId: 4,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "rinkeby",
        _defaultProvider: ethDefaultProvider("rinkeby")
    },
    kovan: {
        chainId: 42,
        name: "kovan",
        _defaultProvider: ethDefaultProvider("kovan")
    },
    goerli: {
        chainId: 5,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "goerli",
        _defaultProvider: ethDefaultProvider("goerli")
    },
    kintsugi: {
        chainId: 1337702,
        name: "kintsugi"
    },
    sepolia: {
        chainId: 11155111,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "sepolia",
        _defaultProvider: ethDefaultProvider("sepolia")
    },
    holesky: {
        chainId: 17000,
        name: "holesky",
        _defaultProvider: ethDefaultProvider("holesky")
    },
    // ETC (See: #351)
    classic: {
        chainId: 61,
        name: "classic",
        _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/etc", "classic")
    },
    classicMorden: {
        chainId: 62,
        name: "classicMorden"
    },
    classicMordor: classicMordor,
    classicTestnet: classicMordor,
    classicKotti: {
        chainId: 6,
        name: "classicKotti",
        _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/kotti", "classicKotti")
    },
    xdai: {
        chainId: 100,
        name: "xdai"
    },
    matic: {
        chainId: 137,
        name: "matic",
        _defaultProvider: ethDefaultProvider("matic")
    },
    maticmum: {
        chainId: 80001,
        name: "maticmum",
        _defaultProvider: ethDefaultProvider("maticmum")
    },
    optimism: {
        chainId: 10,
        name: "optimism",
        _defaultProvider: ethDefaultProvider("optimism")
    },
    "optimism-kovan": {
        chainId: 69,
        name: "optimism-kovan"
    },
    "optimism-goerli": {
        chainId: 420,
        name: "optimism-goerli"
    },
    "optimism-sepolia": {
        chainId: 11155420,
        name: "optimism-sepolia"
    },
    arbitrum: {
        chainId: 42161,
        name: "arbitrum"
    },
    "arbitrum-rinkeby": {
        chainId: 421611,
        name: "arbitrum-rinkeby"
    },
    "arbitrum-goerli": {
        chainId: 421613,
        name: "arbitrum-goerli"
    },
    "arbitrum-sepolia": {
        chainId: 421614,
        name: "arbitrum-sepolia"
    },
    bnb: {
        chainId: 56,
        name: "bnb"
    },
    bnbt: {
        chainId: 97,
        name: "bnbt"
    }
};
function getNetwork(network) {
    // No network (null)
    if (network == null) return null;
    if (typeof network === "number") {
        for(const name in networks){
            const standard = networks[name];
            if (standard.chainId === network) return {
                name: standard.name,
                chainId: standard.chainId,
                ensAddress: standard.ensAddress || null,
                _defaultProvider: standard._defaultProvider || null
            };
        }
        return {
            chainId: network,
            name: "unknown"
        };
    }
    if (typeof network === "string") {
        const standard = networks[network];
        if (standard == null) return null;
        return {
            name: standard.name,
            chainId: standard.chainId,
            ensAddress: standard.ensAddress,
            _defaultProvider: standard._defaultProvider || null
        };
    }
    const standard = networks[network.name];
    // Not a standard network; check that it is a valid network in general
    if (!standard) {
        if (typeof network.chainId !== "number") logger.throwArgumentError("invalid network chainId", "network", network);
        return network;
    }
    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)
    if (network.chainId !== 0 && network.chainId !== standard.chainId) logger.throwArgumentError("network chainId mismatch", "network", network);
    // @TODO: In the next major version add an attach function to a defaultProvider
    // class and move the _defaultProvider internal to this file (extend Network)
    let defaultProvider = network._defaultProvider || null;
    if (defaultProvider == null && standard._defaultProvider) {
        if (isRenetworkable(standard._defaultProvider)) defaultProvider = standard._defaultProvider.renetwork(network);
        else defaultProvider = standard._defaultProvider;
    }
    // Standard Network (allow overriding the ENS address)
    return {
        name: network.name,
        chainId: standard.chainId,
        ensAddress: network.ensAddress || standard.ensAddress || null,
        _defaultProvider: defaultProvider
    };
}

},{"@ethersproject/logger":"9rXfv","./_version":"bIFuk","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bIFuk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "networks/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8jgHV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Event", ()=>Event);
parcelHelpers.export(exports, "Resolver", ()=>Resolver);
parcelHelpers.export(exports, "BaseProvider", ()=>BaseProvider);
var _abstractProvider = require("@ethersproject/abstract-provider");
var _base64 = require("@ethersproject/base64");
var _basex = require("@ethersproject/basex");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _constants = require("@ethersproject/constants");
var _hash = require("@ethersproject/hash");
var _networks = require("@ethersproject/networks");
var _properties = require("@ethersproject/properties");
var _sha2 = require("@ethersproject/sha2");
var _strings = require("@ethersproject/strings");
var _web = require("@ethersproject/web");
var _bech32 = require("bech32");
var _bech32Default = parcelHelpers.interopDefault(_bech32);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _formatter = require("./formatter");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
const MAX_CCIP_REDIRECTS = 10;
//////////////////////////////
// Event Serializeing
function checkTopic(topic) {
    if (topic == null) return "null";
    if ((0, _bytes.hexDataLength)(topic) !== 32) logger.throwArgumentError("invalid topic", "topic", topic);
    return topic.toLowerCase();
}
function serializeTopics(topics) {
    // Remove trailing null AND-topics; they are redundant
    topics = topics.slice();
    while(topics.length > 0 && topics[topics.length - 1] == null)topics.pop();
    return topics.map((topic)=>{
        if (Array.isArray(topic)) {
            // Only track unique OR-topics
            const unique = {};
            topic.forEach((topic)=>{
                unique[checkTopic(topic)] = true;
            });
            // The order of OR-topics does not matter
            const sorted = Object.keys(unique);
            sorted.sort();
            return sorted.join("|");
        } else return checkTopic(topic);
    }).join("&");
}
function deserializeTopics(data) {
    if (data === "") return [];
    return data.split(/&/g).map((topic)=>{
        if (topic === "") return [];
        const comps = topic.split("|").map((topic)=>{
            return topic === "null" ? null : topic;
        });
        return comps.length === 1 ? comps[0] : comps;
    });
}
function getEventTag(eventName) {
    if (typeof eventName === "string") {
        eventName = eventName.toLowerCase();
        if ((0, _bytes.hexDataLength)(eventName) === 32) return "tx:" + eventName;
        if (eventName.indexOf(":") === -1) return eventName;
    } else if (Array.isArray(eventName)) return "filter:*:" + serializeTopics(eventName);
    else if ((0, _abstractProvider.ForkEvent).isForkEvent(eventName)) {
        logger.warn("not implemented");
        throw new Error("not implemented");
    } else if (eventName && typeof eventName === "object") return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
    throw new Error("invalid event - " + eventName);
}
//////////////////////////////
// Helper Object
function getTime() {
    return new Date().getTime();
}
function stall(duration) {
    return new Promise((resolve)=>{
        setTimeout(resolve, duration);
    });
}
//////////////////////////////
// Provider Object
/**
 *  EventType
 *   - "block"
 *   - "poll"
 *   - "didPoll"
 *   - "pending"
 *   - "error"
 *   - "network"
 *   - filter
 *   - topics array
 *   - transaction hash
 */ const PollableEvents = [
    "block",
    "network",
    "pending",
    "poll"
];
class Event {
    constructor(tag, listener, once){
        (0, _properties.defineReadOnly)(this, "tag", tag);
        (0, _properties.defineReadOnly)(this, "listener", listener);
        (0, _properties.defineReadOnly)(this, "once", once);
        this._lastBlockNumber = -2;
        this._inflight = false;
    }
    get event() {
        switch(this.type){
            case "tx":
                return this.hash;
            case "filter":
                return this.filter;
        }
        return this.tag;
    }
    get type() {
        return this.tag.split(":")[0];
    }
    get hash() {
        const comps = this.tag.split(":");
        if (comps[0] !== "tx") return null;
        return comps[1];
    }
    get filter() {
        const comps = this.tag.split(":");
        if (comps[0] !== "filter") return null;
        const address = comps[1];
        const topics = deserializeTopics(comps[2]);
        const filter = {};
        if (topics.length > 0) filter.topics = topics;
        if (address && address !== "*") filter.address = address;
        return filter;
    }
    pollable() {
        return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
    }
}
// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
const coinInfos = {
    "0": {
        symbol: "btc",
        p2pkh: 0x00,
        p2sh: 0x05,
        prefix: "bc"
    },
    "2": {
        symbol: "ltc",
        p2pkh: 0x30,
        p2sh: 0x32,
        prefix: "ltc"
    },
    "3": {
        symbol: "doge",
        p2pkh: 0x1e,
        p2sh: 0x16
    },
    "60": {
        symbol: "eth",
        ilk: "eth"
    },
    "61": {
        symbol: "etc",
        ilk: "eth"
    },
    "700": {
        symbol: "xdai",
        ilk: "eth"
    }
};
function bytes32ify(value) {
    return (0, _bytes.hexZeroPad)((0, _bignumber.BigNumber).from(value).toHexString(), 32);
}
// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)
function base58Encode(data) {
    return (0, _basex.Base58).encode((0, _bytes.concat)([
        data,
        (0, _bytes.hexDataSlice)((0, _sha2.sha256)((0, _sha2.sha256)(data)), 0, 4)
    ]));
}
const matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
const matchers = [
    new RegExp("^(https):/\/(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    matcherIpfs,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function _parseString(result, start) {
    try {
        return (0, _strings.toUtf8String)(_parseBytes(result, start));
    } catch (error) {}
    return null;
}
function _parseBytes(result, start) {
    if (result === "0x") return null;
    const offset = (0, _bignumber.BigNumber).from((0, _bytes.hexDataSlice)(result, start, start + 32)).toNumber();
    const length = (0, _bignumber.BigNumber).from((0, _bytes.hexDataSlice)(result, offset, offset + 32)).toNumber();
    return (0, _bytes.hexDataSlice)(result, offset + 32, offset + 32 + length);
}
// Trim off the ipfs:// prefix and return the default gateway URL
function getIpfsLink(link) {
    if (link.match(/^ipfs:\/\/ipfs\//i)) link = link.substring(12);
    else if (link.match(/^ipfs:\/\//i)) link = link.substring(7);
    else logger.throwArgumentError("unsupported IPFS format", "link", link);
    return `https:/\/gateway.ipfs.io/ipfs/${link}`;
}
function numPad(value) {
    const result = (0, _bytes.arrayify)(value);
    if (result.length > 32) throw new Error("internal; should not happen");
    const padded = new Uint8Array(32);
    padded.set(result, 32 - result.length);
    return padded;
}
function bytesPad(value) {
    if (value.length % 32 === 0) return value;
    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
    result.set(value);
    return result;
}
// ABI Encodes a series of (bytes, bytes, ...)
function encodeBytes(datas) {
    const result = [];
    let byteCount = 0;
    // Add place-holders for pointers as we add items
    for(let i = 0; i < datas.length; i++){
        result.push(null);
        byteCount += 32;
    }
    for(let i = 0; i < datas.length; i++){
        const data = (0, _bytes.arrayify)(datas[i]);
        // Update the bytes offset
        result[i] = numPad(byteCount);
        // The length and padded value of data
        result.push(numPad(data.length));
        result.push(bytesPad(data));
        byteCount += 32 + Math.ceil(data.length / 32) * 32;
    }
    return (0, _bytes.hexConcat)(result);
}
class Resolver {
    // The resolvedAddress is only for creating a ReverseLookup resolver
    constructor(provider, address, name, resolvedAddress){
        (0, _properties.defineReadOnly)(this, "provider", provider);
        (0, _properties.defineReadOnly)(this, "name", name);
        (0, _properties.defineReadOnly)(this, "address", provider.formatter.address(address));
        (0, _properties.defineReadOnly)(this, "_resolvedAddress", resolvedAddress);
    }
    supportsWildcard() {
        if (!this._supportsEip2544) // supportsInterface(bytes4 = selector("resolve(bytes,bytes)"))
        this._supportsEip2544 = this.provider.call({
            to: this.address,
            data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
        }).then((result)=>{
            return (0, _bignumber.BigNumber).from(result).eq(1);
        }).catch((error)=>{
            if (error.code === (0, _logger.Logger).errors.CALL_EXCEPTION) return false;
            // Rethrow the error: link is down, etc. Let future attempts retry.
            this._supportsEip2544 = null;
            throw error;
        });
        return this._supportsEip2544;
    }
    _fetch(selector, parameters) {
        return __awaiter(this, void 0, void 0, function*() {
            // e.g. keccak256("addr(bytes32,uint256)")
            const tx = {
                to: this.address,
                ccipReadEnabled: true,
                data: (0, _bytes.hexConcat)([
                    selector,
                    (0, _hash.namehash)(this.name),
                    parameters || "0x"
                ])
            };
            // Wildcard support; use EIP-2544 to resolve the request
            let parseBytes = false;
            if (yield this.supportsWildcard()) {
                parseBytes = true;
                // selector("resolve(bytes,bytes)")
                tx.data = (0, _bytes.hexConcat)([
                    "0x9061b923",
                    encodeBytes([
                        (0, _hash.dnsEncode)(this.name),
                        tx.data
                    ])
                ]);
            }
            try {
                let result = yield this.provider.call(tx);
                if ((0, _bytes.arrayify)(result).length % 32 === 4) logger.throwError("resolver threw error", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                    transaction: tx,
                    data: result
                });
                if (parseBytes) result = _parseBytes(result, 0);
                return result;
            } catch (error) {
                if (error.code === (0, _logger.Logger).errors.CALL_EXCEPTION) return null;
                throw error;
            }
        });
    }
    _fetchBytes(selector, parameters) {
        return __awaiter(this, void 0, void 0, function*() {
            const result = yield this._fetch(selector, parameters);
            if (result != null) return _parseBytes(result, 0);
            return null;
        });
    }
    _getAddress(coinType, hexBytes) {
        const coinInfo = coinInfos[String(coinType)];
        if (coinInfo == null) logger.throwError(`unsupported coin type: ${coinType}`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: `getAddress(${coinType})`
        });
        if (coinInfo.ilk === "eth") return this.provider.formatter.address(hexBytes);
        const bytes = (0, _bytes.arrayify)(hexBytes);
        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        if (coinInfo.p2pkh != null) {
            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
            if (p2pkh) {
                const length = parseInt(p2pkh[1], 16);
                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) return base58Encode((0, _bytes.concat)([
                    [
                        coinInfo.p2pkh
                    ],
                    "0x" + p2pkh[2]
                ]));
            }
        }
        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL
        if (coinInfo.p2sh != null) {
            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
            if (p2sh) {
                const length = parseInt(p2sh[1], 16);
                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) return base58Encode((0, _bytes.concat)([
                    [
                        coinInfo.p2sh
                    ],
                    "0x" + p2sh[2]
                ]));
            }
        }
        // Bech32
        if (coinInfo.prefix != null) {
            const length = bytes[1];
            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program
            let version = bytes[0];
            if (version === 0x00) {
                if (length !== 20 && length !== 32) version = -1;
            } else version = -1;
            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
                const words = (0, _bech32Default.default).toWords(bytes.slice(2));
                words.unshift(version);
                return (0, _bech32Default.default).encode(coinInfo.prefix, words);
            }
        }
        return null;
    }
    getAddress(coinType) {
        return __awaiter(this, void 0, void 0, function*() {
            if (coinType == null) coinType = 60;
            // If Ethereum, use the standard `addr(bytes32)`
            if (coinType === 60) try {
                // keccak256("addr(bytes32)")
                const result = yield this._fetch("0x3b3b57de");
                // No address
                if (result === "0x" || result === (0, _constants.HashZero)) return null;
                return this.provider.formatter.callAddress(result);
            } catch (error) {
                if (error.code === (0, _logger.Logger).errors.CALL_EXCEPTION) return null;
                throw error;
            }
            // keccak256("addr(bytes32,uint256")
            const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
            // No address
            if (hexBytes == null || hexBytes === "0x") return null;
            // Compute the address
            const address = this._getAddress(coinType, hexBytes);
            if (address == null) logger.throwError(`invalid or unsupported coin data`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: `getAddress(${coinType})`,
                coinType: coinType,
                data: hexBytes
            });
            return address;
        });
    }
    getAvatar() {
        return __awaiter(this, void 0, void 0, function*() {
            const linkage = [
                {
                    type: "name",
                    content: this.name
                }
            ];
            try {
                // test data for ricmoo.eth
                //const avatar = "eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233";
                const avatar = yield this.getText("avatar");
                if (avatar == null) return null;
                for(let i = 0; i < matchers.length; i++){
                    const match = avatar.match(matchers[i]);
                    if (match == null) continue;
                    const scheme = match[1].toLowerCase();
                    switch(scheme){
                        case "https":
                            linkage.push({
                                type: "url",
                                content: avatar
                            });
                            return {
                                linkage,
                                url: avatar
                            };
                        case "data":
                            linkage.push({
                                type: "data",
                                content: avatar
                            });
                            return {
                                linkage,
                                url: avatar
                            };
                        case "ipfs":
                            linkage.push({
                                type: "ipfs",
                                content: avatar
                            });
                            return {
                                linkage,
                                url: getIpfsLink(avatar)
                            };
                        case "erc721":
                        case "erc1155":
                            {
                                // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
                                const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                                linkage.push({
                                    type: scheme,
                                    content: avatar
                                });
                                // The owner of this name
                                const owner = this._resolvedAddress || (yield this.getAddress());
                                const comps = (match[2] || "").split("/");
                                if (comps.length !== 2) return null;
                                const addr = yield this.provider.formatter.address(comps[0]);
                                const tokenId = (0, _bytes.hexZeroPad)((0, _bignumber.BigNumber).from(comps[1]).toHexString(), 32);
                                // Check that this account owns the token
                                if (scheme === "erc721") {
                                    // ownerOf(uint256 tokenId)
                                    const tokenOwner = this.provider.formatter.callAddress((yield this.provider.call({
                                        to: addr,
                                        data: (0, _bytes.hexConcat)([
                                            "0x6352211e",
                                            tokenId
                                        ])
                                    })));
                                    if (owner !== tokenOwner) return null;
                                    linkage.push({
                                        type: "owner",
                                        content: tokenOwner
                                    });
                                } else if (scheme === "erc1155") {
                                    // balanceOf(address owner, uint256 tokenId)
                                    const balance = (0, _bignumber.BigNumber).from((yield this.provider.call({
                                        to: addr,
                                        data: (0, _bytes.hexConcat)([
                                            "0x00fdd58e",
                                            (0, _bytes.hexZeroPad)(owner, 32),
                                            tokenId
                                        ])
                                    })));
                                    if (balance.isZero()) return null;
                                    linkage.push({
                                        type: "balance",
                                        content: balance.toString()
                                    });
                                }
                                // Call the token contract for the metadata URL
                                const tx = {
                                    to: this.provider.formatter.address(comps[0]),
                                    data: (0, _bytes.hexConcat)([
                                        selector,
                                        tokenId
                                    ])
                                };
                                let metadataUrl = _parseString((yield this.provider.call(tx)), 0);
                                if (metadataUrl == null) return null;
                                linkage.push({
                                    type: "metadata-url-base",
                                    content: metadataUrl
                                });
                                // ERC-1155 allows a generic {id} in the URL
                                if (scheme === "erc1155") {
                                    metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                                    linkage.push({
                                        type: "metadata-url-expanded",
                                        content: metadataUrl
                                    });
                                }
                                // Transform IPFS metadata links
                                if (metadataUrl.match(/^ipfs:/i)) metadataUrl = getIpfsLink(metadataUrl);
                                linkage.push({
                                    type: "metadata-url",
                                    content: metadataUrl
                                });
                                // Get the token metadata
                                const metadata = yield (0, _web.fetchJson)(metadataUrl);
                                if (!metadata) return null;
                                linkage.push({
                                    type: "metadata",
                                    content: JSON.stringify(metadata)
                                });
                                // Pull the image URL out
                                let imageUrl = metadata.image;
                                if (typeof imageUrl !== "string") return null;
                                if (imageUrl.match(/^(https:\/\/|data:)/i)) ;
                                else {
                                    // Transform IPFS link to gateway
                                    const ipfs = imageUrl.match(matcherIpfs);
                                    if (ipfs == null) return null;
                                    linkage.push({
                                        type: "url-ipfs",
                                        content: imageUrl
                                    });
                                    imageUrl = getIpfsLink(imageUrl);
                                }
                                linkage.push({
                                    type: "url",
                                    content: imageUrl
                                });
                                return {
                                    linkage,
                                    url: imageUrl
                                };
                            }
                    }
                }
            } catch (error) {}
            return null;
        });
    }
    getContentHash() {
        return __awaiter(this, void 0, void 0, function*() {
            // keccak256("contenthash()")
            const hexBytes = yield this._fetchBytes("0xbc1c58d1");
            // No contenthash
            if (hexBytes == null || hexBytes === "0x") return null;
            // IPFS (CID: 1, Type: DAG-PB)
            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (ipfs) {
                const length = parseInt(ipfs[3], 16);
                if (ipfs[4].length === length * 2) return "ipfs:/\/" + (0, _basex.Base58).encode("0x" + ipfs[1]);
            }
            // IPNS (CID: 1, Type: libp2p-key)
            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (ipns) {
                const length = parseInt(ipns[3], 16);
                if (ipns[4].length === length * 2) return "ipns:/\/" + (0, _basex.Base58).encode("0x" + ipns[1]);
            }
            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (swarm) {
                if (swarm[1].length === 64) return "bzz:/\/" + swarm[1];
            }
            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
            if (skynet) {
                if (skynet[1].length === 68) {
                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5
                    const urlSafe = {
                        "=": "",
                        "+": "-",
                        "/": "_"
                    };
                    const hash = (0, _base64.encode)("0x" + skynet[1]).replace(/[=+\/]/g, (a)=>urlSafe[a]);
                    return "sia:/\/" + hash;
                }
            }
            return logger.throwError(`invalid or unsupported content hash data`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "getContentHash()",
                data: hexBytes
            });
        });
    }
    getText(key) {
        return __awaiter(this, void 0, void 0, function*() {
            // The key encoded as parameter to fetchBytes
            let keyBytes = (0, _strings.toUtf8Bytes)(key);
            // The nodehash consumes the first slot, so the string pointer targets
            // offset 64, with the length at offset 64 and data starting at offset 96
            keyBytes = (0, _bytes.concat)([
                bytes32ify(64),
                bytes32ify(keyBytes.length),
                keyBytes
            ]);
            // Pad to word-size (32 bytes)
            if (keyBytes.length % 32 !== 0) keyBytes = (0, _bytes.concat)([
                keyBytes,
                (0, _bytes.hexZeroPad)("0x", 32 - key.length % 32)
            ]);
            const hexBytes = yield this._fetchBytes("0x59d1d43c", (0, _bytes.hexlify)(keyBytes));
            if (hexBytes == null || hexBytes === "0x") return null;
            return (0, _strings.toUtf8String)(hexBytes);
        });
    }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends (0, _abstractProvider.Provider) {
    /**
     *  ready
     *
     *  A Promise<Network> that resolves only once the provider is ready.
     *
     *  Sub-classes that call the super with a network without a chainId
     *  MUST set this. Standard named networks have a known chainId.
     *
     */ constructor(network){
        super();
        // Events being listened to
        this._events = [];
        this._emitted = {
            block: -2
        };
        this.disableCcipRead = false;
        this.formatter = new.target.getFormatter();
        // If network is any, this Provider allows the underlying
        // network to change dynamically, and we auto-detect the
        // current network
        (0, _properties.defineReadOnly)(this, "anyNetwork", network === "any");
        if (this.anyNetwork) network = this.detectNetwork();
        if (network instanceof Promise) {
            this._networkPromise = network;
            // Squash any "unhandled promise" errors; that do not need to be handled
            network.catch((error)=>{});
            // Trigger initial network setting (async)
            this._ready().catch((error)=>{});
        } else {
            const knownNetwork = (0, _properties.getStatic)(new.target, "getNetwork")(network);
            if (knownNetwork) {
                (0, _properties.defineReadOnly)(this, "_network", knownNetwork);
                this.emit("network", knownNetwork, null);
            } else logger.throwArgumentError("invalid network", "network", network);
        }
        this._maxInternalBlockNumber = -1024;
        this._lastBlockNumber = -2;
        this._maxFilterBlockRange = 10;
        this._pollingInterval = 4000;
        this._fastQueryDate = 0;
    }
    _ready() {
        return __awaiter(this, void 0, void 0, function*() {
            if (this._network == null) {
                let network = null;
                if (this._networkPromise) try {
                    network = yield this._networkPromise;
                } catch (error) {}
                // Try the Provider's network detection (this MUST throw if it cannot)
                if (network == null) network = yield this.detectNetwork();
                // This should never happen; every Provider sub-class should have
                // suggested a network by here (or have thrown).
                if (!network) logger.throwError("no network detected", (0, _logger.Logger).errors.UNKNOWN_ERROR, {});
                // Possible this call stacked so do not call defineReadOnly again
                if (this._network == null) {
                    if (this.anyNetwork) this._network = network;
                    else (0, _properties.defineReadOnly)(this, "_network", network);
                    this.emit("network", network, null);
                }
            }
            return this._network;
        });
    }
    // This will always return the most recently established network.
    // For "any", this can change (a "network" event is emitted before
    // any change is reflected); otherwise this cannot change
    get ready() {
        return (0, _web.poll)(()=>{
            return this._ready().then((network)=>{
                return network;
            }, (error)=>{
                // If the network isn't running yet, we will wait
                if (error.code === (0, _logger.Logger).errors.NETWORK_ERROR && error.event === "noNetwork") return undefined;
                throw error;
            });
        });
    }
    // @TODO: Remove this and just create a singleton formatter
    static getFormatter() {
        if (defaultFormatter == null) defaultFormatter = new (0, _formatter.Formatter)();
        return defaultFormatter;
    }
    // @TODO: Remove this and just use getNetwork
    static getNetwork(network) {
        return (0, _networks.getNetwork)(network == null ? "homestead" : network);
    }
    ccipReadFetch(tx, calldata, urls) {
        return __awaiter(this, void 0, void 0, function*() {
            if (this.disableCcipRead || urls.length === 0) return null;
            const sender = tx.to.toLowerCase();
            const data = calldata.toLowerCase();
            const errorMessages = [];
            for(let i = 0; i < urls.length; i++){
                const url = urls[i];
                // URL expansion
                const href = url.replace("{sender}", sender).replace("{data}", data);
                // If no {data} is present, use POST; otherwise GET
                const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({
                    data,
                    sender
                });
                const result = yield (0, _web.fetchJson)({
                    url: href,
                    errorPassThrough: true
                }, json, (value, response)=>{
                    value.status = response.statusCode;
                    return value;
                });
                if (result.data) return result.data;
                const errorMessage = result.message || "unknown error";
                // 4xx indicates the result is not present; stop
                if (result.status >= 400 && result.status < 500) return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, (0, _logger.Logger).errors.SERVER_ERROR, {
                    url,
                    errorMessage
                });
                // 5xx indicates server issue; try the next url
                errorMessages.push(errorMessage);
            }
            return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m)=>JSON.stringify(m)).join(", ")}`, (0, _logger.Logger).errors.SERVER_ERROR, {
                urls,
                errorMessages
            });
        });
    }
    // Fetches the blockNumber, but will reuse any result that is less
    // than maxAge old or has been requested since the last request
    _getInternalBlockNumber(maxAge) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this._ready();
            // Allowing stale data up to maxAge old
            if (maxAge > 0) // While there are pending internal block requests...
            while(this._internalBlockNumber){
                // ..."remember" which fetch we started with
                const internalBlockNumber = this._internalBlockNumber;
                try {
                    // Check the result is not too stale
                    const result = yield internalBlockNumber;
                    if (getTime() - result.respTime <= maxAge) return result.blockNumber;
                    break;
                } catch (error) {
                    // The fetch rejected; if we are the first to get the
                    // rejection, drop through so we replace it with a new
                    // fetch; all others blocked will then get that fetch
                    // which won't match the one they "remembered" and loop
                    if (this._internalBlockNumber === internalBlockNumber) break;
                }
            }
            const reqTime = getTime();
            const checkInternalBlockNumber = (0, _properties.resolveProperties)({
                blockNumber: this.perform("getBlockNumber", {}),
                networkError: this.getNetwork().then((network)=>null, (error)=>error)
            }).then(({ blockNumber, networkError })=>{
                if (networkError) {
                    // Unremember this bad internal block number
                    if (this._internalBlockNumber === checkInternalBlockNumber) this._internalBlockNumber = null;
                    throw networkError;
                }
                const respTime = getTime();
                blockNumber = (0, _bignumber.BigNumber).from(blockNumber).toNumber();
                if (blockNumber < this._maxInternalBlockNumber) blockNumber = this._maxInternalBlockNumber;
                this._maxInternalBlockNumber = blockNumber;
                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?
                return {
                    blockNumber,
                    reqTime,
                    respTime
                };
            });
            this._internalBlockNumber = checkInternalBlockNumber;
            // Swallow unhandled exceptions; if needed they are handled else where
            checkInternalBlockNumber.catch((error)=>{
                // Don't null the dead (rejected) fetch, if it has already been updated
                if (this._internalBlockNumber === checkInternalBlockNumber) this._internalBlockNumber = null;
            });
            return (yield checkInternalBlockNumber).blockNumber;
        });
    }
    poll() {
        return __awaiter(this, void 0, void 0, function*() {
            const pollId = nextPollId++;
            // Track all running promises, so we can trigger a post-poll once they are complete
            const runners = [];
            let blockNumber = null;
            try {
                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
            } catch (error) {
                this.emit("error", error);
                return;
            }
            this._setFastBlockNumber(blockNumber);
            // Emit a poll event after we have the latest (fast) block number
            this.emit("poll", pollId, blockNumber);
            // If the block has not changed, meh.
            if (blockNumber === this._lastBlockNumber) {
                this.emit("didPoll", pollId);
                return;
            }
            // First polling cycle, trigger a "block" events
            if (this._emitted.block === -2) this._emitted.block = blockNumber - 1;
            if (Math.abs(this._emitted.block - blockNumber) > 1000) {
                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
                this.emit("error", logger.makeError("network block skew detected", (0, _logger.Logger).errors.NETWORK_ERROR, {
                    blockNumber: blockNumber,
                    event: "blockSkew",
                    previousBlockNumber: this._emitted.block
                }));
                this.emit("block", blockNumber);
            } else // Notify all listener for each block that has passed
            for(let i = this._emitted.block + 1; i <= blockNumber; i++)this.emit("block", i);
            // The emitted block was updated, check for obsolete events
            if (this._emitted.block !== blockNumber) {
                this._emitted.block = blockNumber;
                Object.keys(this._emitted).forEach((key)=>{
                    // The block event does not expire
                    if (key === "block") return;
                    // The block we were at when we emitted this event
                    const eventBlockNumber = this._emitted[key];
                    // We cannot garbage collect pending transactions or blocks here
                    // They should be garbage collected by the Provider when setting
                    // "pending" events
                    if (eventBlockNumber === "pending") return;
                    // Evict any transaction hashes or block hashes over 12 blocks
                    // old, since they should not return null anyways
                    if (blockNumber - eventBlockNumber > 12) delete this._emitted[key];
                });
            }
            // First polling cycle
            if (this._lastBlockNumber === -2) this._lastBlockNumber = blockNumber - 1;
            // Find all transaction hashes we are waiting on
            this._events.forEach((event)=>{
                switch(event.type){
                    case "tx":
                        {
                            const hash = event.hash;
                            let runner = this.getTransactionReceipt(hash).then((receipt)=>{
                                if (!receipt || receipt.blockNumber == null) return null;
                                this._emitted["t:" + hash] = receipt.blockNumber;
                                this.emit(hash, receipt);
                                return null;
                            }).catch((error)=>{
                                this.emit("error", error);
                            });
                            runners.push(runner);
                            break;
                        }
                    case "filter":
                        // We only allow a single getLogs to be in-flight at a time
                        if (!event._inflight) {
                            event._inflight = true;
                            // This is the first filter for this event, so we want to
                            // restrict events to events that happened no earlier than now
                            if (event._lastBlockNumber === -2) event._lastBlockNumber = blockNumber - 1;
                            // Filter from the last *known* event; due to load-balancing
                            // and some nodes returning updated block numbers before
                            // indexing events, a logs result with 0 entries cannot be
                            // trusted and we must retry a range which includes it again
                            const filter = event.filter;
                            filter.fromBlock = event._lastBlockNumber + 1;
                            filter.toBlock = blockNumber;
                            // Prevent fitler ranges from growing too wild, since it is quite
                            // likely there just haven't been any events to move the lastBlockNumber.
                            const minFromBlock = filter.toBlock - this._maxFilterBlockRange;
                            if (minFromBlock > filter.fromBlock) filter.fromBlock = minFromBlock;
                            if (filter.fromBlock < 0) filter.fromBlock = 0;
                            const runner = this.getLogs(filter).then((logs)=>{
                                // Allow the next getLogs
                                event._inflight = false;
                                if (logs.length === 0) return;
                                logs.forEach((log)=>{
                                    // Only when we get an event for a given block number
                                    // can we trust the events are indexed
                                    if (log.blockNumber > event._lastBlockNumber) event._lastBlockNumber = log.blockNumber;
                                    // Make sure we stall requests to fetch blocks and txs
                                    this._emitted["b:" + log.blockHash] = log.blockNumber;
                                    this._emitted["t:" + log.transactionHash] = log.blockNumber;
                                    this.emit(filter, log);
                                });
                            }).catch((error)=>{
                                this.emit("error", error);
                                // Allow another getLogs (the range was not updated)
                                event._inflight = false;
                            });
                            runners.push(runner);
                        }
                        break;
                }
            });
            this._lastBlockNumber = blockNumber;
            // Once all events for this loop have been processed, emit "didPoll"
            Promise.all(runners).then(()=>{
                this.emit("didPoll", pollId);
            }).catch((error)=>{
                this.emit("error", error);
            });
            return;
        });
    }
    // Deprecated; do not use this
    resetEventsBlock(blockNumber) {
        this._lastBlockNumber = blockNumber - 1;
        if (this.polling) this.poll();
    }
    get network() {
        return this._network;
    }
    // This method should query the network if the underlying network
    // can change, such as when connected to a JSON-RPC backend
    detectNetwork() {
        return __awaiter(this, void 0, void 0, function*() {
            return logger.throwError("provider does not support network detection", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "provider.detectNetwork"
            });
        });
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function*() {
            const network = yield this._ready();
            // Make sure we are still connected to the same network; this is
            // only an external call for backends which can have the underlying
            // network change spontaneously
            const currentNetwork = yield this.detectNetwork();
            if (network.chainId !== currentNetwork.chainId) {
                // We are allowing network changes, things can get complex fast;
                // make sure you know what you are doing if you use "any"
                if (this.anyNetwork) {
                    this._network = currentNetwork;
                    // Reset all internal block number guards and caches
                    this._lastBlockNumber = -2;
                    this._fastBlockNumber = null;
                    this._fastBlockNumberPromise = null;
                    this._fastQueryDate = 0;
                    this._emitted.block = -2;
                    this._maxInternalBlockNumber = -1024;
                    this._internalBlockNumber = null;
                    // The "network" event MUST happen before this method resolves
                    // so any events have a chance to unregister, so we stall an
                    // additional event loop before returning from /this/ call
                    this.emit("network", currentNetwork, network);
                    yield stall(0);
                    return this._network;
                }
                const error = logger.makeError("underlying network changed", (0, _logger.Logger).errors.NETWORK_ERROR, {
                    event: "changed",
                    network: network,
                    detectedNetwork: currentNetwork
                });
                this.emit("error", error);
                throw error;
            }
            return network;
        });
    }
    get blockNumber() {
        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber)=>{
            this._setFastBlockNumber(blockNumber);
        }, (error)=>{});
        return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
    }
    get polling() {
        return this._poller != null;
    }
    set polling(value) {
        if (value && !this._poller) {
            this._poller = setInterval(()=>{
                this.poll();
            }, this.pollingInterval);
            if (!this._bootstrapPoll) this._bootstrapPoll = setTimeout(()=>{
                this.poll();
                // We block additional polls until the polling interval
                // is done, to prevent overwhelming the poll function
                this._bootstrapPoll = setTimeout(()=>{
                    // If polling was disabled, something may require a poke
                    // since starting the bootstrap poll and it was disabled
                    if (!this._poller) this.poll();
                    // Clear out the bootstrap so we can do another
                    this._bootstrapPoll = null;
                }, this.pollingInterval);
            }, 0);
        } else if (!value && this._poller) {
            clearInterval(this._poller);
            this._poller = null;
        }
    }
    get pollingInterval() {
        return this._pollingInterval;
    }
    set pollingInterval(value) {
        if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) throw new Error("invalid polling interval");
        this._pollingInterval = value;
        if (this._poller) {
            clearInterval(this._poller);
            this._poller = setInterval(()=>{
                this.poll();
            }, this._pollingInterval);
        }
    }
    _getFastBlockNumber() {
        const now = getTime();
        // Stale block number, request a newer value
        if (now - this._fastQueryDate > 2 * this._pollingInterval) {
            this._fastQueryDate = now;
            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber)=>{
                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) this._fastBlockNumber = blockNumber;
                return this._fastBlockNumber;
            });
        }
        return this._fastBlockNumberPromise;
    }
    _setFastBlockNumber(blockNumber) {
        // Older block, maybe a stale request
        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) return;
        // Update the time we updated the blocknumber
        this._fastQueryDate = getTime();
        // Newer block number, use  it
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
            this._fastBlockNumber = blockNumber;
            this._fastBlockNumberPromise = Promise.resolve(blockNumber);
        }
    }
    waitForTransaction(transactionHash, confirmations, timeout) {
        return __awaiter(this, void 0, void 0, function*() {
            return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
        });
    }
    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
        return __awaiter(this, void 0, void 0, function*() {
            const receipt = yield this.getTransactionReceipt(transactionHash);
            // Receipt is already good
            if ((receipt ? receipt.confirmations : 0) >= confirmations) return receipt;
            // Poll until the receipt is good...
            return new Promise((resolve, reject)=>{
                const cancelFuncs = [];
                let done = false;
                const alreadyDone = function() {
                    if (done) return true;
                    done = true;
                    cancelFuncs.forEach((func)=>{
                        func();
                    });
                    return false;
                };
                const minedHandler = (receipt)=>{
                    if (receipt.confirmations < confirmations) return;
                    if (alreadyDone()) return;
                    resolve(receipt);
                };
                this.on(transactionHash, minedHandler);
                cancelFuncs.push(()=>{
                    this.removeListener(transactionHash, minedHandler);
                });
                if (replaceable) {
                    let lastBlockNumber = replaceable.startBlock;
                    let scannedBlock = null;
                    const replaceHandler = (blockNumber)=>__awaiter(this, void 0, void 0, function*() {
                            if (done) return;
                            // Wait 1 second; this is only used in the case of a fault, so
                            // we will trade off a little bit of latency for more consistent
                            // results and fewer JSON-RPC calls
                            yield stall(1000);
                            this.getTransactionCount(replaceable.from).then((nonce)=>__awaiter(this, void 0, void 0, function*() {
                                    if (done) return;
                                    if (nonce <= replaceable.nonce) lastBlockNumber = blockNumber;
                                    else {
                                        // First check if the transaction was mined
                                        {
                                            const mined = yield this.getTransaction(transactionHash);
                                            if (mined && mined.blockNumber != null) return;
                                        }
                                        // First time scanning. We start a little earlier for some
                                        // wiggle room here to handle the eventually consistent nature
                                        // of blockchain (e.g. the getTransactionCount was for a
                                        // different block)
                                        if (scannedBlock == null) {
                                            scannedBlock = lastBlockNumber - 3;
                                            if (scannedBlock < replaceable.startBlock) scannedBlock = replaceable.startBlock;
                                        }
                                        while(scannedBlock <= blockNumber){
                                            if (done) return;
                                            const block = yield this.getBlockWithTransactions(scannedBlock);
                                            for(let ti = 0; ti < block.transactions.length; ti++){
                                                const tx = block.transactions[ti];
                                                // Successfully mined!
                                                if (tx.hash === transactionHash) return;
                                                // Matches our transaction from and nonce; its a replacement
                                                if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                                                    if (done) return;
                                                    // Get the receipt of the replacement
                                                    const receipt = yield this.waitForTransaction(tx.hash, confirmations);
                                                    // Already resolved or rejected (prolly a timeout)
                                                    if (alreadyDone()) return;
                                                    // The reason we were replaced
                                                    let reason = "replaced";
                                                    if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) reason = "repriced";
                                                    else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) reason = "cancelled";
                                                    // Explain why we were replaced
                                                    reject(logger.makeError("transaction was replaced", (0, _logger.Logger).errors.TRANSACTION_REPLACED, {
                                                        cancelled: reason === "replaced" || reason === "cancelled",
                                                        reason,
                                                        replacement: this._wrapTransaction(tx),
                                                        hash: transactionHash,
                                                        receipt
                                                    }));
                                                    return;
                                                }
                                            }
                                            scannedBlock++;
                                        }
                                    }
                                    if (done) return;
                                    this.once("block", replaceHandler);
                                }), (error)=>{
                                if (done) return;
                                this.once("block", replaceHandler);
                            });
                        });
                    if (done) return;
                    this.once("block", replaceHandler);
                    cancelFuncs.push(()=>{
                        this.removeListener("block", replaceHandler);
                    });
                }
                if (typeof timeout === "number" && timeout > 0) {
                    const timer = setTimeout(()=>{
                        if (alreadyDone()) return;
                        reject(logger.makeError("timeout exceeded", (0, _logger.Logger).errors.TIMEOUT, {
                            timeout: timeout
                        }));
                    }, timeout);
                    if (timer.unref) timer.unref();
                    cancelFuncs.push(()=>{
                        clearTimeout(timer);
                    });
                }
            });
        });
    }
    getBlockNumber() {
        return __awaiter(this, void 0, void 0, function*() {
            return this._getInternalBlockNumber(0);
        });
    }
    getGasPrice() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const result = yield this.perform("getGasPrice", {});
            try {
                return (0, _bignumber.BigNumber).from(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "getGasPrice",
                    result,
                    error
                });
            }
        });
    }
    getBalance(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getBalance", params);
            try {
                return (0, _bignumber.BigNumber).from(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "getBalance",
                    params,
                    result,
                    error
                });
            }
        });
    }
    getTransactionCount(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getTransactionCount", params);
            try {
                return (0, _bignumber.BigNumber).from(result).toNumber();
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params,
                    result,
                    error
                });
            }
        });
    }
    getCode(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getCode", params);
            try {
                return (0, _bytes.hexlify)(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "getCode",
                    params,
                    result,
                    error
                });
            }
        });
    }
    getStorageAt(addressOrName, position, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag),
                position: Promise.resolve(position).then((p)=>(0, _bytes.hexValue)(p))
            });
            const result = yield this.perform("getStorageAt", params);
            try {
                return (0, _bytes.hexlify)(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params,
                    result,
                    error
                });
            }
        });
    }
    // This should be called by any subclass wrapping a TransactionResponse
    _wrapTransaction(tx, hash, startBlock) {
        if (hash != null && (0, _bytes.hexDataLength)(hash) !== 32) throw new Error("invalid response - sendTransaction");
        const result = tx;
        // Check the hash we expect is the same as the hash the server reported
        if (hash != null && tx.hash !== hash) logger.throwError("Transaction hash mismatch from Provider.sendTransaction.", (0, _logger.Logger).errors.UNKNOWN_ERROR, {
            expectedHash: tx.hash,
            returnedHash: hash
        });
        result.wait = (confirms, timeout)=>__awaiter(this, void 0, void 0, function*() {
                if (confirms == null) confirms = 1;
                if (timeout == null) timeout = 0;
                // Get the details to detect replacement
                let replacement = undefined;
                if (confirms !== 0 && startBlock != null) replacement = {
                    data: tx.data,
                    from: tx.from,
                    nonce: tx.nonce,
                    to: tx.to,
                    value: tx.value,
                    startBlock
                };
                const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
                if (receipt == null && confirms === 0) return null;
                // No longer pending, allow the polling loop to garbage collect this
                this._emitted["t:" + tx.hash] = receipt.blockNumber;
                if (receipt.status === 0) logger.throwError("transaction failed", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                    transactionHash: tx.hash,
                    transaction: tx,
                    receipt: receipt
                });
                return receipt;
            });
        return result;
    }
    sendTransaction(signedTransaction) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const hexTx = yield Promise.resolve(signedTransaction).then((t)=>(0, _bytes.hexlify)(t));
            const tx = this.formatter.transaction(signedTransaction);
            if (tx.confirmations == null) tx.confirmations = 0;
            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            try {
                const hash = yield this.perform("sendTransaction", {
                    signedTransaction: hexTx
                });
                return this._wrapTransaction(tx, hash, blockNumber);
            } catch (error) {
                error.transaction = tx;
                error.transactionHash = tx.hash;
                throw error;
            }
        });
    }
    _getTransactionRequest(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            const values = yield transaction;
            const tx = {};
            [
                "from",
                "to"
            ].forEach((key)=>{
                if (values[key] == null) return;
                tx[key] = Promise.resolve(values[key]).then((v)=>v ? this._getAddress(v) : null);
            });
            [
                "gasLimit",
                "gasPrice",
                "maxFeePerGas",
                "maxPriorityFeePerGas",
                "value"
            ].forEach((key)=>{
                if (values[key] == null) return;
                tx[key] = Promise.resolve(values[key]).then((v)=>v ? (0, _bignumber.BigNumber).from(v) : null);
            });
            [
                "type"
            ].forEach((key)=>{
                if (values[key] == null) return;
                tx[key] = Promise.resolve(values[key]).then((v)=>v != null ? v : null);
            });
            if (values.accessList) tx.accessList = this.formatter.accessList(values.accessList);
            [
                "data"
            ].forEach((key)=>{
                if (values[key] == null) return;
                tx[key] = Promise.resolve(values[key]).then((v)=>v ? (0, _bytes.hexlify)(v) : null);
            });
            return this.formatter.transactionRequest((yield (0, _properties.resolveProperties)(tx)));
        });
    }
    _getFilter(filter) {
        return __awaiter(this, void 0, void 0, function*() {
            filter = yield filter;
            const result = {};
            if (filter.address != null) result.address = this._getAddress(filter.address);
            [
                "blockHash",
                "topics"
            ].forEach((key)=>{
                if (filter[key] == null) return;
                result[key] = filter[key];
            });
            [
                "fromBlock",
                "toBlock"
            ].forEach((key)=>{
                if (filter[key] == null) return;
                result[key] = this._getBlockTag(filter[key]);
            });
            return this.formatter.filter((yield (0, _properties.resolveProperties)(result)));
        });
    }
    _call(transaction, blockTag, attempt) {
        return __awaiter(this, void 0, void 0, function*() {
            if (attempt >= MAX_CCIP_REDIRECTS) logger.throwError("CCIP read exceeded maximum redirections", (0, _logger.Logger).errors.SERVER_ERROR, {
                redirects: attempt,
                transaction
            });
            const txSender = transaction.to;
            const result = yield this.perform("call", {
                transaction,
                blockTag
            });
            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)
            if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && (0, _bytes.hexDataLength)(result) % 32 === 4) try {
                const data = (0, _bytes.hexDataSlice)(result, 4);
                // Check the sender of the OffchainLookup matches the transaction
                const sender = (0, _bytes.hexDataSlice)(data, 0, 32);
                if (!(0, _bignumber.BigNumber).from(sender).eq(txSender)) logger.throwError("CCIP Read sender did not match", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                });
                // Read the URLs from the response
                const urls = [];
                const urlsOffset = (0, _bignumber.BigNumber).from((0, _bytes.hexDataSlice)(data, 32, 64)).toNumber();
                const urlsLength = (0, _bignumber.BigNumber).from((0, _bytes.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();
                const urlsData = (0, _bytes.hexDataSlice)(data, urlsOffset + 32);
                for(let u = 0; u < urlsLength; u++){
                    const url = _parseString(urlsData, u * 32);
                    if (url == null) logger.throwError("CCIP Read contained corrupt URL string", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                        name: "OffchainLookup",
                        signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                        transaction,
                        data: result
                    });
                    urls.push(url);
                }
                // Get the CCIP calldata to forward
                const calldata = _parseBytes(data, 64);
                // Get the callbackSelector (bytes4)
                if (!(0, _bignumber.BigNumber).from((0, _bytes.hexDataSlice)(data, 100, 128)).isZero()) logger.throwError("CCIP Read callback selector included junk", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                });
                const callbackSelector = (0, _bytes.hexDataSlice)(data, 96, 100);
                // Get the extra data to send back to the contract as context
                const extraData = _parseBytes(data, 128);
                const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
                if (ccipResult == null) logger.throwError("CCIP Read disabled or provided no URLs", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction,
                    data: result
                });
                const tx = {
                    to: txSender,
                    data: (0, _bytes.hexConcat)([
                        callbackSelector,
                        encodeBytes([
                            ccipResult,
                            extraData
                        ])
                    ])
                };
                return this._call(tx, blockTag, attempt + 1);
            } catch (error) {
                if (error.code === (0, _logger.Logger).errors.SERVER_ERROR) throw error;
            }
            try {
                return (0, _bytes.hexlify)(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "call",
                    params: {
                        transaction,
                        blockTag
                    },
                    result,
                    error
                });
            }
        });
    }
    call(transaction, blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const resolved = yield (0, _properties.resolveProperties)({
                transaction: this._getTransactionRequest(transaction),
                blockTag: this._getBlockTag(blockTag),
                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
            });
            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
        });
    }
    estimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                transaction: this._getTransactionRequest(transaction)
            });
            const result = yield this.perform("estimateGas", params);
            try {
                return (0, _bignumber.BigNumber).from(result);
            } catch (error) {
                return logger.throwError("bad result from backend", (0, _logger.Logger).errors.SERVER_ERROR, {
                    method: "estimateGas",
                    params,
                    result,
                    error
                });
            }
        });
    }
    _getAddress(addressOrName) {
        return __awaiter(this, void 0, void 0, function*() {
            addressOrName = yield addressOrName;
            if (typeof addressOrName !== "string") logger.throwArgumentError("invalid address or ENS name", "name", addressOrName);
            const address = yield this.resolveName(addressOrName);
            if (address == null) logger.throwError("ENS name not configured", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: `resolveName(${JSON.stringify(addressOrName)})`
            });
            return address;
        });
    }
    _getBlock(blockHashOrBlockTag, includeTransactions) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            blockHashOrBlockTag = yield blockHashOrBlockTag;
            // If blockTag is a number (not "latest", etc), this is the block number
            let blockNumber = -128;
            const params = {
                includeTransactions: !!includeTransactions
            };
            if ((0, _bytes.isHexString)(blockHashOrBlockTag, 32)) params.blockHash = blockHashOrBlockTag;
            else try {
                params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
                if ((0, _bytes.isHexString)(params.blockTag)) blockNumber = parseInt(params.blockTag.substring(2), 16);
            } catch (error) {
                logger.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
            }
            return (0, _web.poll)(()=>__awaiter(this, void 0, void 0, function*() {
                    const block = yield this.perform("getBlock", params);
                    // Block was not found
                    if (block == null) {
                        // For blockhashes, if we didn't say it existed, that blockhash may
                        // not exist. If we did see it though, perhaps from a log, we know
                        // it exists, and this node is just not caught up yet.
                        if (params.blockHash != null) {
                            if (this._emitted["b:" + params.blockHash] == null) return null;
                        }
                        // For block tags, if we are asking for a future block, we return null
                        if (params.blockTag != null) {
                            if (blockNumber > this._emitted.block) return null;
                        }
                        // Retry on the next block
                        return undefined;
                    }
                    // Add transactions
                    if (includeTransactions) {
                        let blockNumber = null;
                        for(let i = 0; i < block.transactions.length; i++){
                            const tx = block.transactions[i];
                            if (tx.blockNumber == null) tx.confirmations = 0;
                            else if (tx.confirmations == null) {
                                if (blockNumber == null) blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                                // Add the confirmations using the fast block number (pessimistic)
                                let confirmations = blockNumber - tx.blockNumber + 1;
                                if (confirmations <= 0) confirmations = 1;
                                tx.confirmations = confirmations;
                            }
                        }
                        const blockWithTxs = this.formatter.blockWithTransactions(block);
                        blockWithTxs.transactions = blockWithTxs.transactions.map((tx)=>this._wrapTransaction(tx));
                        return blockWithTxs;
                    }
                    return this.formatter.block(block);
                }), {
                oncePoll: this
            });
        });
    }
    getBlock(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, false);
    }
    getBlockWithTransactions(blockHashOrBlockTag) {
        return this._getBlock(blockHashOrBlockTag, true);
    }
    getTransaction(transactionHash) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            transactionHash = yield transactionHash;
            const params = {
                transactionHash: this.formatter.hash(transactionHash, true)
            };
            return (0, _web.poll)(()=>__awaiter(this, void 0, void 0, function*() {
                    const result = yield this.perform("getTransaction", params);
                    if (result == null) {
                        if (this._emitted["t:" + transactionHash] == null) return null;
                        return undefined;
                    }
                    const tx = this.formatter.transactionResponse(result);
                    if (tx.blockNumber == null) tx.confirmations = 0;
                    else if (tx.confirmations == null) {
                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                        // Add the confirmations using the fast block number (pessimistic)
                        let confirmations = blockNumber - tx.blockNumber + 1;
                        if (confirmations <= 0) confirmations = 1;
                        tx.confirmations = confirmations;
                    }
                    return this._wrapTransaction(tx);
                }), {
                oncePoll: this
            });
        });
    }
    getTransactionReceipt(transactionHash) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            transactionHash = yield transactionHash;
            const params = {
                transactionHash: this.formatter.hash(transactionHash, true)
            };
            return (0, _web.poll)(()=>__awaiter(this, void 0, void 0, function*() {
                    const result = yield this.perform("getTransactionReceipt", params);
                    if (result == null) {
                        if (this._emitted["t:" + transactionHash] == null) return null;
                        return undefined;
                    }
                    // "geth-etc" returns receipts before they are ready
                    if (result.blockHash == null) return undefined;
                    const receipt = this.formatter.receipt(result);
                    if (receipt.blockNumber == null) receipt.confirmations = 0;
                    else if (receipt.confirmations == null) {
                        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                        // Add the confirmations using the fast block number (pessimistic)
                        let confirmations = blockNumber - receipt.blockNumber + 1;
                        if (confirmations <= 0) confirmations = 1;
                        receipt.confirmations = confirmations;
                    }
                    return receipt;
                }), {
                oncePoll: this
            });
        });
    }
    getLogs(filter) {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            const params = yield (0, _properties.resolveProperties)({
                filter: this._getFilter(filter)
            });
            const logs = yield this.perform("getLogs", params);
            logs.forEach((log)=>{
                if (log.removed == null) log.removed = false;
            });
            return (0, _formatter.Formatter).arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
        });
    }
    getEtherPrice() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.getNetwork();
            return this.perform("getEtherPrice", {});
        });
    }
    _getBlockTag(blockTag) {
        return __awaiter(this, void 0, void 0, function*() {
            blockTag = yield blockTag;
            if (typeof blockTag === "number" && blockTag < 0) {
                if (blockTag % 1) logger.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                blockNumber += blockTag;
                if (blockNumber < 0) blockNumber = 0;
                return this.formatter.blockTag(blockNumber);
            }
            return this.formatter.blockTag(blockTag);
        });
    }
    getResolver(name) {
        return __awaiter(this, void 0, void 0, function*() {
            let currentName = name;
            while(true){
                if (currentName === "" || currentName === ".") return null;
                // Optimization since the eth node cannot change and does
                // not have a wildcard resolver
                if (name !== "eth" && currentName === "eth") return null;
                // Check the current node for a resolver
                const addr = yield this._getResolver(currentName, "getResolver");
                // Found a resolver!
                if (addr != null) {
                    const resolver = new Resolver(this, addr, name);
                    // Legacy resolver found, using EIP-2544 so it isn't safe to use
                    if (currentName !== name && !(yield resolver.supportsWildcard())) return null;
                    return resolver;
                }
                // Get the parent node
                currentName = currentName.split(".").slice(1).join(".");
            }
        });
    }
    _getResolver(name, operation) {
        return __awaiter(this, void 0, void 0, function*() {
            if (operation == null) operation = "ENS";
            const network = yield this.getNetwork();
            // No ENS...
            if (!network.ensAddress) logger.throwError("network does not support ENS", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation,
                network: network.name
            });
            try {
                // keccak256("resolver(bytes32)")
                const addrData = yield this.call({
                    to: network.ensAddress,
                    data: "0x0178b8bf" + (0, _hash.namehash)(name).substring(2)
                });
                return this.formatter.callAddress(addrData);
            } catch (error) {
            // ENS registry cannot throw errors on resolver(bytes32)
            }
            return null;
        });
    }
    resolveName(name) {
        return __awaiter(this, void 0, void 0, function*() {
            name = yield name;
            // If it is already an address, nothing to resolve
            try {
                return Promise.resolve(this.formatter.address(name));
            } catch (error) {
                // If is is a hexstring, the address is bad (See #694)
                if ((0, _bytes.isHexString)(name)) throw error;
            }
            if (typeof name !== "string") logger.throwArgumentError("invalid ENS name", "name", name);
            // Get the addr from the resolver
            const resolver = yield this.getResolver(name);
            if (!resolver) return null;
            return yield resolver.getAddress();
        });
    }
    lookupAddress(address) {
        return __awaiter(this, void 0, void 0, function*() {
            address = yield address;
            address = this.formatter.address(address);
            const node = address.substring(2).toLowerCase() + ".addr.reverse";
            const resolverAddr = yield this._getResolver(node, "lookupAddress");
            if (resolverAddr == null) return null;
            // keccak("name(bytes32)")
            const name = _parseString((yield this.call({
                to: resolverAddr,
                data: "0x691f3431" + (0, _hash.namehash)(node).substring(2)
            })), 0);
            const addr = yield this.resolveName(name);
            if (addr != address) return null;
            return name;
        });
    }
    getAvatar(nameOrAddress) {
        return __awaiter(this, void 0, void 0, function*() {
            let resolver = null;
            if ((0, _bytes.isHexString)(nameOrAddress)) {
                // Address; reverse lookup
                const address = this.formatter.address(nameOrAddress);
                const node = address.substring(2).toLowerCase() + ".addr.reverse";
                const resolverAddress = yield this._getResolver(node, "getAvatar");
                if (!resolverAddress) return null;
                // Try resolving the avatar against the addr.reverse resolver
                resolver = new Resolver(this, resolverAddress, node);
                try {
                    const avatar = yield resolver.getAvatar();
                    if (avatar) return avatar.url;
                } catch (error) {
                    if (error.code !== (0, _logger.Logger).errors.CALL_EXCEPTION) throw error;
                }
                // Try getting the name and performing forward lookup; allowing wildcards
                try {
                    // keccak("name(bytes32)")
                    const name = _parseString((yield this.call({
                        to: resolverAddress,
                        data: "0x691f3431" + (0, _hash.namehash)(node).substring(2)
                    })), 0);
                    resolver = yield this.getResolver(name);
                } catch (error) {
                    if (error.code !== (0, _logger.Logger).errors.CALL_EXCEPTION) throw error;
                    return null;
                }
            } else {
                // ENS name; forward lookup with wildcard
                resolver = yield this.getResolver(nameOrAddress);
                if (!resolver) return null;
            }
            const avatar = yield resolver.getAvatar();
            if (avatar == null) return null;
            return avatar.url;
        });
    }
    perform(method, params) {
        return logger.throwError(method + " not implemented", (0, _logger.Logger).errors.NOT_IMPLEMENTED, {
            operation: method
        });
    }
    _startEvent(event) {
        this.polling = this._events.filter((e)=>e.pollable()).length > 0;
    }
    _stopEvent(event) {
        this.polling = this._events.filter((e)=>e.pollable()).length > 0;
    }
    _addEventListener(eventName, listener, once) {
        const event = new Event(getEventTag(eventName), listener, once);
        this._events.push(event);
        this._startEvent(event);
        return this;
    }
    on(eventName, listener) {
        return this._addEventListener(eventName, listener, false);
    }
    once(eventName, listener) {
        return this._addEventListener(eventName, listener, true);
    }
    emit(eventName, ...args) {
        let result = false;
        let stopped = [];
        let eventTag = getEventTag(eventName);
        this._events = this._events.filter((event)=>{
            if (event.tag !== eventTag) return true;
            setTimeout(()=>{
                event.listener.apply(this, args);
            }, 0);
            result = true;
            if (event.once) {
                stopped.push(event);
                return false;
            }
            return true;
        });
        stopped.forEach((event)=>{
            this._stopEvent(event);
        });
        return result;
    }
    listenerCount(eventName) {
        if (!eventName) return this._events.length;
        let eventTag = getEventTag(eventName);
        return this._events.filter((event)=>{
            return event.tag === eventTag;
        }).length;
    }
    listeners(eventName) {
        if (eventName == null) return this._events.map((event)=>event.listener);
        let eventTag = getEventTag(eventName);
        return this._events.filter((event)=>event.tag === eventTag).map((event)=>event.listener);
    }
    off(eventName, listener) {
        if (listener == null) return this.removeAllListeners(eventName);
        const stopped = [];
        let found = false;
        let eventTag = getEventTag(eventName);
        this._events = this._events.filter((event)=>{
            if (event.tag !== eventTag || event.listener != listener) return true;
            if (found) return true;
            found = true;
            stopped.push(event);
            return false;
        });
        stopped.forEach((event)=>{
            this._stopEvent(event);
        });
        return this;
    }
    removeAllListeners(eventName) {
        let stopped = [];
        if (eventName == null) {
            stopped = this._events;
            this._events = [];
        } else {
            const eventTag = getEventTag(eventName);
            this._events = this._events.filter((event)=>{
                if (event.tag !== eventTag) return true;
                stopped.push(event);
                return false;
            });
        }
        stopped.forEach((event)=>{
            this._stopEvent(event);
        });
        return this;
    }
}

},{"@ethersproject/abstract-provider":"fYevg","@ethersproject/base64":"4pM60","@ethersproject/basex":"e80EH","@ethersproject/bignumber":"gSTRF","@ethersproject/bytes":"5ReBN","@ethersproject/constants":"fVOEx","@ethersproject/hash":"gr11a","@ethersproject/networks":"hQL7z","@ethersproject/properties":"2X633","@ethersproject/sha2":"dRlnY","@ethersproject/strings":"8Rh0h","@ethersproject/web":"ebBVL","bech32":"6NFHR","@ethersproject/logger":"9rXfv","./_version":"bmrdP","./formatter":"eHThO","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4pM60":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decode", ()=>(0, _base64.decode));
parcelHelpers.export(exports, "encode", ()=>(0, _base64.encode));
var _base64 = require("./base64");
"use strict";

},{"./base64":"cO7Vg","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cO7Vg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decode", ()=>decode);
parcelHelpers.export(exports, "encode", ()=>encode);
var _bytes = require("@ethersproject/bytes");
"use strict";
function decode(textData) {
    textData = atob(textData);
    const data = [];
    for(let i = 0; i < textData.length; i++)data.push(textData.charCodeAt(i));
    return (0, _bytes.arrayify)(data);
}
function encode(data) {
    data = (0, _bytes.arrayify)(data);
    let textData = "";
    for(let i = 0; i < data.length; i++)textData += String.fromCharCode(data[i]);
    return btoa(textData);
}

},{"@ethersproject/bytes":"5ReBN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e80EH":[function(require,module,exports,__globalThis) {
/**
 * var basex = require("base-x");
 *
 * This implementation is heavily based on base-x. The main reason to
 * deviate was to prevent the dependency of Buffer.
 *
 * Contributors:
 *
 * base-x encoding
 * Forked from https://github.com/cryptocoinjs/bs58
 * Originally written by Mike Hearn for BitcoinJ
 * Copyright (c) 2011 Google Inc
 * Ported to JavaScript by Stefan Thomas
 * Merged Buffer refactorings from base58-native by Stephen Pair
 * Copyright (c) 2013 BitPay Inc
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseX", ()=>BaseX);
parcelHelpers.export(exports, "Base32", ()=>Base32) //console.log(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj"))
 //console.log(Base58.encode(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj")))
;
parcelHelpers.export(exports, "Base58", ()=>Base58);
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
class BaseX {
    constructor(alphabet){
        (0, _properties.defineReadOnly)(this, "alphabet", alphabet);
        (0, _properties.defineReadOnly)(this, "base", alphabet.length);
        (0, _properties.defineReadOnly)(this, "_alphabetMap", {});
        (0, _properties.defineReadOnly)(this, "_leader", alphabet.charAt(0));
        // pre-compute lookup table
        for(let i = 0; i < alphabet.length; i++)this._alphabetMap[alphabet.charAt(i)] = i;
    }
    encode(value) {
        let source = (0, _bytes.arrayify)(value);
        if (source.length === 0) return "";
        let digits = [
            0
        ];
        for(let i = 0; i < source.length; ++i){
            let carry = source[i];
            for(let j = 0; j < digits.length; ++j){
                carry += digits[j] << 8;
                digits[j] = carry % this.base;
                carry = carry / this.base | 0;
            }
            while(carry > 0){
                digits.push(carry % this.base);
                carry = carry / this.base | 0;
            }
        }
        let string = "";
        // deal with leading zeros
        for(let k = 0; source[k] === 0 && k < source.length - 1; ++k)string += this._leader;
        // convert digits to a string
        for(let q = digits.length - 1; q >= 0; --q)string += this.alphabet[digits[q]];
        return string;
    }
    decode(value) {
        if (typeof value !== "string") throw new TypeError("Expected String");
        let bytes = [];
        if (value.length === 0) return new Uint8Array(bytes);
        bytes.push(0);
        for(let i = 0; i < value.length; i++){
            let byte = this._alphabetMap[value[i]];
            if (byte === undefined) throw new Error("Non-base" + this.base + " character");
            let carry = byte;
            for(let j = 0; j < bytes.length; ++j){
                carry += bytes[j] * this.base;
                bytes[j] = carry & 0xff;
                carry >>= 8;
            }
            while(carry > 0){
                bytes.push(carry & 0xff);
                carry >>= 8;
            }
        }
        // deal with leading zeros
        for(let k = 0; value[k] === this._leader && k < value.length - 1; ++k)bytes.push(0);
        return (0, _bytes.arrayify)(new Uint8Array(bytes.reverse()));
    }
}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

},{"@ethersproject/bytes":"5ReBN","@ethersproject/properties":"2X633","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fVOEx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AddressZero", ()=>(0, _addresses.AddressZero));
parcelHelpers.export(exports, "NegativeOne", ()=>(0, _bignumbers.NegativeOne));
parcelHelpers.export(exports, "Zero", ()=>(0, _bignumbers.Zero));
parcelHelpers.export(exports, "One", ()=>(0, _bignumbers.One));
parcelHelpers.export(exports, "Two", ()=>(0, _bignumbers.Two));
parcelHelpers.export(exports, "WeiPerEther", ()=>(0, _bignumbers.WeiPerEther));
parcelHelpers.export(exports, "MaxUint256", ()=>(0, _bignumbers.MaxUint256));
parcelHelpers.export(exports, "MinInt256", ()=>(0, _bignumbers.MinInt256));
parcelHelpers.export(exports, "MaxInt256", ()=>(0, _bignumbers.MaxInt256));
parcelHelpers.export(exports, "HashZero", ()=>(0, _hashes.HashZero));
parcelHelpers.export(exports, "EtherSymbol", ()=>(0, _strings.EtherSymbol));
var _addresses = require("./addresses");
var _bignumbers = require("./bignumbers");
var _hashes = require("./hashes");
var _strings = require("./strings");
"use strict";

},{"./addresses":"72ewb","./bignumbers":"gsd2I","./hashes":"fS5lA","./strings":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"72ewb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AddressZero", ()=>AddressZero);
const AddressZero = "0x0000000000000000000000000000000000000000";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gsd2I":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NegativeOne", ()=>NegativeOne);
parcelHelpers.export(exports, "Zero", ()=>Zero);
parcelHelpers.export(exports, "One", ()=>One);
parcelHelpers.export(exports, "Two", ()=>Two);
parcelHelpers.export(exports, "WeiPerEther", ()=>WeiPerEther);
parcelHelpers.export(exports, "MaxUint256", ()=>MaxUint256);
parcelHelpers.export(exports, "MinInt256", ()=>MinInt256);
parcelHelpers.export(exports, "MaxInt256", ()=>MaxInt256);
var _bignumber = require("@ethersproject/bignumber");
const NegativeOne = /*#__PURE__*/ (0, _bignumber.BigNumber).from(-1);
const Zero = /*#__PURE__*/ (0, _bignumber.BigNumber).from(0);
const One = /*#__PURE__*/ (0, _bignumber.BigNumber).from(1);
const Two = /*#__PURE__*/ (0, _bignumber.BigNumber).from(2);
const WeiPerEther = /*#__PURE__*/ (0, _bignumber.BigNumber).from("1000000000000000000");
const MaxUint256 = /*#__PURE__*/ (0, _bignumber.BigNumber).from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const MinInt256 = /*#__PURE__*/ (0, _bignumber.BigNumber).from("-0x8000000000000000000000000000000000000000000000000000000000000000");
const MaxInt256 = /*#__PURE__*/ (0, _bignumber.BigNumber).from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

},{"@ethersproject/bignumber":"gSTRF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fS5lA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HashZero", ()=>HashZero);
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gr11a":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "id", ()=>(0, _id.id));
parcelHelpers.export(exports, "dnsEncode", ()=>(0, _namehash.dnsEncode));
parcelHelpers.export(exports, "namehash", ()=>(0, _namehash.namehash));
parcelHelpers.export(exports, "isValidName", ()=>(0, _namehash.isValidName));
parcelHelpers.export(exports, "ensNormalize", ()=>(0, _namehash.ensNormalize));
parcelHelpers.export(exports, "messagePrefix", ()=>(0, _message.messagePrefix));
parcelHelpers.export(exports, "hashMessage", ()=>(0, _message.hashMessage));
parcelHelpers.export(exports, "_TypedDataEncoder", ()=>(0, _typedData.TypedDataEncoder));
var _id = require("./id");
var _namehash = require("./namehash");
var _message = require("./message");
var _typedData = require("./typed-data");
"use strict";

},{"./id":"9QwKC","./namehash":"6QfSa","./message":false,"./typed-data":"7Zsbd","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9QwKC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "id", ()=>id);
var _keccak256 = require("@ethersproject/keccak256");
var _strings = require("@ethersproject/strings");
function id(text) {
    return (0, _keccak256.keccak256)((0, _strings.toUtf8Bytes)(text));
}

},{"@ethersproject/keccak256":"8rdQU","@ethersproject/strings":"8Rh0h","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8rdQU":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "keccak256", ()=>keccak256);
var _jsSha3 = require("js-sha3");
var _jsSha3Default = parcelHelpers.interopDefault(_jsSha3);
var _bytes = require("@ethersproject/bytes");
"use strict";
function keccak256(data) {
    return '0x' + (0, _jsSha3Default.default).keccak_256((0, _bytes.arrayify)(data));
}

},{"js-sha3":"czKe0","@ethersproject/bytes":"5ReBN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"czKe0":[function(require,module,exports,__globalThis) {
var global = arguments[3];
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */ /*jslint bitwise: true */ (function() {
    'use strict';
    var INPUT_ERROR = 'input is invalid type';
    var FINALIZE_ERROR = 'finalize already called';
    var WINDOW = typeof window === 'object';
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) WINDOW = false;
    var WEB_WORKER = !WINDOW && typeof self === 'object';
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && false;
    if (NODE_JS) root = global;
    else if (WEB_WORKER) root = self;
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && true && module.exports;
    var AMD = typeof define === 'function' && define.amd;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
    var HEX_CHARS = '0123456789abcdef'.split('');
    var SHAKE_PADDING = [
        31,
        7936,
        2031616,
        520093696
    ];
    var CSHAKE_PADDING = [
        4,
        1024,
        262144,
        67108864
    ];
    var KECCAK_PADDING = [
        1,
        256,
        65536,
        16777216
    ];
    var PADDING = [
        6,
        1536,
        393216,
        100663296
    ];
    var SHIFT = [
        0,
        8,
        16,
        24
    ];
    var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
    ];
    var BITS = [
        224,
        256,
        384,
        512
    ];
    var SHAKE_BITS = [
        128,
        256
    ];
    var OUTPUT_TYPES = [
        'hex',
        'buffer',
        'arrayBuffer',
        'array',
        'digest'
    ];
    var CSHAKE_BYTEPAD = {
        '128': 168,
        '256': 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
    };
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) ArrayBuffer.isView = function(obj) {
        return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
    var createOutputMethod = function(bits, padding, outputType) {
        return function(message) {
            return new Keccak(bits, padding, bits).update(message)[outputType]();
        };
    };
    var createShakeOutputMethod = function(bits, padding, outputType) {
        return function(message, outputBits) {
            return new Keccak(bits, padding, outputBits).update(message)[outputType]();
        };
    };
    var createCshakeOutputMethod = function(bits, padding, outputType) {
        return function(message, outputBits, n, s) {
            return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
        };
    };
    var createKmacOutputMethod = function(bits, padding, outputType) {
        return function(key, message, outputBits, s) {
            return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
        };
    };
    var createOutputMethods = function(method, createMethod, bits, padding) {
        for(var i = 0; i < OUTPUT_TYPES.length; ++i){
            var type = OUTPUT_TYPES[i];
            method[type] = createMethod(bits, padding, type);
        }
        return method;
    };
    var createMethod = function(bits, padding) {
        var method = createOutputMethod(bits, padding, 'hex');
        method.create = function() {
            return new Keccak(bits, padding, bits);
        };
        method.update = function(message) {
            return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits, padding);
    };
    var createShakeMethod = function(bits, padding) {
        var method = createShakeOutputMethod(bits, padding, 'hex');
        method.create = function(outputBits) {
            return new Keccak(bits, padding, outputBits);
        };
        method.update = function(message, outputBits) {
            return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits, padding);
    };
    var createCshakeMethod = function(bits, padding) {
        var w = CSHAKE_BYTEPAD[bits];
        var method = createCshakeOutputMethod(bits, padding, 'hex');
        method.create = function(outputBits, n, s) {
            if (!n && !s) return methods['shake' + bits].create(outputBits);
            else return new Keccak(bits, padding, outputBits).bytepad([
                n,
                s
            ], w);
        };
        method.update = function(message, outputBits, n, s) {
            return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
    };
    var createKmacMethod = function(bits, padding) {
        var w = CSHAKE_BYTEPAD[bits];
        var method = createKmacOutputMethod(bits, padding, 'hex');
        method.create = function(key, outputBits, s) {
            return new Kmac(bits, padding, outputBits).bytepad([
                'KMAC',
                s
            ], w).bytepad([
                key
            ], w);
        };
        method.update = function(key, message, outputBits, s) {
            return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits, padding);
    };
    var algorithms = [
        {
            name: 'keccak',
            padding: KECCAK_PADDING,
            bits: BITS,
            createMethod: createMethod
        },
        {
            name: 'sha3',
            padding: PADDING,
            bits: BITS,
            createMethod: createMethod
        },
        {
            name: 'shake',
            padding: SHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createShakeMethod
        },
        {
            name: 'cshake',
            padding: CSHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createCshakeMethod
        },
        {
            name: 'kmac',
            padding: CSHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createKmacMethod
        }
    ];
    var methods = {}, methodNames = [];
    for(var i = 0; i < algorithms.length; ++i){
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for(var j = 0; j < bits.length; ++j){
            var methodName = algorithm.name + '_' + bits[j];
            methodNames.push(methodName);
            methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
            if (algorithm.name !== 'sha3') {
                var newMethodName = algorithm.name + bits[j];
                methodNames.push(newMethodName);
                methods[newMethodName] = methods[methodName];
            }
        }
    }
    function Keccak(bits, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for(var i = 0; i < 50; ++i)this.s[i] = 0;
    }
    Keccak.prototype.update = function(message) {
        if (this.finalized) throw new Error(FINALIZE_ERROR);
        var notString, type = typeof message;
        if (type !== 'string') {
            if (type === 'object') {
                if (message === null) throw new Error(INPUT_ERROR);
                else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) message = new Uint8Array(message);
                else if (!Array.isArray(message)) {
                    if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) throw new Error(INPUT_ERROR);
                }
            } else throw new Error(INPUT_ERROR);
            notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i, code;
        while(index < length){
            if (this.reset) {
                this.reset = false;
                blocks[0] = this.block;
                for(i = 1; i < blockCount + 1; ++i)blocks[i] = 0;
            }
            if (notString) for(i = this.start; index < length && i < byteCount; ++index)blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
            else for(i = this.start; index < length && i < byteCount; ++index){
                code = message.charCodeAt(index);
                if (code < 0x80) blocks[i >> 2] |= code << SHIFT[i++ & 3];
                else if (code < 0x800) {
                    blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                } else if (code < 0xd800 || code >= 0xe000) {
                    blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                } else {
                    code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                    blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                    blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                }
            }
            this.lastByteIndex = i;
            if (i >= byteCount) {
                this.start = i - byteCount;
                this.block = blocks[blockCount];
                for(i = 0; i < blockCount; ++i)s[i] ^= blocks[i];
                f(s);
                this.reset = true;
            } else this.start = i;
        }
        return this;
    };
    Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [
            o
        ];
        x = x >> 8;
        o = x & 255;
        while(o > 0){
            bytes.unshift(o);
            x = x >> 8;
            o = x & 255;
            ++n;
        }
        if (right) bytes.push(n);
        else bytes.unshift(n);
        this.update(bytes);
        return bytes.length;
    };
    Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== 'string') {
            if (type === 'object') {
                if (str === null) throw new Error(INPUT_ERROR);
                else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) str = new Uint8Array(str);
                else if (!Array.isArray(str)) {
                    if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) throw new Error(INPUT_ERROR);
                }
            } else throw new Error(INPUT_ERROR);
            notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) bytes = length;
        else for(var i = 0; i < str.length; ++i){
            var code = str.charCodeAt(i);
            if (code < 0x80) bytes += 1;
            else if (code < 0x800) bytes += 2;
            else if (code < 0xd800 || code >= 0xe000) bytes += 3;
            else {
                code = 0x10000 + ((code & 0x3ff) << 10 | str.charCodeAt(++i) & 0x3ff);
                bytes += 4;
            }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
    };
    Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for(var i = 0; i < strs.length; ++i)bytes += this.encodeString(strs[i]);
        var paddingBytes = w - bytes % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
    };
    Keccak.prototype.finalize = function() {
        if (this.finalized) return;
        this.finalized = true;
        var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i >> 2] |= this.padding[i & 3];
        if (this.lastByteIndex === this.byteCount) {
            blocks[0] = blocks[blockCount];
            for(i = 1; i < blockCount + 1; ++i)blocks[i] = 0;
        }
        blocks[blockCount - 1] |= 0x80000000;
        for(i = 0; i < blockCount; ++i)s[i] ^= blocks[i];
        f(s);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var hex = '', block;
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j){
                block = s[i];
                hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F] + HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F] + HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F] + HEX_CHARS[block >> 28 & 0x0F] + HEX_CHARS[block >> 24 & 0x0F];
            }
            if (j % blockCount === 0) {
                f(s);
                i = 0;
            }
        }
        if (extraBytes) {
            block = s[i];
            hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F];
            if (extraBytes > 1) hex += HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F];
            if (extraBytes > 2) hex += HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F];
        }
        return hex;
    };
    Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        else buffer = new ArrayBuffer(bytes);
        var array = new Uint32Array(buffer);
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j)array[j] = s[i];
            if (j % blockCount === 0) f(s);
        }
        if (extraBytes) {
            array[i] = s[i];
            buffer = buffer.slice(0, bytes);
        }
        return buffer;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var array = [], offset, block;
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j){
                offset = j << 2;
                block = s[i];
                array[offset] = block & 0xFF;
                array[offset + 1] = block >> 8 & 0xFF;
                array[offset + 2] = block >> 16 & 0xFF;
                array[offset + 3] = block >> 24 & 0xFF;
            }
            if (j % blockCount === 0) f(s);
        }
        if (extraBytes) {
            offset = j << 2;
            block = s[i];
            array[offset] = block & 0xFF;
            if (extraBytes > 1) array[offset + 1] = block >> 8 & 0xFF;
            if (extraBytes > 2) array[offset + 2] = block >> 16 & 0xFF;
        }
        return array;
    };
    function Kmac(bits, padding, outputBits) {
        Keccak.call(this, bits, padding, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
    };
    var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for(n = 0; n < 48; n += 2){
            c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
            c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
            c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
            c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
            c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
            c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
            c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
            c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
            c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
            c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
            h = c8 ^ (c2 << 1 | c3 >>> 31);
            l = c9 ^ (c3 << 1 | c2 >>> 31);
            s[0] ^= h;
            s[1] ^= l;
            s[10] ^= h;
            s[11] ^= l;
            s[20] ^= h;
            s[21] ^= l;
            s[30] ^= h;
            s[31] ^= l;
            s[40] ^= h;
            s[41] ^= l;
            h = c0 ^ (c4 << 1 | c5 >>> 31);
            l = c1 ^ (c5 << 1 | c4 >>> 31);
            s[2] ^= h;
            s[3] ^= l;
            s[12] ^= h;
            s[13] ^= l;
            s[22] ^= h;
            s[23] ^= l;
            s[32] ^= h;
            s[33] ^= l;
            s[42] ^= h;
            s[43] ^= l;
            h = c2 ^ (c6 << 1 | c7 >>> 31);
            l = c3 ^ (c7 << 1 | c6 >>> 31);
            s[4] ^= h;
            s[5] ^= l;
            s[14] ^= h;
            s[15] ^= l;
            s[24] ^= h;
            s[25] ^= l;
            s[34] ^= h;
            s[35] ^= l;
            s[44] ^= h;
            s[45] ^= l;
            h = c4 ^ (c8 << 1 | c9 >>> 31);
            l = c5 ^ (c9 << 1 | c8 >>> 31);
            s[6] ^= h;
            s[7] ^= l;
            s[16] ^= h;
            s[17] ^= l;
            s[26] ^= h;
            s[27] ^= l;
            s[36] ^= h;
            s[37] ^= l;
            s[46] ^= h;
            s[47] ^= l;
            h = c6 ^ (c0 << 1 | c1 >>> 31);
            l = c7 ^ (c1 << 1 | c0 >>> 31);
            s[8] ^= h;
            s[9] ^= l;
            s[18] ^= h;
            s[19] ^= l;
            s[28] ^= h;
            s[29] ^= l;
            s[38] ^= h;
            s[39] ^= l;
            s[48] ^= h;
            s[49] ^= l;
            b0 = s[0];
            b1 = s[1];
            b32 = s[11] << 4 | s[10] >>> 28;
            b33 = s[10] << 4 | s[11] >>> 28;
            b14 = s[20] << 3 | s[21] >>> 29;
            b15 = s[21] << 3 | s[20] >>> 29;
            b46 = s[31] << 9 | s[30] >>> 23;
            b47 = s[30] << 9 | s[31] >>> 23;
            b28 = s[40] << 18 | s[41] >>> 14;
            b29 = s[41] << 18 | s[40] >>> 14;
            b20 = s[2] << 1 | s[3] >>> 31;
            b21 = s[3] << 1 | s[2] >>> 31;
            b2 = s[13] << 12 | s[12] >>> 20;
            b3 = s[12] << 12 | s[13] >>> 20;
            b34 = s[22] << 10 | s[23] >>> 22;
            b35 = s[23] << 10 | s[22] >>> 22;
            b16 = s[33] << 13 | s[32] >>> 19;
            b17 = s[32] << 13 | s[33] >>> 19;
            b48 = s[42] << 2 | s[43] >>> 30;
            b49 = s[43] << 2 | s[42] >>> 30;
            b40 = s[5] << 30 | s[4] >>> 2;
            b41 = s[4] << 30 | s[5] >>> 2;
            b22 = s[14] << 6 | s[15] >>> 26;
            b23 = s[15] << 6 | s[14] >>> 26;
            b4 = s[25] << 11 | s[24] >>> 21;
            b5 = s[24] << 11 | s[25] >>> 21;
            b36 = s[34] << 15 | s[35] >>> 17;
            b37 = s[35] << 15 | s[34] >>> 17;
            b18 = s[45] << 29 | s[44] >>> 3;
            b19 = s[44] << 29 | s[45] >>> 3;
            b10 = s[6] << 28 | s[7] >>> 4;
            b11 = s[7] << 28 | s[6] >>> 4;
            b42 = s[17] << 23 | s[16] >>> 9;
            b43 = s[16] << 23 | s[17] >>> 9;
            b24 = s[26] << 25 | s[27] >>> 7;
            b25 = s[27] << 25 | s[26] >>> 7;
            b6 = s[36] << 21 | s[37] >>> 11;
            b7 = s[37] << 21 | s[36] >>> 11;
            b38 = s[47] << 24 | s[46] >>> 8;
            b39 = s[46] << 24 | s[47] >>> 8;
            b30 = s[8] << 27 | s[9] >>> 5;
            b31 = s[9] << 27 | s[8] >>> 5;
            b12 = s[18] << 20 | s[19] >>> 12;
            b13 = s[19] << 20 | s[18] >>> 12;
            b44 = s[29] << 7 | s[28] >>> 25;
            b45 = s[28] << 7 | s[29] >>> 25;
            b26 = s[38] << 8 | s[39] >>> 24;
            b27 = s[39] << 8 | s[38] >>> 24;
            b8 = s[48] << 14 | s[49] >>> 18;
            b9 = s[49] << 14 | s[48] >>> 18;
            s[0] = b0 ^ ~b2 & b4;
            s[1] = b1 ^ ~b3 & b5;
            s[10] = b10 ^ ~b12 & b14;
            s[11] = b11 ^ ~b13 & b15;
            s[20] = b20 ^ ~b22 & b24;
            s[21] = b21 ^ ~b23 & b25;
            s[30] = b30 ^ ~b32 & b34;
            s[31] = b31 ^ ~b33 & b35;
            s[40] = b40 ^ ~b42 & b44;
            s[41] = b41 ^ ~b43 & b45;
            s[2] = b2 ^ ~b4 & b6;
            s[3] = b3 ^ ~b5 & b7;
            s[12] = b12 ^ ~b14 & b16;
            s[13] = b13 ^ ~b15 & b17;
            s[22] = b22 ^ ~b24 & b26;
            s[23] = b23 ^ ~b25 & b27;
            s[32] = b32 ^ ~b34 & b36;
            s[33] = b33 ^ ~b35 & b37;
            s[42] = b42 ^ ~b44 & b46;
            s[43] = b43 ^ ~b45 & b47;
            s[4] = b4 ^ ~b6 & b8;
            s[5] = b5 ^ ~b7 & b9;
            s[14] = b14 ^ ~b16 & b18;
            s[15] = b15 ^ ~b17 & b19;
            s[24] = b24 ^ ~b26 & b28;
            s[25] = b25 ^ ~b27 & b29;
            s[34] = b34 ^ ~b36 & b38;
            s[35] = b35 ^ ~b37 & b39;
            s[44] = b44 ^ ~b46 & b48;
            s[45] = b45 ^ ~b47 & b49;
            s[6] = b6 ^ ~b8 & b0;
            s[7] = b7 ^ ~b9 & b1;
            s[16] = b16 ^ ~b18 & b10;
            s[17] = b17 ^ ~b19 & b11;
            s[26] = b26 ^ ~b28 & b20;
            s[27] = b27 ^ ~b29 & b21;
            s[36] = b36 ^ ~b38 & b30;
            s[37] = b37 ^ ~b39 & b31;
            s[46] = b46 ^ ~b48 & b40;
            s[47] = b47 ^ ~b49 & b41;
            s[8] = b8 ^ ~b0 & b2;
            s[9] = b9 ^ ~b1 & b3;
            s[18] = b18 ^ ~b10 & b12;
            s[19] = b19 ^ ~b11 & b13;
            s[28] = b28 ^ ~b20 & b22;
            s[29] = b29 ^ ~b21 & b23;
            s[38] = b38 ^ ~b30 & b32;
            s[39] = b39 ^ ~b31 & b33;
            s[48] = b48 ^ ~b40 & b42;
            s[49] = b49 ^ ~b41 & b43;
            s[0] ^= RC[n];
            s[1] ^= RC[n + 1];
        }
    };
    if (COMMON_JS) module.exports = methods;
    else {
        for(i = 0; i < methodNames.length; ++i)root[methodNames[i]] = methods[methodNames[i]];
        if (AMD) define(function() {
            return methods;
        });
    }
})();

},{}],"8Rh0h":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "_toEscapedUtf8String", ()=>(0, _utf8._toEscapedUtf8String));
parcelHelpers.export(exports, "toUtf8Bytes", ()=>(0, _utf8.toUtf8Bytes));
parcelHelpers.export(exports, "toUtf8CodePoints", ()=>(0, _utf8.toUtf8CodePoints));
parcelHelpers.export(exports, "toUtf8String", ()=>(0, _utf8.toUtf8String));
parcelHelpers.export(exports, "Utf8ErrorFuncs", ()=>(0, _utf8.Utf8ErrorFuncs));
parcelHelpers.export(exports, "Utf8ErrorReason", ()=>(0, _utf8.Utf8ErrorReason));
parcelHelpers.export(exports, "UnicodeNormalizationForm", ()=>(0, _utf8.UnicodeNormalizationForm));
parcelHelpers.export(exports, "formatBytes32String", ()=>(0, _bytes32.formatBytes32String));
parcelHelpers.export(exports, "parseBytes32String", ()=>(0, _bytes32.parseBytes32String));
parcelHelpers.export(exports, "nameprep", ()=>(0, _idna.nameprep));
var _bytes32 = require("./bytes32");
var _idna = require("./idna");
var _utf8 = require("./utf8");
"use strict";

},{"./bytes32":false,"./idna":false,"./utf8":"11mwZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"11mwZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UnicodeNormalizationForm", ()=>UnicodeNormalizationForm);
parcelHelpers.export(exports, "Utf8ErrorReason", ()=>Utf8ErrorReason);
parcelHelpers.export(exports, "Utf8ErrorFuncs", ()=>Utf8ErrorFuncs);
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
parcelHelpers.export(exports, "toUtf8Bytes", ()=>toUtf8Bytes);
parcelHelpers.export(exports, "_toEscapedUtf8String", ()=>_toEscapedUtf8String);
parcelHelpers.export(exports, "_toUtf8String", ()=>_toUtf8String);
parcelHelpers.export(exports, "toUtf8String", ()=>toUtf8String);
parcelHelpers.export(exports, "toUtf8CodePoints", ()=>toUtf8CodePoints);
var _bytes = require("@ethersproject/bytes");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
var UnicodeNormalizationForm;
(function(UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function(Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for(let o = offset + 1; o < bytes.length; o++){
            if (bytes[o] >> 6 !== 0x02) break;
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) return bytes.length - offset - 1;
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) onError = Utf8ErrorFuncs.error;
    bytes = (0, _bytes.arrayify)(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while(i < bytes.length){
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
        // 1110 xxxx 10xx xxxx 10xx xxxx
        } else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
        // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        } else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        } else {
            if ((c & 0xc0) === 0x80) i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            else i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & (1 << 8 - extraLength - 1) - 1;
        for(let j = 0; j < extraLength; j++){
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            res = res << 6 | nextChar & 0x3f;
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) continue;
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for(let i = 0; i < str.length; i++){
        const c = str.charCodeAt(i);
        if (c < 0x80) result.push(c);
        else if (c < 0x800) {
            result.push(c >> 6 | 0xc0);
            result.push(c & 0x3f | 0x80);
        } else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) throw new Error("invalid utf-8 string");
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push(pair >> 18 | 0xf0);
            result.push(pair >> 12 & 0x3f | 0x80);
            result.push(pair >> 6 & 0x3f | 0x80);
            result.push(pair & 0x3f | 0x80);
        } else {
            result.push(c >> 12 | 0xe0);
            result.push(c >> 6 & 0x3f | 0x80);
            result.push(c & 0x3f | 0x80);
        }
    }
    return (0, _bytes.arrayify)(result);
}
function escapeChar(value) {
    const hex = "0000" + value.toString(16);
    return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
    return '"' + getUtf8CodePoints(bytes, onError).map((codePoint)=>{
        if (codePoint < 256) {
            switch(codePoint){
                case 8:
                    return "\\b";
                case 9:
                    return "\\t";
                case 10:
                    return "\\n";
                case 13:
                    return "\\r";
                case 34:
                    return "\\\"";
                case 92:
                    return "\\\\";
            }
            if (codePoint >= 32 && codePoint < 127) return String.fromCharCode(codePoint);
        }
        if (codePoint <= 0xffff) return escapeChar(codePoint);
        codePoint -= 0x10000;
        return escapeChar((codePoint >> 10 & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
    }).join("") + '"';
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint)=>{
        if (codePoint <= 0xffff) return String.fromCharCode(codePoint);
        codePoint -= 0x10000;
        return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
}

},{"@ethersproject/bytes":"5ReBN","@ethersproject/logger":"9rXfv","./_version":"dDYLR","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dDYLR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "strings/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6QfSa":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ensNormalize", ()=>ensNormalize);
parcelHelpers.export(exports, "isValidName", ()=>isValidName);
parcelHelpers.export(exports, "namehash", ()=>namehash);
parcelHelpers.export(exports, "dnsEncode", ()=>dnsEncode);
var _bytes = require("@ethersproject/bytes");
var _strings = require("@ethersproject/strings");
var _keccak256 = require("@ethersproject/keccak256");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _lib = require("./ens-normalize/lib");
const logger = new (0, _logger.Logger)((0, _version.version));
const Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
    if (comp.length === 0) throw new Error("invalid ENS name; empty component");
    return comp;
}
function ensNameSplit(name) {
    const bytes = (0, _strings.toUtf8Bytes)((0, _lib.ens_normalize)(name));
    const comps = [];
    if (name.length === 0) return comps;
    let last = 0;
    for(let i = 0; i < bytes.length; i++){
        const d = bytes[i];
        // A separator (i.e. "."); copy this component
        if (d === 0x2e) {
            comps.push(checkComponent(bytes.slice(last, i)));
            last = i + 1;
        }
    }
    // There was a stray separator at the end of the name
    if (last >= bytes.length) throw new Error("invalid ENS name; empty component");
    comps.push(checkComponent(bytes.slice(last)));
    return comps;
}
function ensNormalize(name) {
    return ensNameSplit(name).map((comp)=>(0, _strings.toUtf8String)(comp)).join(".");
}
function isValidName(name) {
    try {
        return ensNameSplit(name).length !== 0;
    } catch (error) {}
    return false;
}
function namehash(name) {
    /* istanbul ignore if */ if (typeof name !== "string") logger.throwArgumentError("invalid ENS name; not a string", "name", name);
    let result = Zeros;
    const comps = ensNameSplit(name);
    while(comps.length)result = (0, _keccak256.keccak256)((0, _bytes.concat)([
        result,
        (0, _keccak256.keccak256)(comps.pop())
    ]));
    return (0, _bytes.hexlify)(result);
}
function dnsEncode(name) {
    return (0, _bytes.hexlify)((0, _bytes.concat)(ensNameSplit(name).map((comp)=>{
        // DNS does not allow components over 63 bytes in length
        if (comp.length > 63) throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
        const bytes = new Uint8Array(comp.length + 1);
        bytes.set(comp, 1);
        bytes[0] = bytes.length - 1;
        return bytes;
    }))) + "00";
}

},{"@ethersproject/bytes":"5ReBN","@ethersproject/strings":"8Rh0h","@ethersproject/keccak256":"8rdQU","@ethersproject/logger":"9rXfv","./_version":"gsEwy","./ens-normalize/lib":"gLMdb","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gsEwy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "hash/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gLMdb":[function(require,module,exports,__globalThis) {
/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ens_normalize_post_check", ()=>ens_normalize_post_check);
parcelHelpers.export(exports, "ens_normalize", ()=>ens_normalize);
var _strings = require("@ethersproject/strings");
var _includeJs = require("./include.js");
var _decoderJs = require("./decoder.js");
const r = (0, _includeJs.getData)();
// @TODO: This should be lazily loaded
const VALID = new Set((0, _decoderJs.read_member_array)(r));
const IGNORED = new Set((0, _decoderJs.read_member_array)(r));
const MAPPED = (0, _decoderJs.read_mapped_map)(r);
const EMOJI_ROOT = (0, _decoderJs.read_emoji_trie)(r);
//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));
//const STOP = 0x2E;
const HYPHEN = 0x2D;
const UNDERSCORE = 0x5F;
function explode_cp(name) {
    return (0, _strings.toUtf8CodePoints)(name);
}
function filter_fe0f(cps) {
    return cps.filter((cp)=>cp != 0xFE0F);
}
function ens_normalize_post_check(name) {
    for (let label of name.split('.')){
        let cps = explode_cp(label);
        try {
            for(let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--){
                if (cps[i] !== UNDERSCORE) throw new Error(`underscore only allowed at start`);
            }
            if (cps.length >= 4 && cps.every((cp)=>cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) throw new Error(`invalid label extension`);
        } catch (err) {
            throw new Error(`Invalid label "${label}": ${err.message}`);
        }
    }
    return name;
}
function ens_normalize(name) {
    return ens_normalize_post_check(normalize(name, filter_fe0f));
}
function normalize(name, emoji_filter) {
    let input = explode_cp(name).reverse(); // flip for pop
    let output = [];
    while(input.length){
        let emoji = consume_emoji_reversed(input);
        if (emoji) {
            output.push(...emoji_filter(emoji));
            continue;
        }
        let cp = input.pop();
        if (VALID.has(cp)) {
            output.push(cp);
            continue;
        }
        if (IGNORED.has(cp)) continue;
        let cps = MAPPED[cp];
        if (cps) {
            output.push(...cps);
            continue;
        }
        throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
    }
    return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));
}
function nfc(s) {
    return s.normalize('NFC');
}
function consume_emoji_reversed(cps, eaten) {
    var _a;
    let node = EMOJI_ROOT;
    let emoji;
    let saved;
    let stack = [];
    let pos = cps.length;
    if (eaten) eaten.length = 0; // clear input buffer (if needed)
    while(pos){
        let cp = cps[--pos];
        node = (_a = node.branches.find((x)=>x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;
        if (!node) break;
        if (node.save) saved = cp;
        else if (node.check) {
            if (cp === saved) break;
        }
        stack.push(cp);
        if (node.fe0f) {
            stack.push(0xFE0F);
            if (pos > 0 && cps[pos - 1] == 0xFE0F) pos--; // consume optional FE0F
        }
        if (node.valid) {
            emoji = stack.slice(); // copy stack
            if (node.valid == 2) emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)
            if (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)
            cps.length = pos; // truncate
        }
    }
    return emoji;
}

},{"@ethersproject/strings":"8Rh0h","./include.js":"bCRYi","./decoder.js":"3mYRt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bCRYi":[function(require,module,exports,__globalThis) {
/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getData", ()=>getData);
var _base64 = require("@ethersproject/base64");
var _decoderJs = require("./decoder.js");
function getData() {
    return (0, _decoderJs.read_compressed_payload)((0, _base64.decode)('AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=='));
}

},{"@ethersproject/base64":"4pM60","./decoder.js":"3mYRt","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3mYRt":[function(require,module,exports,__globalThis) {
/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */ // https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decode_arithmetic", ()=>decode_arithmetic);
// returns an iterator which returns the next symbol
parcelHelpers.export(exports, "read_payload", ()=>read_payload);
parcelHelpers.export(exports, "read_compressed_payload", ()=>read_compressed_payload);
// eg. [0,1,2,3...] => [0,-1,1,-2,...]
parcelHelpers.export(exports, "signed", ()=>signed);
parcelHelpers.export(exports, "read_member_array", ()=>read_member_array);
// returns array of 
// [x, ys] => single replacement rule
// [x, ys, n, dx, dx] => linear map
parcelHelpers.export(exports, "read_mapped_map", ()=>read_mapped_map);
parcelHelpers.export(exports, "read_zero_terminated_array", ()=>read_zero_terminated_array);
parcelHelpers.export(exports, "read_emoji_trie", ()=>read_emoji_trie);
function flat(array, depth) {
    if (depth == null) depth = 1;
    const result = [];
    const forEach = result.forEach;
    const flatDeep = function(arr, depth) {
        forEach.call(arr, function(val) {
            if (depth > 0 && Array.isArray(val)) flatDeep(val, depth - 1);
            else result.push(val);
        });
    };
    flatDeep(array, depth);
    return result;
}
function fromEntries(array) {
    const result = {};
    for(let i = 0; i < array.length; i++){
        const value = array[i];
        result[value[0]] = value[1];
    }
    return result;
}
function decode_arithmetic(bytes) {
    let pos = 0;
    function u16() {
        return bytes[pos++] << 8 | bytes[pos++];
    }
    // decode the frequency table
    let symbol_count = u16();
    let total = 1;
    let acc = [
        0,
        1
    ]; // first symbol has frequency 1
    for(let i = 1; i < symbol_count; i++)acc.push(total += u16());
    // skip the sized-payload that the last 3 symbols index into
    let skip = u16();
    let pos_payload = pos;
    pos += skip;
    let read_width = 0;
    let read_buffer = 0;
    function read_bit() {
        if (read_width == 0) {
            // this will read beyond end of buffer
            // but (undefined|0) => zero pad
            read_buffer = read_buffer << 8 | bytes[pos++];
            read_width = 8;
        }
        return read_buffer >> --read_width & 1;
    }
    const N = 31;
    const FULL = Math.pow(2, N);
    const HALF = FULL >>> 1;
    const QRTR = HALF >> 1;
    const MASK = FULL - 1;
    // fill register
    let register = 0;
    for(let i = 0; i < N; i++)register = register << 1 | read_bit();
    let symbols = [];
    let low = 0;
    let range = FULL; // treat like a float
    while(true){
        let value = Math.floor(((register - low + 1) * total - 1) / range);
        let start = 0;
        let end = symbol_count;
        while(end - start > 1){
            let mid = start + end >>> 1;
            if (value < acc[mid]) end = mid;
            else start = mid;
        }
        if (start == 0) break; // first symbol is end mark
        symbols.push(start);
        let a = low + Math.floor(range * acc[start] / total);
        let b = low + Math.floor(range * acc[start + 1] / total) - 1;
        while(((a ^ b) & HALF) == 0){
            register = register << 1 & MASK | read_bit();
            a = a << 1 & MASK;
            b = b << 1 & MASK | 1;
        }
        while(a & ~b & QRTR){
            register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
            a = a << 1 ^ HALF;
            b = (b ^ HALF) << 1 | HALF | 1;
        }
        low = a;
        range = 1 + b - a;
    }
    let offset = symbol_count - 4;
    return symbols.map((x)=>{
        switch(x - offset){
            case 3:
                return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
            case 2:
                return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
            case 1:
                return offset + bytes[pos_payload++];
            default:
                return x - 1;
        }
    });
}
function read_payload(v) {
    let pos = 0;
    return ()=>v[pos++];
}
function read_compressed_payload(bytes) {
    return read_payload(decode_arithmetic(bytes));
}
function signed(i) {
    return i & 1 ? ~i >> 1 : i >> 1;
}
function read_counts(n, next) {
    let v = Array(n);
    for(let i = 0; i < n; i++)v[i] = 1 + next();
    return v;
}
function read_ascending(n, next) {
    let v = Array(n);
    for(let i = 0, x = -1; i < n; i++)v[i] = x += 1 + next();
    return v;
}
function read_deltas(n, next) {
    let v = Array(n);
    for(let i = 0, x = 0; i < n; i++)v[i] = x += signed(next());
    return v;
}
function read_member_array(next, lookup) {
    let v = read_ascending(next(), next);
    let n = next();
    let vX = read_ascending(n, next);
    let vN = read_counts(n, next);
    for(let i = 0; i < n; i++)for(let j = 0; j < vN[i]; j++)v.push(vX[i] + j);
    return lookup ? v.map((x)=>lookup[x]) : v;
}
function read_mapped_map(next) {
    let ret = [];
    while(true){
        let w = next();
        if (w == 0) break;
        ret.push(read_linear_table(w, next));
    }
    while(true){
        let w = next() - 1;
        if (w < 0) break;
        ret.push(read_replacement_table(w, next));
    }
    return fromEntries(flat(ret));
}
function read_zero_terminated_array(next) {
    let v = [];
    while(true){
        let i = next();
        if (i == 0) break;
        v.push(i);
    }
    return v;
}
function read_transposed(n, w, next) {
    let m = Array(n).fill(undefined).map(()=>[]);
    for(let i = 0; i < w; i++)read_deltas(n, next).forEach((x, j)=>m[j].push(x));
    return m;
}
function read_linear_table(w, next) {
    let dx = 1 + next();
    let dy = next();
    let vN = read_zero_terminated_array(next);
    let m = read_transposed(vN.length, 1 + w, next);
    return flat(m.map((v, i)=>{
        const x = v[0], ys = v.slice(1);
        //let [x, ...ys] = v;
        //return Array(vN[i]).fill().map((_, j) => {
        return Array(vN[i]).fill(undefined).map((_, j)=>{
            let j_dy = j * dy;
            return [
                x + j * dx,
                ys.map((y)=>y + j_dy)
            ];
        });
    }));
}
function read_replacement_table(w, next) {
    let n = 1 + next();
    let m = read_transposed(n, 1 + w, next);
    return m.map((v)=>[
            v[0],
            v.slice(1)
        ]);
}
function read_emoji_trie(next) {
    let sorted = read_member_array(next).sort((a, b)=>a - b);
    return read();
    function read() {
        let branches = [];
        while(true){
            let keys = read_member_array(next, sorted);
            if (keys.length == 0) break;
            branches.push({
                set: new Set(keys),
                node: read()
            });
        }
        branches.sort((a, b)=>b.set.size - a.set.size); // sort by likelihood
        let temp = next();
        let valid = temp % 3;
        temp = temp / 3 | 0;
        let fe0f = !!(temp & 1);
        temp >>= 1;
        let save = temp == 1;
        let check = temp == 2;
        return {
            branches,
            valid,
            fe0f,
            save,
            check
        };
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7Zsbd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TypedDataEncoder", ()=>TypedDataEncoder);
var _address = require("@ethersproject/address");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _keccak256 = require("@ethersproject/keccak256");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _id = require("./id");
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = (0, _bignumber.BigNumber).from(-1);
const Zero = (0, _bignumber.BigNumber).from(0);
const One = (0, _bignumber.BigNumber).from(1);
const MaxUint256 = (0, _bignumber.BigNumber).from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
    const bytes = (0, _bytes.arrayify)(value);
    const padOffset = bytes.length % 32;
    if (padOffset) return (0, _bytes.hexConcat)([
        bytes,
        padding.slice(padOffset)
    ]);
    return (0, _bytes.hexlify)(bytes);
}
const hexTrue = (0, _bytes.hexZeroPad)(One.toHexString(), 32);
const hexFalse = (0, _bytes.hexZeroPad)(Zero.toHexString(), 32);
const domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
};
const domainFieldNames = [
    "name",
    "version",
    "chainId",
    "verifyingContract",
    "salt"
];
function checkString(key) {
    return function(value) {
        if (typeof value !== "string") logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
        return value;
    };
}
const domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function(value) {
        try {
            return (0, _bignumber.BigNumber).from(value).toString();
        } catch (error) {}
        return logger.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
    },
    verifyingContract: function(value) {
        try {
            return (0, _address.getAddress)(value).toLowerCase();
        } catch (error) {}
        return logger.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
    },
    salt: function(value) {
        try {
            const bytes = (0, _bytes.arrayify)(value);
            if (bytes.length !== 32) throw new Error("bad length");
            return (0, _bytes.hexlify)(bytes);
        } catch (error) {}
        return logger.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
    }
};
function getBaseEncoder(type) {
    // intXX and uintXX
    {
        const match = type.match(/^(u?)int(\d*)$/);
        if (match) {
            const signed = match[1] === "";
            const width = parseInt(match[2] || "256");
            if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) logger.throwArgumentError("invalid numeric width", "type", type);
            const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);
            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;
            return function(value) {
                const v = (0, _bignumber.BigNumber).from(value);
                if (v.lt(boundsLower) || v.gt(boundsUpper)) logger.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
                return (0, _bytes.hexZeroPad)(v.toTwos(256).toHexString(), 32);
            };
        }
    }
    // bytesXX
    {
        const match = type.match(/^bytes(\d+)$/);
        if (match) {
            const width = parseInt(match[1]);
            if (width === 0 || width > 32 || match[1] !== String(width)) logger.throwArgumentError("invalid bytes width", "type", type);
            return function(value) {
                const bytes = (0, _bytes.arrayify)(value);
                if (bytes.length !== width) logger.throwArgumentError(`invalid length for ${type}`, "value", value);
                return hexPadRight(value);
            };
        }
    }
    switch(type){
        case "address":
            return function(value) {
                return (0, _bytes.hexZeroPad)((0, _address.getAddress)(value), 32);
            };
        case "bool":
            return function(value) {
                return !value ? hexFalse : hexTrue;
            };
        case "bytes":
            return function(value) {
                return (0, _keccak256.keccak256)(value);
            };
        case "string":
            return function(value) {
                return (0, _id.id)(value);
            };
    }
    return null;
}
function encodeType(name, fields) {
    return `${name}(${fields.map(({ name, type })=>type + " " + name).join(",")})`;
}
class TypedDataEncoder {
    constructor(types){
        (0, _properties.defineReadOnly)(this, "types", Object.freeze((0, _properties.deepCopy)(types)));
        (0, _properties.defineReadOnly)(this, "_encoderCache", {});
        (0, _properties.defineReadOnly)(this, "_types", {});
        // Link struct types to their direct child structs
        const links = {};
        // Link structs to structs which contain them as a child
        const parents = {};
        // Link all subtypes within a given struct
        const subtypes = {};
        Object.keys(types).forEach((type)=>{
            links[type] = {};
            parents[type] = [];
            subtypes[type] = {};
        });
        for(const name in types){
            const uniqueNames = {};
            types[name].forEach((field)=>{
                // Check each field has a unique name
                if (uniqueNames[field.name]) logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
                uniqueNames[field.name] = true;
                // Get the base type (drop any array specifiers)
                const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                if (baseType === name) logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
                // Is this a base encoding type?
                const encoder = getBaseEncoder(baseType);
                if (encoder) return;
                if (!parents[baseType]) logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
                // Add linkage
                parents[baseType].push(name);
                links[name][baseType] = true;
            });
        }
        // Deduce the primary type
        const primaryTypes = Object.keys(parents).filter((n)=>parents[n].length === 0);
        if (primaryTypes.length === 0) logger.throwArgumentError("missing primary type", "types", types);
        else if (primaryTypes.length > 1) logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t)=>JSON.stringify(t)).join(", ")}`, "types", types);
        (0, _properties.defineReadOnly)(this, "primaryType", primaryTypes[0]);
        // Check for circular type references
        function checkCircular(type, found) {
            if (found[type]) logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
            found[type] = true;
            Object.keys(links[type]).forEach((child)=>{
                if (!parents[child]) return;
                // Recursively check children
                checkCircular(child, found);
                // Mark all ancestors as having this decendant
                Object.keys(found).forEach((subtype)=>{
                    subtypes[subtype][child] = true;
                });
            });
            delete found[type];
        }
        checkCircular(this.primaryType, {});
        // Compute each fully describe type
        for(const name in subtypes){
            const st = Object.keys(subtypes[name]);
            st.sort();
            this._types[name] = encodeType(name, types[name]) + st.map((t)=>encodeType(t, types[t])).join("");
        }
    }
    getEncoder(type) {
        let encoder = this._encoderCache[type];
        if (!encoder) encoder = this._encoderCache[type] = this._getEncoder(type);
        return encoder;
    }
    _getEncoder(type) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) return encoder;
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const subEncoder = this.getEncoder(subtype);
            const length = parseInt(match[3]);
            return (value)=>{
                if (length >= 0 && value.length !== length) logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
                let result = value.map(subEncoder);
                if (this._types[subtype]) result = result.map((0, _keccak256.keccak256));
                return (0, _keccak256.keccak256)((0, _bytes.hexConcat)(result));
            };
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            const encodedType = (0, _id.id)(this._types[type]);
            return (value)=>{
                const values = fields.map(({ name, type })=>{
                    const result = this.getEncoder(type)(value[name]);
                    if (this._types[type]) return (0, _keccak256.keccak256)(result);
                    return result;
                });
                values.unshift(encodedType);
                return (0, _bytes.hexConcat)(values);
            };
        }
        return logger.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    encodeType(name) {
        const result = this._types[name];
        if (!result) logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
        return result;
    }
    encodeData(type, value) {
        return this.getEncoder(type)(value);
    }
    hashStruct(name, value) {
        return (0, _keccak256.keccak256)(this.encodeData(name, value));
    }
    encode(value) {
        return this.encodeData(this.primaryType, value);
    }
    hash(value) {
        return this.hashStruct(this.primaryType, value);
    }
    _visit(type, value, callback) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) return callback(type, value);
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const length = parseInt(match[3]);
            if (length >= 0 && value.length !== length) logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            return value.map((v)=>this._visit(subtype, v, callback));
        }
        // Struct
        const fields = this.types[type];
        if (fields) return fields.reduce((accum, { name, type })=>{
            accum[name] = this._visit(type, value[name], callback);
            return accum;
        }, {});
        return logger.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
    }
    static from(types) {
        return new TypedDataEncoder(types);
    }
    static getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
    }
    static hashStruct(name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
    }
    static hashDomain(domain) {
        const domainFields = [];
        for(const name in domain){
            const type = domainFieldTypes[name];
            if (!type) logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
            domainFields.push({
                name,
                type
            });
        }
        domainFields.sort((a, b)=>{
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", {
            EIP712Domain: domainFields
        }, domain);
    }
    static encode(domain, types, value) {
        return (0, _bytes.hexConcat)([
            "0x1901",
            TypedDataEncoder.hashDomain(domain),
            TypedDataEncoder.from(types).hash(value)
        ]);
    }
    static hash(domain, types, value) {
        return (0, _keccak256.keccak256)(TypedDataEncoder.encode(domain, types, value));
    }
    // Replaces all address types with ENS names with their looked up address
    static resolveNames(domain, types, value, resolveName) {
        return __awaiter(this, void 0, void 0, function*() {
            // Make a copy to isolate it from the object passed in
            domain = (0, _properties.shallowCopy)(domain);
            // Look up all ENS names
            const ensCache = {};
            // Do we need to look up the domain's verifyingContract?
            if (domain.verifyingContract && !(0, _bytes.isHexString)(domain.verifyingContract, 20)) ensCache[domain.verifyingContract] = "0x";
            // We are going to use the encoder to visit all the base values
            const encoder = TypedDataEncoder.from(types);
            // Get a list of all the addresses
            encoder.visit(value, (type, value)=>{
                if (type === "address" && !(0, _bytes.isHexString)(value, 20)) ensCache[value] = "0x";
                return value;
            });
            // Lookup each name
            for(const name in ensCache)ensCache[name] = yield resolveName(name);
            // Replace the domain verifyingContract if needed
            if (domain.verifyingContract && ensCache[domain.verifyingContract]) domain.verifyingContract = ensCache[domain.verifyingContract];
            // Replace all ENS names with their address
            value = encoder.visit(value, (type, value)=>{
                if (type === "address" && ensCache[value]) return ensCache[value];
                return value;
            });
            return {
                domain,
                value
            };
        });
    }
    static getPayload(domain, types, value) {
        // Validate the domain fields
        TypedDataEncoder.hashDomain(domain);
        // Derive the EIP712Domain Struct reference type
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name)=>{
            const value = domain[name];
            if (value == null) return;
            domainValues[name] = domainChecks[name](value);
            domainTypes.push({
                name,
                type: domainFieldTypes[name]
            });
        });
        const encoder = TypedDataEncoder.from(types);
        const typesWithDomain = (0, _properties.shallowCopy)(types);
        if (typesWithDomain.EIP712Domain) logger.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        else typesWithDomain.EIP712Domain = domainTypes;
        // Validate the data structures and types
        encoder.encode(value);
        return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, (type, value)=>{
                // bytes
                if (type.match(/^bytes(\d*)/)) return (0, _bytes.hexlify)((0, _bytes.arrayify)(value));
                // uint or int
                if (type.match(/^u?int/)) return (0, _bignumber.BigNumber).from(value).toString();
                switch(type){
                    case "address":
                        return value.toLowerCase();
                    case "bool":
                        return !!value;
                    case "string":
                        if (typeof value !== "string") logger.throwArgumentError(`invalid string`, "value", value);
                        return value;
                }
                return logger.throwArgumentError("unsupported type", "type", type);
            })
        };
    }
}

},{"@ethersproject/address":"9Jgcg","@ethersproject/bignumber":"gSTRF","@ethersproject/bytes":"5ReBN","@ethersproject/keccak256":"8rdQU","@ethersproject/properties":"2X633","@ethersproject/logger":"9rXfv","./_version":"gsEwy","./id":"9QwKC","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9Jgcg":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAddress", ()=>getAddress);
parcelHelpers.export(exports, "isAddress", ()=>isAddress);
parcelHelpers.export(exports, "getIcapAddress", ()=>getIcapAddress);
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
parcelHelpers.export(exports, "getContractAddress", ()=>getContractAddress);
parcelHelpers.export(exports, "getCreate2Address", ()=>getCreate2Address);
var _bytes = require("@ethersproject/bytes");
var _bignumber = require("@ethersproject/bignumber");
var _keccak256 = require("@ethersproject/keccak256");
var _rlp = require("@ethersproject/rlp");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function getChecksumAddress(address) {
    if (!(0, _bytes.isHexString)(address, 20)) logger.throwArgumentError("invalid address", "address", address);
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for(let i = 0; i < 40; i++)expanded[i] = chars[i].charCodeAt(0);
    const hashed = (0, _bytes.arrayify)((0, _keccak256.keccak256)(expanded));
    for(let i = 0; i < 40; i += 2){
        if (hashed[i >> 1] >> 4 >= 8) chars[i] = chars[i].toUpperCase();
        if ((hashed[i >> 1] & 0x0f) >= 8) chars[i + 1] = chars[i + 1].toUpperCase();
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) return Math.log10(x);
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for(let i = 0; i < 10; i++)ibanLookup[String(i)] = String(i);
for(let i = 0; i < 26; i++)ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c)=>{
        return ibanLookup[c];
    }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while(expanded.length >= safeDigits){
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - parseInt(expanded, 10) % 97);
    while(checksum.length < 2)checksum = "0" + checksum;
    return checksum;
}
function getAddress(address) {
    let result = null;
    if (typeof address !== "string") logger.throwArgumentError("invalid address", "address", address);
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") address = "0x" + address;
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) logger.throwArgumentError("bad address checksum", "address", address);
    // Maybe ICAP? (we only support direct mode)
    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) logger.throwArgumentError("bad icap checksum", "address", address);
        result = (0, _bignumber._base36To16)(address.substring(4));
        while(result.length < 40)result = "0" + result;
        result = getChecksumAddress("0x" + result);
    } else logger.throwArgumentError("invalid address", "address", address);
    return result;
}
function isAddress(address) {
    try {
        getAddress(address);
        return true;
    } catch (error) {}
    return false;
}
function getIcapAddress(address) {
    let base36 = (0, _bignumber._base16To36)(getAddress(address).substring(2)).toUpperCase();
    while(base36.length < 30)base36 = "0" + base36;
    return "XE" + ibanChecksum("XE00" + base36) + base36;
}
function getContractAddress(transaction) {
    let from = null;
    try {
        from = getAddress(transaction.from);
    } catch (error) {
        logger.throwArgumentError("missing from address", "transaction", transaction);
    }
    const nonce = (0, _bytes.stripZeros)((0, _bytes.arrayify)((0, _bignumber.BigNumber).from(transaction.nonce).toHexString()));
    return getAddress((0, _bytes.hexDataSlice)((0, _keccak256.keccak256)((0, _rlp.encode)([
        from,
        nonce
    ])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
    if ((0, _bytes.hexDataLength)(salt) !== 32) logger.throwArgumentError("salt must be 32 bytes", "salt", salt);
    if ((0, _bytes.hexDataLength)(initCodeHash) !== 32) logger.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
    return getAddress((0, _bytes.hexDataSlice)((0, _keccak256.keccak256)((0, _bytes.concat)([
        "0xff",
        getAddress(from),
        salt,
        initCodeHash
    ])), 12));
}

},{"@ethersproject/bytes":"5ReBN","@ethersproject/bignumber":"gSTRF","@ethersproject/keccak256":"8rdQU","@ethersproject/rlp":"5F2ff","@ethersproject/logger":"9rXfv","./_version":"2rDOr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5F2ff":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "decode", ()=>decode);
//See: https://github.com/ethereum/wiki/wiki/RLP
var _bytes = require("@ethersproject/bytes");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function arrayifyInteger(value) {
    const result = [];
    while(value){
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for(let i = 0; i < length; i++)result = result * 256 + data[offset + i];
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function(child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    if (!(0, _bytes.isBytesLike)(object)) logger.throwArgumentError("RLP object must be BytesLike", "object", object);
    const data = Array.prototype.slice.call((0, _bytes.arrayify)(object));
    if (data.length === 1 && data[0] <= 0x7f) return data;
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
function encode(object) {
    return (0, _bytes.hexlify)(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while(childOffset < offset + 1 + length){
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) logger.throwError("child data too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
    }
    return {
        consumed: 1 + length,
        result: result
    };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    if (data.length === 0) logger.throwError("data too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        if (offset + 1 + lengthLength > data.length) logger.throwError("data short segment too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) logger.throwError("data long segment too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    } else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        if (offset + 1 + length > data.length) logger.throwError("data array too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        return _decodeChildren(data, offset, offset + 1, length);
    } else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        if (offset + 1 + lengthLength > data.length) logger.throwError("data array too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) logger.throwError("data array too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        const result = (0, _bytes.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return {
            consumed: 1 + lengthLength + length,
            result: result
        };
    } else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        if (offset + 1 + length > data.length) logger.throwError("data too short", (0, _logger.Logger).errors.BUFFER_OVERRUN, {});
        const result = (0, _bytes.hexlify)(data.slice(offset + 1, offset + 1 + length));
        return {
            consumed: 1 + length,
            result: result
        };
    }
    return {
        consumed: 1,
        result: (0, _bytes.hexlify)(data[offset])
    };
}
function decode(data) {
    const bytes = (0, _bytes.arrayify)(data);
    const decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) logger.throwArgumentError("invalid rlp data", "data", data);
    return decoded.result;
}

},{"@ethersproject/bytes":"5ReBN","@ethersproject/logger":"9rXfv","./_version":"8ByA2","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8ByA2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "rlp/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2rDOr":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "address/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dRlnY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "computeHmac", ()=>(0, _sha2.computeHmac));
parcelHelpers.export(exports, "ripemd160", ()=>(0, _sha2.ripemd160));
parcelHelpers.export(exports, "sha256", ()=>(0, _sha2.sha256));
parcelHelpers.export(exports, "sha512", ()=>(0, _sha2.sha512));
parcelHelpers.export(exports, "SupportedAlgorithm", ()=>(0, _types.SupportedAlgorithm));
var _sha2 = require("./sha2");
var _types = require("./types");

},{"./sha2":"3BTIL","./types":false,"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3BTIL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ripemd160", ()=>ripemd160);
parcelHelpers.export(exports, "sha256", ()=>sha256);
parcelHelpers.export(exports, "sha512", ()=>sha512);
parcelHelpers.export(exports, "computeHmac", ()=>computeHmac);
var _hashJs = require("hash.js");
var _hashJsDefault = parcelHelpers.interopDefault(_hashJs);
//const _ripemd160 = _hash.ripemd160;
var _bytes = require("@ethersproject/bytes");
var _types = require("./types");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function ripemd160(data) {
    return "0x" + (0, _hashJsDefault.default).ripemd160().update((0, _bytes.arrayify)(data)).digest("hex");
}
function sha256(data) {
    return "0x" + (0, _hashJsDefault.default).sha256().update((0, _bytes.arrayify)(data)).digest("hex");
}
function sha512(data) {
    return "0x" + (0, _hashJsDefault.default).sha512().update((0, _bytes.arrayify)(data)).digest("hex");
}
function computeHmac(algorithm, key, data) {
    if (!(0, _types.SupportedAlgorithm)[algorithm]) logger.throwError("unsupported algorithm " + algorithm, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
        operation: "hmac",
        algorithm: algorithm
    });
    return "0x" + (0, _hashJsDefault.default).hmac((0, _hashJsDefault.default)[algorithm], (0, _bytes.arrayify)(key)).update((0, _bytes.arrayify)(data)).digest("hex");
}

},{"hash.js":"jo8Bq","@ethersproject/bytes":"5ReBN","./types":"kSno7","@ethersproject/logger":"9rXfv","./_version":"ca54T","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jo8Bq":[function(require,module,exports,__globalThis) {
var hash = exports;
hash.utils = require("38593959f18bd562");
hash.common = require("31a457752237e8ad");
hash.sha = require("3e37816d2a2fd68d");
hash.ripemd = require("ce5a13b5bd10f171");
hash.hmac = require("c32fbac97a361580");
// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"38593959f18bd562":"mvBnM","31a457752237e8ad":"9Boob","3e37816d2a2fd68d":"9sOCG","ce5a13b5bd10f171":"i6YrS","c32fbac97a361580":"fu1w5"}],"mvBnM":[function(require,module,exports,__globalThis) {
'use strict';
var assert = require("6002b0feade022a4");
var inherits = require("d4826c9d0ff1b1f");
exports.inherits = inherits;
function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) return false;
    if (i < 0 || i + 1 >= msg.length) return false;
    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg === 'string') {
        if (!enc) {
            // Inspired by stringToUtf8ByteArray() in closure-library by Google
            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
            // Apache License 2.0
            // https://github.com/google/closure-library/blob/master/LICENSE
            var p = 0;
            for(var i = 0; i < msg.length; i++){
                var c = msg.charCodeAt(i);
                if (c < 128) res[p++] = c;
                else if (c < 2048) {
                    res[p++] = c >> 6 | 192;
                    res[p++] = c & 63 | 128;
                } else if (isSurrogatePair(msg, i)) {
                    c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
                    res[p++] = c >> 18 | 240;
                    res[p++] = c >> 12 & 63 | 128;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                } else {
                    res[p++] = c >> 12 | 224;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                }
            }
        } else if (enc === 'hex') {
            msg = msg.replace(/[^a-z0-9]+/ig, '');
            if (msg.length % 2 !== 0) msg = '0' + msg;
            for(i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
    } else for(i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
    return res;
}
exports.toArray = toArray;
function toHex(msg) {
    var res = '';
    for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
    return res;
}
exports.toHex = toHex;
function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
    return res >>> 0;
}
exports.htonl = htonl;
function toHex32(msg, endian) {
    var res = '';
    for(var i = 0; i < msg.length; i++){
        var w = msg[i];
        if (endian === 'little') w = htonl(w);
        res += zero8(w.toString(16));
    }
    return res;
}
exports.toHex32 = toHex32;
function zero2(word) {
    if (word.length === 1) return '0' + word;
    else return word;
}
exports.zero2 = zero2;
function zero8(word) {
    if (word.length === 7) return '0' + word;
    else if (word.length === 6) return '00' + word;
    else if (word.length === 5) return '000' + word;
    else if (word.length === 4) return '0000' + word;
    else if (word.length === 3) return '00000' + word;
    else if (word.length === 2) return '000000' + word;
    else if (word.length === 1) return '0000000' + word;
    else return word;
}
exports.zero8 = zero8;
function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for(var i = 0, k = start; i < res.length; i++, k += 4){
        var w;
        if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
    }
    return res;
}
exports.join32 = join32;
function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for(var i = 0, k = 0; i < msg.length; i++, k += 4){
        var m = msg[i];
        if (endian === 'big') {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 0xff;
            res[k + 2] = m >>> 8 & 0xff;
            res[k + 3] = m & 0xff;
        } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 0xff;
            res[k + 1] = m >>> 8 & 0xff;
            res[k] = m & 0xff;
        }
    }
    return res;
}
exports.split32 = split32;
function rotr32(w, b) {
    return w >>> b | w << 32 - b;
}
exports.rotr32 = rotr32;
function rotl32(w, b) {
    return w << b | w >>> 32 - b;
}
exports.rotl32 = rotl32;
function sum32(a, b) {
    return a + b >>> 0;
}
exports.sum32 = sum32;
function sum32_3(a, b, c) {
    return a + b + c >>> 0;
}
exports.sum32_3 = sum32_3;
function sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
}
exports.sum32_4 = sum32_4;
function sum32_5(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
}
exports.sum32_5 = sum32_5;
function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
}
exports.sum64 = sum64;
function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
}
exports.sum64_hi = sum64_hi;
function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
}
exports.sum64_lo = sum64_lo;
function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;
function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;
function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;
function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;
function rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;
function rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;
function shr64_hi(ah, al, num) {
    return ah >>> num;
}
exports.shr64_hi = shr64_hi;
function shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"6002b0feade022a4":"cVOsq","d4826c9d0ff1b1f":"9UN53"}],"cVOsq":[function(require,module,exports,__globalThis) {
module.exports = assert;
function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
}
assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};

},{}],"9UN53":[function(require,module,exports,__globalThis) {
if (typeof Object.create === 'function') // implementation from standard node.js 'util' module
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    }
};
else // old school shim for old browsers
module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
};

},{}],"9Boob":[function(require,module,exports,__globalThis) {
'use strict';
var utils = require("e9291abdfb47ee4f");
var assert = require("ea8841b701712638");
function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = 'big';
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;
BlockHash.prototype.update = function update(msg, enc) {
    // Convert message to array, pad it, and join into 32bit blocks
    msg = utils.toArray(msg, enc);
    if (!this.pending) this.pending = msg;
    else this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    // Enough data, try updating
    if (this.pending.length >= this._delta8) {
        msg = this.pending;
        // Process pending data in blocks
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0) this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for(var i = 0; i < msg.length; i += this._delta32)this._update(msg, i, i + this._delta32);
    }
    return this;
};
BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
};
BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for(var i = 1; i < k; i++)res[i] = 0;
    // Append length
    len <<= 3;
    if (this.endian === 'big') {
        for(var t = 8; t < this.padLength; t++)res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len & 0xff;
    } else {
        res[i++] = len & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for(t = 8; t < this.padLength; t++)res[i++] = 0;
    }
    return res;
};

},{"e9291abdfb47ee4f":"mvBnM","ea8841b701712638":"cVOsq"}],"9sOCG":[function(require,module,exports,__globalThis) {
'use strict';
exports.sha1 = require("3835379564860fd7");
exports.sha224 = require("bb9f72f042233648");
exports.sha256 = require("20a3b0fa42e37dfe");
exports.sha384 = require("ad4827efa7d953c2");
exports.sha512 = require("301292595a944c1d");

},{"3835379564860fd7":"kSz0c","bb9f72f042233648":"c7Dzd","20a3b0fa42e37dfe":"1K2u2","ad4827efa7d953c2":"bzwjm","301292595a944c1d":"4t2Wy"}],"kSz0c":[function(require,module,exports,__globalThis) {
'use strict';
var utils = require("b75f3c1442bf9100");
var common = require("a29e68029e4c48f8");
var shaCommon = require("1be62f90a237cba5");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;
var sha1_K = [
    0x5A827999,
    0x6ED9EBA1,
    0x8F1BBCDC,
    0xCA62C1D6
];
function SHA1() {
    if (!(this instanceof SHA1)) return new SHA1();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.W = new Array(80);
}
utils.inherits(SHA1, BlockHash);
module.exports = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for(i = 0; i < W.length; i++){
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
};
SHA1.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'big');
    else return utils.split32(this.h, 'big');
};

},{"b75f3c1442bf9100":"mvBnM","a29e68029e4c48f8":"9Boob","1be62f90a237cba5":"is1Yj"}],"is1Yj":[function(require,module,exports,__globalThis) {
'use strict';
var utils = require("f0fb61f828bacd0f");
var rotr32 = utils.rotr32;
function ft_1(s, x, y, z) {
    if (s === 0) return ch32(x, y, z);
    if (s === 1 || s === 3) return p32(x, y, z);
    if (s === 2) return maj32(x, y, z);
}
exports.ft_1 = ft_1;
function ch32(x, y, z) {
    return x & y ^ ~x & z;
}
exports.ch32 = ch32;
function maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
}
exports.maj32 = maj32;
function p32(x, y, z) {
    return x ^ y ^ z;
}
exports.p32 = p32;
function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;
function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;
function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
exports.g0_256 = g0_256;
function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
exports.g1_256 = g1_256;

},{"f0fb61f828bacd0f":"mvBnM"}],"c7Dzd":[function(require,module,exports,__globalThis) {
'use strict';
var utils = require("fe5acd040463c159");
var SHA256 = require("fa3503eda3738d05");
function SHA224() {
    if (!(this instanceof SHA224)) return new SHA224();
    SHA256.call(this);
    this.h = [
        0xc1059ed8,
        0x367cd507,
        0x3070dd17,
        0xf70e5939,
        0xffc00b31,
        0x68581511,
        0x64f98fa7,
        0xbefa4fa4
    ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest(enc) {
    // Just truncate output
    if (enc === 'hex') return utils.toHex32(this.h.slice(0, 7), 'big');
    else return utils.split32(this.h.slice(0, 7), 'big');
};

},{"fe5acd040463c159":"mvBnM","fa3503eda3738d05":"1K2u2"}],"1K2u2":[function(require,module,exports,__globalThis) {
'use strict';
var utils = require("32ad3e510bd41f2a");
var common = require("469ad88ad505772a");
var shaCommon = require("fffa7d1ddf1f0b43");
var assert = require("126369f57b5225ed");
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash = common.BlockHash;
var sha256_K = [
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
];
function SHA256() {
    if (!(this instanceof SHA256)) return new SHA256();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19
    ];
    this.k = sha256_K;
    this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;
SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for(i = 0; i < W.length; i++){
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
};
SHA256.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'big');
    else return utils.split32(this.h, 'big');
};

},{"32ad3e510bd41f2a":"mvBnM","469ad88ad505772a":"9Boob","fffa7d1ddf1f0b43":"is1Yj","126369f57b5225ed":"cVOsq"}],"bzwjm":[function(require,module,exports,__globalThis) {
'use strict';
var utils = require("a696ee34c45713da");
var SHA512 = require("fff95253fdaa49ea");
function SHA384() {
    if (!(this instanceof SHA384)) return new SHA384();
    SHA512.call(this);
    this.h = [
        0xcbbb9d5d,
        0xc1059ed8,
        0x629a292a,
        0x367cd507,
        0x9159015a,
        0x3070dd17,
        0x152fecd8,
        0xf70e5939,
        0x67332667,
        0xffc00b31,
        0x8eb44a87,
        0x68581511,
        0xdb0c2e0d,
        0x64f98fa7,
        0x47b5481d,
        0xbefa4fa4
    ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h.slice(0, 12), 'big');
    else return utils.split32(this.h.slice(0, 12), 'big');
};

},{"a696ee34c45713da":"mvBnM","fff95253fdaa49ea":"4t2Wy"}],"4t2Wy":[function(require,module,exports,__globalThis) {
'use strict';
var utils = require("7753b1fa702fbb54");
var common = require("81b6970d75627ce1");
var assert = require("f660976cede694e2");
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = common.BlockHash;
var sha512_K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
function SHA512() {
    if (!(this instanceof SHA512)) return new SHA512();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xf3bcc908,
        0xbb67ae85,
        0x84caa73b,
        0x3c6ef372,
        0xfe94f82b,
        0xa54ff53a,
        0x5f1d36f1,
        0x510e527f,
        0xade682d1,
        0x9b05688c,
        0x2b3e6c1f,
        0x1f83d9ab,
        0xfb41bd6b,
        0x5be0cd19,
        0x137e2179
    ];
    this.k = sha512_K;
    this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;
SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;
SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    // 32 x 32bit words
    for(var i = 0; i < 32; i++)W[i] = msg[start + i];
    for(; i < W.length; i += 2){
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14]; // i - 7
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32]; // i - 16
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
};
SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for(var i = 0; i < W.length; i += 2){
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
};
SHA512.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'big');
    else return utils.split32(this.h, 'big');
};
function ch64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2); // 34
    var c2_hi = rotr64_hi(xl, xh, 7); // 39
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2); // 34
    var c2_lo = rotr64_lo(xl, xh, 7); // 39
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9); // 41
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9); // 41
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29); // 61
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29); // 61
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}

},{"7753b1fa702fbb54":"mvBnM","81b6970d75627ce1":"9Boob","f660976cede694e2":"cVOsq"}],"i6YrS":[function(require,module,exports,__globalThis) {
'use strict';
var utils = require("36495272d446418f");
var common = require("ad8cf0490e28e8d7");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
    if (!(this instanceof RIPEMD160)) return new RIPEMD160();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for(var j = 0; j < 80; j++){
        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
};
RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'little');
    else return utils.split32(this.h, 'little');
};
function f(j, x, y, z) {
    if (j <= 15) return x ^ y ^ z;
    else if (j <= 31) return x & y | ~x & z;
    else if (j <= 47) return (x | ~y) ^ z;
    else if (j <= 63) return x & z | y & ~z;
    else return x ^ (y | ~z);
}
function K(j) {
    if (j <= 15) return 0x00000000;
    else if (j <= 31) return 0x5a827999;
    else if (j <= 47) return 0x6ed9eba1;
    else if (j <= 63) return 0x8f1bbcdc;
    else return 0xa953fd4e;
}
function Kh(j) {
    if (j <= 15) return 0x50a28be6;
    else if (j <= 31) return 0x5c4dd124;
    else if (j <= 47) return 0x6d703ef3;
    else if (j <= 63) return 0x7a6d76e9;
    else return 0x00000000;
}
var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
];
var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
];
var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
];
var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
];

},{"36495272d446418f":"mvBnM","ad8cf0490e28e8d7":"9Boob"}],"fu1w5":[function(require,module,exports,__globalThis) {
'use strict';
var utils = require("596c08b6835a6e2d");
var assert = require("be527907d4f06808");
function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
}
module.exports = Hmac;
Hmac.prototype._init = function init(key) {
    // Shorten key, if needed
    if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    // Add padding to key
    for(var i = key.length; i < this.blockSize; i++)key.push(0);
    for(i = 0; i < key.length; i++)key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
    // 0x36 ^ 0x5c = 0x6a
    for(i = 0; i < key.length; i++)key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
};
Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
};
Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
};

},{"596c08b6835a6e2d":"mvBnM","be527907d4f06808":"cVOsq"}],"kSno7":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SupportedAlgorithm", ()=>SupportedAlgorithm);
var SupportedAlgorithm;
(function(SupportedAlgorithm) {
    SupportedAlgorithm["sha256"] = "sha256";
    SupportedAlgorithm["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ca54T":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "sha2/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ebBVL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// This API is still a work in progress; the future changes will likely be:
// - ConnectionInfo => FetchDataRequest<T = any>
// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }
//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)
// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T
// For this reason, it should be considered internal until the API is finalized
parcelHelpers.export(exports, "_fetchData", ()=>_fetchData);
parcelHelpers.export(exports, "fetchJson", ()=>fetchJson);
parcelHelpers.export(exports, "poll", ()=>poll);
var _base64 = require("@ethersproject/base64");
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _strings = require("@ethersproject/strings");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _geturl = require("./geturl");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
function staller(duration) {
    return new Promise((resolve)=>{
        setTimeout(resolve, duration);
    });
}
function bodyify(value, type) {
    if (value == null) return null;
    if (typeof value === "string") return value;
    if ((0, _bytes.isBytesLike)(value)) {
        if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) try {
            return (0, _strings.toUtf8String)(value);
        } catch (error) {}
        return (0, _bytes.hexlify)(value);
    }
    return value;
}
function unpercent(value) {
    return (0, _strings.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code)=>{
        return String.fromCharCode(parseInt(code, 16));
    }));
}
function _fetchData(connection, body, processFunc) {
    // How many times to retry in the event of a throttle
    const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
    logger.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
    const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
    const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
    logger.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
    const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
    const headers = {};
    let url = null;
    // @TODO: Allow ConnectionInfo to override some of these values
    const options = {
        method: "GET"
    };
    let allow304 = false;
    let timeout = 120000;
    if (typeof connection === "string") url = connection;
    else if (typeof connection === "object") {
        if (connection == null || connection.url == null) logger.throwArgumentError("missing URL", "connection.url", connection);
        url = connection.url;
        if (typeof connection.timeout === "number" && connection.timeout > 0) timeout = connection.timeout;
        if (connection.headers) for(const key in connection.headers){
            headers[key.toLowerCase()] = {
                key: key,
                value: String(connection.headers[key])
            };
            if ([
                "if-none-match",
                "if-modified-since"
            ].indexOf(key.toLowerCase()) >= 0) allow304 = true;
        }
        options.allowGzip = !!connection.allowGzip;
        if (connection.user != null && connection.password != null) {
            if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) logger.throwError("basic authentication requires a secure https url", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                argument: "url",
                url: url,
                user: connection.user,
                password: "[REDACTED]"
            });
            const authorization = connection.user + ":" + connection.password;
            headers["authorization"] = {
                key: "Authorization",
                value: "Basic " + (0, _base64.encode)((0, _strings.toUtf8Bytes)(authorization))
            };
        }
        if (connection.skipFetchSetup != null) options.skipFetchSetup = !!connection.skipFetchSetup;
        if (connection.fetchOptions != null) options.fetchOptions = (0, _properties.shallowCopy)(connection.fetchOptions);
    }
    const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
    const dataMatch = url ? url.match(reData) : null;
    if (dataMatch) try {
        const response = {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
                "content-type": dataMatch[1] || "text/plain"
            },
            body: dataMatch[2] ? (0, _base64.decode)(dataMatch[3]) : unpercent(dataMatch[3])
        };
        let result = response.body;
        if (processFunc) result = processFunc(response.body, response);
        return Promise.resolve(result);
    } catch (error) {
        logger.throwError("processing response error", (0, _logger.Logger).errors.SERVER_ERROR, {
            body: bodyify(dataMatch[1], dataMatch[2]),
            error: error,
            requestBody: null,
            requestMethod: "GET",
            url: url
        });
    }
    if (body) {
        options.method = "POST";
        options.body = body;
        if (headers["content-type"] == null) headers["content-type"] = {
            key: "Content-Type",
            value: "application/octet-stream"
        };
        if (headers["content-length"] == null) headers["content-length"] = {
            key: "Content-Length",
            value: String(body.length)
        };
    }
    const flatHeaders = {};
    Object.keys(headers).forEach((key)=>{
        const header = headers[key];
        flatHeaders[header.key] = header.value;
    });
    options.headers = flatHeaders;
    const runningTimeout = function() {
        let timer = null;
        const promise = new Promise(function(resolve, reject) {
            if (timeout) timer = setTimeout(()=>{
                if (timer == null) return;
                timer = null;
                reject(logger.makeError("timeout", (0, _logger.Logger).errors.TIMEOUT, {
                    requestBody: bodyify(options.body, flatHeaders["content-type"]),
                    requestMethod: options.method,
                    timeout: timeout,
                    url: url
                }));
            }, timeout);
        });
        const cancel = function() {
            if (timer == null) return;
            clearTimeout(timer);
            timer = null;
        };
        return {
            promise,
            cancel
        };
    }();
    const runningFetch = function() {
        return __awaiter(this, void 0, void 0, function*() {
            for(let attempt = 0; attempt < attemptLimit; attempt++){
                let response = null;
                try {
                    response = yield (0, _geturl.getUrl)(url, options);
                    if (attempt < attemptLimit) {
                        if (response.statusCode === 301 || response.statusCode === 302) {
                            // Redirection; for now we only support absolute locataions
                            const location = response.headers.location || "";
                            if (options.method === "GET" && location.match(/^https:/)) {
                                url = response.headers.location;
                                continue;
                            }
                        } else if (response.statusCode === 429) {
                            // Exponential back-off throttling
                            let tryAgain = true;
                            if (throttleCallback) tryAgain = yield throttleCallback(attempt, url);
                            if (tryAgain) {
                                let stall = 0;
                                const retryAfter = response.headers["retry-after"];
                                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) stall = parseInt(retryAfter) * 1000;
                                else stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                                //console.log("Stalling 429");
                                yield staller(stall);
                                continue;
                            }
                        }
                    }
                } catch (error) {
                    response = error.response;
                    if (response == null) {
                        runningTimeout.cancel();
                        logger.throwError("missing response", (0, _logger.Logger).errors.SERVER_ERROR, {
                            requestBody: bodyify(options.body, flatHeaders["content-type"]),
                            requestMethod: options.method,
                            serverError: error,
                            url: url
                        });
                    }
                }
                let body = response.body;
                if (allow304 && response.statusCode === 304) body = null;
                else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
                    runningTimeout.cancel();
                    logger.throwError("bad response", (0, _logger.Logger).errors.SERVER_ERROR, {
                        status: response.statusCode,
                        headers: response.headers,
                        body: bodyify(body, response.headers ? response.headers["content-type"] : null),
                        requestBody: bodyify(options.body, flatHeaders["content-type"]),
                        requestMethod: options.method,
                        url: url
                    });
                }
                if (processFunc) try {
                    const result = yield processFunc(body, response);
                    runningTimeout.cancel();
                    return result;
                } catch (error) {
                    // Allow the processFunc to trigger a throttle
                    if (error.throttleRetry && attempt < attemptLimit) {
                        let tryAgain = true;
                        if (throttleCallback) tryAgain = yield throttleCallback(attempt, url);
                        if (tryAgain) {
                            const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                            //console.log("Stalling callback");
                            yield staller(timeout);
                            continue;
                        }
                    }
                    runningTimeout.cancel();
                    logger.throwError("processing response error", (0, _logger.Logger).errors.SERVER_ERROR, {
                        body: bodyify(body, response.headers ? response.headers["content-type"] : null),
                        error: error,
                        requestBody: bodyify(options.body, flatHeaders["content-type"]),
                        requestMethod: options.method,
                        url: url
                    });
                }
                runningTimeout.cancel();
                // If we had a processFunc, it either returned a T or threw above.
                // The "body" is now a Uint8Array.
                return body;
            }
            return logger.throwError("failed response", (0, _logger.Logger).errors.SERVER_ERROR, {
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                url: url
            });
        });
    }();
    return Promise.race([
        runningTimeout.promise,
        runningFetch
    ]);
}
function fetchJson(connection, json, processFunc) {
    let processJsonFunc = (value, response)=>{
        let result = null;
        if (value != null) try {
            result = JSON.parse((0, _strings.toUtf8String)(value));
        } catch (error) {
            logger.throwError("invalid JSON", (0, _logger.Logger).errors.SERVER_ERROR, {
                body: value,
                error: error
            });
        }
        if (processFunc) result = processFunc(result, response);
        return result;
    };
    // If we have json to send, we must
    // - add content-type of application/json (unless already overridden)
    // - convert the json to bytes
    let body = null;
    if (json != null) {
        body = (0, _strings.toUtf8Bytes)(json);
        // Create a connection with the content-type set for JSON
        const updated = typeof connection === "string" ? {
            url: connection
        } : (0, _properties.shallowCopy)(connection);
        if (updated.headers) {
            const hasContentType = Object.keys(updated.headers).filter((k)=>k.toLowerCase() === "content-type").length !== 0;
            if (!hasContentType) {
                updated.headers = (0, _properties.shallowCopy)(updated.headers);
                updated.headers["content-type"] = "application/json";
            }
        } else updated.headers = {
            "content-type": "application/json"
        };
        connection = updated;
    }
    return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
    if (!options) options = {};
    options = (0, _properties.shallowCopy)(options);
    if (options.floor == null) options.floor = 0;
    if (options.ceiling == null) options.ceiling = 10000;
    if (options.interval == null) options.interval = 250;
    return new Promise(function(resolve, reject) {
        let timer = null;
        let done = false;
        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.
        const cancel = ()=>{
            if (done) return false;
            done = true;
            if (timer) clearTimeout(timer);
            return true;
        };
        if (options.timeout) timer = setTimeout(()=>{
            if (cancel()) reject(new Error("timeout"));
        }, options.timeout);
        const retryLimit = options.retryLimit;
        let attempt = 0;
        function check() {
            return func().then(function(result) {
                // If we have a result, or are allowed null then we're done
                if (result !== undefined) {
                    if (cancel()) resolve(result);
                } else if (options.oncePoll) options.oncePoll.once("poll", check);
                else if (options.onceBlock) options.onceBlock.once("block", check);
                else if (!done) {
                    attempt++;
                    if (attempt > retryLimit) {
                        if (cancel()) reject(new Error("retry limit reached"));
                        return;
                    }
                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                    if (timeout < options.floor) timeout = options.floor;
                    if (timeout > options.ceiling) timeout = options.ceiling;
                    setTimeout(check, timeout);
                }
                return null;
            }, function(error) {
                if (cancel()) reject(error);
            });
        }
        check();
    });
}

},{"@ethersproject/base64":"4pM60","@ethersproject/bytes":"5ReBN","@ethersproject/properties":"2X633","@ethersproject/strings":"8Rh0h","@ethersproject/logger":"9rXfv","./_version":"6Gdjz","./geturl":"cTUjL","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6Gdjz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "web/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cTUjL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getUrl", ()=>getUrl);
var _bytes = require("@ethersproject/bytes");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getUrl(href, options) {
    return __awaiter(this, void 0, void 0, function*() {
        if (options == null) options = {};
        const request = {
            method: options.method || "GET",
            headers: options.headers || {},
            body: options.body || undefined
        };
        if (options.skipFetchSetup !== true) {
            request.mode = "cors"; // no-cors, cors, *same-origin
            request.cache = "no-cache"; // *default, no-cache, reload, force-cache, only-if-cached
            request.credentials = "same-origin"; // include, *same-origin, omit
            request.redirect = "follow"; // manual, *follow, error
            request.referrer = "client"; // no-referrer, *client
        }
        if (options.fetchOptions != null) {
            const opts = options.fetchOptions;
            if (opts.mode) request.mode = opts.mode;
            if (opts.cache) request.cache = opts.cache;
            if (opts.credentials) request.credentials = opts.credentials;
            if (opts.redirect) request.redirect = opts.redirect;
            if (opts.referrer) request.referrer = opts.referrer;
        }
        const response = yield fetch(href, request);
        const body = yield response.arrayBuffer();
        const headers = {};
        if (response.headers.forEach) response.headers.forEach((value, key)=>{
            headers[key.toLowerCase()] = value;
        });
        else response.headers.keys().forEach((key)=>{
            headers[key.toLowerCase()] = response.headers.get(key);
        });
        return {
            headers: headers,
            statusCode: response.status,
            statusMessage: response.statusText,
            body: (0, _bytes.arrayify)(new Uint8Array(body))
        };
    });
}

},{"@ethersproject/bytes":"5ReBN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6NFHR":[function(require,module,exports,__globalThis) {
'use strict';
var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
// pre-compute lookup table
var ALPHABET_MAP = {};
for(var z = 0; z < ALPHABET.length; z++){
    var x = ALPHABET.charAt(z);
    if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous');
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    var b = pre >> 25;
    return (pre & 0x1FFFFFF) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}
function prefixChk(prefix) {
    var chk = 1;
    for(var i = 0; i < prefix.length; ++i){
        var c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ c >> 5;
    }
    chk = polymodStep(chk);
    for(i = 0; i < prefix.length; ++i){
        var v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 0x1f;
    }
    return chk;
}
function encode(prefix, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');
    prefix = prefix.toLowerCase();
    // determine chk mod
    var chk = prefixChk(prefix);
    if (typeof chk === 'string') throw new Error(chk);
    var result = prefix + '1';
    for(var i = 0; i < words.length; ++i){
        var x = words[i];
        if (x >> 5 !== 0) throw new Error('Non 5-bit word');
        chk = polymodStep(chk) ^ x;
        result += ALPHABET.charAt(x);
    }
    for(i = 0; i < 6; ++i)chk = polymodStep(chk);
    chk ^= 1;
    for(i = 0; i < 6; ++i){
        var v = chk >> (5 - i) * 5 & 0x1f;
        result += ALPHABET.charAt(v);
    }
    return result;
}
function __decode(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8) return str + ' too short';
    if (str.length > LIMIT) return 'Exceeds length limit';
    // don't allow mixed case
    var lowered = str.toLowerCase();
    var uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;
    str = lowered;
    var split = str.lastIndexOf('1');
    if (split === -1) return 'No separator character for ' + str;
    if (split === 0) return 'Missing prefix for ' + str;
    var prefix = str.slice(0, split);
    var wordChars = str.slice(split + 1);
    if (wordChars.length < 6) return 'Data too short';
    var chk = prefixChk(prefix);
    if (typeof chk === 'string') return chk;
    var words = [];
    for(var i = 0; i < wordChars.length; ++i){
        var c = wordChars.charAt(i);
        var v = ALPHABET_MAP[c];
        if (v === undefined) return 'Unknown character ' + c;
        chk = polymodStep(chk) ^ v;
        // not in the checksum?
        if (i + 6 >= wordChars.length) continue;
        words.push(v);
    }
    if (chk !== 1) return 'Invalid checksum for ' + str;
    return {
        prefix: prefix,
        words: words
    };
}
function decodeUnsafe() {
    var res = __decode.apply(null, arguments);
    if (typeof res === 'object') return res;
}
function decode(str) {
    var res = __decode.apply(null, arguments);
    if (typeof res === 'object') return res;
    throw new Error(res);
}
function convert(data, inBits, outBits, pad) {
    var value = 0;
    var bits = 0;
    var maxV = (1 << outBits) - 1;
    var result = [];
    for(var i = 0; i < data.length; ++i){
        value = value << inBits | data[i];
        bits += inBits;
        while(bits >= outBits){
            bits -= outBits;
            result.push(value >> bits & maxV);
        }
    }
    if (pad) {
        if (bits > 0) result.push(value << outBits - bits & maxV);
    } else {
        if (bits >= inBits) return 'Excess padding';
        if (value << outBits - bits & maxV) return 'Non-zero padding';
    }
    return result;
}
function toWordsUnsafe(bytes) {
    var res = convert(bytes, 8, 5, true);
    if (Array.isArray(res)) return res;
}
function toWords(bytes) {
    var res = convert(bytes, 8, 5, true);
    if (Array.isArray(res)) return res;
    throw new Error(res);
}
function fromWordsUnsafe(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
}
function fromWords(words) {
    var res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
    throw new Error(res);
}
module.exports = {
    decodeUnsafe: decodeUnsafe,
    decode: decode,
    encode: encode,
    toWordsUnsafe: toWordsUnsafe,
    toWords: toWords,
    fromWordsUnsafe: fromWordsUnsafe,
    fromWords: fromWords
};

},{}],"bmrdP":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "providers/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eHThO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Formatter", ()=>Formatter);
parcelHelpers.export(exports, "isCommunityResourcable", ()=>isCommunityResourcable);
parcelHelpers.export(exports, "isCommunityResource", ()=>isCommunityResource);
parcelHelpers.export(exports, "showThrottleMessage", ()=>showThrottleMessage);
var _address = require("@ethersproject/address");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _constants = require("@ethersproject/constants");
var _properties = require("@ethersproject/properties");
var _transactions = require("@ethersproject/transactions");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
class Formatter {
    constructor(){
        this.formats = this.getDefaultFormats();
    }
    getDefaultFormats() {
        const formats = {};
        const address = this.address.bind(this);
        const bigNumber = this.bigNumber.bind(this);
        const blockTag = this.blockTag.bind(this);
        const data = this.data.bind(this);
        const hash = this.hash.bind(this);
        const hex = this.hex.bind(this);
        const number = this.number.bind(this);
        const type = this.type.bind(this);
        const strictData = (v)=>{
            return this.data(v, true);
        };
        formats.transaction = {
            hash: hash,
            type: type,
            accessList: Formatter.allowNull(this.accessList.bind(this), null),
            blockHash: Formatter.allowNull(hash, null),
            blockNumber: Formatter.allowNull(number, null),
            transactionIndex: Formatter.allowNull(number, null),
            confirmations: Formatter.allowNull(number, null),
            from: address,
            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
            // must be set
            gasPrice: Formatter.allowNull(bigNumber),
            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
            maxFeePerGas: Formatter.allowNull(bigNumber),
            gasLimit: bigNumber,
            to: Formatter.allowNull(address, null),
            value: bigNumber,
            nonce: number,
            data: data,
            r: Formatter.allowNull(this.uint256),
            s: Formatter.allowNull(this.uint256),
            v: Formatter.allowNull(number),
            creates: Formatter.allowNull(address, null),
            raw: Formatter.allowNull(data)
        };
        formats.transactionRequest = {
            from: Formatter.allowNull(address),
            nonce: Formatter.allowNull(number),
            gasLimit: Formatter.allowNull(bigNumber),
            gasPrice: Formatter.allowNull(bigNumber),
            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
            maxFeePerGas: Formatter.allowNull(bigNumber),
            to: Formatter.allowNull(address),
            value: Formatter.allowNull(bigNumber),
            data: Formatter.allowNull(strictData),
            type: Formatter.allowNull(number),
            accessList: Formatter.allowNull(this.accessList.bind(this), null)
        };
        formats.receiptLog = {
            transactionIndex: number,
            blockNumber: number,
            transactionHash: hash,
            address: address,
            topics: Formatter.arrayOf(hash),
            data: data,
            logIndex: number,
            blockHash: hash
        };
        formats.receipt = {
            to: Formatter.allowNull(this.address, null),
            from: Formatter.allowNull(this.address, null),
            contractAddress: Formatter.allowNull(address, null),
            transactionIndex: number,
            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
            root: Formatter.allowNull(hex),
            gasUsed: bigNumber,
            logsBloom: Formatter.allowNull(data),
            blockHash: hash,
            transactionHash: hash,
            logs: Formatter.arrayOf(this.receiptLog.bind(this)),
            blockNumber: number,
            confirmations: Formatter.allowNull(number, null),
            cumulativeGasUsed: bigNumber,
            effectiveGasPrice: Formatter.allowNull(bigNumber),
            status: Formatter.allowNull(number),
            type: type
        };
        formats.block = {
            hash: Formatter.allowNull(hash),
            parentHash: hash,
            number: number,
            timestamp: number,
            nonce: Formatter.allowNull(hex),
            difficulty: this.difficulty.bind(this),
            gasLimit: bigNumber,
            gasUsed: bigNumber,
            miner: Formatter.allowNull(address),
            extraData: data,
            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),
            baseFeePerGas: Formatter.allowNull(bigNumber)
        };
        formats.blockWithTransactions = (0, _properties.shallowCopy)(formats.block);
        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
        formats.filter = {
            fromBlock: Formatter.allowNull(blockTag, undefined),
            toBlock: Formatter.allowNull(blockTag, undefined),
            blockHash: Formatter.allowNull(hash, undefined),
            address: Formatter.allowNull(address, undefined),
            topics: Formatter.allowNull(this.topics.bind(this), undefined)
        };
        formats.filterLog = {
            blockNumber: Formatter.allowNull(number),
            blockHash: Formatter.allowNull(hash),
            transactionIndex: number,
            removed: Formatter.allowNull(this.boolean.bind(this)),
            address: address,
            data: Formatter.allowFalsish(data, "0x"),
            topics: Formatter.arrayOf(hash),
            transactionHash: hash,
            logIndex: number
        };
        return formats;
    }
    accessList(accessList) {
        return (0, _transactions.accessListify)(accessList || []);
    }
    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
    // Strict! Used on input.
    number(number) {
        if (number === "0x") return 0;
        return (0, _bignumber.BigNumber).from(number).toNumber();
    }
    type(number) {
        if (number === "0x" || number == null) return 0;
        return (0, _bignumber.BigNumber).from(number).toNumber();
    }
    // Strict! Used on input.
    bigNumber(value) {
        return (0, _bignumber.BigNumber).from(value);
    }
    // Requires a boolean, "true" or  "false"; returns a boolean
    boolean(value) {
        if (typeof value === "boolean") return value;
        if (typeof value === "string") {
            value = value.toLowerCase();
            if (value === "true") return true;
            if (value === "false") return false;
        }
        throw new Error("invalid boolean - " + value);
    }
    hex(value, strict) {
        if (typeof value === "string") {
            if (!strict && value.substring(0, 2) !== "0x") value = "0x" + value;
            if ((0, _bytes.isHexString)(value)) return value.toLowerCase();
        }
        return logger.throwArgumentError("invalid hash", "value", value);
    }
    data(value, strict) {
        const result = this.hex(value, strict);
        if (result.length % 2 !== 0) throw new Error("invalid data; odd-length - " + value);
        return result;
    }
    // Requires an address
    // Strict! Used on input.
    address(value) {
        return (0, _address.getAddress)(value);
    }
    callAddress(value) {
        if (!(0, _bytes.isHexString)(value, 32)) return null;
        const address = (0, _address.getAddress)((0, _bytes.hexDataSlice)(value, 12));
        return address === (0, _constants.AddressZero) ? null : address;
    }
    contractAddress(value) {
        return (0, _address.getContractAddress)(value);
    }
    // Strict! Used on input.
    blockTag(blockTag) {
        if (blockTag == null) return "latest";
        if (blockTag === "earliest") return "0x0";
        switch(blockTag){
            case "earliest":
                return "0x0";
            case "latest":
            case "pending":
            case "safe":
            case "finalized":
                return blockTag;
        }
        if (typeof blockTag === "number" || (0, _bytes.isHexString)(blockTag)) return (0, _bytes.hexValue)(blockTag);
        throw new Error("invalid blockTag");
    }
    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
    hash(value, strict) {
        const result = this.hex(value, strict);
        if ((0, _bytes.hexDataLength)(result) !== 32) return logger.throwArgumentError("invalid hash", "value", value);
        return result;
    }
    // Returns the difficulty as a number, or if too large (i.e. PoA network) null
    difficulty(value) {
        if (value == null) return null;
        const v = (0, _bignumber.BigNumber).from(value);
        try {
            return v.toNumber();
        } catch (error) {}
        return null;
    }
    uint256(value) {
        if (!(0, _bytes.isHexString)(value)) throw new Error("invalid uint256");
        return (0, _bytes.hexZeroPad)(value, 32);
    }
    _block(value, format) {
        if (value.author != null && value.miner == null) value.miner = value.author;
        // The difficulty may need to come from _difficulty in recursed blocks
        const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
        const result = Formatter.check(format, value);
        result._difficulty = difficulty == null ? null : (0, _bignumber.BigNumber).from(difficulty);
        return result;
    }
    block(value) {
        return this._block(value, this.formats.block);
    }
    blockWithTransactions(value) {
        return this._block(value, this.formats.blockWithTransactions);
    }
    // Strict! Used on input.
    transactionRequest(value) {
        return Formatter.check(this.formats.transactionRequest, value);
    }
    transactionResponse(transaction) {
        // Rename gas to gasLimit
        if (transaction.gas != null && transaction.gasLimit == null) transaction.gasLimit = transaction.gas;
        // Some clients (TestRPC) do strange things like return 0x0 for the
        // 0 address; correct this to be a real address
        if (transaction.to && (0, _bignumber.BigNumber).from(transaction.to).isZero()) transaction.to = "0x0000000000000000000000000000000000000000";
        // Rename input to data
        if (transaction.input != null && transaction.data == null) transaction.data = transaction.input;
        // If to and creates are empty, populate the creates from the transaction
        if (transaction.to == null && transaction.creates == null) transaction.creates = this.contractAddress(transaction);
        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) transaction.accessList = [];
        const result = Formatter.check(this.formats.transaction, transaction);
        if (transaction.chainId != null) {
            let chainId = transaction.chainId;
            if ((0, _bytes.isHexString)(chainId)) chainId = (0, _bignumber.BigNumber).from(chainId).toNumber();
            result.chainId = chainId;
        } else {
            let chainId = transaction.networkId;
            // geth-etc returns chainId
            if (chainId == null && result.v == null) chainId = transaction.chainId;
            if ((0, _bytes.isHexString)(chainId)) chainId = (0, _bignumber.BigNumber).from(chainId).toNumber();
            if (typeof chainId !== "number" && result.v != null) {
                chainId = (result.v - 35) / 2;
                if (chainId < 0) chainId = 0;
                chainId = parseInt(chainId);
            }
            if (typeof chainId !== "number") chainId = 0;
            result.chainId = chainId;
        }
        // 0x0000... should actually be null
        if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") result.blockHash = null;
        return result;
    }
    transaction(value) {
        return (0, _transactions.parse)(value);
    }
    receiptLog(value) {
        return Formatter.check(this.formats.receiptLog, value);
    }
    receipt(value) {
        const result = Formatter.check(this.formats.receipt, value);
        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it
        if (result.root != null) {
            if (result.root.length <= 4) {
                // Could be 0x00, 0x0, 0x01 or 0x1
                const value = (0, _bignumber.BigNumber).from(result.root).toNumber();
                if (value === 0 || value === 1) {
                    // Make sure if both are specified, they match
                    if (result.status != null && result.status !== value) logger.throwArgumentError("alt-root-status/status mismatch", "value", {
                        root: result.root,
                        status: result.status
                    });
                    result.status = value;
                    delete result.root;
                } else logger.throwArgumentError("invalid alt-root-status", "value.root", result.root);
            } else if (result.root.length !== 66) // Must be a valid bytes32
            logger.throwArgumentError("invalid root hash", "value.root", result.root);
        }
        if (result.status != null) result.byzantium = true;
        return result;
    }
    topics(value) {
        if (Array.isArray(value)) return value.map((v)=>this.topics(v));
        else if (value != null) return this.hash(value, true);
        return null;
    }
    filter(value) {
        return Formatter.check(this.formats.filter, value);
    }
    filterLog(value) {
        return Formatter.check(this.formats.filterLog, value);
    }
    static check(format, object) {
        const result = {};
        for(const key in format)try {
            const value = format[key](object[key]);
            if (value !== undefined) result[key] = value;
        } catch (error) {
            error.checkKey = key;
            error.checkValue = object[key];
            throw error;
        }
        return result;
    }
    // if value is null-ish, nullValue is returned
    static allowNull(format, nullValue) {
        return function(value) {
            if (value == null) return nullValue;
            return format(value);
        };
    }
    // If value is false-ish, replaceValue is returned
    static allowFalsish(format, replaceValue) {
        return function(value) {
            if (!value) return replaceValue;
            return format(value);
        };
    }
    // Requires an Array satisfying check
    static arrayOf(format) {
        return function(array) {
            if (!Array.isArray(array)) throw new Error("not an array");
            const result = [];
            array.forEach(function(value) {
                result.push(format(value));
            });
            return result;
        };
    }
}
function isCommunityResourcable(value) {
    return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
    return isCommunityResourcable(value) && value.isCommunityResource();
}
// Show the throttle message only once
let throttleMessage = false;
function showThrottleMessage() {
    if (throttleMessage) return;
    throttleMessage = true;
    console.log("========= NOTICE =========");
    console.log("Request-Rate Exceeded  (this message will not be repeated)");
    console.log("");
    console.log("The default API keys for each service are provided as a highly-throttled,");
    console.log("community resource for low-traffic projects and early prototyping.");
    console.log("");
    console.log("While your application will continue to function, we highly recommended");
    console.log("signing up for your own API keys to improve performance, increase your");
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
    console.log("");
    console.log("For more details: https:/\/docs.ethers.io/api-keys/");
    console.log("==========================");
}

},{"@ethersproject/address":"9Jgcg","@ethersproject/bignumber":"gSTRF","@ethersproject/bytes":"5ReBN","@ethersproject/constants":"fVOEx","@ethersproject/properties":"2X633","@ethersproject/transactions":"lqSCl","@ethersproject/logger":"9rXfv","./_version":"bmrdP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lqSCl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TransactionTypes", ()=>TransactionTypes);
parcelHelpers.export(exports, "computeAddress", ()=>computeAddress);
parcelHelpers.export(exports, "recoverAddress", ()=>recoverAddress);
parcelHelpers.export(exports, "accessListify", ()=>accessListify);
parcelHelpers.export(exports, "serialize", ()=>serialize);
parcelHelpers.export(exports, "parse", ()=>parse);
var _address = require("@ethersproject/address");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _constants = require("@ethersproject/constants");
var _keccak256 = require("@ethersproject/keccak256");
var _properties = require("@ethersproject/properties");
var _rlp = require("@ethersproject/rlp");
var _signingKey = require("@ethersproject/signing-key");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
var TransactionTypes;
(function(TransactionTypes) {
    TransactionTypes[TransactionTypes["legacy"] = 0] = "legacy";
    TransactionTypes[TransactionTypes["eip2930"] = 1] = "eip2930";
    TransactionTypes[TransactionTypes["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
///////////////////////////////
function handleAddress(value) {
    if (value === "0x") return null;
    return (0, _address.getAddress)(value);
}
function handleNumber(value) {
    if (value === "0x") return 0, _constants.Zero;
    return (0, _bignumber.BigNumber).from(value);
}
// Legacy Transaction Fields
const transactionFields = [
    {
        name: "nonce",
        maxLength: 32,
        numeric: true
    },
    {
        name: "gasPrice",
        maxLength: 32,
        numeric: true
    },
    {
        name: "gasLimit",
        maxLength: 32,
        numeric: true
    },
    {
        name: "to",
        length: 20
    },
    {
        name: "value",
        maxLength: 32,
        numeric: true
    },
    {
        name: "data"
    }
];
const allowedTransactionKeys = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    type: true,
    value: true
};
function computeAddress(key) {
    const publicKey = (0, _signingKey.computePublicKey)(key);
    return (0, _address.getAddress)((0, _bytes.hexDataSlice)((0, _keccak256.keccak256)((0, _bytes.hexDataSlice)(publicKey, 1)), 12));
}
function recoverAddress(digest, signature) {
    return computeAddress((0, _signingKey.recoverPublicKey)((0, _bytes.arrayify)(digest), signature));
}
function formatNumber(value, name) {
    const result = (0, _bytes.stripZeros)((0, _bignumber.BigNumber).from(value).toHexString());
    if (result.length > 32) logger.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
    return result;
}
function accessSetify(addr, storageKeys) {
    return {
        address: (0, _address.getAddress)(addr),
        storageKeys: (storageKeys || []).map((storageKey, index)=>{
            if ((0, _bytes.hexDataLength)(storageKey) !== 32) logger.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
            return storageKey.toLowerCase();
        })
    };
}
function accessListify(value) {
    if (Array.isArray(value)) return value.map((set, index)=>{
        if (Array.isArray(set)) {
            if (set.length > 2) logger.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
            return accessSetify(set[0], set[1]);
        }
        return accessSetify(set.address, set.storageKeys);
    });
    const result = Object.keys(value).map((addr)=>{
        const storageKeys = value[addr].reduce((accum, storageKey)=>{
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b)=>a.address.localeCompare(b.address));
    return result;
}
function formatAccessList(value) {
    return accessListify(value).map((set)=>[
            set.address,
            set.storageKeys
        ]);
}
function _serializeEip1559(transaction, signature) {
    // If there is an explicit gasPrice, make sure it matches the
    // EIP-1559 fees; otherwise they may not understand what they
    // think they are setting in terms of fee.
    if (transaction.gasPrice != null) {
        const gasPrice = (0, _bignumber.BigNumber).from(transaction.gasPrice);
        const maxFeePerGas = (0, _bignumber.BigNumber).from(transaction.maxFeePerGas || 0);
        if (!gasPrice.eq(maxFeePerGas)) logger.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
            gasPrice,
            maxFeePerGas
        });
    }
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? (0, _address.getAddress)(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x",
        formatAccessList(transaction.accessList || [])
    ];
    if (signature) {
        const sig = (0, _bytes.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, _bytes.stripZeros)(sig.r));
        fields.push((0, _bytes.stripZeros)(sig.s));
    }
    return (0, _bytes.hexConcat)([
        "0x02",
        _rlp.encode(fields)
    ]);
}
function _serializeEip2930(transaction, signature) {
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.gasPrice || 0, "gasPrice"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        transaction.to != null ? (0, _address.getAddress)(transaction.to) : "0x",
        formatNumber(transaction.value || 0, "value"),
        transaction.data || "0x",
        formatAccessList(transaction.accessList || [])
    ];
    if (signature) {
        const sig = (0, _bytes.splitSignature)(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push((0, _bytes.stripZeros)(sig.r));
        fields.push((0, _bytes.stripZeros)(sig.s));
    }
    return (0, _bytes.hexConcat)([
        "0x01",
        _rlp.encode(fields)
    ]);
}
// Legacy Transactions and EIP-155
function _serialize(transaction, signature) {
    (0, _properties.checkProperties)(transaction, allowedTransactionKeys);
    const raw = [];
    transactionFields.forEach(function(fieldInfo) {
        let value = transaction[fieldInfo.name] || [];
        const options = {};
        if (fieldInfo.numeric) options.hexPad = "left";
        value = (0, _bytes.arrayify)((0, _bytes.hexlify)(value, options));
        // Fixed-width field
        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) logger.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
        // Variable-width (with a maximum)
        if (fieldInfo.maxLength) {
            value = (0, _bytes.stripZeros)(value);
            if (value.length > fieldInfo.maxLength) logger.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
        }
        raw.push((0, _bytes.hexlify)(value));
    });
    let chainId = 0;
    if (transaction.chainId != null) {
        // A chainId was provided; if non-zero we'll use EIP-155
        chainId = transaction.chainId;
        if (typeof chainId !== "number") logger.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    } else if (signature && !(0, _bytes.isBytesLike)(signature) && signature.v > 28) // No chainId provided, but the signature is signing with EIP-155; derive chainId
    chainId = Math.floor((signature.v - 35) / 2);
    // We have an EIP-155 transaction (chainId was specified and non-zero)
    if (chainId !== 0) {
        raw.push((0, _bytes.hexlify)(chainId)); // @TODO: hexValue?
        raw.push("0x");
        raw.push("0x");
    }
    // Requesting an unsigned transaction
    if (!signature) return _rlp.encode(raw);
    // The splitSignature will ensure the transaction has a recoveryParam in the
    // case that the signTransaction function only adds a v.
    const sig = (0, _bytes.splitSignature)(signature);
    // We pushed a chainId and null r, s on for hashing only; remove those
    let v = 27 + sig.recoveryParam;
    if (chainId !== 0) {
        raw.pop();
        raw.pop();
        raw.pop();
        v += chainId * 2 + 8;
        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!
        if (sig.v > 28 && sig.v !== v) logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    } else if (sig.v !== v) logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    raw.push((0, _bytes.hexlify)(v));
    raw.push((0, _bytes.stripZeros)((0, _bytes.arrayify)(sig.r)));
    raw.push((0, _bytes.stripZeros)((0, _bytes.arrayify)(sig.s)));
    return _rlp.encode(raw);
}
function serialize(transaction, signature) {
    // Legacy and EIP-155 Transactions
    if (transaction.type == null || transaction.type === 0) {
        if (transaction.accessList != null) logger.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
        return _serialize(transaction, signature);
    }
    // Typed Transactions (EIP-2718)
    switch(transaction.type){
        case 1:
            return _serializeEip2930(transaction, signature);
        case 2:
            return _serializeEip1559(transaction, signature);
        default:
            break;
    }
    return logger.throwError(`unsupported transaction type: ${transaction.type}`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: transaction.type
    });
}
function _parseEipSignature(tx, fields, serialize) {
    try {
        const recid = handleNumber(fields[0]).toNumber();
        if (recid !== 0 && recid !== 1) throw new Error("bad recid");
        tx.v = recid;
    } catch (error) {
        logger.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
    }
    tx.r = (0, _bytes.hexZeroPad)(fields[1], 32);
    tx.s = (0, _bytes.hexZeroPad)(fields[2], 32);
    try {
        const digest = (0, _keccak256.keccak256)(serialize(tx));
        tx.from = recoverAddress(digest, {
            r: tx.r,
            s: tx.s,
            recoveryParam: tx.v
        });
    } catch (error) {}
}
function _parseEip1559(payload) {
    const transaction = _rlp.decode(payload.slice(1));
    if (transaction.length !== 9 && transaction.length !== 12) logger.throwArgumentError("invalid component count for transaction type: 2", "payload", (0, _bytes.hexlify)(payload));
    const maxPriorityFeePerGas = handleNumber(transaction[2]);
    const maxFeePerGas = handleNumber(transaction[3]);
    const tx = {
        type: 2,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        maxPriorityFeePerGas: maxPriorityFeePerGas,
        maxFeePerGas: maxFeePerGas,
        gasPrice: null,
        gasLimit: handleNumber(transaction[4]),
        to: handleAddress(transaction[5]),
        value: handleNumber(transaction[6]),
        data: transaction[7],
        accessList: accessListify(transaction[8])
    };
    // Unsigned EIP-1559 Transaction
    if (transaction.length === 9) return tx;
    tx.hash = (0, _keccak256.keccak256)(payload);
    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
    return tx;
}
function _parseEip2930(payload) {
    const transaction = _rlp.decode(payload.slice(1));
    if (transaction.length !== 8 && transaction.length !== 11) logger.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, _bytes.hexlify)(payload));
    const tx = {
        type: 1,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        gasPrice: handleNumber(transaction[2]),
        gasLimit: handleNumber(transaction[3]),
        to: handleAddress(transaction[4]),
        value: handleNumber(transaction[5]),
        data: transaction[6],
        accessList: accessListify(transaction[7])
    };
    // Unsigned EIP-2930 Transaction
    if (transaction.length === 8) return tx;
    tx.hash = (0, _keccak256.keccak256)(payload);
    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
    return tx;
}
// Legacy Transactions and EIP-155
function _parse(rawTransaction) {
    const transaction = _rlp.decode(rawTransaction);
    if (transaction.length !== 9 && transaction.length !== 6) logger.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
    const tx = {
        nonce: handleNumber(transaction[0]).toNumber(),
        gasPrice: handleNumber(transaction[1]),
        gasLimit: handleNumber(transaction[2]),
        to: handleAddress(transaction[3]),
        value: handleNumber(transaction[4]),
        data: transaction[5],
        chainId: 0
    };
    // Legacy unsigned transaction
    if (transaction.length === 6) return tx;
    try {
        tx.v = (0, _bignumber.BigNumber).from(transaction[6]).toNumber();
    } catch (error) {
        // @TODO: What makes snese to do? The v is too big
        return tx;
    }
    tx.r = (0, _bytes.hexZeroPad)(transaction[7], 32);
    tx.s = (0, _bytes.hexZeroPad)(transaction[8], 32);
    if ((0, _bignumber.BigNumber).from(tx.r).isZero() && (0, _bignumber.BigNumber).from(tx.s).isZero()) {
        // EIP-155 unsigned transaction
        tx.chainId = tx.v;
        tx.v = 0;
    } else {
        // Signed Transaction
        tx.chainId = Math.floor((tx.v - 35) / 2);
        if (tx.chainId < 0) tx.chainId = 0;
        let recoveryParam = tx.v - 27;
        const raw = transaction.slice(0, 6);
        if (tx.chainId !== 0) {
            raw.push((0, _bytes.hexlify)(tx.chainId));
            raw.push("0x");
            raw.push("0x");
            recoveryParam -= tx.chainId * 2 + 8;
        }
        const digest = (0, _keccak256.keccak256)(_rlp.encode(raw));
        try {
            tx.from = recoverAddress(digest, {
                r: (0, _bytes.hexlify)(tx.r),
                s: (0, _bytes.hexlify)(tx.s),
                recoveryParam: recoveryParam
            });
        } catch (error) {}
        tx.hash = (0, _keccak256.keccak256)(rawTransaction);
    }
    tx.type = null;
    return tx;
}
function parse(rawTransaction) {
    const payload = (0, _bytes.arrayify)(rawTransaction);
    // Legacy and EIP-155 Transactions
    if (payload[0] > 0x7f) return _parse(payload);
    // Typed Transaction (EIP-2718)
    switch(payload[0]){
        case 1:
            return _parseEip2930(payload);
        case 2:
            return _parseEip1559(payload);
        default:
            break;
    }
    return logger.throwError(`unsupported transaction type: ${payload[0]}`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: payload[0]
    });
}

},{"@ethersproject/address":"9Jgcg","@ethersproject/bignumber":"gSTRF","@ethersproject/bytes":"5ReBN","@ethersproject/constants":"fVOEx","@ethersproject/keccak256":"8rdQU","@ethersproject/properties":"2X633","@ethersproject/rlp":"5F2ff","@ethersproject/signing-key":"8aLf8","@ethersproject/logger":"9rXfv","./_version":"JqtcH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8aLf8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SigningKey", ()=>SigningKey);
parcelHelpers.export(exports, "recoverPublicKey", ()=>recoverPublicKey);
parcelHelpers.export(exports, "computePublicKey", ()=>computePublicKey);
var _elliptic = require("./elliptic");
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
let _curve = null;
function getCurve() {
    if (!_curve) _curve = new (0, _elliptic.EC)("secp256k1");
    return _curve;
}
class SigningKey {
    constructor(privateKey){
        (0, _properties.defineReadOnly)(this, "curve", "secp256k1");
        (0, _properties.defineReadOnly)(this, "privateKey", (0, _bytes.hexlify)(privateKey));
        if ((0, _bytes.hexDataLength)(this.privateKey) !== 32) logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
        const keyPair = getCurve().keyFromPrivate((0, _bytes.arrayify)(this.privateKey));
        (0, _properties.defineReadOnly)(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
        (0, _properties.defineReadOnly)(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
        (0, _properties.defineReadOnly)(this, "_isSigningKey", true);
    }
    _addPoint(other) {
        const p0 = getCurve().keyFromPublic((0, _bytes.arrayify)(this.publicKey));
        const p1 = getCurve().keyFromPublic((0, _bytes.arrayify)(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
    }
    signDigest(digest) {
        const keyPair = getCurve().keyFromPrivate((0, _bytes.arrayify)(this.privateKey));
        const digestBytes = (0, _bytes.arrayify)(digest);
        if (digestBytes.length !== 32) logger.throwArgumentError("bad digest length", "digest", digest);
        const signature = keyPair.sign(digestBytes, {
            canonical: true
        });
        return (0, _bytes.splitSignature)({
            recoveryParam: signature.recoveryParam,
            r: (0, _bytes.hexZeroPad)("0x" + signature.r.toString(16), 32),
            s: (0, _bytes.hexZeroPad)("0x" + signature.s.toString(16), 32)
        });
    }
    computeSharedSecret(otherKey) {
        const keyPair = getCurve().keyFromPrivate((0, _bytes.arrayify)(this.privateKey));
        const otherKeyPair = getCurve().keyFromPublic((0, _bytes.arrayify)(computePublicKey(otherKey)));
        return (0, _bytes.hexZeroPad)("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
    }
    static isSigningKey(value) {
        return !!(value && value._isSigningKey);
    }
}
function recoverPublicKey(digest, signature) {
    const sig = (0, _bytes.splitSignature)(signature);
    const rs = {
        r: (0, _bytes.arrayify)(sig.r),
        s: (0, _bytes.arrayify)(sig.s)
    };
    return "0x" + getCurve().recoverPubKey((0, _bytes.arrayify)(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key, compressed) {
    const bytes = (0, _bytes.arrayify)(key);
    if (bytes.length === 32) {
        const signingKey = new SigningKey(bytes);
        if (compressed) return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
        return signingKey.publicKey;
    } else if (bytes.length === 33) {
        if (compressed) return (0, _bytes.hexlify)(bytes);
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
    } else if (bytes.length === 65) {
        if (!compressed) return (0, _bytes.hexlify)(bytes);
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
    }
    return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

},{"./elliptic":"cbbIv","@ethersproject/bytes":"5ReBN","@ethersproject/properties":"2X633","@ethersproject/logger":"9rXfv","./_version":"hncq9","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cbbIv":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EC", ()=>EC$1);
var _bnJs = require("bn.js");
var _bnJsDefault = parcelHelpers.interopDefault(_bnJs);
var _hashJs = require("hash.js");
var _hashJsDefault = parcelHelpers.interopDefault(_hashJs);
var global = arguments[3];
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
function createCommonjsModule(fn, basedir, module) {
    return module = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire(path, base === undefined || base === null ? module.path : base);
        }
    }, fn(module, module.exports), module.exports;
}
function getDefaultExportFromNamespaceIfPresent(n) {
    return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}
function getDefaultExportFromNamespaceIfNotNamed(n) {
    return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}
function getAugmentedNamespace(n) {
    if (n.__esModule) return n;
    var a = Object.defineProperty({}, '__esModule', {
        value: true
    });
    Object.keys(n).forEach(function(k) {
        var d = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(a, k, d.get ? d : {
            enumerable: true,
            get: function() {
                return n[k];
            }
        });
    });
    return a;
}
function commonjsRequire() {
    throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}
var minimalisticAssert = assert;
function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
}
assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};
var utils_1 = createCommonjsModule(function(module, exports) {
    'use strict';
    var utils = exports;
    function toArray(msg, enc) {
        if (Array.isArray(msg)) return msg.slice();
        if (!msg) return [];
        var res = [];
        if (typeof msg !== 'string') {
            for(var i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
            return res;
        }
        if (enc === 'hex') {
            msg = msg.replace(/[^a-z0-9]+/ig, '');
            if (msg.length % 2 !== 0) msg = '0' + msg;
            for(var i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
        } else for(var i = 0; i < msg.length; i++){
            var c = msg.charCodeAt(i);
            var hi = c >> 8;
            var lo = c & 0xff;
            if (hi) res.push(hi, lo);
            else res.push(lo);
        }
        return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
        if (word.length === 1) return '0' + word;
        else return word;
    }
    utils.zero2 = zero2;
    function toHex(msg) {
        var res = '';
        for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
        return res;
    }
    utils.toHex = toHex;
    utils.encode = function encode(arr, enc) {
        if (enc === 'hex') return toHex(arr);
        else return arr;
    };
});
var utils_1$1 = createCommonjsModule(function(module, exports) {
    'use strict';
    var utils = exports;
    utils.assert = minimalisticAssert;
    utils.toArray = utils_1.toArray;
    utils.zero2 = utils_1.zero2;
    utils.toHex = utils_1.toHex;
    utils.encode = utils_1.encode;
    // Represent num in a w-NAF form
    function getNAF(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        var i;
        for(i = 0; i < naf.length; i += 1)naf[i] = 0;
        var ws = 1 << w + 1;
        var k = num.clone();
        for(i = 0; i < naf.length; i++){
            var z;
            var mod = k.andln(ws - 1);
            if (k.isOdd()) {
                if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;
                else z = mod;
                k.isubn(z);
            } else z = 0;
            naf[i] = z;
            k.iushrn(1);
        }
        return naf;
    }
    utils.getNAF = getNAF;
    // Represent k1, k2 in a Joint Sparse Form
    function getJSF(k1, k2) {
        var jsf = [
            [],
            []
        ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while(k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0){
            // First phase
            var m14 = k1.andln(3) + d1 & 3;
            var m24 = k2.andln(3) + d2 & 3;
            if (m14 === 3) m14 = -1;
            if (m24 === 3) m24 = -1;
            var u1;
            if ((m14 & 1) === 0) u1 = 0;
            else {
                m8 = k1.andln(7) + d1 & 7;
                if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;
                else u1 = m14;
            }
            jsf[0].push(u1);
            var u2;
            if ((m24 & 1) === 0) u2 = 0;
            else {
                m8 = k2.andln(7) + d2 & 7;
                if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;
                else u2 = m24;
            }
            jsf[1].push(u2);
            // Second phase
            if (2 * d1 === u1 + 1) d1 = 1 - d1;
            if (2 * d2 === u2 + 1) d2 = 1 - d2;
            k1.iushrn(1);
            k2.iushrn(1);
        }
        return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
        var key = '_' + name;
        obj.prototype[name] = function cachedProperty() {
            return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
        };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
        return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') : bytes;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes) {
        return new (0, _bnJsDefault.default)(bytes, 'hex', 'le');
    }
    utils.intFromLE = intFromLE;
});
'use strict';
var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;
function BaseCurve(type, conf) {
    this.type = type;
    this.p = new (0, _bnJsDefault.default)(conf.p, 16);
    // Use Montgomery, when there is no fast reduction for the prime
    this.red = conf.prime ? (0, _bnJsDefault.default).red(conf.prime) : (0, _bnJsDefault.default).mont(this.p);
    // Useful for many curves
    this.zero = new (0, _bnJsDefault.default)(0).toRed(this.red);
    this.one = new (0, _bnJsDefault.default)(1).toRed(this.red);
    this.two = new (0, _bnJsDefault.default)(2).toRed(this.red);
    // Curve configuration, optional
    this.n = conf.n && new (0, _bnJsDefault.default)(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    // Temporary arrays
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    // Generalized Greg Maxwell's trick
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) this.redN = null;
    else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
    }
}
var base = BaseCurve;
BaseCurve.prototype.point = function point() {
    throw new Error('Not implemented');
};
BaseCurve.prototype.validate = function validate() {
    throw new Error('Not implemented');
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert$1(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    // Translate into more windowed form
    var repr = [];
    var j;
    var nafW;
    for(j = 0; j < naf.length; j += doubles.step){
        nafW = 0;
        for(var l = j + doubles.step - 1; l >= j; l--)nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for(var i = I; i > 0; i--){
        for(j = 0; j < repr.length; j++){
            nafW = repr[j];
            if (nafW === i) b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
    }
    return a.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    // Precompute window
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    // Get NAF form
    var naf = getNAF(k, w, this._bitLength);
    // Add `this`*(N+1) for every w-NAF index
    var acc = this.jpoint(null, null, null);
    for(var i = naf.length - 1; i >= 0; i--){
        // Count zeroes
        for(var l = 0; i >= 0 && naf[i] === 0; i--)l++;
        if (i >= 0) l++;
        acc = acc.dblp(l);
        if (i < 0) break;
        var z = naf[i];
        assert$1(z !== 0);
        if (p.type === 'affine') {
            // J +- P
            if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else // J +- J
        if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);
        else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
    return p.type === 'affine' ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    // Fill all arrays
    var max = 0;
    var i;
    var j;
    var p;
    for(i = 0; i < len; i++){
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
    }
    // Comb small window NAFs
    for(i = len - 1; i >= 1; i -= 2){
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max = Math.max(naf[a].length, max);
            max = Math.max(naf[b].length, max);
            continue;
        }
        var comb = [
            points[a],
            /* 1 */ null,
            /* 3 */ null,
            /* 5 */ points[b]
        ];
        // Try to avoid Projective points, if possible
        if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
        } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
            -3,
            /* -1 -1 */ -1,
            /* -1 0 */ -5,
            /* -1 1 */ -7,
            /* 0 -1 */ 0,
            /* 0 0 */ 7,
            /* 0 1 */ 5,
            /* 1 -1 */ 1,
            /* 1 0 */ 3
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for(j = 0; j < max; j++){
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
        }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for(i = max; i >= 0; i--){
        var k = 0;
        while(i >= 0){
            var zero = true;
            for(j = 0; j < len; j++){
                tmp[j] = naf[j][i] | 0;
                if (tmp[j] !== 0) zero = false;
            }
            if (!zero) break;
            k++;
            i--;
        }
        if (i >= 0) k++;
        acc = acc.dblp(k);
        if (i < 0) break;
        for(j = 0; j < len; j++){
            var z = tmp[j];
            p;
            if (z === 0) continue;
            else if (z > 0) p = wnd[j][z - 1 >> 1];
            else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === 'affine') acc = acc.mixedAdd(p);
            else acc = acc.add(p);
        }
    }
    // Zeroify references
    for(i = 0; i < len; i++)wnd[i] = null;
    if (jacobianResult) return acc;
    else return acc.toP();
};
function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq() {
    throw new Error('Not implemented');
};
BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils_1$1.toArray(bytes, enc);
    var len = this.p.byteLength();
    // uncompressed, hybrid-odd, hybrid-even
    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 0x06) assert$1(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 0x07) assert$1(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
        return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    throw new Error('Unknown point format');
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray('be', len);
    if (compact) return [
        this.getY().isEven() ? 0x02 : 0x03
    ].concat(x);
    return [
        0x04
    ].concat(x, this.getY().toArray('be', len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
    return utils_1$1.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed) return this;
    var precomputed = {
        doubles: null,
        naf: null,
        beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed) return false;
    var doubles = this.precomputed.doubles;
    if (!doubles) return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
    var doubles = [
        this
    ];
    var acc = this;
    for(var i = 0; i < power; i += step){
        for(var j = 0; j < step; j++)acc = acc.dbl();
        doubles.push(acc);
    }
    return {
        step: step,
        points: doubles
    };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
    var res = [
        this
    ];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for(var i = 1; i < max; i++)res[i] = res[i - 1].add(dbl);
    return {
        wnd: wnd,
        points: res
    };
};
BasePoint.prototype._getBeta = function _getBeta() {
    return null;
};
BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for(var i = 0; i < k; i++)r = r.dbl();
    return r;
};
var inherits_browser = createCommonjsModule(function(module) {
    if (typeof Object.create === 'function') // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        }
    };
    else // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        }
    };
});
'use strict';
var assert$2 = utils_1$1.assert;
function ShortCurve(conf) {
    base.call(this, 'short', conf);
    this.a = new (0, _bnJsDefault.default)(conf.a, 16).toRed(this.red);
    this.b = new (0, _bnJsDefault.default)(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    // If the curve is endomorphic, precalculate beta and lambda
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    // No efficient endomorphism
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;
    // Compute beta and lambda, that lambda * P = (beta * Px; Py)
    var beta;
    var lambda;
    if (conf.beta) beta = new (0, _bnJsDefault.default)(conf.beta, 16).toRed(this.red);
    else {
        var betas = this._getEndoRoots(this.p);
        // Choose the smallest beta
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
    }
    if (conf.lambda) lambda = new (0, _bnJsDefault.default)(conf.lambda, 16);
    else {
        // Choose the lambda that is matching selected beta
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) lambda = lambdas[0];
        else {
            lambda = lambdas[1];
            assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
    }
    // Get basis vectors, used for balanced length-two representation
    var basis;
    if (conf.basis) basis = conf.basis.map(function(vec) {
        return {
            a: new (0, _bnJsDefault.default)(vec.a, 16),
            b: new (0, _bnJsDefault.default)(vec.b, 16)
        };
    });
    else basis = this._getEndoBasis(lambda);
    return {
        beta: beta,
        lambda: lambda,
        basis: basis
    };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    // Find roots of for x^2 + x + 1 in F
    // Root = (-1 +- Sqrt(-3)) / 2
    //
    var red = num === this.p ? this.red : (0, _bnJsDefault.default).mont(num);
    var tinv = new (0, _bnJsDefault.default)(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new (0, _bnJsDefault.default)(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [
        l1,
        l2
    ];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    // aprxSqrt >= sqrt(this.n)
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    // 3.74
    // Run EGCD, until r(L + 1) < aprxSqrt
    var u = lambda;
    var v = this.n.clone();
    var x1 = new (0, _bnJsDefault.default)(1);
    var y1 = new (0, _bnJsDefault.default)(0);
    var x2 = new (0, _bnJsDefault.default)(0);
    var y2 = new (0, _bnJsDefault.default)(1);
    // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
    var a0;
    var b0;
    // First vector
    var a1;
    var b1;
    // Second vector
    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while(u.cmpn(0) !== 0){
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
        } else if (a1 && ++i === 2) break;
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
    }
    // Normalize signs
    if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
    }
    if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
    }
    return [
        {
            a: a1,
            b: b1
        },
        {
            a: a2,
            b: b2
        }
    ];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    // Calculate answer
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return {
        k1: k1,
        k2: k2
    };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new (0, _bnJsDefault.default)(x, 16);
    if (!x.red) x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point');
    // XXX Is there any way to tell if the number is odd without converting it
    // to non-red form?
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
    return this.point(x, y);
};
ShortCurve.prototype.validate = function validate(point) {
    if (point.inf) return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for(var i = 0; i < points.length; i++){
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
        }
        if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    // Clean-up references to points and coefficients
    for(var j = 0; j < i * 2; j++){
        npoints[j] = null;
        ncoeffs[j] = null;
    }
    return res;
};
function Point(curve, x, y, isRed) {
    base.BasePoint.call(this, curve, 'affine');
    if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
    } else {
        this.x = new (0, _bnJsDefault.default)(x, 16);
        this.y = new (0, _bnJsDefault.default)(y, 16);
        // Force redgomery representation when loading from JSON
        if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
        }
        if (!this.x.red) this.x = this.x.toRed(this.curve.red);
        if (!this.y.red) this.y = this.y.toRed(this.curve.red);
        this.inf = false;
    }
}
inherits_browser(Point, base.BasePoint);
ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo) return;
    var pre = this.precomputed;
    if (pre && pre.beta) return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
            beta: null,
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(endoMul)
            }
        };
    }
    return beta;
};
Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed) return [
        this.x,
        this.y
    ];
    return [
        this.x,
        this.y,
        this.precomputed && {
            doubles: this.precomputed.doubles && {
                step: this.precomputed.doubles.step,
                points: this.precomputed.doubles.points.slice(1)
            },
            naf: this.precomputed.naf && {
                wnd: this.precomputed.naf.wnd,
                points: this.precomputed.naf.points.slice(1)
            }
        }
    ];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === 'string') obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2]) return res;
    function obj2point(obj) {
        return curve.point(obj[0], obj[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [
                res
            ].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [
                res
            ].concat(pre.naf.points.map(obj2point))
        }
    };
    return res;
};
Point.prototype.inspect = function inspect() {
    if (this.isInfinity()) return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};
Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
};
Point.prototype.add = function add(p) {
    // O + P = P
    if (this.inf) return p;
    // P + O = P
    if (p.inf) return this;
    // P + P = 2P
    if (this.eq(p)) return this.dbl();
    // P + (-P) = O
    if (this.neg().eq(p)) return this.curve.point(null, null);
    // P + Q = O
    if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
    if (this.inf) return this;
    // 2P = O
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
    return this.x.fromRed();
};
Point.prototype.getY = function getY() {
    return this.y.fromRed();
};
Point.prototype.mul = function mul(k) {
    k = new (0, _bnJsDefault.default)(k, 16);
    if (this.isInfinity()) return this;
    else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo) return this.curve._endoWnafMulAdd([
        this
    ], [
        k
    ]);
    else return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [
        this,
        p2
    ];
    var coeffs = [
        k1,
        k2
    ];
    if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);
    else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
    if (this.inf) return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
            return p.neg();
        };
        res.precomputed = {
            naf: pre.naf && {
                wnd: pre.naf.wnd,
                points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
                step: pre.doubles.step,
                points: pre.doubles.points.map(negate)
            }
        };
    }
    return res;
};
Point.prototype.toJ = function toJ() {
    if (this.inf) return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
};
function JPoint(curve, x, y, z) {
    base.BasePoint.call(this, curve, 'jacobian');
    if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new (0, _bnJsDefault.default)(0);
    } else {
        this.x = new (0, _bnJsDefault.default)(x, 16);
        this.y = new (0, _bnJsDefault.default)(y, 16);
        this.z = new (0, _bnJsDefault.default)(z, 16);
    }
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
};
JPoint.prototype.toP = function toP() {
    if (this.isInfinity()) return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add(p) {
    // O + P = P
    if (this.isInfinity()) return p;
    // P + O = P
    if (p.isInfinity()) return this;
    // 12M + 4S + 7A
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p) {
    // O + P = P
    if (this.isInfinity()) return p.toJ();
    // P + O = P
    if (p.isInfinity()) return this;
    // 8M + 3S + 7A
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);
        else return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0) return this;
    if (this.isInfinity()) return this;
    if (!pow) return this.dbl();
    var i;
    if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for(i = 0; i < pow; i++)r = r.dbl();
        return r;
    }
    // 1M + 2S + 1A + N * (4S + 5M + 8A)
    // N = 1 => 6M + 6S + 9A
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    // Reuse results
    var jyd = jy.redAdd(jy);
    for(i = 0; i < pow; i++){
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity()) return this;
    if (this.curve.zeroA) return this._zeroDbl();
    else if (this.curve.threeA) return this._threeDbl();
    else return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 14A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a; a = 0
        var m = xx.redAdd(xx).redIAdd(xx);
        // T = M ^ 2 - 2*S
        var t = m.redSqr().redISub(s).redISub(s);
        // 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2*Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
        //     #doubling-dbl-2009-l
        // 2M + 5S + 13A
        // A = X1^2
        var a = this.x.redSqr();
        // B = Y1^2
        var b = this.y.redSqr();
        // C = B^2
        var c = b.redSqr();
        // D = 2 * ((X1 + B)^2 - A - C)
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        // E = 3 * A
        var e = a.redAdd(a).redIAdd(a);
        // F = E^2
        var f = e.redSqr();
        // 8 * C
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        // X3 = F - 2 * D
        nx = f.redISub(d).redISub(d);
        // Y3 = E * (D - X3) - 8 * C
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        // Z3 = 2 * Y1 * Z1
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    // Z = 1
    if (this.zOne) {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
        //     #doubling-mdbl-2007-bl
        // 1M + 5S + 15A
        // XX = X1^2
        var xx = this.x.redSqr();
        // YY = Y1^2
        var yy = this.y.redSqr();
        // YYYY = YY^2
        var yyyy = yy.redSqr();
        // S = 2 * ((X1 + YY)^2 - XX - YYYY)
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        // M = 3 * XX + a
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        // T = M^2 - 2 * S
        var t = m.redSqr().redISub(s).redISub(s);
        // X3 = T
        nx = t;
        // Y3 = M * (S - T) - 8 * YYYY
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        // Z3 = 2 * Y1
        nz = this.y.redAdd(this.y);
    } else {
        // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
        // 3M + 5S
        // delta = Z1^2
        var delta = this.z.redSqr();
        // gamma = Y1^2
        var gamma = this.y.redSqr();
        // beta = X1 * gamma
        var beta = this.x.redMul(gamma);
        // alpha = 3 * (X1 - delta) * (X1 + delta)
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        // X3 = alpha^2 - 8 * beta
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        // Z3 = (Y1 + Z1)^2 - gamma - delta
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    // 4M + 6S + 10A
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA) return this.dbl().add(this);
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
    // 5M + 10S + ...
    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // ZZ = Z1^2
    var zz = this.z.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // M = 3 * XX + a * ZZ2; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // MM = M^2
    var mm = m.redSqr();
    // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    // EE = E^2
    var ee = e.redSqr();
    // T = 16*YYYY
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    // U = (M + E)^2 - MM - EE - T
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    // X3 = 4 * (X1 * EE - 4 * YY * U)
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    // Z3 = (Z1 + E)^2 - ZZ - EE
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul(k, kbase) {
    k = new (0, _bnJsDefault.default)(k, kbase);
    return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq(p) {
    if (p.type === 'affine') return this.eq(p.toJ());
    if (this === p) return true;
    // x1 * z2^2 == x2 * z1^2
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;
    // y1 * z2^3 == y2 * z1^3
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0) return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for(;;){
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0) return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0) return true;
    }
};
JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity()) return '<EC JPoint Infinity>';
    return '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
};
JPoint.prototype.isInfinity = function isInfinity() {
    // XXX This code assumes that zero is always zero in red
    return this.z.cmpn(0) === 0;
};
var curve_1 = createCommonjsModule(function(module, exports) {
    'use strict';
    var curve = exports;
    curve.base = base;
    curve.short = short_1;
    curve.mont = /*RicMoo:ethers:require(./mont)*/ null;
    curve.edwards = /*RicMoo:ethers:require(./edwards)*/ null;
});
var curves_1 = createCommonjsModule(function(module, exports) {
    'use strict';
    var curves = exports;
    var assert = utils_1$1.assert;
    function PresetCurve(options) {
        if (options.type === 'short') this.curve = new curve_1.short(options);
        else if (options.type === 'edwards') this.curve = new curve_1.edwards(options);
        else this.curve = new curve_1.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert(this.g.validate(), 'Invalid curve');
        assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            get: function() {
                var curve = new PresetCurve(options);
                Object.defineProperty(curves, name, {
                    configurable: true,
                    enumerable: true,
                    value: curve
                });
                return curve;
            }
        });
    }
    defineCurve('p192', {
        type: 'short',
        prime: 'p192',
        p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
        a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
        b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
        n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
        hash: (0, _hashJsDefault.default).sha256,
        gRed: false,
        g: [
            '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
            '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
        ]
    });
    defineCurve('p224', {
        type: 'short',
        prime: 'p224',
        p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
        a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
        b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
        n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
        hash: (0, _hashJsDefault.default).sha256,
        gRed: false,
        g: [
            'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
            'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
        ]
    });
    defineCurve('p256', {
        type: 'short',
        prime: null,
        p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
        a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
        b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
        n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
        hash: (0, _hashJsDefault.default).sha256,
        gRed: false,
        g: [
            '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
            '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
        ]
    });
    defineCurve('p384', {
        type: 'short',
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: (0, _hashJsDefault.default).sha384,
        gRed: false,
        g: [
            "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
            "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
    });
    defineCurve('p521', {
        type: 'short',
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: (0, _hashJsDefault.default).sha512,
        gRed: false,
        g: [
            "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
            "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
    });
    defineCurve('curve25519', {
        type: 'mont',
        prime: 'p25519',
        p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
        a: '76d06',
        b: '1',
        n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
        hash: (0, _hashJsDefault.default).sha256,
        gRed: false,
        g: [
            '9'
        ]
    });
    defineCurve('ed25519', {
        type: 'edwards',
        prime: 'p25519',
        p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
        a: '-1',
        c: '1',
        // -121665 * (121666^(-1)) (mod P)
        d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
        n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
        hash: (0, _hashJsDefault.default).sha256,
        gRed: false,
        g: [
            '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
            // 4/5
            '6666666666666666666666666666666666666666666666666666666666666658'
        ]
    });
    var pre;
    try {
        pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/ null.crash();
    } catch (e) {
        pre = undefined;
    }
    defineCurve('secp256k1', {
        type: 'short',
        prime: 'k256',
        p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
        a: '0',
        b: '7',
        n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
        h: '1',
        hash: (0, _hashJsDefault.default).sha256,
        // Precomputed endomorphism
        beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
        lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
        basis: [
            {
                a: '3086d221a7d46bcde86c90e49284eb15',
                b: '-e4437ed6010e88286f547fa90abfe4c3'
            },
            {
                a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
                b: '3086d221a7d46bcde86c90e49284eb15'
            }
        ],
        gRed: false,
        g: [
            '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
            '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
            pre
        ]
    });
});
'use strict';
function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');
    var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');
    var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');
    minimalisticAssert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for(var i = 0; i < this.V.length; i++){
        this.K[i] = 0x00;
        this.V[i] = 0x01;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 0x1000000000000; // 2^48
};
HmacDRBG.prototype._hmac = function hmac() {
    return new (0, _hashJsDefault.default).hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([
        0x00
    ]);
    if (seed) kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed) return;
    this.K = this._hmac().update(this.V).update([
        0x01
    ]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    // Optional entropy enc
    if (typeof entropyEnc !== 'string') {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
    }
    entropy = utils_1.toArray(entropy, entropyEnc);
    add = utils_1.toArray(add, addEnc);
    minimalisticAssert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._update(entropy.concat(add || []));
    this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval) throw new Error('Reseed is required');
    // Optional encoding
    if (typeof enc !== 'string') {
        addEnc = add;
        add = enc;
        enc = null;
    }
    // Optional additional data
    if (add) {
        add = utils_1.toArray(add, addEnc || 'hex');
        this._update(add);
    }
    var temp = [];
    while(temp.length < len){
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this._reseed++;
    return utils_1.encode(res, enc);
};
'use strict';
var assert$3 = utils_1$1.assert;
function KeyPair(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    // KeyPair(ec, { priv: ..., pub: ... })
    if (options.priv) this._importPrivate(options.priv, options.privEnc);
    if (options.pub) this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;
KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair) return pub;
    return new KeyPair(ec, {
        pub: pub,
        pubEnc: enc
    });
};
KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair) return priv;
    return new KeyPair(ec, {
        priv: priv,
        privEnc: enc
    });
};
KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity()) return {
        result: false,
        reason: 'Invalid public key'
    };
    if (!pub.validate()) return {
        result: false,
        reason: 'Public key is not a point'
    };
    if (!pub.mul(this.ec.curve.n).isInfinity()) return {
        result: false,
        reason: 'Public key * N != O'
    };
    return {
        result: true,
        reason: null
    };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    // compact is optional argument
    if (typeof compact === 'string') {
        enc = compact;
        compact = null;
    }
    if (!this.pub) this.pub = this.ec.g.mul(this.priv);
    if (!enc) return this.pub;
    return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === 'hex') return this.priv.toString(16, 2);
    else return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new (0, _bnJsDefault.default)(key, enc || 16);
    // Ensure that the priv won't be bigger than n, otherwise we may fail
    // in fixed multiplication method
    this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
        // Montgomery points only have an `x` coordinate.
        // Weierstrass/Edwards points on the other hand have both `x` and
        // `y` coordinates.
        if (this.ec.curve.type === 'mont') assert$3(key.x, 'Need x coordinate');
        else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') assert$3(key.x && key.y, 'Need both x and y coordinate');
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
};
// ECDH
KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) assert$3(pub.validate(), 'public point not validated');
    return pub.mul(this.priv).getX();
};
// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature, options) {
    return this.ec.verify(msg, signature, this, undefined, options);
};
KeyPair.prototype.inspect = function inspect() {
    return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};
'use strict';
var assert$4 = utils_1$1.assert;
function Signature(options, enc) {
    if (options instanceof Signature) return options;
    if (this._importDER(options, enc)) return;
    assert$4(options.r && options.s, 'Signature without r or s');
    this.r = new (0, _bnJsDefault.default)(options.r, 16);
    this.s = new (0, _bnJsDefault.default)(options.s, 16);
    if (options.recoveryParam === undefined) this.recoveryParam = null;
    else this.recoveryParam = options.recoveryParam;
}
var signature = Signature;
function Position() {
    this.place = 0;
}
function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 0x80)) return initial;
    var octetLen = initial & 0xf;
    // Indefinite length or overflow
    if (octetLen === 0 || octetLen > 4) return false;
    if (buf[p.place] === 0x00) return false;
    var val = 0;
    for(var i = 0, off = p.place; i < octetLen; i++, off++){
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
    }
    // Leading zeroes
    if (val <= 0x7f) return false;
    p.place = off;
    return val;
}
function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while(!buf[i] && !(buf[i + 1] & 0x80) && i < len)i++;
    if (i === 0) return buf;
    return buf.slice(i);
}
Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils_1$1.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 0x30) return false;
    var len = getLength(data, p);
    if (len === false) return false;
    if (len + p.place !== data.length) return false;
    if (data[p.place++] !== 0x02) return false;
    var rlen = getLength(data, p);
    if (rlen === false) return false;
    if ((data[p.place] & 128) !== 0) return false;
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 0x02) return false;
    var slen = getLength(data, p);
    if (slen === false) return false;
    if (data.length !== slen + p.place) return false;
    if ((data[p.place] & 128) !== 0) return false;
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0) {
        if (r[1] & 0x80) r = r.slice(1);
        else // Leading zeroes
        return false;
    }
    if (s[0] === 0) {
        if (s[1] & 0x80) s = s.slice(1);
        else // Leading zeroes
        return false;
    }
    this.r = new (0, _bnJsDefault.default)(r);
    this.s = new (0, _bnJsDefault.default)(s);
    this.recoveryParam = null;
    return true;
};
function constructLength(arr, len) {
    if (len < 0x80) {
        arr.push(len);
        return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);
    while(--octets)arr.push(len >>> (octets << 3) & 0xff);
    arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    // Pad values
    if (r[0] & 0x80) r = [
        0
    ].concat(r);
    // Pad values
    if (s[0] & 0x80) s = [
        0
    ].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while(!s[0] && !(s[1] & 0x80))s = s.slice(1);
    var arr = [
        0x02
    ];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [
        0x30
    ];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils_1$1.encode(res, enc);
};
'use strict';
var rand = /*RicMoo:ethers:require(brorand)*/ function() {
    throw new Error('unsupported');
};
var assert$5 = utils_1$1.assert;
function EC(options) {
    if (!(this instanceof EC)) return new EC(options);
    // Shortcut `elliptic.ec(curve-name)`
    if (typeof options === 'string') {
        assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), 'Unknown curve ' + options);
        options = curves_1[options];
    }
    // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
    if (options instanceof curves_1.PresetCurve) options = {
        curve: options
    };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    // Point on curve
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    // Hash for function for DRBG
    this.hash = options.hash || options.curve.hash;
}
var ec = EC;
EC.prototype.keyPair = function keyPair(options) {
    return new key(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return key.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return key.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options) options = {};
    // Instantiate Hmac_DRBG
    var drbg = new hmacDrbg({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || 'utf8',
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || 'utf8',
        nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new (0, _bnJsDefault.default)(2));
    for(;;){
        var priv = new (0, _bnJsDefault.default)(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0) continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
    }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly, bitLength) {
    var byteLength;
    if ((0, _bnJsDefault.default).isBN(msg) || typeof msg === 'number') {
        msg = new (0, _bnJsDefault.default)(msg, 16);
        byteLength = msg.byteLength();
    } else if (typeof msg === 'object') {
        // BN assumes an array-like input and asserts length
        byteLength = msg.length;
        msg = new (0, _bnJsDefault.default)(msg, 16);
    } else {
        // BN converts the value to string
        var str = msg.toString();
        // HEX encoding
        byteLength = str.length + 1 >>> 1;
        msg = new (0, _bnJsDefault.default)(str, 16);
    }
    // Allow overriding
    if (typeof bitLength !== 'number') bitLength = byteLength * 8;
    var delta = bitLength - this.n.bitLength();
    if (delta > 0) msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);
    else return msg;
};
EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === 'object') {
        options = enc;
        enc = null;
    }
    if (!options) options = {};
    if (typeof msg !== 'string' && typeof msg !== 'number' && !(0, _bnJsDefault.default).isBN(msg)) {
        assert$5(typeof msg === 'object' && msg && typeof msg.length === 'number', 'Expected message to be an array-like, a hex string, or a BN instance');
        assert$5(msg.length >>> 0 === msg.length); // non-negative 32-bit integer
        for(var i = 0; i < msg.length; i++)assert$5((msg[i] & 255) === msg[i]);
    }
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(msg, false, options.msgBitLength);
    // Would fail further checks, but let's make the error message clear
    assert$5(!msg.isNeg(), 'Can not sign a negative message');
    // Zero-extend key to provide enough entropy
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray('be', bytes);
    // Zero-extend nonce to have the same byte size as N
    var nonce = msg.toArray('be', bytes);
    // Recheck nonce to be bijective to msg
    assert$5(new (0, _bnJsDefault.default)(nonce).eq(msg), 'Can not sign message');
    // Instantiate Hmac_DRBG
    var drbg = new hmacDrbg({
        hash: this.hash,
        entropy: bkey,
        nonce: nonce,
        pers: options.pers,
        persEnc: options.persEnc || 'utf8'
    });
    // Number of bytes to generate
    var ns1 = this.n.sub(new (0, _bnJsDefault.default)(1));
    for(var iter = 0;; iter++){
        var k = options.k ? options.k(iter) : new (0, _bnJsDefault.default)(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity()) continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0) continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0) continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        // Use complement of `s`, if it is > `n / 2`
        if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
        }
        return new signature({
            r: r,
            s: s,
            recoveryParam: recoveryParam
        });
    }
};
EC.prototype.verify = function verify(msg, signature$1, key, enc, options) {
    if (!options) options = {};
    msg = this._truncateToN(msg, false, options.msgBitLength);
    key = this.keyFromPublic(key, enc);
    signature$1 = new signature(signature$1, 'hex');
    // Perform primitive values validation
    var r = signature$1.r;
    var s = signature$1.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;
    // Validate signature
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;
    if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity()) return false;
        return p.getX().umod(this.n).cmp(r) === 0;
    }
    // NOTE: Greg Maxwell's trick, inspired by:
    // https://git.io/vad3K
    p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    // Compare `p.x` of Jacobian point with `r`,
    // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
    // inverse of `p.z^2`
    return p.eqXToP(r);
};
EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
    assert$5((3 & j) === j, 'The recovery param is more than two bits');
    signature$1 = new signature(signature$1, enc);
    var n = this.n;
    var e = new (0, _bnJsDefault.default)(msg);
    var r = signature$1.r;
    var s = signature$1.s;
    // A set LSB signifies that the y-coordinate is odd
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error('Unable to find sencond key candinate');
    // 1.1. Let x = r + jn.
    if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature$1.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
    // 1.6.1 Compute Q = r^-1 (sR -  eG)
    //               Q = r^-1 (sR + -eG)
    return this.g.mulAdd(s1, r, s2);
};
EC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
    signature$1 = new signature(signature$1, enc);
    if (signature$1.recoveryParam !== null) return signature$1.recoveryParam;
    for(var i = 0; i < 4; i++){
        var Qprime;
        try {
            Qprime = this.recoverPubKey(e, signature$1, i);
        } catch (e) {
            continue;
        }
        if (Qprime.eq(Q)) return i;
    }
    throw new Error('Unable to find valid recovery factor');
};
var elliptic_1 = createCommonjsModule(function(module, exports) {
    'use strict';
    var elliptic = exports;
    elliptic.version = "6.6.1";
    elliptic.utils = utils_1$1;
    elliptic.rand = /*RicMoo:ethers:require(brorand)*/ function() {
        throw new Error('unsupported');
    };
    elliptic.curve = curve_1;
    elliptic.curves = curves_1;
    // Protocols
    elliptic.ec = ec;
    elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/ null;
});
var EC$1 = elliptic_1.ec;

},{"bn.js":"2x6os","hash.js":"jo8Bq","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hncq9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "signing-key/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"JqtcH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "transactions/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"anaZ0":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AlchemyWebSocketProvider", ()=>AlchemyWebSocketProvider);
parcelHelpers.export(exports, "AlchemyProvider", ()=>AlchemyProvider);
var _properties = require("@ethersproject/properties");
var _formatter = require("./formatter");
var _websocketProvider = require("./websocket-provider");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
// This key was provided to ethers.js by Alchemy to be used by the
// default provider, but it is recommended that for your own
// production environments, that you acquire your own API key at:
//   https://dashboard.alchemyapi.io
const defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class AlchemyWebSocketProvider extends (0, _websocketProvider.WebSocketProvider) {
    constructor(network, apiKey){
        const provider = new AlchemyProvider(network, apiKey);
        const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
        super(url, provider.network);
        (0, _properties.defineReadOnly)(this, "apiKey", provider.apiKey);
    }
    isCommunityResource() {
        return this.apiKey === defaultApiKey;
    }
}
class AlchemyProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    static getWebSocketProvider(network, apiKey) {
        return new AlchemyWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
        if (apiKey == null) return defaultApiKey;
        if (apiKey && typeof apiKey !== "string") logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        return apiKey;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch(network.name){
            case "homestead":
                host = "eth-mainnet.alchemyapi.io/v2/";
                break;
            case "goerli":
                host = "eth-goerli.g.alchemy.com/v2/";
                break;
            case "sepolia":
                host = "eth-sepolia.g.alchemy.com/v2/";
                break;
            case "matic":
                host = "polygon-mainnet.g.alchemy.com/v2/";
                break;
            case "maticmum":
                host = "polygon-mumbai.g.alchemy.com/v2/";
                break;
            case "arbitrum":
                host = "arb-mainnet.g.alchemy.com/v2/";
                break;
            case "arbitrum-goerli":
                host = "arb-goerli.g.alchemy.com/v2/";
                break;
            case "arbitrum-sepolia":
                host = "arb-sepolia.g.alchemy.com/v2/";
                break;
            case "optimism":
                host = "opt-mainnet.g.alchemy.com/v2/";
                break;
            case "optimism-goerli":
                host = "opt-goerli.g.alchemy.com/v2/";
                break;
            case "optimism-sepolia":
                host = "opt-sepolia.g.alchemy.com/v2/";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return {
            allowGzip: true,
            url: "https://" + host + apiKey,
            throttleCallback: (attempt, url)=>{
                if (apiKey === defaultApiKey) (0, _formatter.showThrottleMessage)();
                return Promise.resolve(true);
            }
        };
    }
    isCommunityResource() {
        return this.apiKey === defaultApiKey;
    }
}

},{"@ethersproject/properties":"2X633","./formatter":"eHThO","./websocket-provider":"82IGf","@ethersproject/logger":"9rXfv","./_version":"bmrdP","./url-json-rpc-provider":"ecfF1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"82IGf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// For more info about the Real-time Event API see:
//   https://geth.ethereum.org/docs/rpc/pubsub
parcelHelpers.export(exports, "WebSocketProvider", ()=>WebSocketProvider);
var _bignumber = require("@ethersproject/bignumber");
var _properties = require("@ethersproject/properties");
var _jsonRpcProvider = require("./json-rpc-provider");
var _ws = require("./ws");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
/**
 *  Notes:
 *
 *  This provider differs a bit from the polling providers. One main
 *  difference is how it handles consistency. The polling providers
 *  will stall responses to ensure a consistent state, while this
 *  WebSocket provider assumes the connected backend will manage this.
 *
 *  For example, if a polling provider emits an event which indicates
 *  the event occurred in blockhash XXX, a call to fetch that block by
 *  its hash XXX, if not present will retry until it is present. This
 *  can occur when querying a pool of nodes that are mildly out of sync
 *  with each other.
 */ let NextId = 1;
class WebSocketProvider extends (0, _jsonRpcProvider.JsonRpcProvider) {
    constructor(url, network){
        // This will be added in the future; please open an issue to expedite
        if (network === "any") logger.throwError("WebSocketProvider does not support 'any' network yet", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "network:any"
        });
        if (typeof url === "string") super(url, network);
        else super("_websocket", network);
        this._pollingInterval = -1;
        this._wsReady = false;
        if (typeof url === "string") (0, _properties.defineReadOnly)(this, "_websocket", new (0, _ws.WebSocket)(this.connection.url));
        else (0, _properties.defineReadOnly)(this, "_websocket", url);
        (0, _properties.defineReadOnly)(this, "_requests", {});
        (0, _properties.defineReadOnly)(this, "_subs", {});
        (0, _properties.defineReadOnly)(this, "_subIds", {});
        (0, _properties.defineReadOnly)(this, "_detectNetwork", super.detectNetwork());
        // Stall sending requests until the socket is open...
        this.websocket.onopen = ()=>{
            this._wsReady = true;
            Object.keys(this._requests).forEach((id)=>{
                this.websocket.send(this._requests[id].payload);
            });
        };
        this.websocket.onmessage = (messageEvent)=>{
            const data = messageEvent.data;
            const result = JSON.parse(data);
            if (result.id != null) {
                const id = String(result.id);
                const request = this._requests[id];
                delete this._requests[id];
                if (result.result !== undefined) {
                    request.callback(null, result.result);
                    this.emit("debug", {
                        action: "response",
                        request: JSON.parse(request.payload),
                        response: result.result,
                        provider: this
                    });
                } else {
                    let error = null;
                    if (result.error) {
                        error = new Error(result.error.message || "unknown error");
                        (0, _properties.defineReadOnly)(error, "code", result.error.code || null);
                        (0, _properties.defineReadOnly)(error, "response", data);
                    } else error = new Error("unknown error");
                    request.callback(error, undefined);
                    this.emit("debug", {
                        action: "response",
                        error: error,
                        request: JSON.parse(request.payload),
                        provider: this
                    });
                }
            } else if (result.method === "eth_subscription") {
                // Subscription...
                const sub = this._subs[result.params.subscription];
                if (sub) //this.emit.apply(this,                  );
                sub.processFunc(result.params.result);
            } else console.warn("this should not happen");
        };
        // This Provider does not actually poll, but we want to trigger
        // poll events for things that depend on them (like stalling for
        // block and transaction lookups)
        const fauxPoll = setInterval(()=>{
            this.emit("poll");
        }, 1000);
        if (fauxPoll.unref) fauxPoll.unref();
    }
    // Cannot narrow the type of _websocket, as that is not backwards compatible
    // so we add a getter and let the WebSocket be a public API.
    get websocket() {
        return this._websocket;
    }
    detectNetwork() {
        return this._detectNetwork;
    }
    get pollingInterval() {
        return 0;
    }
    resetEventsBlock(blockNumber) {
        logger.throwError("cannot reset events block on WebSocketProvider", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "resetEventBlock"
        });
    }
    set pollingInterval(value) {
        logger.throwError("cannot set polling interval on WebSocketProvider", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "setPollingInterval"
        });
    }
    poll() {
        return __awaiter(this, void 0, void 0, function*() {
            return null;
        });
    }
    set polling(value) {
        if (!value) return;
        logger.throwError("cannot set polling on WebSocketProvider", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "setPolling"
        });
    }
    send(method, params) {
        const rid = NextId++;
        return new Promise((resolve, reject)=>{
            function callback(error, result) {
                if (error) return reject(error);
                return resolve(result);
            }
            const payload = JSON.stringify({
                method: method,
                params: params,
                id: rid,
                jsonrpc: "2.0"
            });
            this.emit("debug", {
                action: "request",
                request: JSON.parse(payload),
                provider: this
            });
            this._requests[String(rid)] = {
                callback,
                payload
            };
            if (this._wsReady) this.websocket.send(payload);
        });
    }
    static defaultUrl() {
        return "ws:/\/localhost:8546";
    }
    _subscribe(tag, param, processFunc) {
        return __awaiter(this, void 0, void 0, function*() {
            let subIdPromise = this._subIds[tag];
            if (subIdPromise == null) {
                subIdPromise = Promise.all(param).then((param)=>{
                    return this.send("eth_subscribe", param);
                });
                this._subIds[tag] = subIdPromise;
            }
            const subId = yield subIdPromise;
            this._subs[subId] = {
                tag,
                processFunc
            };
        });
    }
    _startEvent(event) {
        switch(event.type){
            case "block":
                this._subscribe("block", [
                    "newHeads"
                ], (result)=>{
                    const blockNumber = (0, _bignumber.BigNumber).from(result.number).toNumber();
                    this._emitted.block = blockNumber;
                    this.emit("block", blockNumber);
                });
                break;
            case "pending":
                this._subscribe("pending", [
                    "newPendingTransactions"
                ], (result)=>{
                    this.emit("pending", result);
                });
                break;
            case "filter":
                this._subscribe(event.tag, [
                    "logs",
                    this._getFilter(event.filter)
                ], (result)=>{
                    if (result.removed == null) result.removed = false;
                    this.emit(event.filter, this.formatter.filterLog(result));
                });
                break;
            case "tx":
                {
                    const emitReceipt = (event)=>{
                        const hash = event.hash;
                        this.getTransactionReceipt(hash).then((receipt)=>{
                            if (!receipt) return;
                            this.emit(hash, receipt);
                        });
                    };
                    // In case it is already mined
                    emitReceipt(event);
                    // To keep things simple, we start up a single newHeads subscription
                    // to keep an eye out for transactions we are watching for.
                    // Starting a subscription for an event (i.e. "tx") that is already
                    // running is (basically) a nop.
                    this._subscribe("tx", [
                        "newHeads"
                    ], (result)=>{
                        this._events.filter((e)=>e.type === "tx").forEach(emitReceipt);
                    });
                    break;
                }
            // Nothing is needed
            case "debug":
            case "poll":
            case "willPoll":
            case "didPoll":
            case "error":
                break;
            default:
                console.log("unhandled:", event);
                break;
        }
    }
    _stopEvent(event) {
        let tag = event.tag;
        if (event.type === "tx") {
            // There are remaining transaction event listeners
            if (this._events.filter((e)=>e.type === "tx").length) return;
            tag = "tx";
        } else if (this.listenerCount(event.event)) // There are remaining event listeners
        return;
        const subId = this._subIds[tag];
        if (!subId) return;
        delete this._subIds[tag];
        subId.then((subId)=>{
            if (!this._subs[subId]) return;
            delete this._subs[subId];
            this.send("eth_unsubscribe", [
                subId
            ]);
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function*() {
            // Wait until we have connected before trying to disconnect
            if (this.websocket.readyState === (0, _ws.WebSocket).CONNECTING) yield new Promise((resolve)=>{
                this.websocket.onopen = function() {
                    resolve(true);
                };
                this.websocket.onerror = function() {
                    resolve(false);
                };
            });
            // Hangup
            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
            this.websocket.close(1000);
        });
    }
}

},{"@ethersproject/bignumber":"gSTRF","@ethersproject/properties":"2X633","./json-rpc-provider":"9mdlH","./ws":"bNEJl","@ethersproject/logger":"9rXfv","./_version":"bmrdP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9mdlH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "JsonRpcSigner", ()=>JsonRpcSigner);
parcelHelpers.export(exports, "JsonRpcProvider", ()=>JsonRpcProvider);
var _abstractSigner = require("@ethersproject/abstract-signer");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _hash = require("@ethersproject/hash");
var _properties = require("@ethersproject/properties");
var _strings = require("@ethersproject/strings");
var _transactions = require("@ethersproject/transactions");
var _web = require("@ethersproject/web");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _baseProvider = require("./base-provider");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
const errorGas = [
    "call",
    "estimateGas"
];
function spelunk(value, requireData) {
    if (value == null) return null;
    // These *are* the droids we're looking for.
    if (typeof value.message === "string" && value.message.match("reverted")) {
        const data = (0, _bytes.isHexString)(value.data) ? value.data : null;
        if (!requireData || data) return {
            message: value.message,
            data
        };
    }
    // Spelunk further...
    if (typeof value === "object") {
        for(const key in value){
            const result = spelunk(value[key], requireData);
            if (result) return result;
        }
        return null;
    }
    // Might be a JSON string we can further descend...
    if (typeof value === "string") try {
        return spelunk(JSON.parse(value), requireData);
    } catch (error) {}
    return null;
}
function checkError(method, error, params) {
    const transaction = params.transaction || params.signedTransaction;
    // Undo the "convenience" some nodes are attempting to prevent backwards
    // incompatibility; maybe for v6 consider forwarding reverts as errors
    if (method === "call") {
        const result = spelunk(error, true);
        if (result) return result.data;
        // Nothing descriptive..
        logger.throwError("missing revert data in call exception; Transaction reverted without a reason string", (0, _logger.Logger).errors.CALL_EXCEPTION, {
            data: "0x",
            transaction,
            error
        });
    }
    if (method === "estimateGas") {
        // Try to find something, with a preference on SERVER_ERROR body
        let result = spelunk(error.body, false);
        if (result == null) result = spelunk(error, false);
        // Found "reverted", this is a CALL_EXCEPTION
        if (result) logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", (0, _logger.Logger).errors.UNPREDICTABLE_GAS_LIMIT, {
            reason: result.message,
            method,
            transaction,
            error
        });
    }
    // @TODO: Should we spelunk for message too?
    let message = error.message;
    if (error.code === (0, _logger.Logger).errors.SERVER_ERROR && error.error && typeof error.error.message === "string") message = error.error.message;
    else if (typeof error.body === "string") message = error.body;
    else if (typeof error.responseText === "string") message = error.responseText;
    message = (message || "").toLowerCase();
    // "insufficient funds for gas * price + value + cost(data)"
    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) logger.throwError("insufficient funds for intrinsic transaction cost", (0, _logger.Logger).errors.INSUFFICIENT_FUNDS, {
        error,
        method,
        transaction
    });
    // "nonce too low"
    if (message.match(/nonce (is )?too low/i)) logger.throwError("nonce has already been used", (0, _logger.Logger).errors.NONCE_EXPIRED, {
        error,
        method,
        transaction
    });
    // "replacement transaction underpriced"
    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) logger.throwError("replacement fee too low", (0, _logger.Logger).errors.REPLACEMENT_UNDERPRICED, {
        error,
        method,
        transaction
    });
    // "replacement transaction underpriced"
    if (message.match(/only replay-protected/i)) logger.throwError("legacy pre-eip-155 transactions not supported", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
        error,
        method,
        transaction
    });
    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", (0, _logger.Logger).errors.UNPREDICTABLE_GAS_LIMIT, {
        error,
        method,
        transaction
    });
    throw error;
}
function timer(timeout) {
    return new Promise(function(resolve) {
        setTimeout(resolve, timeout);
    });
}
function getResult(payload) {
    if (payload.error) {
        // @TODO: not any
        const error = new Error(payload.error.message);
        error.code = payload.error.code;
        error.data = payload.error.data;
        throw error;
    }
    return payload.result;
}
function getLowerCase(value) {
    if (value) return value.toLowerCase();
    return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends (0, _abstractSigner.Signer) {
    constructor(constructorGuard, provider, addressOrIndex){
        super();
        if (constructorGuard !== _constructorGuard) throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        (0, _properties.defineReadOnly)(this, "provider", provider);
        if (addressOrIndex == null) addressOrIndex = 0;
        if (typeof addressOrIndex === "string") {
            (0, _properties.defineReadOnly)(this, "_address", this.provider.formatter.address(addressOrIndex));
            (0, _properties.defineReadOnly)(this, "_index", null);
        } else if (typeof addressOrIndex === "number") {
            (0, _properties.defineReadOnly)(this, "_index", addressOrIndex);
            (0, _properties.defineReadOnly)(this, "_address", null);
        } else logger.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
    connect(provider) {
        return logger.throwError("cannot alter JSON-RPC Signer connection", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "connect"
        });
    }
    connectUnchecked() {
        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
    }
    getAddress() {
        if (this._address) return Promise.resolve(this._address);
        return this.provider.send("eth_accounts", []).then((accounts)=>{
            if (accounts.length <= this._index) logger.throwError("unknown account #" + this._index, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "getAddress"
            });
            return this.provider.formatter.address(accounts[this._index]);
        });
    }
    sendUncheckedTransaction(transaction) {
        transaction = (0, _properties.shallowCopy)(transaction);
        const fromAddress = this.getAddress().then((address)=>{
            if (address) address = address.toLowerCase();
            return address;
        });
        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
        // wishes to use this, it is easy to specify explicitly, otherwise
        // we look it up for them.
        if (transaction.gasLimit == null) {
            const estimate = (0, _properties.shallowCopy)(transaction);
            estimate.from = fromAddress;
            transaction.gasLimit = this.provider.estimateGas(estimate);
        }
        if (transaction.to != null) transaction.to = Promise.resolve(transaction.to).then((to)=>__awaiter(this, void 0, void 0, function*() {
                if (to == null) return null;
                const address = yield this.provider.resolveName(to);
                if (address == null) logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                return address;
            }));
        return (0, _properties.resolveProperties)({
            tx: (0, _properties.resolveProperties)(transaction),
            sender: fromAddress
        }).then(({ tx, sender })=>{
            if (tx.from != null) {
                if (tx.from.toLowerCase() !== sender) logger.throwArgumentError("from address mismatch", "transaction", transaction);
            } else tx.from = sender;
            const hexTx = this.provider.constructor.hexlifyTransaction(tx, {
                from: true
            });
            return this.provider.send("eth_sendTransaction", [
                hexTx
            ]).then((hash)=>{
                return hash;
            }, (error)=>{
                if (typeof error.message === "string" && error.message.match(/user denied/i)) logger.throwError("user rejected transaction", (0, _logger.Logger).errors.ACTION_REJECTED, {
                    action: "sendTransaction",
                    transaction: tx
                });
                return checkError("sendTransaction", error, hexTx);
            });
        });
    }
    signTransaction(transaction) {
        return logger.throwError("signing transactions is unsupported", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "signTransaction"
        });
    }
    sendTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function*() {
            // This cannot be mined any earlier than any recent block
            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
            // Send the transaction
            const hash = yield this.sendUncheckedTransaction(transaction);
            try {
                // Unfortunately, JSON-RPC only provides and opaque transaction hash
                // for a response, and we need the actual transaction, so we poll
                // for it; it should show up very quickly
                return yield (0, _web.poll)(()=>__awaiter(this, void 0, void 0, function*() {
                        const tx = yield this.provider.getTransaction(hash);
                        if (tx === null) return undefined;
                        return this.provider._wrapTransaction(tx, hash, blockNumber);
                    }), {
                    oncePoll: this.provider
                });
            } catch (error) {
                error.transactionHash = hash;
                throw error;
            }
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function*() {
            const data = typeof message === "string" ? (0, _strings.toUtf8Bytes)(message) : message;
            const address = yield this.getAddress();
            try {
                return yield this.provider.send("personal_sign", [
                    (0, _bytes.hexlify)(data),
                    address.toLowerCase()
                ]);
            } catch (error) {
                if (typeof error.message === "string" && error.message.match(/user denied/i)) logger.throwError("user rejected signing", (0, _logger.Logger).errors.ACTION_REJECTED, {
                    action: "signMessage",
                    from: address,
                    messageData: message
                });
                throw error;
            }
        });
    }
    _legacySignMessage(message) {
        return __awaiter(this, void 0, void 0, function*() {
            const data = typeof message === "string" ? (0, _strings.toUtf8Bytes)(message) : message;
            const address = yield this.getAddress();
            try {
                // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
                return yield this.provider.send("eth_sign", [
                    address.toLowerCase(),
                    (0, _bytes.hexlify)(data)
                ]);
            } catch (error) {
                if (typeof error.message === "string" && error.message.match(/user denied/i)) logger.throwError("user rejected signing", (0, _logger.Logger).errors.ACTION_REJECTED, {
                    action: "_legacySignMessage",
                    from: address,
                    messageData: message
                });
                throw error;
            }
        });
    }
    _signTypedData(domain, types, value) {
        return __awaiter(this, void 0, void 0, function*() {
            // Populate any ENS names (in-place)
            const populated = yield (0, _hash._TypedDataEncoder).resolveNames(domain, types, value, (name)=>{
                return this.provider.resolveName(name);
            });
            const address = yield this.getAddress();
            try {
                return yield this.provider.send("eth_signTypedData_v4", [
                    address.toLowerCase(),
                    JSON.stringify((0, _hash._TypedDataEncoder).getPayload(populated.domain, types, populated.value))
                ]);
            } catch (error) {
                if (typeof error.message === "string" && error.message.match(/user denied/i)) logger.throwError("user rejected signing", (0, _logger.Logger).errors.ACTION_REJECTED, {
                    action: "_signTypedData",
                    from: address,
                    messageData: {
                        domain: populated.domain,
                        types,
                        value: populated.value
                    }
                });
                throw error;
            }
        });
    }
    unlock(password) {
        return __awaiter(this, void 0, void 0, function*() {
            const provider = this.provider;
            const address = yield this.getAddress();
            return provider.send("personal_unlockAccount", [
                address.toLowerCase(),
                password,
                null
            ]);
        });
    }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
    sendTransaction(transaction) {
        return this.sendUncheckedTransaction(transaction).then((hash)=>{
            return {
                hash: hash,
                nonce: null,
                gasLimit: null,
                gasPrice: null,
                data: null,
                value: null,
                chainId: null,
                confirmations: 0,
                from: null,
                wait: (confirmations)=>{
                    return this.provider.waitForTransaction(hash, confirmations);
                }
            };
        });
    }
}
const allowedTransactionKeys = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    value: true,
    type: true,
    accessList: true,
    maxFeePerGas: true,
    maxPriorityFeePerGas: true
};
class JsonRpcProvider extends (0, _baseProvider.BaseProvider) {
    constructor(url, network){
        let networkOrReady = network;
        // The network is unknown, query the JSON-RPC for it
        if (networkOrReady == null) networkOrReady = new Promise((resolve, reject)=>{
            setTimeout(()=>{
                this.detectNetwork().then((network)=>{
                    resolve(network);
                }, (error)=>{
                    reject(error);
                });
            }, 0);
        });
        super(networkOrReady);
        // Default URL
        if (!url) url = (0, _properties.getStatic)(this.constructor, "defaultUrl")();
        if (typeof url === "string") (0, _properties.defineReadOnly)(this, "connection", Object.freeze({
            url: url
        }));
        else (0, _properties.defineReadOnly)(this, "connection", Object.freeze((0, _properties.shallowCopy)(url)));
        this._nextId = 42;
    }
    get _cache() {
        if (this._eventLoopCache == null) this._eventLoopCache = {};
        return this._eventLoopCache;
    }
    static defaultUrl() {
        return "http:/\/localhost:8545";
    }
    detectNetwork() {
        if (!this._cache["detectNetwork"]) {
            this._cache["detectNetwork"] = this._uncachedDetectNetwork();
            // Clear this cache at the beginning of the next event loop
            setTimeout(()=>{
                this._cache["detectNetwork"] = null;
            }, 0);
        }
        return this._cache["detectNetwork"];
    }
    _uncachedDetectNetwork() {
        return __awaiter(this, void 0, void 0, function*() {
            yield timer(0);
            let chainId = null;
            try {
                chainId = yield this.send("eth_chainId", []);
            } catch (error) {
                try {
                    chainId = yield this.send("net_version", []);
                } catch (error) {}
            }
            if (chainId != null) {
                const getNetwork = (0, _properties.getStatic)(this.constructor, "getNetwork");
                try {
                    return getNetwork((0, _bignumber.BigNumber).from(chainId).toNumber());
                } catch (error) {
                    return logger.throwError("could not detect network", (0, _logger.Logger).errors.NETWORK_ERROR, {
                        chainId: chainId,
                        event: "invalidNetwork",
                        serverError: error
                    });
                }
            }
            return logger.throwError("could not detect network", (0, _logger.Logger).errors.NETWORK_ERROR, {
                event: "noNetwork"
            });
        });
    }
    getSigner(addressOrIndex) {
        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
    }
    getUncheckedSigner(addressOrIndex) {
        return this.getSigner(addressOrIndex).connectUnchecked();
    }
    listAccounts() {
        return this.send("eth_accounts", []).then((accounts)=>{
            return accounts.map((a)=>this.formatter.address(a));
        });
    }
    send(method, params) {
        const request = {
            method: method,
            params: params,
            id: this._nextId++,
            jsonrpc: "2.0"
        };
        this.emit("debug", {
            action: "request",
            request: (0, _properties.deepCopy)(request),
            provider: this
        });
        // We can expand this in the future to any call, but for now these
        // are the biggest wins and do not require any serializing parameters.
        const cache = [
            "eth_chainId",
            "eth_blockNumber"
        ].indexOf(method) >= 0;
        if (cache && this._cache[method]) return this._cache[method];
        const result = (0, _web.fetchJson)(this.connection, JSON.stringify(request), getResult).then((result)=>{
            this.emit("debug", {
                action: "response",
                request: request,
                response: result,
                provider: this
            });
            return result;
        }, (error)=>{
            this.emit("debug", {
                action: "response",
                error: error,
                request: request,
                provider: this
            });
            throw error;
        });
        // Cache the fetch, but clear it on the next event loop
        if (cache) {
            this._cache[method] = result;
            setTimeout(()=>{
                this._cache[method] = null;
            }, 0);
        }
        return result;
    }
    prepareRequest(method, params) {
        switch(method){
            case "getBlockNumber":
                return [
                    "eth_blockNumber",
                    []
                ];
            case "getGasPrice":
                return [
                    "eth_gasPrice",
                    []
                ];
            case "getBalance":
                return [
                    "eth_getBalance",
                    [
                        getLowerCase(params.address),
                        params.blockTag
                    ]
                ];
            case "getTransactionCount":
                return [
                    "eth_getTransactionCount",
                    [
                        getLowerCase(params.address),
                        params.blockTag
                    ]
                ];
            case "getCode":
                return [
                    "eth_getCode",
                    [
                        getLowerCase(params.address),
                        params.blockTag
                    ]
                ];
            case "getStorageAt":
                return [
                    "eth_getStorageAt",
                    [
                        getLowerCase(params.address),
                        (0, _bytes.hexZeroPad)(params.position, 32),
                        params.blockTag
                    ]
                ];
            case "sendTransaction":
                return [
                    "eth_sendRawTransaction",
                    [
                        params.signedTransaction
                    ]
                ];
            case "getBlock":
                if (params.blockTag) return [
                    "eth_getBlockByNumber",
                    [
                        params.blockTag,
                        !!params.includeTransactions
                    ]
                ];
                else if (params.blockHash) return [
                    "eth_getBlockByHash",
                    [
                        params.blockHash,
                        !!params.includeTransactions
                    ]
                ];
                return null;
            case "getTransaction":
                return [
                    "eth_getTransactionByHash",
                    [
                        params.transactionHash
                    ]
                ];
            case "getTransactionReceipt":
                return [
                    "eth_getTransactionReceipt",
                    [
                        params.transactionHash
                    ]
                ];
            case "call":
                {
                    const hexlifyTransaction = (0, _properties.getStatic)(this.constructor, "hexlifyTransaction");
                    return [
                        "eth_call",
                        [
                            hexlifyTransaction(params.transaction, {
                                from: true
                            }),
                            params.blockTag
                        ]
                    ];
                }
            case "estimateGas":
                {
                    const hexlifyTransaction = (0, _properties.getStatic)(this.constructor, "hexlifyTransaction");
                    return [
                        "eth_estimateGas",
                        [
                            hexlifyTransaction(params.transaction, {
                                from: true
                            })
                        ]
                    ];
                }
            case "getLogs":
                if (params.filter && params.filter.address != null) params.filter.address = getLowerCase(params.filter.address);
                return [
                    "eth_getLogs",
                    [
                        params.filter
                    ]
                ];
            default:
                break;
        }
        return null;
    }
    perform(method, params) {
        return __awaiter(this, void 0, void 0, function*() {
            // Legacy networks do not like the type field being passed along (which
            // is fair), so we delete type if it is 0 and a non-EIP-1559 network
            if (method === "call" || method === "estimateGas") {
                const tx = params.transaction;
                if (tx && tx.type != null && (0, _bignumber.BigNumber).from(tx.type).isZero()) // If there are no EIP-1559 properties, it might be non-EIP-1559
                {
                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
                        const feeData = yield this.getFeeData();
                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                            // Network doesn't know about EIP-1559 (and hence type)
                            params = (0, _properties.shallowCopy)(params);
                            params.transaction = (0, _properties.shallowCopy)(tx);
                            delete params.transaction.type;
                        }
                    }
                }
            }
            const args = this.prepareRequest(method, params);
            if (args == null) logger.throwError(method + " not implemented", (0, _logger.Logger).errors.NOT_IMPLEMENTED, {
                operation: method
            });
            try {
                return yield this.send(args[0], args[1]);
            } catch (error) {
                return checkError(method, error, params);
            }
        });
    }
    _startEvent(event) {
        if (event.tag === "pending") this._startPending();
        super._startEvent(event);
    }
    _startPending() {
        if (this._pendingFilter != null) return;
        const self = this;
        const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = pendingFilter;
        pendingFilter.then(function(filterId) {
            function poll() {
                self.send("eth_getFilterChanges", [
                    filterId
                ]).then(function(hashes) {
                    if (self._pendingFilter != pendingFilter) return null;
                    let seq = Promise.resolve();
                    hashes.forEach(function(hash) {
                        // @TODO: This should be garbage collected at some point... How? When?
                        self._emitted["t:" + hash.toLowerCase()] = "pending";
                        seq = seq.then(function() {
                            return self.getTransaction(hash).then(function(tx) {
                                self.emit("pending", tx);
                                return null;
                            });
                        });
                    });
                    return seq.then(function() {
                        return timer(1000);
                    });
                }).then(function() {
                    if (self._pendingFilter != pendingFilter) {
                        self.send("eth_uninstallFilter", [
                            filterId
                        ]);
                        return;
                    }
                    setTimeout(function() {
                        poll();
                    }, 0);
                    return null;
                }).catch((error)=>{});
            }
            poll();
            return filterId;
        }).catch((error)=>{});
    }
    _stopEvent(event) {
        if (event.tag === "pending" && this.listenerCount("pending") === 0) this._pendingFilter = null;
        super._stopEvent(event);
    }
    // Convert an ethers.js transaction into a JSON-RPC transaction
    //  - gasLimit => gas
    //  - All values hexlified
    //  - All numeric values zero-striped
    //  - All addresses are lowercased
    // NOTE: This allows a TransactionRequest, but all values should be resolved
    //       before this is called
    // @TODO: This will likely be removed in future versions and prepareRequest
    //        will be the preferred method for this.
    static hexlifyTransaction(transaction, allowExtra) {
        // Check only allowed properties are given
        const allowed = (0, _properties.shallowCopy)(allowedTransactionKeys);
        if (allowExtra) {
            for(const key in allowExtra)if (allowExtra[key]) allowed[key] = true;
        }
        (0, _properties.checkProperties)(transaction, allowed);
        const result = {};
        // JSON-RPC now requires numeric values to be "quantity" values
        [
            "chainId",
            "gasLimit",
            "gasPrice",
            "type",
            "maxFeePerGas",
            "maxPriorityFeePerGas",
            "nonce",
            "value"
        ].forEach(function(key) {
            if (transaction[key] == null) return;
            const value = (0, _bytes.hexValue)((0, _bignumber.BigNumber).from(transaction[key]));
            if (key === "gasLimit") key = "gas";
            result[key] = value;
        });
        [
            "from",
            "to",
            "data"
        ].forEach(function(key) {
            if (transaction[key] == null) return;
            result[key] = (0, _bytes.hexlify)(transaction[key]);
        });
        if (transaction.accessList) result["accessList"] = (0, _transactions.accessListify)(transaction.accessList);
        return result;
    }
}

},{"@ethersproject/abstract-signer":"bq0ju","@ethersproject/bignumber":"gSTRF","@ethersproject/bytes":"5ReBN","@ethersproject/hash":"gr11a","@ethersproject/properties":"2X633","@ethersproject/strings":"8Rh0h","@ethersproject/transactions":"lqSCl","@ethersproject/web":"ebBVL","@ethersproject/logger":"9rXfv","./_version":"bmrdP","./base-provider":"8jgHV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bNEJl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
//export default WS;
//module.exports = WS;
parcelHelpers.export(exports, "WebSocket", ()=>WS);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
let WS = null;
try {
    WS = WebSocket;
    if (WS == null) throw new Error("inject please");
} catch (error) {
    const logger = new (0, _logger.Logger)((0, _version.version));
    WS = function() {
        logger.throwError("WebSockets not supported in this environment", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new WebSocket()"
        });
    };
}

},{"@ethersproject/logger":"9rXfv","./_version":"bmrdP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ecfF1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// A StaticJsonRpcProvider is useful when you *know* for certain that
// the backend will never change, as it never calls eth_chainId to
// verify its backend. However, if the backend does change, the effects
// are undefined and may include:
// - inconsistent results
// - locking up the UI
// - block skew warnings
// - wrong results
// If the network is not explicit (i.e. auto-detection is expected), the
// node MUST be running and available to respond to requests BEFORE this
// is instantiated.
parcelHelpers.export(exports, "StaticJsonRpcProvider", ()=>StaticJsonRpcProvider);
parcelHelpers.export(exports, "UrlJsonRpcProvider", ()=>UrlJsonRpcProvider);
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _jsonRpcProvider = require("./json-rpc-provider");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
class StaticJsonRpcProvider extends (0, _jsonRpcProvider.JsonRpcProvider) {
    detectNetwork() {
        const _super = Object.create(null, {
            detectNetwork: {
                get: ()=>super.detectNetwork
            }
        });
        return __awaiter(this, void 0, void 0, function*() {
            let network = this.network;
            if (network == null) {
                network = yield _super.detectNetwork.call(this);
                if (!network) logger.throwError("no network detected", (0, _logger.Logger).errors.UNKNOWN_ERROR, {});
                // If still not set, set it
                if (this._network == null) {
                    // A static network does not support "any"
                    (0, _properties.defineReadOnly)(this, "_network", network);
                    this.emit("network", network, null);
                }
            }
            return network;
        });
    }
}
class UrlJsonRpcProvider extends StaticJsonRpcProvider {
    constructor(network, apiKey){
        logger.checkAbstract(new.target, UrlJsonRpcProvider);
        // Normalize the Network and API Key
        network = (0, _properties.getStatic)(new.target, "getNetwork")(network);
        apiKey = (0, _properties.getStatic)(new.target, "getApiKey")(apiKey);
        const connection = (0, _properties.getStatic)(new.target, "getUrl")(network, apiKey);
        super(connection, network);
        if (typeof apiKey === "string") (0, _properties.defineReadOnly)(this, "apiKey", apiKey);
        else if (apiKey != null) Object.keys(apiKey).forEach((key)=>{
            (0, _properties.defineReadOnly)(this, key, apiKey[key]);
        });
    }
    _startPending() {
        logger.warn("WARNING: API provider does not support pending filters");
    }
    isCommunityResource() {
        return false;
    }
    getSigner(address) {
        return logger.throwError("API provider does not support signing", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "getSigner"
        });
    }
    listAccounts() {
        return Promise.resolve([]);
    }
    // Return a defaultApiKey if null, otherwise validate the API key
    static getApiKey(apiKey) {
        return apiKey;
    }
    // Returns the url or connection for the given network and API key. The
    // API key will have been sanitized by the getApiKey first, so any validation
    // or transformations can be done there.
    static getUrl(network, apiKey) {
        return logger.throwError("not implemented; sub-classes must override getUrl", (0, _logger.Logger).errors.NOT_IMPLEMENTED, {
            operation: "getUrl"
        });
    }
}

},{"@ethersproject/properties":"2X633","@ethersproject/logger":"9rXfv","./_version":"bmrdP","./json-rpc-provider":"9mdlH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9bnQV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AnkrProvider", ()=>AnkrProvider);
var _formatter = require("./formatter");
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
const logger = new (0, _logger.Logger)((0, _version.version));
const defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name) {
    switch(name){
        case "homestead":
            return "rpc.ankr.com/eth/";
        case "ropsten":
            return "rpc.ankr.com/eth_ropsten/";
        case "rinkeby":
            return "rpc.ankr.com/eth_rinkeby/";
        case "goerli":
            return "rpc.ankr.com/eth_goerli/";
        case "sepolia":
            return "rpc.ankr.com/eth_sepolia/";
        case "matic":
            return "rpc.ankr.com/polygon/";
        case "maticmum":
            return "rpc.ankr.com/polygon_mumbai/";
        case "optimism":
            return "rpc.ankr.com/optimism/";
        case "optimism-goerli":
            return "rpc.ankr.com/optimism_testnet/";
        case "optimism-sepolia":
            return "rpc.ankr.com/optimism_sepolia/";
        case "arbitrum":
            return "rpc.ankr.com/arbitrum/";
    }
    return logger.throwArgumentError("unsupported network", "name", name);
}
class AnkrProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    isCommunityResource() {
        return this.apiKey === defaultApiKey;
    }
    static getApiKey(apiKey) {
        if (apiKey == null) return defaultApiKey;
        return apiKey;
    }
    static getUrl(network, apiKey) {
        if (apiKey == null) apiKey = defaultApiKey;
        const connection = {
            allowGzip: true,
            url: "https:/\/" + getHost(network.name) + apiKey,
            throttleCallback: (attempt, url)=>{
                if (apiKey.apiKey === defaultApiKey) (0, _formatter.showThrottleMessage)();
                return Promise.resolve(true);
            }
        };
        if (apiKey.projectSecret != null) {
            connection.user = "";
            connection.password = apiKey.projectSecret;
        }
        return connection;
    }
}

},{"./formatter":"eHThO","./url-json-rpc-provider":"ecfF1","@ethersproject/logger":"9rXfv","./_version":"bmrdP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j7paZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CloudflareProvider", ()=>CloudflareProvider);
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
class CloudflareProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    static getApiKey(apiKey) {
        if (apiKey != null) logger.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
        return null;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch(network.name){
            case "homestead":
                host = "https://cloudflare-eth.com/";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host;
    }
    perform(method, params) {
        const _super = Object.create(null, {
            perform: {
                get: ()=>super.perform
            }
        });
        return __awaiter(this, void 0, void 0, function*() {
            // The Cloudflare provider does not support eth_blockNumber,
            // so we get the latest block and pull it from that
            if (method === "getBlockNumber") {
                const block = yield _super.perform.call(this, "getBlock", {
                    blockTag: "latest"
                });
                return block.number;
            }
            return _super.perform.call(this, method, params);
        });
    }
}

},{"./url-json-rpc-provider":"ecfF1","@ethersproject/logger":"9rXfv","./_version":"bmrdP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hMPHR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EtherscanProvider", ()=>EtherscanProvider);
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _transactions = require("@ethersproject/transactions");
var _web = require("@ethersproject/web");
var _formatter = require("./formatter");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _baseProvider = require("./base-provider");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
// The transaction has already been sanitized by the calls in Provider
function getTransactionPostData(transaction) {
    const result = {};
    for(let key in transaction){
        if (transaction[key] == null) continue;
        let value = transaction[key];
        if (key === "type" && value === 0) continue;
        // Quantity-types require no leading zero, unless 0
        if (({
            type: true,
            gasLimit: true,
            gasPrice: true,
            maxFeePerGs: true,
            maxPriorityFeePerGas: true,
            nonce: true,
            value: true
        })[key]) value = (0, _bytes.hexValue)((0, _bytes.hexlify)(value));
        else if (key === "accessList") value = "[" + (0, _transactions.accessListify)(value).map((set)=>{
            return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
        else value = (0, _bytes.hexlify)(value);
        result[key] = value;
    }
    return result;
}
function getResult(result) {
    // getLogs, getHistory have weird success responses
    if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) return result.result;
    if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
        const error = new Error("invalid response");
        error.result = JSON.stringify(result);
        if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) error.throttleRetry = true;
        throw error;
    }
    return result.result;
}
function getJsonResult(result) {
    // This response indicates we are being throttled
    if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        const error = new Error("throttled response");
        error.result = JSON.stringify(result);
        error.throttleRetry = true;
        throw error;
    }
    if (result.jsonrpc != "2.0") {
        // @TODO: not any
        const error = new Error("invalid response");
        error.result = JSON.stringify(result);
        throw error;
    }
    if (result.error) {
        // @TODO: not any
        const error = new Error(result.error.message || "unknown error");
        if (result.error.code) error.code = result.error.code;
        if (result.error.data) error.data = result.error.data;
        throw error;
    }
    return result.result;
}
// The blockTag was normalized as a string by the Provider pre-perform operations
function checkLogTag(blockTag) {
    if (blockTag === "pending") throw new Error("pending not supported");
    if (blockTag === "latest") return blockTag;
    return parseInt(blockTag.substring(2), 16);
}
function checkError(method, error, transaction) {
    // Undo the "convenience" some nodes are attempting to prevent backwards
    // incompatibility; maybe for v6 consider forwarding reverts as errors
    if (method === "call" && error.code === (0, _logger.Logger).errors.SERVER_ERROR) {
        const e = error.error;
        // Etherscan keeps changing their string
        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
            // Etherscan prefixes the data like "Reverted 0x1234"
            let data = e.data;
            if (data) data = "0x" + data.replace(/^.*0x/i, "");
            if ((0, _bytes.isHexString)(data)) return data;
            logger.throwError("missing revert data in call exception", (0, _logger.Logger).errors.CALL_EXCEPTION, {
                error,
                data: "0x"
            });
        }
    }
    // Get the message from any nested error structure
    let message = error.message;
    if (error.code === (0, _logger.Logger).errors.SERVER_ERROR) {
        if (error.error && typeof error.error.message === "string") message = error.error.message;
        else if (typeof error.body === "string") message = error.body;
        else if (typeof error.responseText === "string") message = error.responseText;
    }
    message = (message || "").toLowerCase();
    // "Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0"
    if (message.match(/insufficient funds/)) logger.throwError("insufficient funds for intrinsic transaction cost", (0, _logger.Logger).errors.INSUFFICIENT_FUNDS, {
        error,
        method,
        transaction
    });
    // "Transaction with the same hash was already imported."
    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) logger.throwError("nonce has already been used", (0, _logger.Logger).errors.NONCE_EXPIRED, {
        error,
        method,
        transaction
    });
    // "Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce."
    if (message.match(/another transaction with same nonce/)) logger.throwError("replacement fee too low", (0, _logger.Logger).errors.REPLACEMENT_UNDERPRICED, {
        error,
        method,
        transaction
    });
    if (message.match(/execution failed due to an exception|execution reverted/)) logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", (0, _logger.Logger).errors.UNPREDICTABLE_GAS_LIMIT, {
        error,
        method,
        transaction
    });
    throw error;
}
class EtherscanProvider extends (0, _baseProvider.BaseProvider) {
    constructor(network, apiKey){
        super(network);
        (0, _properties.defineReadOnly)(this, "baseUrl", this.getBaseUrl());
        (0, _properties.defineReadOnly)(this, "apiKey", apiKey || null);
    }
    getBaseUrl() {
        switch(this.network ? this.network.name : "invalid"){
            case "homestead":
                return "https:/\/api.etherscan.io";
            case "goerli":
                return "https:/\/api-goerli.etherscan.io";
            case "sepolia":
                return "https:/\/api-sepolia.etherscan.io";
            case "matic":
                return "https:/\/api.polygonscan.com";
            case "maticmum":
                return "https:/\/api-testnet.polygonscan.com";
            case "arbitrum":
                return "https:/\/api.arbiscan.io";
            case "arbitrum-goerli":
                return "https:/\/api-goerli.arbiscan.io";
            case "optimism":
                return "https:/\/api-optimistic.etherscan.io";
            case "optimism-goerli":
                return "https:/\/api-goerli-optimistic.etherscan.io";
            default:
        }
        return logger.throwArgumentError("unsupported network", "network", this.network.name);
    }
    getUrl(module, params) {
        const query = Object.keys(params).reduce((accum, key)=>{
            const value = params[key];
            if (value != null) accum += `&${key}=${value}`;
            return accum;
        }, "");
        const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
    }
    getPostUrl() {
        return `${this.baseUrl}/api`;
    }
    getPostData(module, params) {
        params.module = module;
        params.apikey = this.apiKey;
        return params;
    }
    fetch(module, params, post) {
        return __awaiter(this, void 0, void 0, function*() {
            const url = post ? this.getPostUrl() : this.getUrl(module, params);
            const payload = post ? this.getPostData(module, params) : null;
            const procFunc = module === "proxy" ? getJsonResult : getResult;
            this.emit("debug", {
                action: "request",
                request: url,
                provider: this
            });
            const connection = {
                url: url,
                throttleSlotInterval: 1000,
                throttleCallback: (attempt, url)=>{
                    if (this.isCommunityResource()) (0, _formatter.showThrottleMessage)();
                    return Promise.resolve(true);
                }
            };
            let payloadStr = null;
            if (payload) {
                connection.headers = {
                    "content-type": "application/x-www-form-urlencoded; charset=UTF-8"
                };
                payloadStr = Object.keys(payload).map((key)=>{
                    return `${key}=${payload[key]}`;
                }).join("&");
            }
            const result = yield (0, _web.fetchJson)(connection, payloadStr, procFunc || getJsonResult);
            this.emit("debug", {
                action: "response",
                request: url,
                response: (0, _properties.deepCopy)(result),
                provider: this
            });
            return result;
        });
    }
    detectNetwork() {
        return __awaiter(this, void 0, void 0, function*() {
            return this.network;
        });
    }
    perform(method, params) {
        const _super = Object.create(null, {
            perform: {
                get: ()=>super.perform
            }
        });
        return __awaiter(this, void 0, void 0, function*() {
            switch(method){
                case "getBlockNumber":
                    return this.fetch("proxy", {
                        action: "eth_blockNumber"
                    });
                case "getGasPrice":
                    return this.fetch("proxy", {
                        action: "eth_gasPrice"
                    });
                case "getBalance":
                    // Returns base-10 result
                    return this.fetch("account", {
                        action: "balance",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getTransactionCount":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionCount",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getCode":
                    return this.fetch("proxy", {
                        action: "eth_getCode",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getStorageAt":
                    return this.fetch("proxy", {
                        action: "eth_getStorageAt",
                        address: params.address,
                        position: params.position,
                        tag: params.blockTag
                    });
                case "sendTransaction":
                    return this.fetch("proxy", {
                        action: "eth_sendRawTransaction",
                        hex: params.signedTransaction
                    }, true).catch((error)=>{
                        return checkError("sendTransaction", error, params.signedTransaction);
                    });
                case "getBlock":
                    if (params.blockTag) return this.fetch("proxy", {
                        action: "eth_getBlockByNumber",
                        tag: params.blockTag,
                        boolean: params.includeTransactions ? "true" : "false"
                    });
                    throw new Error("getBlock by blockHash not implemented");
                case "getTransaction":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionByHash",
                        txhash: params.transactionHash
                    });
                case "getTransactionReceipt":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionReceipt",
                        txhash: params.transactionHash
                    });
                case "call":
                    {
                        if (params.blockTag !== "latest") throw new Error("EtherscanProvider does not support blockTag for call");
                        const postData = getTransactionPostData(params.transaction);
                        postData.module = "proxy";
                        postData.action = "eth_call";
                        try {
                            return yield this.fetch("proxy", postData, true);
                        } catch (error) {
                            return checkError("call", error, params.transaction);
                        }
                    }
                case "estimateGas":
                    {
                        const postData = getTransactionPostData(params.transaction);
                        postData.module = "proxy";
                        postData.action = "eth_estimateGas";
                        try {
                            return yield this.fetch("proxy", postData, true);
                        } catch (error) {
                            return checkError("estimateGas", error, params.transaction);
                        }
                    }
                case "getLogs":
                    {
                        const args = {
                            action: "getLogs"
                        };
                        if (params.filter.fromBlock) args.fromBlock = checkLogTag(params.filter.fromBlock);
                        if (params.filter.toBlock) args.toBlock = checkLogTag(params.filter.toBlock);
                        if (params.filter.address) args.address = params.filter.address;
                        // @TODO: We can handle slightly more complicated logs using the logs API
                        if (params.filter.topics && params.filter.topics.length > 0) {
                            if (params.filter.topics.length > 1) logger.throwError("unsupported topic count", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                                topics: params.filter.topics
                            });
                            if (params.filter.topics.length === 1) {
                                const topic0 = params.filter.topics[0];
                                if (typeof topic0 !== "string" || topic0.length !== 66) logger.throwError("unsupported topic format", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                                    topic0: topic0
                                });
                                args.topic0 = topic0;
                            }
                        }
                        const logs = yield this.fetch("logs", args);
                        // Cache txHash => blockHash
                        let blocks = {};
                        // Add any missing blockHash to the logs
                        for(let i = 0; i < logs.length; i++){
                            const log = logs[i];
                            if (log.blockHash != null) continue;
                            if (blocks[log.blockNumber] == null) {
                                const block = yield this.getBlock(log.blockNumber);
                                if (block) blocks[log.blockNumber] = block.hash;
                            }
                            log.blockHash = blocks[log.blockNumber];
                        }
                        return logs;
                    }
                case "getEtherPrice":
                    if (this.network.name !== "homestead") return 0.0;
                    return parseFloat((yield this.fetch("stats", {
                        action: "ethprice"
                    })).ethusd);
                default:
                    break;
            }
            return _super.perform.call(this, method, params);
        });
    }
    // Note: The `page` page parameter only allows pagination within the
    //       10,000 window available without a page and offset parameter
    //       Error: Result window is too large, PageNo x Offset size must
    //              be less than or equal to 10000
    getHistory(addressOrName, startBlock, endBlock) {
        return __awaiter(this, void 0, void 0, function*() {
            const params = {
                action: "txlist",
                address: yield this.resolveName(addressOrName),
                startblock: startBlock == null ? 0 : startBlock,
                endblock: endBlock == null ? 99999999 : endBlock,
                sort: "asc"
            };
            const result = yield this.fetch("account", params);
            return result.map((tx)=>{
                [
                    "contractAddress",
                    "to"
                ].forEach(function(key) {
                    if (tx[key] == "") delete tx[key];
                });
                if (tx.creates == null && tx.contractAddress != null) tx.creates = tx.contractAddress;
                const item = this.formatter.transactionResponse(tx);
                if (tx.timeStamp) item.timestamp = parseInt(tx.timeStamp);
                return item;
            });
        });
    }
    isCommunityResource() {
        return this.apiKey == null;
    }
}

},{"@ethersproject/bytes":"5ReBN","@ethersproject/properties":"2X633","@ethersproject/transactions":"lqSCl","@ethersproject/web":"ebBVL","./formatter":"eHThO","@ethersproject/logger":"9rXfv","./_version":"bmrdP","./base-provider":"8jgHV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"26sUb":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FallbackProvider", ()=>FallbackProvider);
var _abstractProvider = require("@ethersproject/abstract-provider");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _random = require("@ethersproject/random");
var _web = require("@ethersproject/web");
var _baseProvider = require("./base-provider");
var _formatter = require("./formatter");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
function now() {
    return new Date().getTime();
}
// Returns to network as long as all agree, or null if any is null.
// Throws an error if any two networks do not match.
function checkNetworks(networks) {
    let result = null;
    for(let i = 0; i < networks.length; i++){
        const network = networks[i];
        // Null! We do not know our network; bail.
        if (network == null) return null;
        if (result) // Make sure the network matches the previous networks
        {
            if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) logger.throwArgumentError("provider mismatch", "networks", networks);
        } else result = network;
    }
    return result;
}
function median(values, maxDelta) {
    values = values.slice().sort();
    const middle = Math.floor(values.length / 2);
    // Odd length; take the middle
    if (values.length % 2) return values[middle];
    // Even length; take the average of the two middle
    const a = values[middle - 1], b = values[middle];
    if (maxDelta != null && Math.abs(a - b) > maxDelta) return null;
    return (a + b) / 2;
}
function serialize(value) {
    if (value === null) return "null";
    else if (typeof value === "number" || typeof value === "boolean") return JSON.stringify(value);
    else if (typeof value === "string") return value;
    else if ((0, _bignumber.BigNumber).isBigNumber(value)) return value.toString();
    else if (Array.isArray(value)) return JSON.stringify(value.map((i)=>serialize(i)));
    else if (typeof value === "object") {
        const keys = Object.keys(value);
        keys.sort();
        return "{" + keys.map((key)=>{
            let v = value[key];
            if (typeof v === "function") v = "[function]";
            else v = serialize(v);
            return JSON.stringify(key) + ":" + v;
        }).join(",") + "}";
    }
    throw new Error("unknown value type: " + typeof value);
}
// Next request ID to use for emitting debug info
let nextRid = 1;
function stall(duration) {
    let cancel = null;
    let timer = null;
    let promise = new Promise((resolve)=>{
        cancel = function() {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            resolve();
        };
        timer = setTimeout(cancel, duration);
    });
    const wait = (func)=>{
        promise = promise.then(func);
        return promise;
    };
    function getPromise() {
        return promise;
    }
    return {
        cancel,
        getPromise,
        wait
    };
}
const ForwardErrors = [
    (0, _logger.Logger).errors.CALL_EXCEPTION,
    (0, _logger.Logger).errors.INSUFFICIENT_FUNDS,
    (0, _logger.Logger).errors.NONCE_EXPIRED,
    (0, _logger.Logger).errors.REPLACEMENT_UNDERPRICED,
    (0, _logger.Logger).errors.UNPREDICTABLE_GAS_LIMIT
];
const ForwardProperties = [
    "address",
    "args",
    "errorArgs",
    "errorSignature",
    "method",
    "transaction"
];
function exposeDebugConfig(config, now) {
    const result = {
        weight: config.weight
    };
    Object.defineProperty(result, "provider", {
        get: ()=>config.provider
    });
    if (config.start) result.start = config.start;
    if (now) result.duration = now - config.start;
    if (config.done) {
        if (config.error) result.error = config.error;
        else result.result = config.result || null;
    }
    return result;
}
function normalizedTally(normalize, quorum) {
    return function(configs) {
        // Count the votes for each result
        const tally = {};
        configs.forEach((c)=>{
            const value = normalize(c.result);
            if (!tally[value]) tally[value] = {
                count: 0,
                result: c.result
            };
            tally[value].count++;
        });
        // Check for a quorum on any given result
        const keys = Object.keys(tally);
        for(let i = 0; i < keys.length; i++){
            const check = tally[keys[i]];
            if (check.count >= quorum) return check.result;
        }
        // No quroum
        return undefined;
    };
}
function getProcessFunc(provider, method, params) {
    let normalize = serialize;
    switch(method){
        case "getBlockNumber":
            // Return the median value, unless there is (median + 1) is also
            // present, in which case that is probably true and the median
            // is going to be stale soon. In the event of a malicious node,
            // the lie will be true soon enough.
            return function(configs) {
                const values = configs.map((c)=>c.result);
                // Get the median block number
                let blockNumber = median(configs.map((c)=>c.result), 2);
                if (blockNumber == null) return undefined;
                blockNumber = Math.ceil(blockNumber);
                // If the next block height is present, its prolly safe to use
                if (values.indexOf(blockNumber + 1) >= 0) blockNumber++;
                // Don't ever roll back the blockNumber
                if (blockNumber >= provider._highestBlockNumber) provider._highestBlockNumber = blockNumber;
                return provider._highestBlockNumber;
            };
        case "getGasPrice":
            // Return the middle (round index up) value, similar to median
            // but do not average even entries and choose the higher.
            // Malicious actors must compromise 50% of the nodes to lie.
            return function(configs) {
                const values = configs.map((c)=>c.result);
                values.sort();
                return values[Math.floor(values.length / 2)];
            };
        case "getEtherPrice":
            // Returns the median price. Malicious actors must compromise at
            // least 50% of the nodes to lie (in a meaningful way).
            return function(configs) {
                return median(configs.map((c)=>c.result));
            };
        // No additional normalizing required; serialize is enough
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
        case "getStorageAt":
        case "call":
        case "estimateGas":
        case "getLogs":
            break;
        // We drop the confirmations from transactions as it is approximate
        case "getTransaction":
        case "getTransactionReceipt":
            normalize = function(tx) {
                if (tx == null) return null;
                tx = (0, _properties.shallowCopy)(tx);
                tx.confirmations = -1;
                return serialize(tx);
            };
            break;
        // We drop the confirmations from transactions as it is approximate
        case "getBlock":
            // We drop the confirmations from transactions as it is approximate
            if (params.includeTransactions) normalize = function(block) {
                if (block == null) return null;
                block = (0, _properties.shallowCopy)(block);
                block.transactions = block.transactions.map((tx)=>{
                    tx = (0, _properties.shallowCopy)(tx);
                    tx.confirmations = -1;
                    return tx;
                });
                return serialize(block);
            };
            else normalize = function(block) {
                if (block == null) return null;
                return serialize(block);
            };
            break;
        default:
            throw new Error("unknown method: " + method);
    }
    // Return the result if and only if the expected quorum is
    // satisfied and agreed upon for the final result.
    return normalizedTally(normalize, provider.quorum);
}
// If we are doing a blockTag query, we need to make sure the backend is
// caught up to the FallbackProvider, before sending a request to it.
function waitForSync(config, blockNumber) {
    return __awaiter(this, void 0, void 0, function*() {
        const provider = config.provider;
        if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) return provider;
        return (0, _web.poll)(()=>{
            return new Promise((resolve, reject)=>{
                setTimeout(function() {
                    // We are synced
                    if (provider.blockNumber >= blockNumber) return resolve(provider);
                    // We're done; just quit
                    if (config.cancelled) return resolve(null);
                    // Try again, next block
                    return resolve(undefined);
                }, 0);
            });
        }, {
            oncePoll: provider
        });
    });
}
function getRunner(config, currentBlockNumber, method, params) {
    return __awaiter(this, void 0, void 0, function*() {
        let provider = config.provider;
        switch(method){
            case "getBlockNumber":
            case "getGasPrice":
                return provider[method]();
            case "getEtherPrice":
                if (provider.getEtherPrice) return provider.getEtherPrice();
                break;
            case "getBalance":
            case "getTransactionCount":
            case "getCode":
                if (params.blockTag && (0, _bytes.isHexString)(params.blockTag)) provider = yield waitForSync(config, currentBlockNumber);
                return provider[method](params.address, params.blockTag || "latest");
            case "getStorageAt":
                if (params.blockTag && (0, _bytes.isHexString)(params.blockTag)) provider = yield waitForSync(config, currentBlockNumber);
                return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
            case "getBlock":
                if (params.blockTag && (0, _bytes.isHexString)(params.blockTag)) provider = yield waitForSync(config, currentBlockNumber);
                return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
            case "call":
            case "estimateGas":
                if (params.blockTag && (0, _bytes.isHexString)(params.blockTag)) provider = yield waitForSync(config, currentBlockNumber);
                if (method === "call" && params.blockTag) return provider[method](params.transaction, params.blockTag);
                return provider[method](params.transaction);
            case "getTransaction":
            case "getTransactionReceipt":
                return provider[method](params.transactionHash);
            case "getLogs":
                {
                    let filter = params.filter;
                    if (filter.fromBlock && (0, _bytes.isHexString)(filter.fromBlock) || filter.toBlock && (0, _bytes.isHexString)(filter.toBlock)) provider = yield waitForSync(config, currentBlockNumber);
                    return provider.getLogs(filter);
                }
        }
        return logger.throwError("unknown method error", (0, _logger.Logger).errors.UNKNOWN_ERROR, {
            method: method,
            params: params
        });
    });
}
class FallbackProvider extends (0, _baseProvider.BaseProvider) {
    constructor(providers, quorum){
        if (providers.length === 0) logger.throwArgumentError("missing providers", "providers", providers);
        const providerConfigs = providers.map((configOrProvider, index)=>{
            if ((0, _abstractProvider.Provider).isProvider(configOrProvider)) {
                const stallTimeout = (0, _formatter.isCommunityResource)(configOrProvider) ? 2000 : 750;
                const priority = 1;
                return Object.freeze({
                    provider: configOrProvider,
                    weight: 1,
                    stallTimeout,
                    priority
                });
            }
            const config = (0, _properties.shallowCopy)(configOrProvider);
            if (config.priority == null) config.priority = 1;
            if (config.stallTimeout == null) config.stallTimeout = (0, _formatter.isCommunityResource)(configOrProvider) ? 2000 : 750;
            if (config.weight == null) config.weight = 1;
            const weight = config.weight;
            if (weight % 1 || weight > 512 || weight < 1) logger.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
            return Object.freeze(config);
        });
        const total = providerConfigs.reduce((accum, c)=>accum + c.weight, 0);
        if (quorum == null) quorum = total / 2;
        else if (quorum > total) logger.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
        // Are all providers' networks are known
        let networkOrReady = checkNetworks(providerConfigs.map((c)=>c.provider.network));
        // Not all networks are known; we must stall
        if (networkOrReady == null) networkOrReady = new Promise((resolve, reject)=>{
            setTimeout(()=>{
                this.detectNetwork().then(resolve, reject);
            }, 0);
        });
        super(networkOrReady);
        // Preserve a copy, so we do not get mutated
        (0, _properties.defineReadOnly)(this, "providerConfigs", Object.freeze(providerConfigs));
        (0, _properties.defineReadOnly)(this, "quorum", quorum);
        this._highestBlockNumber = -1;
    }
    detectNetwork() {
        return __awaiter(this, void 0, void 0, function*() {
            const networks = yield Promise.all(this.providerConfigs.map((c)=>c.provider.getNetwork()));
            return checkNetworks(networks);
        });
    }
    perform(method, params) {
        return __awaiter(this, void 0, void 0, function*() {
            // Sending transactions is special; always broadcast it to all backends
            if (method === "sendTransaction") {
                const results = yield Promise.all(this.providerConfigs.map((c)=>{
                    return c.provider.sendTransaction(params.signedTransaction).then((result)=>{
                        return result.hash;
                    }, (error)=>{
                        return error;
                    });
                }));
                // Any success is good enough (other errors are likely "already seen" errors
                for(let i = 0; i < results.length; i++){
                    const result = results[i];
                    if (typeof result === "string") return result;
                }
                // They were all an error; pick the first error
                throw results[0];
            }
            // We need to make sure we are in sync with our backends, so we need
            // to know this before we can make a lot of calls
            if (this._highestBlockNumber === -1 && method !== "getBlockNumber") yield this.getBlockNumber();
            const processFunc = getProcessFunc(this, method, params);
            // Shuffle the providers and then sort them by their priority; we
            // shallowCopy them since we will store the result in them too
            const configs = (0, _random.shuffled)(this.providerConfigs.map((0, _properties.shallowCopy)));
            configs.sort((a, b)=>a.priority - b.priority);
            const currentBlockNumber = this._highestBlockNumber;
            let i = 0;
            let first = true;
            while(true){
                const t0 = now();
                // Compute the inflight weight (exclude anything past)
                let inflightWeight = configs.filter((c)=>c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c)=>accum + c.weight, 0);
                // Start running enough to meet quorum
                while(inflightWeight < this.quorum && i < configs.length){
                    const config = configs[i++];
                    const rid = nextRid++;
                    config.start = now();
                    config.staller = stall(config.stallTimeout);
                    config.staller.wait(()=>{
                        config.staller = null;
                    });
                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result)=>{
                        config.done = true;
                        config.result = result;
                        if (this.listenerCount("debug")) this.emit("debug", {
                            action: "request",
                            rid: rid,
                            backend: exposeDebugConfig(config, now()),
                            request: {
                                method: method,
                                params: (0, _properties.deepCopy)(params)
                            },
                            provider: this
                        });
                    }, (error)=>{
                        config.done = true;
                        config.error = error;
                        if (this.listenerCount("debug")) this.emit("debug", {
                            action: "request",
                            rid: rid,
                            backend: exposeDebugConfig(config, now()),
                            request: {
                                method: method,
                                params: (0, _properties.deepCopy)(params)
                            },
                            provider: this
                        });
                    });
                    if (this.listenerCount("debug")) this.emit("debug", {
                        action: "request",
                        rid: rid,
                        backend: exposeDebugConfig(config, null),
                        request: {
                            method: method,
                            params: (0, _properties.deepCopy)(params)
                        },
                        provider: this
                    });
                    inflightWeight += config.weight;
                }
                // Wait for anything meaningful to finish or stall out
                const waiting = [];
                configs.forEach((c)=>{
                    if (c.done || !c.runner) return;
                    waiting.push(c.runner);
                    if (c.staller) waiting.push(c.staller.getPromise());
                });
                if (waiting.length) yield Promise.race(waiting);
                // Check the quorum and process the results; the process function
                // may additionally decide the quorum is not met
                const results = configs.filter((c)=>c.done && c.error == null);
                if (results.length >= this.quorum) {
                    const result = processFunc(results);
                    if (result !== undefined) {
                        // Shut down any stallers
                        configs.forEach((c)=>{
                            if (c.staller) c.staller.cancel();
                            c.cancelled = true;
                        });
                        return result;
                    }
                    if (!first) yield stall(100).getPromise();
                    first = false;
                }
                // No result, check for errors that should be forwarded
                const errors = configs.reduce((accum, c)=>{
                    if (!c.done || c.error == null) return accum;
                    const code = c.error.code;
                    if (ForwardErrors.indexOf(code) >= 0) {
                        if (!accum[code]) accum[code] = {
                            error: c.error,
                            weight: 0
                        };
                        accum[code].weight += c.weight;
                    }
                    return accum;
                }, {});
                Object.keys(errors).forEach((errorCode)=>{
                    const tally = errors[errorCode];
                    if (tally.weight < this.quorum) return;
                    // Shut down any stallers
                    configs.forEach((c)=>{
                        if (c.staller) c.staller.cancel();
                        c.cancelled = true;
                    });
                    const e = tally.error;
                    const props = {};
                    ForwardProperties.forEach((name)=>{
                        if (e[name] == null) return;
                        props[name] = e[name];
                    });
                    logger.throwError(e.reason || e.message, errorCode, props);
                });
                // All configs have run to completion; we will never get more data
                if (configs.filter((c)=>!c.done).length === 0) break;
            }
            // Shut down any stallers; shouldn't be any
            configs.forEach((c)=>{
                if (c.staller) c.staller.cancel();
                c.cancelled = true;
            });
            return logger.throwError("failed to meet quorum", (0, _logger.Logger).errors.SERVER_ERROR, {
                method: method,
                params: params,
                //results: configs.map((c) => c.result),
                //errors: configs.map((c) => c.error),
                results: configs.map((c)=>exposeDebugConfig(c)),
                provider: this
            });
        });
    }
}

},{"@ethersproject/abstract-provider":"fYevg","@ethersproject/bignumber":"gSTRF","@ethersproject/bytes":"5ReBN","@ethersproject/properties":"2X633","@ethersproject/random":"2EoWn","@ethersproject/web":"ebBVL","./base-provider":"8jgHV","./formatter":"eHThO","@ethersproject/logger":"9rXfv","./_version":"bmrdP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2EoWn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "randomBytes", ()=>(0, _random.randomBytes));
parcelHelpers.export(exports, "shuffled", ()=>(0, _shuffle.shuffled));
var _random = require("./random");
var _shuffle = require("./shuffle");
"use strict";

},{"./random":false,"./shuffle":"jUXG4","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jUXG4":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shuffled", ()=>shuffled);
"use strict";
function shuffled(array) {
    array = array.slice();
    for(let i = array.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
    return array;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hO0gF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "IpcProvider", ()=>IpcProvider);
"use strict";
const IpcProvider = null;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"laas2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "InfuraWebSocketProvider", ()=>InfuraWebSocketProvider);
parcelHelpers.export(exports, "InfuraProvider", ()=>InfuraProvider);
var _properties = require("@ethersproject/properties");
var _websocketProvider = require("./websocket-provider");
var _formatter = require("./formatter");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const defaultProjectId = "84842078b09946638c03157f83405213";
class InfuraWebSocketProvider extends (0, _websocketProvider.WebSocketProvider) {
    constructor(network, apiKey){
        const provider = new InfuraProvider(network, apiKey);
        const connection = provider.connection;
        if (connection.password) logger.throwError("INFURA WebSocket project secrets unsupported", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "InfuraProvider.getWebSocketProvider()"
        });
        const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        super(url, network);
        (0, _properties.defineReadOnly)(this, "apiKey", provider.projectId);
        (0, _properties.defineReadOnly)(this, "projectId", provider.projectId);
        (0, _properties.defineReadOnly)(this, "projectSecret", provider.projectSecret);
    }
    isCommunityResource() {
        return this.projectId === defaultProjectId;
    }
}
class InfuraProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    static getWebSocketProvider(network, apiKey) {
        return new InfuraWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
        const apiKeyObj = {
            apiKey: defaultProjectId,
            projectId: defaultProjectId,
            projectSecret: null
        };
        if (apiKey == null) return apiKeyObj;
        if (typeof apiKey === "string") apiKeyObj.projectId = apiKey;
        else if (apiKey.projectSecret != null) {
            logger.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
            logger.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
            apiKeyObj.projectId = apiKey.projectId;
            apiKeyObj.projectSecret = apiKey.projectSecret;
        } else if (apiKey.projectId) apiKeyObj.projectId = apiKey.projectId;
        apiKeyObj.apiKey = apiKeyObj.projectId;
        return apiKeyObj;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch(network ? network.name : "unknown"){
            case "homestead":
                host = "mainnet.infura.io";
                break;
            case "goerli":
                host = "goerli.infura.io";
                break;
            case "sepolia":
                host = "sepolia.infura.io";
                break;
            case "matic":
                host = "polygon-mainnet.infura.io";
                break;
            case "maticmum":
                host = "polygon-mumbai.infura.io";
                break;
            case "optimism":
                host = "optimism-mainnet.infura.io";
                break;
            case "optimism-goerli":
                host = "optimism-goerli.infura.io";
                break;
            case "optimism-sepolia":
                host = "optimism-sepolia.infura.io";
                break;
            case "arbitrum":
                host = "arbitrum-mainnet.infura.io";
                break;
            case "arbitrum-goerli":
                host = "arbitrum-goerli.infura.io";
                break;
            case "arbitrum-sepolia":
                host = "arbitrum-sepolia.infura.io";
                break;
            default:
                logger.throwError("unsupported network", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
        }
        const connection = {
            allowGzip: true,
            url: "https://" + host + "/v3/" + apiKey.projectId,
            throttleCallback: (attempt, url)=>{
                if (apiKey.projectId === defaultProjectId) (0, _formatter.showThrottleMessage)();
                return Promise.resolve(true);
            }
        };
        if (apiKey.projectSecret != null) {
            connection.user = "";
            connection.password = apiKey.projectSecret;
        }
        return connection;
    }
    isCommunityResource() {
        return this.projectId === defaultProjectId;
    }
}

},{"@ethersproject/properties":"2X633","./websocket-provider":"82IGf","./formatter":"eHThO","@ethersproject/logger":"9rXfv","./_version":"bmrdP","./url-json-rpc-provider":"ecfF1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dzx4I":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Experimental
parcelHelpers.export(exports, "JsonRpcBatchProvider", ()=>JsonRpcBatchProvider);
var _properties = require("@ethersproject/properties");
var _web = require("@ethersproject/web");
var _jsonRpcProvider = require("./json-rpc-provider");
class JsonRpcBatchProvider extends (0, _jsonRpcProvider.JsonRpcProvider) {
    send(method, params) {
        const request = {
            method: method,
            params: params,
            id: this._nextId++,
            jsonrpc: "2.0"
        };
        if (this._pendingBatch == null) this._pendingBatch = [];
        const inflightRequest = {
            request,
            resolve: null,
            reject: null
        };
        const promise = new Promise((resolve, reject)=>{
            inflightRequest.resolve = resolve;
            inflightRequest.reject = reject;
        });
        this._pendingBatch.push(inflightRequest);
        if (!this._pendingBatchAggregator) // Schedule batch for next event loop + short duration
        this._pendingBatchAggregator = setTimeout(()=>{
            // Get teh current batch and clear it, so new requests
            // go into the next batch
            const batch = this._pendingBatch;
            this._pendingBatch = null;
            this._pendingBatchAggregator = null;
            // Get the request as an array of requests
            const request = batch.map((inflight)=>inflight.request);
            this.emit("debug", {
                action: "requestBatch",
                request: (0, _properties.deepCopy)(request),
                provider: this
            });
            return (0, _web.fetchJson)(this.connection, JSON.stringify(request)).then((result)=>{
                this.emit("debug", {
                    action: "response",
                    request: request,
                    response: result,
                    provider: this
                });
                // For each result, feed it to the correct Promise, depending
                // on whether it was a success or error
                batch.forEach((inflightRequest, index)=>{
                    const payload = result[index];
                    if (payload.error) {
                        const error = new Error(payload.error.message);
                        error.code = payload.error.code;
                        error.data = payload.error.data;
                        inflightRequest.reject(error);
                    } else inflightRequest.resolve(payload.result);
                });
            }, (error)=>{
                this.emit("debug", {
                    action: "response",
                    error: error,
                    request: request,
                    provider: this
                });
                batch.forEach((inflightRequest)=>{
                    inflightRequest.reject(error);
                });
            });
        }, 10);
        return promise;
    }
}

},{"@ethersproject/properties":"2X633","@ethersproject/web":"ebBVL","./json-rpc-provider":"9mdlH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jxJf7":[function(require,module,exports,__globalThis) {
/* istanbul ignore file */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NodesmithProvider", ()=>NodesmithProvider);
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
// Special API key provided by Nodesmith for ethers.js
const defaultApiKey = "ETHERS_JS_SHARED";
class NodesmithProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    static getApiKey(apiKey) {
        if (apiKey && typeof apiKey !== "string") logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        return apiKey || defaultApiKey;
    }
    static getUrl(network, apiKey) {
        logger.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
        let host = null;
        switch(network.name){
            case "homestead":
                host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
                break;
            case "ropsten":
                host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
                break;
            case "rinkeby":
                host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
                break;
            case "goerli":
                host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
                break;
            case "kovan":
                host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host + "?apiKey=" + apiKey;
    }
}

},{"./url-json-rpc-provider":"ecfF1","@ethersproject/logger":"9rXfv","./_version":"bmrdP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kJNHs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PocketProvider", ()=>PocketProvider);
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const defaultApplicationId = "62e1ad51b37b8e00394bda3b";
class PocketProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    static getApiKey(apiKey) {
        const apiKeyObj = {
            applicationId: null,
            loadBalancer: true,
            applicationSecretKey: null
        };
        // Parse applicationId and applicationSecretKey
        if (apiKey == null) apiKeyObj.applicationId = defaultApplicationId;
        else if (typeof apiKey === "string") apiKeyObj.applicationId = apiKey;
        else if (apiKey.applicationSecretKey != null) {
            apiKeyObj.applicationId = apiKey.applicationId;
            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
        } else if (apiKey.applicationId) apiKeyObj.applicationId = apiKey.applicationId;
        else logger.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
        return apiKeyObj;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch(network ? network.name : "unknown"){
            case "goerli":
                host = "eth-goerli.gateway.pokt.network";
                break;
            case "homestead":
                host = "eth-mainnet.gateway.pokt.network";
                break;
            case "kovan":
                host = "poa-kovan.gateway.pokt.network";
                break;
            case "matic":
                host = "poly-mainnet.gateway.pokt.network";
                break;
            case "maticmum":
                host = "polygon-mumbai-rpc.gateway.pokt.network";
                break;
            case "rinkeby":
                host = "eth-rinkeby.gateway.pokt.network";
                break;
            case "ropsten":
                host = "eth-ropsten.gateway.pokt.network";
                break;
            default:
                logger.throwError("unsupported network", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
        }
        const url = `https:/\/${host}/v1/lb/${apiKey.applicationId}`;
        const connection = {
            headers: {},
            url
        };
        if (apiKey.applicationSecretKey != null) {
            connection.user = "";
            connection.password = apiKey.applicationSecretKey;
        }
        return connection;
    }
    isCommunityResource() {
        return this.applicationId === defaultApplicationId;
    }
}

},{"@ethersproject/logger":"9rXfv","./_version":"bmrdP","./url-json-rpc-provider":"ecfF1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1iGuq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "QuickNodeProvider", ()=>QuickNodeProvider);
var _urlJsonRpcProvider = require("./url-json-rpc-provider");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
// Special API key provided by Quicknode for ethers.js
const defaultApiKey = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
class QuickNodeProvider extends (0, _urlJsonRpcProvider.UrlJsonRpcProvider) {
    static getApiKey(apiKey) {
        if (apiKey && typeof apiKey !== "string") logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        return apiKey || defaultApiKey;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch(network.name){
            case "homestead":
                host = "ethers.quiknode.pro";
                break;
            case "goerli":
                host = "ethers.ethereum-goerli.quiknode.pro";
                break;
            case "sepolia":
                host = "ethers.ethereum-sepolia.quiknode.pro";
                break;
            case "holesky":
                host = "ethers.ethereum-holesky.quiknode.pro";
                break;
            case "arbitrum":
                host = "ethers.arbitrum-mainnet.quiknode.pro";
                break;
            case "arbitrum-goerli":
                host = "ethers.arbitrum-goerli.quiknode.pro";
                break;
            case "arbitrum-sepolia":
                host = "ethers.arbitrum-sepolia.quiknode.pro";
                break;
            case "base":
                host = "ethers.base-mainnet.quiknode.pro";
                break;
            case "base-goerli":
                host = "ethers.base-goerli.quiknode.pro";
                break;
            case "base-spolia":
                host = "ethers.base-sepolia.quiknode.pro";
                break;
            case "bnb":
                host = "ethers.bsc.quiknode.pro";
                break;
            case "bnbt":
                host = "ethers.bsc-testnet.quiknode.pro";
                break;
            case "matic":
                host = "ethers.matic.quiknode.pro";
                break;
            case "maticmum":
                host = "ethers.matic-testnet.quiknode.pro";
                break;
            case "optimism":
                host = "ethers.optimism.quiknode.pro";
                break;
            case "optimism-goerli":
                host = "ethers.optimism-goerli.quiknode.pro";
                break;
            case "optimism-sepolia":
                host = "ethers.optimism-sepolia.quiknode.pro";
                break;
            case "xdai":
                host = "ethers.xdai.quiknode.pro";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return "https://" + host + "/" + apiKey;
    }
}

},{"./url-json-rpc-provider":"ecfF1","@ethersproject/logger":"9rXfv","./_version":"bmrdP","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cat97":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Web3Provider", ()=>Web3Provider);
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _jsonRpcProvider = require("./json-rpc-provider");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
    const fetcher = "Web3LegacyFetcher";
    return function(method, params) {
        const request = {
            method: method,
            params: params,
            id: _nextId++,
            jsonrpc: "2.0"
        };
        return new Promise((resolve, reject)=>{
            this.emit("debug", {
                action: "request",
                fetcher,
                request: (0, _properties.deepCopy)(request),
                provider: this
            });
            sendFunc(request, (error, response)=>{
                if (error) {
                    this.emit("debug", {
                        action: "response",
                        fetcher,
                        error,
                        request,
                        provider: this
                    });
                    return reject(error);
                }
                this.emit("debug", {
                    action: "response",
                    fetcher,
                    request,
                    response,
                    provider: this
                });
                if (response.error) {
                    const error = new Error(response.error.message);
                    error.code = response.error.code;
                    error.data = response.error.data;
                    return reject(error);
                }
                resolve(response.result);
            });
        });
    };
}
function buildEip1193Fetcher(provider) {
    return function(method, params) {
        if (params == null) params = [];
        const request = {
            method,
            params
        };
        this.emit("debug", {
            action: "request",
            fetcher: "Eip1193Fetcher",
            request: (0, _properties.deepCopy)(request),
            provider: this
        });
        return provider.request(request).then((response)=>{
            this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request,
                response,
                provider: this
            });
            return response;
        }, (error)=>{
            this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request,
                error,
                provider: this
            });
            throw error;
        });
    };
}
class Web3Provider extends (0, _jsonRpcProvider.JsonRpcProvider) {
    constructor(provider, network){
        if (provider == null) logger.throwArgumentError("missing provider", "provider", provider);
        let path = null;
        let jsonRpcFetchFunc = null;
        let subprovider = null;
        if (typeof provider === "function") {
            path = "unknown:";
            jsonRpcFetchFunc = provider;
        } else {
            path = provider.host || provider.path || "";
            if (!path && provider.isMetaMask) path = "metamask";
            subprovider = provider;
            if (provider.request) {
                if (path === "") path = "eip-1193:";
                jsonRpcFetchFunc = buildEip1193Fetcher(provider);
            } else if (provider.sendAsync) jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
            else if (provider.send) jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
            else logger.throwArgumentError("unsupported provider", "provider", provider);
            if (!path) path = "unknown:";
        }
        super(path, network);
        (0, _properties.defineReadOnly)(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
        (0, _properties.defineReadOnly)(this, "provider", subprovider);
    }
    send(method, params) {
        return this.jsonRpcFetchFunc(method, params);
    }
}

},{"@ethersproject/properties":"2X633","@ethersproject/logger":"9rXfv","./_version":"bmrdP","./json-rpc-provider":"9mdlH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hCPYQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultGasForArbitrum", ()=>o);
parcelHelpers.export(exports, "isArbitrum", ()=>a);
var _bignumber = require("@ethersproject/bignumber");
var _chains = require("@privy-io/chains");
var _ethersMjs = require("../utils/ethers.mjs");
const a = (r)=>[
        (0, _chains.arbitrum).id,
        (0, _chains.arbitrumSepolia).id
    ].includes(r), o = async (e, t)=>{
    if (!a(e.chainId)) throw Error("Invalid chain ID for Arbitrum gas estimation.");
    if (void 0 === e.type && (e.type = 2), e.maxFeePerGas) return e;
    try {
        let { lastBaseFeePerGas: a } = await t.getFeeData();
        if (a) {
            let t = a.mul((0, _bignumber.BigNumber).from(120)).div((0, _bignumber.BigNumber).from(100));
            e.maxFeePerGas = (0, _ethersMjs.convertBigNumberish)(t), e.maxPriorityFeePerGas = (0, _ethersMjs.convertBigNumberish)((0, _bignumber.BigNumber).from(0));
        }
    } catch (r) {
        throw Error(`Failed to set gas price for Arbitrum transaction: ${r}.`);
    }
    return e;
};

},{"@ethersproject/bignumber":"gSTRF","@privy-io/chains":"9r5Tr","../utils/ethers.mjs":"1PLH5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1PLH5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "QuantityToBigNumber", ()=>i);
parcelHelpers.export(exports, "convertBigNumberish", ()=>t);
parcelHelpers.export(exports, "toEthersUnsignedTransaction", ()=>r);
var _bignumber = require("@ethersproject/bignumber");
const i = (i)=>(0, _bignumber.BigNumber).from(i);
function t(e) {
    if ("number" == typeof e || "bigint" == typeof e || "string" == typeof e) return e;
    if ("function" == typeof e.toHexString) return e.toHexString();
    throw Error(`Expected numeric value but received ${e}`);
}
function r(e) {
    let t = {};
    return void 0 !== e.to && (t.to = e.to), void 0 !== e.data && (t.data = e.data), void 0 !== e.chainId && (t.chainId = e.chainId), void 0 !== e.type && (t.type = e.type), void 0 !== e.accessList && (t.accessList = e.accessList), void 0 !== e.nonce && (t.nonce = i(e.nonce).toNumber()), void 0 !== e.gasLimit && (t.gasLimit = i(e.gasLimit)), void 0 !== e.gasPrice && (t.gasPrice = i(e.gasPrice)), void 0 !== e.value && (t.value = i(e.value)), void 0 !== e.maxFeePerGas && (t.maxFeePerGas = i(e.maxFeePerGas)), void 0 !== e.maxPriorityFeePerGas && (t.maxPriorityFeePerGas = i(e.maxPriorityFeePerGas)), t;
}

},{"@ethersproject/bignumber":"gSTRF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hbFMz":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultGasForBsc", ()=>i);
parcelHelpers.export(exports, "isBsc", ()=>e);
const e = (e)=>[
        56,
        97
    ].includes(e), i = async (i, t)=>{
    if (!e(i.chainId)) throw Error("Invalid chain ID for BSC gas estimation.");
    if (void 0 === i.type ? i.type = 0 : (1 == i.type || 2 == i.type) && console.warn("Transaction request type specified is incompatible for chain and will result in undefined behavior.  Please use transaction type 0."), !i.gasPrice) {
        let e = await t.getFeeData();
        i.gasPrice = e.gasPrice?.toHexString();
    }
    return i;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"KVI98":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "OPTIMISM_STACK_GAS_PRICE_ORACLE_ABI", ()=>f);
parcelHelpers.export(exports, "OPTIMISM_STACK_GAS_PRICE_ORACLE_ADDRESS", ()=>l);
parcelHelpers.export(exports, "defaultGasForOpStack", ()=>F);
parcelHelpers.export(exports, "estimateOpStackL1Gas", ()=>x);
parcelHelpers.export(exports, "isOpStack", ()=>h);
var _bignumber = require("@ethersproject/bignumber");
var _contracts = require("@ethersproject/contracts");
var _transactions = require("@ethersproject/transactions");
var _chains = require("@privy-io/chains");
var _ethersMjs = require("../utils/ethers.mjs");
const l = "0x420000000000000000000000000000000000000F", f = [
    "function getL1Fee(bytes memory _data) external view returns (uint256)"
], h = (e)=>[
        (0, _chains.base).id,
        (0, _chains.baseSepolia).id,
        (0, _chains.optimism).id,
        (0, _chains.optimismSepolia).id,
        (0, _chains.zora).id,
        (0, _chains.zoraTestnet).id,
        (0, _chains.zoraSepolia).id,
        81457,
        168587773
    ].includes(e), F = async (r, a)=>{
    if (!h(r.chainId)) throw Error("Invalid chain ID for OP Stack gas estimation.");
    if (void 0 === r.type && (r.type = 2), r.gasPrice && (console.warn("`gasPrice` is not supported on this chain and will be ignored. Use `maxPriorityFeePerGas` and/or `maxFeePerGas` instead."), delete r.gasPrice), r.maxPriorityFeePerGas && r.maxFeePerGas) return r;
    try {
        if (!r.maxPriorityFeePerGas) {
            let e = await a.send("eth_maxPriorityFeePerGas", []);
            r.maxPriorityFeePerGas = e;
        }
        if (r.maxFeePerGas && (console.warn("maxFeePerGas is specified without maxPriorityFeePerGas - this can result in hung transactions."), r.maxPriorityFeePerGas >= r.maxFeePerGas)) throw Error("Overridden maxFeePerGas is less than or equal to the calculated maxPriorityFeePerGas. Please set both values or maxPriorityFeePerGas alone for correct gas estimation.");
        if (!r.maxFeePerGas) {
            let { lastBaseFeePerGas: t } = await a.getFeeData();
            if (!t) throw Error("Unable to fetch baseFee for last block.");
            let i = (0, _bignumber.BigNumber).from(t).mul((0, _bignumber.BigNumber).from(126)).div((0, _bignumber.BigNumber).from(100)).add((0, _bignumber.BigNumber).from(r.maxPriorityFeePerGas));
            r.maxFeePerGas = (0, _ethersMjs.convertBigNumberish)(i);
        }
    } catch (e) {
        throw Error(`Failed to set gas price for OP stack transaction: ${e}.`);
    }
    return r;
};
async function x(t, i) {
    if (!t.chainId || t.chainId && !h(t.chainId)) return (0, _bignumber.BigNumber).from(0);
    let o = (0, _bignumber.BigNumber).from(0);
    try {
        let e = new (0, _contracts.Contract)("0x420000000000000000000000000000000000000F", f, i), s = (0, _ethersMjs.toEthersUnsignedTransaction)(t), n = (0, _transactions.serialize)(s);
        o = await e.getL1Fee(n);
    } catch (e) {}
    return o;
}

},{"@ethersproject/bignumber":"gSTRF","@ethersproject/contracts":"26Zqo","@ethersproject/transactions":"lqSCl","@privy-io/chains":"9r5Tr","../utils/ethers.mjs":"1PLH5","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"26Zqo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BaseContract", ()=>BaseContract);
parcelHelpers.export(exports, "Contract", ()=>Contract);
parcelHelpers.export(exports, "ContractFactory", ()=>ContractFactory);
var _abi = require("@ethersproject/abi");
var _abstractProvider = require("@ethersproject/abstract-provider");
var _abstractSigner = require("@ethersproject/abstract-signer");
var _address = require("@ethersproject/address");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _transactions = require("@ethersproject/transactions");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
var __awaiter = undefined && undefined.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const logger = new (0, _logger.Logger)((0, _version.version));
///////////////////////////////
const allowedTransactionKeys = {
    chainId: true,
    data: true,
    from: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    value: true,
    type: true,
    accessList: true,
    maxFeePerGas: true,
    maxPriorityFeePerGas: true,
    customData: true,
    ccipReadEnabled: true
};
function resolveName(resolver, nameOrPromise) {
    return __awaiter(this, void 0, void 0, function*() {
        const name = yield nameOrPromise;
        if (typeof name !== "string") logger.throwArgumentError("invalid address or ENS name", "name", name);
        // If it is already an address, just use it (after adding checksum)
        try {
            return (0, _address.getAddress)(name);
        } catch (error) {}
        if (!resolver) logger.throwError("a provider or signer is needed to resolve ENS names", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName"
        });
        const address = yield resolver.resolveName(name);
        if (address == null) logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
        return address;
    });
}
// Recursively replaces ENS names with promises to resolve the name and resolves all properties
function resolveAddresses(resolver, value, paramType) {
    return __awaiter(this, void 0, void 0, function*() {
        if (Array.isArray(paramType)) return yield Promise.all(paramType.map((paramType, index)=>{
            return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType.name], paramType);
        }));
        if (paramType.type === "address") return yield resolveName(resolver, value);
        if (paramType.type === "tuple") return yield resolveAddresses(resolver, value, paramType.components);
        if (paramType.baseType === "array") {
            if (!Array.isArray(value)) return Promise.reject(logger.makeError("invalid value for array", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                argument: "value",
                value
            }));
            return yield Promise.all(value.map((v)=>resolveAddresses(resolver, v, paramType.arrayChildren)));
        }
        return value;
    });
}
function populateTransaction(contract, fragment, args) {
    return __awaiter(this, void 0, void 0, function*() {
        // If an extra argument is given, it is overrides
        let overrides = {};
        if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") overrides = (0, _properties.shallowCopy)(args.pop());
        // Make sure the parameter count matches
        logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
        // Populate "from" override (allow promises)
        if (contract.signer) {
            if (overrides.from) // Contracts with a Signer are from the Signer's frame-of-reference;
            // but we allow overriding "from" if it matches the signer
            overrides.from = (0, _properties.resolveProperties)({
                override: resolveName(contract.signer, overrides.from),
                signer: contract.signer.getAddress()
            }).then((check)=>__awaiter(this, void 0, void 0, function*() {
                    if ((0, _address.getAddress)(check.signer) !== check.override) logger.throwError("Contract with a Signer cannot override from", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                        operation: "overrides.from"
                    });
                    return check.override;
                }));
            else overrides.from = contract.signer.getAddress();
        } else if (overrides.from) overrides.from = resolveName(contract.provider, overrides.from);
        // Wait for all dependencies to be resolved (prefer the signer over the provider)
        const resolved = yield (0, _properties.resolveProperties)({
            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
            address: contract.resolvedAddress,
            overrides: (0, _properties.resolveProperties)(overrides) || {}
        });
        // The ABI coded transaction
        const data = contract.interface.encodeFunctionData(fragment, resolved.args);
        const tx = {
            data: data,
            to: resolved.address
        };
        // Resolved Overrides
        const ro = resolved.overrides;
        // Populate simple overrides
        if (ro.nonce != null) tx.nonce = (0, _bignumber.BigNumber).from(ro.nonce).toNumber();
        if (ro.gasLimit != null) tx.gasLimit = (0, _bignumber.BigNumber).from(ro.gasLimit);
        if (ro.gasPrice != null) tx.gasPrice = (0, _bignumber.BigNumber).from(ro.gasPrice);
        if (ro.maxFeePerGas != null) tx.maxFeePerGas = (0, _bignumber.BigNumber).from(ro.maxFeePerGas);
        if (ro.maxPriorityFeePerGas != null) tx.maxPriorityFeePerGas = (0, _bignumber.BigNumber).from(ro.maxPriorityFeePerGas);
        if (ro.from != null) tx.from = ro.from;
        if (ro.type != null) tx.type = ro.type;
        if (ro.accessList != null) tx.accessList = (0, _transactions.accessListify)(ro.accessList);
        // If there was no "gasLimit" override, but the ABI specifies a default, use it
        if (tx.gasLimit == null && fragment.gas != null) {
            // Compute the intrinsic gas cost for this transaction
            // @TODO: This is based on the yellow paper as of Petersburg; this is something
            // we may wish to parameterize in v6 as part of the Network object. Since this
            // is always a non-nil to address, we can ignore G_create, but may wish to add
            // similar logic to the ContractFactory.
            let intrinsic = 21000;
            const bytes = (0, _bytes.arrayify)(data);
            for(let i = 0; i < bytes.length; i++){
                intrinsic += 4;
                if (bytes[i]) intrinsic += 64;
            }
            tx.gasLimit = (0, _bignumber.BigNumber).from(fragment.gas).add(intrinsic);
        }
        // Populate "value" override
        if (ro.value) {
            const roValue = (0, _bignumber.BigNumber).from(ro.value);
            if (!roValue.isZero() && !fragment.payable) logger.throwError("non-payable method cannot override value", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.value",
                value: overrides.value
            });
            tx.value = roValue;
        }
        if (ro.customData) tx.customData = (0, _properties.shallowCopy)(ro.customData);
        if (ro.ccipReadEnabled) tx.ccipReadEnabled = !!ro.ccipReadEnabled;
        // Remove the overrides
        delete overrides.nonce;
        delete overrides.gasLimit;
        delete overrides.gasPrice;
        delete overrides.from;
        delete overrides.value;
        delete overrides.type;
        delete overrides.accessList;
        delete overrides.maxFeePerGas;
        delete overrides.maxPriorityFeePerGas;
        delete overrides.customData;
        delete overrides.ccipReadEnabled;
        // Make sure there are no stray overrides, which may indicate a
        // typo or using an unsupported key.
        const leftovers = Object.keys(overrides).filter((key)=>overrides[key] != null);
        if (leftovers.length) logger.throwError(`cannot override ${leftovers.map((l)=>JSON.stringify(l)).join(",")}`, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "overrides",
            overrides: leftovers
        });
        return tx;
    });
}
function buildPopulate(contract, fragment) {
    return function(...args) {
        return populateTransaction(contract, fragment, args);
    };
}
function buildEstimate(contract, fragment) {
    const signerOrProvider = contract.signer || contract.provider;
    return function(...args) {
        return __awaiter(this, void 0, void 0, function*() {
            if (!signerOrProvider) logger.throwError("estimate require a provider or signer", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "estimateGas"
            });
            const tx = yield populateTransaction(contract, fragment, args);
            return yield signerOrProvider.estimateGas(tx);
        });
    };
}
function addContractWait(contract, tx) {
    const wait = tx.wait.bind(tx);
    tx.wait = (confirmations)=>{
        return wait(confirmations).then((receipt)=>{
            receipt.events = receipt.logs.map((log)=>{
                let event = (0, _properties.deepCopy)(log);
                let parsed = null;
                try {
                    parsed = contract.interface.parseLog(log);
                } catch (e) {}
                // Successfully parsed the event log; include it
                if (parsed) {
                    event.args = parsed.args;
                    event.decode = (data, topics)=>{
                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
                    };
                    event.event = parsed.name;
                    event.eventSignature = parsed.signature;
                }
                // Useful operations
                event.removeListener = ()=>{
                    return contract.provider;
                };
                event.getBlock = ()=>{
                    return contract.provider.getBlock(receipt.blockHash);
                };
                event.getTransaction = ()=>{
                    return contract.provider.getTransaction(receipt.transactionHash);
                };
                event.getTransactionReceipt = ()=>{
                    return Promise.resolve(receipt);
                };
                return event;
            });
            return receipt;
        });
    };
}
function buildCall(contract, fragment, collapseSimple) {
    const signerOrProvider = contract.signer || contract.provider;
    return function(...args) {
        return __awaiter(this, void 0, void 0, function*() {
            // Extract the "blockTag" override if present
            let blockTag = undefined;
            if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
                const overrides = (0, _properties.shallowCopy)(args.pop());
                if (overrides.blockTag != null) blockTag = yield overrides.blockTag;
                delete overrides.blockTag;
                args.push(overrides);
            }
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) yield contract._deployed(blockTag);
            // Call a node and get the result
            const tx = yield populateTransaction(contract, fragment, args);
            const result = yield signerOrProvider.call(tx, blockTag);
            try {
                let value = contract.interface.decodeFunctionResult(fragment, result);
                if (collapseSimple && fragment.outputs.length === 1) value = value[0];
                return value;
            } catch (error) {
                if (error.code === (0, _logger.Logger).errors.CALL_EXCEPTION) {
                    error.address = contract.address;
                    error.args = args;
                    error.transaction = tx;
                }
                throw error;
            }
        });
    };
}
function buildSend(contract, fragment) {
    return function(...args) {
        return __awaiter(this, void 0, void 0, function*() {
            if (!contract.signer) logger.throwError("sending a transaction requires a signer", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "sendTransaction"
            });
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) yield contract._deployed();
            const txRequest = yield populateTransaction(contract, fragment, args);
            const tx = yield contract.signer.sendTransaction(txRequest);
            // Tweak the tx.wait so the receipt has extra properties
            addContractWait(contract, tx);
            return tx;
        });
    };
}
function buildDefault(contract, fragment, collapseSimple) {
    if (fragment.constant) return buildCall(contract, fragment, collapseSimple);
    return buildSend(contract, fragment);
}
function getEventTag(filter) {
    if (filter.address && (filter.topics == null || filter.topics.length === 0)) return "*";
    return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic)=>{
        if (Array.isArray(topic)) return topic.join("|");
        return topic;
    }).join(":") : "");
}
class RunningEvent {
    constructor(tag, filter){
        (0, _properties.defineReadOnly)(this, "tag", tag);
        (0, _properties.defineReadOnly)(this, "filter", filter);
        this._listeners = [];
    }
    addListener(listener, once) {
        this._listeners.push({
            listener: listener,
            once: once
        });
    }
    removeListener(listener) {
        let done = false;
        this._listeners = this._listeners.filter((item)=>{
            if (done || item.listener !== listener) return true;
            done = true;
            return false;
        });
    }
    removeAllListeners() {
        this._listeners = [];
    }
    listeners() {
        return this._listeners.map((i)=>i.listener);
    }
    listenerCount() {
        return this._listeners.length;
    }
    run(args) {
        const listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter((item)=>{
            const argsCopy = args.slice();
            // Call the callback in the next event loop
            setTimeout(()=>{
                item.listener.apply(this, argsCopy);
            }, 0);
            // Reschedule it if it not "once"
            return !item.once;
        });
        return listenerCount;
    }
    prepareEvent(event) {}
    // Returns the array that will be applied to an emit
    getEmit(event) {
        return [
            event
        ];
    }
}
class ErrorRunningEvent extends RunningEvent {
    constructor(){
        super("error", null);
    }
}
// @TODO Fragment should inherit Wildcard? and just override getEmit?
//       or have a common abstract super class, with enough constructor
//       options to configure both.
// A Fragment Event will populate all the properties that Wildcard
// will, and additionally dereference the arguments when emitting
class FragmentRunningEvent extends RunningEvent {
    constructor(address, contractInterface, fragment, topics){
        const filter = {
            address: address
        };
        let topic = contractInterface.getEventTopic(fragment);
        if (topics) {
            if (topic !== topics[0]) logger.throwArgumentError("topic mismatch", "topics", topics);
            filter.topics = topics.slice();
        } else filter.topics = [
            topic
        ];
        super(getEventTag(filter), filter);
        (0, _properties.defineReadOnly)(this, "address", address);
        (0, _properties.defineReadOnly)(this, "interface", contractInterface);
        (0, _properties.defineReadOnly)(this, "fragment", fragment);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = (data, topics)=>{
            return this.interface.decodeEventLog(this.fragment, data, topics);
        };
        try {
            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        } catch (error) {
            event.args = null;
            event.decodeError = error;
        }
    }
    getEmit(event) {
        const errors = (0, _abi.checkResultErrors)(event.args);
        if (errors.length) throw errors[0].error;
        const args = (event.args || []).slice();
        args.push(event);
        return args;
    }
}
// A Wildcard Event will attempt to populate:
//  - event            The name of the event name
//  - eventSignature   The full signature of the event
//  - decode           A function to decode data and topics
//  - args             The decoded data and topics
class WildcardRunningEvent extends RunningEvent {
    constructor(address, contractInterface){
        super("*", {
            address: address
        });
        (0, _properties.defineReadOnly)(this, "address", address);
        (0, _properties.defineReadOnly)(this, "interface", contractInterface);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        try {
            const parsed = this.interface.parseLog(event);
            event.event = parsed.name;
            event.eventSignature = parsed.signature;
            event.decode = (data, topics)=>{
                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
            };
            event.args = parsed.args;
        } catch (error) {
        // No matching event
        }
    }
}
class BaseContract {
    constructor(addressOrName, contractInterface, signerOrProvider){
        // @TODO: Maybe still check the addressOrName looks like a valid address or name?
        //address = getAddress(address);
        (0, _properties.defineReadOnly)(this, "interface", (0, _properties.getStatic)(new.target, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
            (0, _properties.defineReadOnly)(this, "provider", null);
            (0, _properties.defineReadOnly)(this, "signer", null);
        } else if ((0, _abstractSigner.Signer).isSigner(signerOrProvider)) {
            (0, _properties.defineReadOnly)(this, "provider", signerOrProvider.provider || null);
            (0, _properties.defineReadOnly)(this, "signer", signerOrProvider);
        } else if ((0, _abstractProvider.Provider).isProvider(signerOrProvider)) {
            (0, _properties.defineReadOnly)(this, "provider", signerOrProvider);
            (0, _properties.defineReadOnly)(this, "signer", null);
        } else logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        (0, _properties.defineReadOnly)(this, "callStatic", {});
        (0, _properties.defineReadOnly)(this, "estimateGas", {});
        (0, _properties.defineReadOnly)(this, "functions", {});
        (0, _properties.defineReadOnly)(this, "populateTransaction", {});
        (0, _properties.defineReadOnly)(this, "filters", {});
        {
            const uniqueFilters = {};
            Object.keys(this.interface.events).forEach((eventSignature)=>{
                const event = this.interface.events[eventSignature];
                (0, _properties.defineReadOnly)(this.filters, eventSignature, (...args)=>{
                    return {
                        address: this.address,
                        topics: this.interface.encodeFilterTopics(event, args)
                    };
                });
                if (!uniqueFilters[event.name]) uniqueFilters[event.name] = [];
                uniqueFilters[event.name].push(eventSignature);
            });
            Object.keys(uniqueFilters).forEach((name)=>{
                const filters = uniqueFilters[name];
                if (filters.length === 1) (0, _properties.defineReadOnly)(this.filters, name, this.filters[filters[0]]);
                else logger.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
            });
        }
        (0, _properties.defineReadOnly)(this, "_runningEvents", {});
        (0, _properties.defineReadOnly)(this, "_wrappedEmits", {});
        if (addressOrName == null) logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        (0, _properties.defineReadOnly)(this, "address", addressOrName);
        if (this.provider) (0, _properties.defineReadOnly)(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        else try {
            (0, _properties.defineReadOnly)(this, "resolvedAddress", Promise.resolve((0, _address.getAddress)(addressOrName)));
        } catch (error) {
            // Without a provider, we cannot use ENS names
            logger.throwError("provider is required to use ENS name as contract address", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "new Contract"
            });
        }
        // Swallow bad ENS names to prevent Unhandled Exceptions
        this.resolvedAddress.catch((e)=>{});
        const uniqueNames = {};
        const uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach((signature)=>{
            const fragment = this.interface.functions[signature];
            // Check that the signature is unique; if not the ABI generation has
            // not been cleaned or may be incorrectly generated
            if (uniqueSignatures[signature]) {
                logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
                return;
            }
            uniqueSignatures[signature] = true;
            // Track unique names; we only expose bare named functions if they
            // are ambiguous
            {
                const name = fragment.name;
                if (!uniqueNames[`%${name}`]) uniqueNames[`%${name}`] = [];
                uniqueNames[`%${name}`].push(signature);
            }
            if (this[signature] == null) (0, _properties.defineReadOnly)(this, signature, buildDefault(this, fragment, true));
            // We do not collapse simple calls on this bucket, which allows
            // frameworks to safely use this without introspection as well as
            // allows decoding error recovery.
            if (this.functions[signature] == null) (0, _properties.defineReadOnly)(this.functions, signature, buildDefault(this, fragment, false));
            if (this.callStatic[signature] == null) (0, _properties.defineReadOnly)(this.callStatic, signature, buildCall(this, fragment, true));
            if (this.populateTransaction[signature] == null) (0, _properties.defineReadOnly)(this.populateTransaction, signature, buildPopulate(this, fragment));
            if (this.estimateGas[signature] == null) (0, _properties.defineReadOnly)(this.estimateGas, signature, buildEstimate(this, fragment));
        });
        Object.keys(uniqueNames).forEach((name)=>{
            // Ambiguous names to not get attached as bare names
            const signatures = uniqueNames[name];
            if (signatures.length > 1) return;
            // Strip off the leading "%" used for prototype protection
            name = name.substring(1);
            const signature = signatures[0];
            // If overwriting a member property that is null, swallow the error
            try {
                if (this[name] == null) (0, _properties.defineReadOnly)(this, name, this[signature]);
            } catch (e) {}
            if (this.functions[name] == null) (0, _properties.defineReadOnly)(this.functions, name, this.functions[signature]);
            if (this.callStatic[name] == null) (0, _properties.defineReadOnly)(this.callStatic, name, this.callStatic[signature]);
            if (this.populateTransaction[name] == null) (0, _properties.defineReadOnly)(this.populateTransaction, name, this.populateTransaction[signature]);
            if (this.estimateGas[name] == null) (0, _properties.defineReadOnly)(this.estimateGas, name, this.estimateGas[signature]);
        });
    }
    static getContractAddress(transaction) {
        return (0, _address.getContractAddress)(transaction);
    }
    static getInterface(contractInterface) {
        if ((0, _abi.Interface).isInterface(contractInterface)) return contractInterface;
        return new (0, _abi.Interface)(contractInterface);
    }
    // @TODO: Allow timeout?
    deployed() {
        return this._deployed();
    }
    _deployed(blockTag) {
        if (!this._deployedPromise) {
            // If we were just deployed, we know the transaction we should occur in
            if (this.deployTransaction) this._deployedPromise = this.deployTransaction.wait().then(()=>{
                return this;
            });
            else // @TODO: Once we allow a timeout to be passed in, we will wait
            // up to that many blocks for getCode
            // Otherwise, poll for our code to be deployed
            this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code)=>{
                if (code === "0x") logger.throwError("contract not deployed", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                    contractAddress: this.address,
                    operation: "getDeployed"
                });
                return this;
            });
        }
        return this._deployedPromise;
    }
    // @TODO:
    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
    // @TODO:
    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
    fallback(overrides) {
        if (!this.signer) logger.throwError("sending a transactions require a signer", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "sendTransaction(fallback)"
        });
        const tx = (0, _properties.shallowCopy)(overrides || {});
        [
            "from",
            "to"
        ].forEach(function(key) {
            if (tx[key] == null) return;
            logger.throwError("cannot override " + key, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: key
            });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(()=>{
            return this.signer.sendTransaction(tx);
        });
    }
    // Reconnect to a different signer or provider
    connect(signerOrProvider) {
        if (typeof signerOrProvider === "string") signerOrProvider = new (0, _abstractSigner.VoidSigner)(signerOrProvider, this.provider);
        const contract = new this.constructor(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) (0, _properties.defineReadOnly)(contract, "deployTransaction", this.deployTransaction);
        return contract;
    }
    // Re-attach to a different on-chain instance of this contract
    attach(addressOrName) {
        return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
    }
    static isIndexed(value) {
        return (0, _abi.Indexed).isIndexed(value);
    }
    _normalizeRunningEvent(runningEvent) {
        // Already have an instance of this event running; we can re-use it
        if (this._runningEvents[runningEvent.tag]) return this._runningEvents[runningEvent.tag];
        return runningEvent;
    }
    _getRunningEvent(eventName) {
        if (typeof eventName === "string") {
            // Listen for "error" events (if your contract has an error event, include
            // the full signature to bypass this special event keyword)
            if (eventName === "error") return this._normalizeRunningEvent(new ErrorRunningEvent());
            // Listen for any event that is registered
            if (eventName === "event") return this._normalizeRunningEvent(new RunningEvent("event", null));
            // Listen for any event
            if (eventName === "*") return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
            // Get the event Fragment (throws if ambiguous/unknown event)
            const fragment = this.interface.getEvent(eventName);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        // We have topics to filter by...
        if (eventName.topics && eventName.topics.length > 0) {
            // Is it a known topichash? (throws if no matching topichash)
            try {
                const topic = eventName.topics[0];
                if (typeof topic !== "string") throw new Error("invalid topic"); // @TODO: May happen for anonymous events
                const fragment = this.interface.getEvent(topic);
                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
            } catch (error) {}
            // Filter by the unknown topichash
            const filter = {
                address: this.address,
                topics: eventName.topics
            };
            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
    }
    _checkRunningEvents(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
            delete this._runningEvents[runningEvent.tag];
            // If we have a poller for this, remove it
            const emit = this._wrappedEmits[runningEvent.tag];
            if (emit && runningEvent.filter) {
                this.provider.off(runningEvent.filter, emit);
                delete this._wrappedEmits[runningEvent.tag];
            }
        }
    }
    // Subclasses can override this to gracefully recover
    // from parse errors if they wish
    _wrapEvent(runningEvent, log, listener) {
        const event = (0, _properties.deepCopy)(log);
        event.removeListener = ()=>{
            if (!listener) return;
            runningEvent.removeListener(listener);
            this._checkRunningEvents(runningEvent);
        };
        event.getBlock = ()=>{
            return this.provider.getBlock(log.blockHash);
        };
        event.getTransaction = ()=>{
            return this.provider.getTransaction(log.transactionHash);
        };
        event.getTransactionReceipt = ()=>{
            return this.provider.getTransactionReceipt(log.transactionHash);
        };
        // This may throw if the topics and data mismatch the signature
        runningEvent.prepareEvent(event);
        return event;
    }
    _addEventListener(runningEvent, listener, once) {
        if (!this.provider) logger.throwError("events require a provider or a signer with a provider", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "once"
        });
        runningEvent.addListener(listener, once);
        // Track this running event and its listeners (may already be there; but no harm in updating)
        this._runningEvents[runningEvent.tag] = runningEvent;
        // If we are not polling the provider, start polling
        if (!this._wrappedEmits[runningEvent.tag]) {
            const wrappedEmit = (log)=>{
                let event = this._wrapEvent(runningEvent, log, listener);
                // Try to emit the result for the parameterized event...
                if (event.decodeError == null) try {
                    const args = runningEvent.getEmit(event);
                    this.emit(runningEvent.filter, ...args);
                } catch (error) {
                    event.decodeError = error.error;
                }
                // Always emit "event" for fragment-base events
                if (runningEvent.filter != null) this.emit("event", event);
                // Emit "error" if there was an error
                if (event.decodeError != null) this.emit("error", event.decodeError, event);
            };
            this._wrappedEmits[runningEvent.tag] = wrappedEmit;
            // Special events, like "error" do not have a filter
            if (runningEvent.filter != null) this.provider.on(runningEvent.filter, wrappedEmit);
        }
    }
    queryFilter(event, fromBlockOrBlockhash, toBlock) {
        const runningEvent = this._getRunningEvent(event);
        const filter = (0, _properties.shallowCopy)(runningEvent.filter);
        if (typeof fromBlockOrBlockhash === "string" && (0, _bytes.isHexString)(fromBlockOrBlockhash, 32)) {
            if (toBlock != null) logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
            filter.blockHash = fromBlockOrBlockhash;
        } else {
            filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
            filter.toBlock = toBlock != null ? toBlock : "latest";
        }
        return this.provider.getLogs(filter).then((logs)=>{
            return logs.map((log)=>this._wrapEvent(runningEvent, log, null));
        });
    }
    on(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
    }
    once(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
    }
    emit(eventName, ...args) {
        if (!this.provider) return false;
        const runningEvent = this._getRunningEvent(eventName);
        const result = runningEvent.run(args) > 0;
        // May have drained all the "once" events; check for living events
        this._checkRunningEvents(runningEvent);
        return result;
    }
    listenerCount(eventName) {
        if (!this.provider) return 0;
        if (eventName == null) return Object.keys(this._runningEvents).reduce((accum, key)=>{
            return accum + this._runningEvents[key].listenerCount();
        }, 0);
        return this._getRunningEvent(eventName).listenerCount();
    }
    listeners(eventName) {
        if (!this.provider) return [];
        if (eventName == null) {
            const result = [];
            for(let tag in this._runningEvents)this._runningEvents[tag].listeners().forEach((listener)=>{
                result.push(listener);
            });
            return result;
        }
        return this._getRunningEvent(eventName).listeners();
    }
    removeAllListeners(eventName) {
        if (!this.provider) return this;
        if (eventName == null) {
            for(const tag in this._runningEvents){
                const runningEvent = this._runningEvents[tag];
                runningEvent.removeAllListeners();
                this._checkRunningEvents(runningEvent);
            }
            return this;
        }
        // Delete any listeners
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
    }
    off(eventName, listener) {
        if (!this.provider) return this;
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
    }
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
}
class Contract extends BaseContract {
}
class ContractFactory {
    constructor(contractInterface, bytecode, signer){
        let bytecodeHex = null;
        if (typeof bytecode === "string") bytecodeHex = bytecode;
        else if ((0, _bytes.isBytes)(bytecode)) bytecodeHex = (0, _bytes.hexlify)(bytecode);
        else if (bytecode && typeof bytecode.object === "string") // Allow the bytecode object from the Solidity compiler
        bytecodeHex = bytecode.object;
        else // Crash in the next verification step
        bytecodeHex = "!";
        // Make sure it is 0x prefixed
        if (bytecodeHex.substring(0, 2) !== "0x") bytecodeHex = "0x" + bytecodeHex;
        // Make sure the final result is valid bytecode
        if (!(0, _bytes.isHexString)(bytecodeHex) || bytecodeHex.length % 2) logger.throwArgumentError("invalid bytecode", "bytecode", bytecode);
        // If we have a signer, make sure it is valid
        if (signer && !(0, _abstractSigner.Signer).isSigner(signer)) logger.throwArgumentError("invalid signer", "signer", signer);
        (0, _properties.defineReadOnly)(this, "bytecode", bytecodeHex);
        (0, _properties.defineReadOnly)(this, "interface", (0, _properties.getStatic)(new.target, "getInterface")(contractInterface));
        (0, _properties.defineReadOnly)(this, "signer", signer || null);
    }
    // @TODO: Future; rename to populateTransaction?
    getDeployTransaction(...args) {
        let tx = {};
        // If we have 1 additional argument, we allow transaction overrides
        if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
            tx = (0, _properties.shallowCopy)(args.pop());
            for(const key in tx){
                if (!allowedTransactionKeys[key]) throw new Error("unknown transaction override " + key);
            }
        }
        // Do not allow these to be overridden in a deployment transaction
        [
            "data",
            "from",
            "to"
        ].forEach((key)=>{
            if (tx[key] == null) return;
            logger.throwError("cannot override " + key, (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: key
            });
        });
        if (tx.value) {
            const value = (0, _bignumber.BigNumber).from(tx.value);
            if (!value.isZero() && !this.interface.deploy.payable) logger.throwError("non-payable constructor cannot override value", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.value",
                value: tx.value
            });
        }
        // Make sure the call matches the constructor signature
        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        // Set the data to the bytecode + the encoded constructor arguments
        tx.data = (0, _bytes.hexlify)((0, _bytes.concat)([
            this.bytecode,
            this.interface.encodeDeploy(args)
        ]));
        return tx;
    }
    deploy(...args) {
        return __awaiter(this, void 0, void 0, function*() {
            let overrides = {};
            // If 1 extra parameter was passed in, it contains overrides
            if (args.length === this.interface.deploy.inputs.length + 1) overrides = args.pop();
            // Make sure the call matches the constructor signature
            logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
            // Resolve ENS names and promises in the arguments
            const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
            params.push(overrides);
            // Get the deployment transaction (with optional overrides)
            const unsignedTx = this.getDeployTransaction(...params);
            // Send the deployment transaction
            const tx = yield this.signer.sendTransaction(unsignedTx);
            const address = (0, _properties.getStatic)(this.constructor, "getContractAddress")(tx);
            const contract = (0, _properties.getStatic)(this.constructor, "getContract")(address, this.interface, this.signer);
            // Add the modified wait that wraps events
            addContractWait(contract, tx);
            (0, _properties.defineReadOnly)(contract, "deployTransaction", tx);
            return contract;
        });
    }
    attach(address) {
        return this.constructor.getContract(address, this.interface, this.signer);
    }
    connect(signer) {
        return new this.constructor(this.interface, this.bytecode, signer);
    }
    static fromSolidity(compilerOutput, signer) {
        if (compilerOutput == null) logger.throwError("missing compiler output", (0, _logger.Logger).errors.MISSING_ARGUMENT, {
            argument: "compilerOutput"
        });
        if (typeof compilerOutput === "string") compilerOutput = JSON.parse(compilerOutput);
        const abi = compilerOutput.abi;
        let bytecode = null;
        if (compilerOutput.bytecode) bytecode = compilerOutput.bytecode;
        else if (compilerOutput.evm && compilerOutput.evm.bytecode) bytecode = compilerOutput.evm.bytecode;
        return new this(abi, bytecode, signer);
    }
    static getInterface(contractInterface) {
        return Contract.getInterface(contractInterface);
    }
    static getContractAddress(tx) {
        return (0, _address.getContractAddress)(tx);
    }
    static getContract(address, contractInterface, signer) {
        return new Contract(address, contractInterface, signer);
    }
}

},{"@ethersproject/abi":"eYc9q","@ethersproject/abstract-provider":"fYevg","@ethersproject/abstract-signer":"bq0ju","@ethersproject/address":"9Jgcg","@ethersproject/bignumber":"gSTRF","@ethersproject/bytes":"5ReBN","@ethersproject/properties":"2X633","@ethersproject/transactions":"lqSCl","@ethersproject/logger":"9rXfv","./_version":"hy1mJ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eYc9q":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ConstructorFragment", ()=>(0, _fragments.ConstructorFragment));
parcelHelpers.export(exports, "ErrorFragment", ()=>(0, _fragments.ErrorFragment));
parcelHelpers.export(exports, "EventFragment", ()=>(0, _fragments.EventFragment));
parcelHelpers.export(exports, "Fragment", ()=>(0, _fragments.Fragment));
parcelHelpers.export(exports, "FunctionFragment", ()=>(0, _fragments.FunctionFragment));
parcelHelpers.export(exports, "ParamType", ()=>(0, _fragments.ParamType));
parcelHelpers.export(exports, "FormatTypes", ()=>(0, _fragments.FormatTypes));
parcelHelpers.export(exports, "AbiCoder", ()=>(0, _abiCoder.AbiCoder));
parcelHelpers.export(exports, "defaultAbiCoder", ()=>(0, _abiCoder.defaultAbiCoder));
parcelHelpers.export(exports, "Interface", ()=>(0, _interface.Interface));
parcelHelpers.export(exports, "Indexed", ()=>(0, _interface.Indexed));
parcelHelpers.export(exports, "checkResultErrors", ()=>(0, _interface.checkResultErrors));
parcelHelpers.export(exports, "LogDescription", ()=>(0, _interface.LogDescription));
parcelHelpers.export(exports, "TransactionDescription", ()=>(0, _interface.TransactionDescription));
var _fragments = require("./fragments");
var _abiCoder = require("./abi-coder");
var _interface = require("./interface");
"use strict";

},{"./fragments":false,"./abi-coder":false,"./interface":"2L9wy","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f0Wfs":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FormatTypes", ()=>FormatTypes);
parcelHelpers.export(exports, "ParamType", ()=>ParamType);
parcelHelpers.export(exports, "Fragment", ()=>Fragment);
parcelHelpers.export(exports, "EventFragment", ()=>EventFragment);
parcelHelpers.export(exports, "ConstructorFragment", ()=>ConstructorFragment);
parcelHelpers.export(exports, "FunctionFragment", ()=>FunctionFragment);
parcelHelpers.export(exports, "ErrorFragment", ()=>ErrorFragment);
var _bignumber = require("@ethersproject/bignumber");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const _constructorGuard = {};
let ModifiersBytes = {
    calldata: true,
    memory: true,
    storage: true
};
let ModifiersNest = {
    calldata: true,
    memory: true
};
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) return true;
    } else if (type === "address") {
        if (name === "payable") return true;
    } else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) return true;
    }
    if (ModifiersBytes[name] || name === "payable") logger.throwArgumentError("invalid modifier", "name", name);
    return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i) {
        logger.throwArgumentError(`unexpected character at position ${i}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        let node = {
            type: "",
            name: "",
            parent: parent,
            state: {
                allowType: true
            }
        };
        if (allowIndexed) node.indexed = false;
        return node;
    }
    let parent = {
        type: "",
        name: "",
        state: {
            allowType: true
        }
    };
    let node = parent;
    for(let i = 0; i < param.length; i++){
        let c = param[i];
        switch(c){
            case "(":
                if (node.state.allowType && node.type === "") node.type = "tuple";
                else if (!node.state.allowParams) throwError(i);
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [
                    newNode(node)
                ];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) throwError(i);
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) node.name = "";
                node.type = verifyType(node.type);
                let child = node;
                node = node.parent;
                if (!node) throwError(i);
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) throwError(i);
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) node.name = "";
                node.type = verifyType(node.type);
                let sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) throwError(i);
                            if (node.indexed) throwError(i);
                            node.indexed = true;
                            node.name = "";
                        } else if (checkModifier(node.type, node.name)) node.name = "";
                        else node.state.allowName = false;
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) throwError(i);
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) throwError(i);
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                } else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                } else if (node.state.readArray) node.type += c;
                else throwError(i);
        }
    }
    if (node.parent) logger.throwArgumentError("unexpected eof", "param", param);
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) throwError(originalParam.length - 7);
        if (node.indexed) throwError(originalParam.length - 7);
        node.indexed = true;
        node.name = "";
    } else if (checkModifier(node.type, node.name)) node.name = "";
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for(let key in params)(0, _properties.defineReadOnly)(object, key, params[key]);
}
const FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
    constructor(constructorGuard, params){
        if (constructorGuard !== _constructorGuard) logger.throwError("use fromString", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
        });
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) populate(this, {
            arrayLength: parseInt(match[2] || "-1"),
            arrayChildren: ParamType.fromObject({
                type: match[1],
                components: this.components
            }),
            baseType: "array"
        });
        else populate(this, {
            arrayLength: null,
            arrayChildren: null,
            baseType: this.components != null ? "tuple" : this.type
        });
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format) {
        if (!format) format = FormatTypes.sighash;
        if (!FormatTypes[format]) logger.throwArgumentError("invalid format type", "format", format);
        if (format === FormatTypes.json) {
            let result = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: this.name || undefined
            };
            if (typeof this.indexed === "boolean") result.indexed = this.indexed;
            if (this.components) result.components = this.components.map((comp)=>JSON.parse(comp.format(format)));
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        } else if (this.baseType === "tuple") {
            if (format !== FormatTypes.sighash) result += this.type;
            result += "(" + this.components.map((comp)=>comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
        } else result += this.type;
        if (format !== FormatTypes.sighash) {
            if (this.indexed === true) result += " indexed";
            if (format === FormatTypes.full && this.name) result += " " + this.name;
        }
        return result;
    }
    static from(value, allowIndexed) {
        if (typeof value === "string") return ParamType.fromString(value, allowIndexed);
        return ParamType.fromObject(value);
    }
    static fromObject(value) {
        if (ParamType.isParamType(value)) return value;
        return new ParamType(_constructorGuard, {
            name: value.name || null,
            type: verifyType(value.type),
            indexed: value.indexed == null ? null : !!value.indexed,
            components: value.components ? value.components.map(ParamType.fromObject) : null
        });
    }
    static fromString(value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
        return !!(value != null && value._isParamType);
    }
}
function parseParams(value, allowIndex) {
    return splitNesting(value).map((param)=>ParamType.fromString(param, allowIndex));
}
class Fragment {
    constructor(constructorGuard, params){
        if (constructorGuard !== _constructorGuard) logger.throwError("use a static from method", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
        });
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    static from(value) {
        if (Fragment.isFragment(value)) return value;
        if (typeof value === "string") return Fragment.fromString(value);
        return Fragment.fromObject(value);
    }
    static fromObject(value) {
        if (Fragment.isFragment(value)) return value;
        switch(value.type){
            case "function":
                return FunctionFragment.fromObject(value);
            case "event":
                return EventFragment.fromObject(value);
            case "constructor":
                return ConstructorFragment.fromObject(value);
            case "error":
                return ErrorFragment.fromObject(value);
            case "fallback":
            case "receive":
                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                return null;
        }
        return logger.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") return EventFragment.fromString(value.substring(5).trim());
        else if (value.split(" ")[0] === "function") return FunctionFragment.fromString(value.substring(8).trim());
        else if (value.split("(")[0].trim() === "constructor") return ConstructorFragment.fromString(value.trim());
        else if (value.split(" ")[0] === "error") return ErrorFragment.fromString(value.substring(5).trim());
        return logger.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
        return !!(value && value._isFragment);
    }
}
class EventFragment extends Fragment {
    format(format) {
        if (!format) format = FormatTypes.sighash;
        if (!FormatTypes[format]) logger.throwArgumentError("invalid format type", "format", format);
        if (format === FormatTypes.json) return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))
        });
        let result = "";
        if (format !== FormatTypes.sighash) result += "event ";
        result += this.name + "(" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.anonymous) result += "anonymous ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof value === "string") return EventFragment.fromString(value);
        return EventFragment.fromObject(value);
    }
    static fromObject(value) {
        if (EventFragment.isEventFragment(value)) return value;
        if (value.type !== "event") logger.throwArgumentError("invalid event object", "value", value);
        const params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
            type: "event"
        };
        return new EventFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let match = value.match(regexParen);
        if (!match) logger.throwArgumentError("invalid event string", "value", value);
        let anonymous = false;
        match[3].split(" ").forEach((modifier)=>{
            switch(modifier.trim()){
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    logger.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
        });
    }
    static isEventFragment(value) {
        return value && value._isFragment && value.type === "event";
    }
}
function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
        if (comps.length > 2) logger.throwArgumentError("invalid human-readable ABI signature", "value", value);
        if (!comps[1].match(/^[0-9]+$/)) logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        params.gas = (0, _bignumber.BigNumber).from(comps[1]);
        return comps[0];
    }
    return value;
}
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier)=>{
        switch(modifier.trim()){
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
function verifyState(value) {
    let result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
        if (value.constant != null) {
            if (!!value.constant !== result.constant) logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
        }
        // Set (and check things are consistent) the payable property
        result.payable = result.stateMutability === "payable";
        if (value.payable != null) {
            if (!!value.payable !== result.payable) logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
        }
    } else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") logger.throwArgumentError("unable to determine stateMutability", "value", value);
        result.constant = !!value.constant;
        if (result.constant) result.stateMutability = "view";
        else result.stateMutability = result.payable ? "payable" : "nonpayable";
        if (result.payable && result.constant) logger.throwArgumentError("cannot have constant payable function", "value", value);
    } else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = result.constant ? "view" : "payable";
    } else if (value.type !== "constructor") logger.throwArgumentError("unable to determine stateMutability", "value", value);
    return result;
}
class ConstructorFragment extends Fragment {
    format(format) {
        if (!format) format = FormatTypes.sighash;
        if (!FormatTypes[format]) logger.throwArgumentError("invalid format type", "format", format);
        if (format === FormatTypes.json) return JSON.stringify({
            type: "constructor",
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : undefined,
            inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))
        });
        if (format === FormatTypes.sighash) logger.throwError("cannot format a constructor for sighash", (0, _logger.Logger).errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
        });
        let result = "constructor(" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") result += this.stateMutability + " ";
        return result.trim();
    }
    static from(value) {
        if (typeof value === "string") return ConstructorFragment.fromString(value);
        return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) return value;
        if (value.type !== "constructor") logger.throwArgumentError("invalid constructor object", "value", value);
        let state = verifyState(value);
        if (state.constant) logger.throwArgumentError("constructor cannot be constant", "value", value);
        const params = {
            name: null,
            type: value.type,
            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: value.gas ? (0, _bignumber.BigNumber).from(value.gas) : null
        };
        return new ConstructorFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = {
            type: "constructor"
        };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") logger.throwArgumentError("invalid constructor string", "value", value);
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
        return value && value._isFragment && value.type === "constructor";
    }
}
class FunctionFragment extends ConstructorFragment {
    format(format) {
        if (!format) format = FormatTypes.sighash;
        if (!FormatTypes[format]) logger.throwArgumentError("invalid format type", "format", format);
        if (format === FormatTypes.json) return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : undefined,
            inputs: this.inputs.map((input)=>JSON.parse(input.format(format))),
            outputs: this.outputs.map((output)=>JSON.parse(output.format(format)))
        });
        let result = "";
        if (format !== FormatTypes.sighash) result += "function ";
        result += this.name + "(" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") result += this.stateMutability + " ";
            } else if (this.constant) result += "view ";
            if (this.outputs && this.outputs.length) result += "returns (" + this.outputs.map((output)=>output.format(format)).join(", ") + ") ";
            if (this.gas != null) result += "@" + this.gas.toString() + " ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof value === "string") return FunctionFragment.fromString(value);
        return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) return value;
        if (value.type !== "function") logger.throwArgumentError("invalid function object", "value", value);
        let state = verifyState(value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
            outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: value.gas ? (0, _bignumber.BigNumber).from(value.gas) : null
        };
        return new FunctionFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = {
            type: "function"
        };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) logger.throwArgumentError("invalid function string", "value", value);
        let parens = comps[0].match(regexParen);
        if (!parens) logger.throwArgumentError("invalid function signature", "value", value);
        params.name = parens[1].trim();
        if (params.name) verifyIdentifier(params.name);
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            let returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") logger.throwArgumentError("unexpected tokens", "value", value);
            params.outputs = parseParams(returns[2], false);
        } else params.outputs = [];
        return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
        return value && value._isFragment && value.type === "function";
    }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") logger.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    return fragment;
}
class ErrorFragment extends Fragment {
    format(format) {
        if (!format) format = FormatTypes.sighash;
        if (!FormatTypes[format]) logger.throwArgumentError("invalid format type", "format", format);
        if (format === FormatTypes.json) return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map((input)=>JSON.parse(input.format(format)))
        });
        let result = "";
        if (format !== FormatTypes.sighash) result += "error ";
        result += this.name + "(" + this.inputs.map((input)=>input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
        return result.trim();
    }
    static from(value) {
        if (typeof value === "string") return ErrorFragment.fromString(value);
        return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) return value;
        if (value.type !== "error") logger.throwArgumentError("invalid error object", "value", value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
        };
        return checkForbidden(new ErrorFragment(_constructorGuard, params));
    }
    static fromString(value) {
        let params = {
            type: "error"
        };
        let parens = value.match(regexParen);
        if (!parens) logger.throwArgumentError("invalid error signature", "value", value);
        params.name = parens[1].trim();
        if (params.name) verifyIdentifier(params.name);
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
        return value && value._isFragment && value.type === "error";
    }
}
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) type = "uint256" + type.substring(4);
    else if (type.match(/^int($|[^1-9])/)) type = "int256" + type.substring(3);
    // @TODO: more verification
    return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) logger.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for(let offset = 0; offset < value.length; offset++){
        let c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        } else {
            accum += c;
            if (c === "(") depth++;
            else if (c === ")") {
                depth--;
                if (depth === -1) logger.throwArgumentError("unbalanced parenthesis", "value", value);
            }
        }
    }
    if (accum) result.push(accum);
    return result;
}

},{"@ethersproject/bignumber":"gSTRF","@ethersproject/properties":"2X633","@ethersproject/logger":"9rXfv","./_version":"3ZLIe","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3ZLIe":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "abi/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5jMud":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbiCoder", ()=>AbiCoder);
parcelHelpers.export(exports, "defaultAbiCoder", ()=>defaultAbiCoder);
// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
var _bytes = require("@ethersproject/bytes");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
var _abstractCoder = require("./coders/abstract-coder");
var _address = require("./coders/address");
var _array = require("./coders/array");
var _boolean = require("./coders/boolean");
var _bytes1 = require("./coders/bytes");
var _fixedBytes = require("./coders/fixed-bytes");
var _null = require("./coders/null");
var _number = require("./coders/number");
var _string = require("./coders/string");
var _tuple = require("./coders/tuple");
var _fragments = require("./fragments");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc){
        (0, _properties.defineReadOnly)(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch(param.baseType){
            case "address":
                return new (0, _address.AddressCoder)(param.name);
            case "bool":
                return new (0, _boolean.BooleanCoder)(param.name);
            case "string":
                return new (0, _string.StringCoder)(param.name);
            case "bytes":
                return new (0, _bytes1.BytesCoder)(param.name);
            case "array":
                return new (0, _array.ArrayCoder)(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new (0, _tuple.TupleCoder)((param.components || []).map((component)=>{
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new (0, _null.NullCoder)(param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || size % 8 !== 0) logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            return new (0, _number.NumberCoder)(size / 8, match[1] === "int", param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) logger.throwArgumentError("invalid bytes length", "param", param);
            return new (0, _fixedBytes.FixedBytesCoder)(size, param.name);
        }
        return logger.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() {
        return 32;
    }
    _getReader(data, allowLoose) {
        return new (0, _abstractCoder.Reader)(data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new (0, _abstractCoder.Writer)(this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type)=>this._getCoder((0, _fragments.ParamType).from(type)));
        const coder = new (0, _tuple.TupleCoder)(coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) logger.throwError("types/values length mismatch", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
            count: {
                types: types.length,
                values: values.length
            },
            value: {
                types: types,
                values: values
            }
        });
        const coders = types.map((type)=>this._getCoder((0, _fragments.ParamType).from(type)));
        const coder = new (0, _tuple.TupleCoder)(coders, "_");
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type)=>this._getCoder((0, _fragments.ParamType).from(type)));
        const coder = new (0, _tuple.TupleCoder)(coders, "_");
        return coder.decode(this._getReader((0, _bytes.arrayify)(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();

},{"@ethersproject/bytes":"5ReBN","@ethersproject/properties":"2X633","@ethersproject/logger":"9rXfv","./_version":"3ZLIe","./coders/abstract-coder":"hjSwT","./coders/address":"gez8r","./coders/array":"kYQNG","./coders/boolean":"dxa5C","./coders/bytes":"dvOVV","./coders/fixed-bytes":"83AvN","./coders/null":"1jc2d","./coders/number":"eEWuL","./coders/string":"gL1hp","./coders/tuple":"eg280","./fragments":"f0Wfs","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hjSwT":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checkResultErrors", ()=>checkResultErrors);
parcelHelpers.export(exports, "Coder", ()=>Coder);
parcelHelpers.export(exports, "Writer", ()=>Writer);
parcelHelpers.export(exports, "Reader", ()=>Reader);
var _bytes = require("@ethersproject/bytes");
var _bignumber = require("@ethersproject/bignumber");
var _properties = require("@ethersproject/properties");
var _logger = require("@ethersproject/logger");
var _version = require("../_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function(path, object) {
        if (!Array.isArray(object)) return;
        for(let key in object){
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            } catch (error) {
                errors.push({
                    path: childPath,
                    error: error
                });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
class Coder {
    constructor(name, type, localName, dynamic){
        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        logger.throwArgumentError(message, this.localName, value);
    }
}
class Writer {
    constructor(wordSize){
        (0, _properties.defineReadOnly)(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }
    get data() {
        return (0, _bytes.hexConcat)(this._data);
    }
    get length() {
        return this._dataLength;
    }
    _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this._writeData((0, _bytes.concat)(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
        let bytes = (0, _bytes.arrayify)(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) bytes = (0, _bytes.concat)([
            bytes,
            this._padding.slice(paddingOffset)
        ]);
        return this._writeData(bytes);
    }
    _getValue(value) {
        let bytes = (0, _bytes.arrayify)((0, _bignumber.BigNumber).from(value));
        if (bytes.length > this.wordSize) logger.throwError("value out-of-bounds", (0, _logger.Logger).errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: bytes.length
        });
        if (bytes.length % this.wordSize) bytes = (0, _bytes.concat)([
            this._padding.slice(bytes.length % this.wordSize),
            bytes
        ]);
        return bytes;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
        return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value)=>{
            this._data[offset] = this._getValue(value);
        };
    }
}
class Reader {
    constructor(data, wordSize, coerceFunc, allowLoose){
        (0, _properties.defineReadOnly)(this, "_data", (0, _bytes.arrayify)(data));
        (0, _properties.defineReadOnly)(this, "wordSize", wordSize || 32);
        (0, _properties.defineReadOnly)(this, "_coerceFunc", coerceFunc);
        (0, _properties.defineReadOnly)(this, "allowLoose", allowLoose);
        this._offset = 0;
    }
    get data() {
        return (0, _bytes.hexlify)(this._data);
    }
    get consumed() {
        return this._offset;
    }
    // The default Coerce function
    static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) value = value.toNumber();
        return value;
    }
    coerce(name, value) {
        if (this._coerceFunc) return this._coerceFunc(name, value);
        return Reader.coerce(name, value);
    }
    _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) alignedLength = length;
            else logger.throwError("data out-of-bounds", (0, _logger.Logger).errors.BUFFER_OVERRUN, {
                length: this._data.length,
                offset: this._offset + alignedLength
            });
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    readValue() {
        return (0, _bignumber.BigNumber).from(this.readBytes(this.wordSize));
    }
}

},{"@ethersproject/bytes":"5ReBN","@ethersproject/bignumber":"gSTRF","@ethersproject/properties":"2X633","@ethersproject/logger":"9rXfv","../_version":"3ZLIe","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gez8r":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AddressCoder", ()=>AddressCoder);
var _address = require("@ethersproject/address");
var _bytes = require("@ethersproject/bytes");
var _abstractCoder = require("./abstract-coder");
"use strict";
class AddressCoder extends (0, _abstractCoder.Coder) {
    constructor(localName){
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
        try {
            value = (0, _address.getAddress)(value);
        } catch (error) {
            this._throwError(error.message, value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return (0, _address.getAddress)((0, _bytes.hexZeroPad)(reader.readValue().toHexString(), 20));
    }
}

},{"@ethersproject/address":"9Jgcg","@ethersproject/bytes":"5ReBN","./abstract-coder":"hjSwT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kYQNG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pack", ()=>pack);
parcelHelpers.export(exports, "unpack", ()=>unpack);
parcelHelpers.export(exports, "ArrayCoder", ()=>ArrayCoder);
var _logger = require("@ethersproject/logger");
var _version = require("../_version");
var _abstractCoder = require("./abstract-coder");
var _anonymous = require("./anonymous");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) arrayValues = values;
    else if (values && typeof values === "object") {
        let unique = {};
        arrayValues = coders.map((coder)=>{
            const name = coder.localName;
            if (!name) logger.throwError("cannot encode object for signature with missing names", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                argument: "values",
                coder: coder,
                value: values
            });
            if (unique[name]) logger.throwError("cannot encode object for signature with duplicate names", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                argument: "values",
                coder: coder,
                value: values
            });
            unique[name] = true;
            return values[name];
        });
    } else logger.throwArgumentError("invalid tuple value", "tuple", values);
    if (coders.length !== arrayValues.length) logger.throwArgumentError("types/value length mismatch", "tuple", values);
    let staticWriter = new (0, _abstractCoder.Writer)(writer.wordSize);
    let dynamicWriter = new (0, _abstractCoder.Writer)(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index)=>{
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset)=>{
                updateFunc(baseOffset + dynamicOffset);
            });
        } else coder.encode(staticWriter, value);
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func)=>{
        func(staticWriter.length);
    });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
function unpack(reader, coders) {
    let values = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder)=>{
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readValue();
            let offsetReader = baseReader.subReader(offset.toNumber());
            try {
                value = coder.decode(offsetReader);
            } catch (error) {
                // Cannot recover from this
                if (error.code === (0, _logger.Logger).errors.BUFFER_OVERRUN) throw error;
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        } else try {
            value = coder.decode(reader);
        } catch (error) {
            // Cannot recover from this
            if (error.code === (0, _logger.Logger).errors.BUFFER_OVERRUN) throw error;
            value = error;
            value.baseType = coder.name;
            value.name = coder.localName;
            value.type = coder.type;
        }
        if (value != undefined) values.push(value);
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = coders.reduce((accum, coder)=>{
        const name = coder.localName;
        if (name) {
            if (!accum[name]) accum[name] = 0;
            accum[name]++;
        }
        return accum;
    }, {});
    // Add any named parameters (i.e. tuples)
    coders.forEach((coder, index)=>{
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) return;
        if (name === "length") name = "_length";
        if (values[name] != null) return;
        const value = values[index];
        if (value instanceof Error) Object.defineProperty(values, name, {
            enumerable: true,
            get: ()=>{
                throw value;
            }
        });
        else values[name] = value;
    });
    for(let i = 0; i < values.length; i++){
        const value = values[i];
        if (value instanceof Error) Object.defineProperty(values, i, {
            enumerable: true,
            get: ()=>{
                throw value;
            }
        });
    }
    return Object.freeze(values);
}
class ArrayCoder extends (0, _abstractCoder.Coder) {
    constructor(coder, length, localName){
        const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
        const dynamic = length === -1 || coder.dynamic;
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for(let i = 0; i < this.length; i++)result.push(defaultChild);
        return result;
    }
    encode(writer, value) {
        if (!Array.isArray(value)) this._throwError("expected array value", value);
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
        let coders = [];
        for(let i = 0; i < value.length; i++)coders.push(this.coder);
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readValue().toNumber();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            if (count * 32 > reader._data.length) logger.throwError("insufficient data length", (0, _logger.Logger).errors.BUFFER_OVERRUN, {
                length: reader._data.length,
                count: count
            });
        }
        let coders = [];
        for(let i = 0; i < count; i++)coders.push(new (0, _anonymous.AnonymousCoder)(this.coder));
        return reader.coerce(this.name, unpack(reader, coders));
    }
}

},{"@ethersproject/logger":"9rXfv","../_version":"3ZLIe","./abstract-coder":"hjSwT","./anonymous":"2AvHY","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2AvHY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Clones the functionality of an existing Coder, but without a localName
parcelHelpers.export(exports, "AnonymousCoder", ()=>AnonymousCoder);
var _abstractCoder = require("./abstract-coder");
"use strict";
class AnonymousCoder extends (0, _abstractCoder.Coder) {
    constructor(coder){
        super(coder.name, coder.type, undefined, coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}

},{"./abstract-coder":"hjSwT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dxa5C":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BooleanCoder", ()=>BooleanCoder);
var _abstractCoder = require("./abstract-coder");
"use strict";
class BooleanCoder extends (0, _abstractCoder.Coder) {
    constructor(localName){
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
    }
}

},{"./abstract-coder":"hjSwT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"dvOVV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DynamicBytesCoder", ()=>DynamicBytesCoder);
parcelHelpers.export(exports, "BytesCoder", ()=>BytesCoder);
var _bytes = require("@ethersproject/bytes");
var _abstractCoder = require("./abstract-coder");
"use strict";
class DynamicBytesCoder extends (0, _abstractCoder.Coder) {
    constructor(type, localName){
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = (0, _bytes.arrayify)(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(localName){
        super("bytes", localName);
    }
    decode(reader) {
        return reader.coerce(this.name, (0, _bytes.hexlify)(super.decode(reader)));
    }
}

},{"@ethersproject/bytes":"5ReBN","./abstract-coder":"hjSwT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"83AvN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// @TODO: Merge this with bytes
parcelHelpers.export(exports, "FixedBytesCoder", ()=>FixedBytesCoder);
var _bytes = require("@ethersproject/bytes");
var _abstractCoder = require("./abstract-coder");
"use strict";
class FixedBytesCoder extends (0, _abstractCoder.Coder) {
    constructor(size, localName){
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = (0, _bytes.arrayify)(value);
        if (data.length !== this.size) this._throwError("incorrect data length", value);
        return writer.writeBytes(data);
    }
    decode(reader) {
        return reader.coerce(this.name, (0, _bytes.hexlify)(reader.readBytes(this.size)));
    }
}

},{"@ethersproject/bytes":"5ReBN","./abstract-coder":"hjSwT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1jc2d":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NullCoder", ()=>NullCoder);
var _abstractCoder = require("./abstract-coder");
"use strict";
class NullCoder extends (0, _abstractCoder.Coder) {
    constructor(localName){
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) this._throwError("not null", value);
        return writer.writeBytes([]);
    }
    decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
    }
}

},{"./abstract-coder":"hjSwT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eEWuL":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "NumberCoder", ()=>NumberCoder);
var _bignumber = require("@ethersproject/bignumber");
var _constants = require("@ethersproject/constants");
var _abstractCoder = require("./abstract-coder");
"use strict";
class NumberCoder extends (0, _abstractCoder.Coder) {
    constructor(size, signed, localName){
        const name = (signed ? "int" : "uint") + size * 8;
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = (0, _bignumber.BigNumber).from(value);
        // Check bounds are safe for encoding
        let maxUintValue = (0, _constants.MaxUint256).mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add((0, _constants.One)).mul((0, _constants.NegativeOne)))) this._throwError("value out-of-bounds", value);
        } else if (v.lt((0, _constants.Zero)) || v.gt(maxUintValue.mask(this.size * 8))) this._throwError("value out-of-bounds", value);
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) value = value.fromTwos(this.size * 8);
        return reader.coerce(this.name, value);
    }
}

},{"@ethersproject/bignumber":"gSTRF","@ethersproject/constants":"fVOEx","./abstract-coder":"hjSwT","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gL1hp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StringCoder", ()=>StringCoder);
var _strings = require("@ethersproject/strings");
var _bytes = require("./bytes");
"use strict";
class StringCoder extends (0, _bytes.DynamicBytesCoder) {
    constructor(localName){
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, value) {
        return super.encode(writer, (0, _strings.toUtf8Bytes)(value));
    }
    decode(reader) {
        return (0, _strings.toUtf8String)(super.decode(reader));
    }
}

},{"@ethersproject/strings":"8Rh0h","./bytes":"dvOVV","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"eg280":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TupleCoder", ()=>TupleCoder);
var _abstractCoder = require("./abstract-coder");
var _array = require("./array");
"use strict";
class TupleCoder extends (0, _abstractCoder.Coder) {
    constructor(coders, localName){
        let dynamic = false;
        const types = [];
        coders.forEach((coder)=>{
            if (coder.dynamic) dynamic = true;
            types.push(coder.type);
        });
        const type = "tuple(" + types.join(",") + ")";
        super("tuple", type, localName, dynamic);
        this.coders = coders;
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder)=>{
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder)=>{
            const name = coder.localName;
            if (name) {
                if (!accum[name]) accum[name] = 0;
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index)=>{
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) return;
            if (name === "length") name = "_length";
            if (values[name] != null) return;
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, value) {
        return (0, _array.pack)(writer, this.coders, value);
    }
    decode(reader) {
        return reader.coerce(this.name, (0, _array.unpack)(reader, this.coders));
    }
}

},{"./abstract-coder":"hjSwT","./array":"kYQNG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2L9wy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "checkResultErrors", ()=>(0, _abstractCoder.checkResultErrors));
parcelHelpers.export(exports, "LogDescription", ()=>LogDescription);
parcelHelpers.export(exports, "TransactionDescription", ()=>TransactionDescription);
parcelHelpers.export(exports, "ErrorDescription", ()=>ErrorDescription);
parcelHelpers.export(exports, "Indexed", ()=>Indexed);
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/ parcelHelpers.export(exports, "Interface", ()=>Interface);
var _address = require("@ethersproject/address");
var _bignumber = require("@ethersproject/bignumber");
var _bytes = require("@ethersproject/bytes");
var _hash = require("@ethersproject/hash");
var _keccak256 = require("@ethersproject/keccak256");
var _properties = require("@ethersproject/properties");
var _abiCoder = require("./abi-coder");
var _abstractCoder = require("./coders/abstract-coder");
var _fragments = require("./fragments");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
class LogDescription extends (0, _properties.Description) {
}
class TransactionDescription extends (0, _properties.Description) {
}
class ErrorDescription extends (0, _properties.Description) {
}
class Indexed extends (0, _properties.Description) {
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
}
const BuiltinErrors = {
    "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: [
            "string"
        ],
        reason: true
    },
    "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: [
            "uint256"
        ]
    }
};
function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
}
class Interface {
    constructor(fragments){
        let abi = [];
        if (typeof fragments === "string") abi = JSON.parse(fragments);
        else abi = fragments;
        (0, _properties.defineReadOnly)(this, "fragments", abi.map((fragment)=>{
            return (0, _fragments.Fragment).from(fragment);
        }).filter((fragment)=>fragment != null));
        (0, _properties.defineReadOnly)(this, "_abiCoder", (0, _properties.getStatic)(new.target, "getAbiCoder")());
        (0, _properties.defineReadOnly)(this, "functions", {});
        (0, _properties.defineReadOnly)(this, "errors", {});
        (0, _properties.defineReadOnly)(this, "events", {});
        (0, _properties.defineReadOnly)(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach((fragment)=>{
            let bucket = null;
            switch(fragment.type){
                case "constructor":
                    if (this.deploy) {
                        logger.warn("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    (0, _properties.defineReadOnly)(this, "deploy", fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.events;
                    break;
                case "error":
                    bucket = this.errors;
                    break;
                default:
                    return;
            }
            let signature = fragment.format();
            if (bucket[signature]) {
                logger.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        if (!this.deploy) (0, _properties.defineReadOnly)(this, "deploy", (0, _fragments.ConstructorFragment).from({
            payable: false,
            type: "constructor"
        }));
        (0, _properties.defineReadOnly)(this, "_isInterface", true);
    }
    format(format) {
        if (!format) format = (0, _fragments.FormatTypes).full;
        if (format === (0, _fragments.FormatTypes).sighash) logger.throwArgumentError("interface does not support formatting sighash", "format", format);
        const abi = this.fragments.map((fragment)=>fragment.format(format));
        // We need to re-bundle the JSON fragments a bit
        if (format === (0, _fragments.FormatTypes).json) return JSON.stringify(abi.map((j)=>JSON.parse(j)));
        return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
        return 0, _abiCoder.defaultAbiCoder;
    }
    static getAddress(address) {
        return (0, _address.getAddress)(address);
    }
    static getSighash(fragment) {
        return (0, _bytes.hexDataSlice)((0, _hash.id)(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
        return (0, _hash.id)(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
        if ((0, _bytes.isHexString)(nameOrSignatureOrSighash)) {
            for(const name in this.functions){
                if (nameOrSignatureOrSighash === this.getSighash(name)) return this.functions[name];
            }
            logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.functions).filter((f)=>f.split("(" /* fix:) */ )[0] === name);
            if (matching.length === 0) logger.throwArgumentError("no matching function", "name", name);
            else if (matching.length > 1) logger.throwArgumentError("multiple matching functions", "name", name);
            return this.functions[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.functions[(0, _fragments.FunctionFragment).fromString(nameOrSignatureOrSighash).format()];
        if (!result) logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
        if ((0, _bytes.isHexString)(nameOrSignatureOrTopic)) {
            const topichash = nameOrSignatureOrTopic.toLowerCase();
            for(const name in this.events){
                if (topichash === this.getEventTopic(name)) return this.events[name];
            }
            logger.throwArgumentError("no matching event", "topichash", topichash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            const name = nameOrSignatureOrTopic.trim();
            const matching = Object.keys(this.events).filter((f)=>f.split("(" /* fix:) */ )[0] === name);
            if (matching.length === 0) logger.throwArgumentError("no matching event", "name", name);
            else if (matching.length > 1) logger.throwArgumentError("multiple matching events", "name", name);
            return this.events[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.events[(0, _fragments.EventFragment).fromString(nameOrSignatureOrTopic).format()];
        if (!result) logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
        if ((0, _bytes.isHexString)(nameOrSignatureOrSighash)) {
            const getSighash = (0, _properties.getStatic)(this.constructor, "getSighash");
            for(const name in this.errors){
                const error = this.errors[name];
                if (nameOrSignatureOrSighash === getSighash(error)) return this.errors[name];
            }
            logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.errors).filter((f)=>f.split("(" /* fix:) */ )[0] === name);
            if (matching.length === 0) logger.throwArgumentError("no matching error", "name", name);
            else if (matching.length > 1) logger.throwArgumentError("multiple matching errors", "name", name);
            return this.errors[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.errors[(0, _fragments.FunctionFragment).fromString(nameOrSignatureOrSighash).format()];
        if (!result) logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
        if (typeof fragment === "string") try {
            fragment = this.getFunction(fragment);
        } catch (error) {
            try {
                fragment = this.getError(fragment);
            } catch (_) {
                throw error;
            }
        }
        return (0, _properties.getStatic)(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
        if (typeof eventFragment === "string") eventFragment = this.getEvent(eventFragment);
        return (0, _properties.getStatic)(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
        if (typeof fragment === "string") fragment = this.getError(fragment);
        const bytes = (0, _bytes.arrayify)(data);
        if ((0, _bytes.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", (0, _bytes.hexlify)(bytes));
        return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
        if (typeof fragment === "string") fragment = this.getError(fragment);
        return (0, _bytes.hexlify)((0, _bytes.concat)([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
        ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data) {
        if (typeof functionFragment === "string") functionFragment = this.getFunction(functionFragment);
        const bytes = (0, _bytes.arrayify)(data);
        if ((0, _bytes.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", (0, _bytes.hexlify)(bytes));
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
        if (typeof functionFragment === "string") functionFragment = this.getFunction(functionFragment);
        return (0, _bytes.hexlify)((0, _bytes.concat)([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
        ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data) {
        if (typeof functionFragment === "string") functionFragment = this.getFunction(functionFragment);
        let bytes = (0, _bytes.arrayify)(data);
        let reason = null;
        let message = "";
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch(bytes.length % this._abiCoder._getWordSize()){
            case 0:
                try {
                    return this._abiCoder.decode(functionFragment.outputs, bytes);
                } catch (error) {}
                break;
            case 4:
                {
                    const selector = (0, _bytes.hexlify)(bytes.slice(0, 4));
                    const builtin = BuiltinErrors[selector];
                    if (builtin) {
                        errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                        errorName = builtin.name;
                        errorSignature = builtin.signature;
                        if (builtin.reason) reason = errorArgs[0];
                        if (errorName === "Error") message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
                        else if (errorName === "Panic") message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
                    } else try {
                        const error = this.getError(selector);
                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                        errorName = error.name;
                        errorSignature = error.format();
                    } catch (error) {}
                    break;
                }
        }
        return logger.throwError("call revert exception" + message, (0, _logger.Logger).errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            data: (0, _bytes.hexlify)(data),
            errorArgs,
            errorName,
            errorSignature,
            reason
        });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
        if (typeof functionFragment === "string") functionFragment = this.getFunction(functionFragment);
        return (0, _bytes.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
        if (typeof eventFragment === "string") eventFragment = this.getEvent(eventFragment);
        if (values.length > eventFragment.inputs.length) logger.throwError("too many arguments for " + eventFragment.format(), (0, _logger.Logger).errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: values
        });
        let topics = [];
        if (!eventFragment.anonymous) topics.push(this.getEventTopic(eventFragment));
        const encodeTopic = (param, value)=>{
            if (param.type === "string") return (0, _hash.id)(value);
            else if (param.type === "bytes") return (0, _keccak256.keccak256)((0, _bytes.hexlify)(value));
            if (param.type === "bool" && typeof value === "boolean") value = value ? "0x01" : "0x00";
            if (param.type.match(/^u?int/)) value = (0, _bignumber.BigNumber).from(value).toHexString();
            // Check addresses are valid
            if (param.type === "address") this._abiCoder.encode([
                "address"
            ], [
                value
            ]);
            return (0, _bytes.hexZeroPad)((0, _bytes.hexlify)(value), 32);
        };
        values.forEach((value, index)=>{
            let param = eventFragment.inputs[index];
            if (!param.indexed) {
                if (value != null) logger.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
                return;
            }
            if (value == null) topics.push(null);
            else if (param.baseType === "array" || param.baseType === "tuple") logger.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
            else if (Array.isArray(value)) topics.push(value.map((value)=>encodeTopic(param, value)));
            else topics.push(encodeTopic(param, value));
        });
        // Trim off trailing nulls
        while(topics.length && topics[topics.length - 1] === null)topics.pop();
        return topics;
    }
    encodeEventLog(eventFragment, values) {
        if (typeof eventFragment === "string") eventFragment = this.getEvent(eventFragment);
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) topics.push(this.getEventTopic(eventFragment));
        if (values.length !== eventFragment.inputs.length) logger.throwArgumentError("event arguments/values mismatch", "values", values);
        eventFragment.inputs.forEach((param, index)=>{
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") topics.push((0, _hash.id)(value));
                else if (param.type === "bytes") topics.push((0, _keccak256.keccak256)(value));
                else if (param.baseType === "tuple" || param.baseType === "array") // @TODO
                throw new Error("not implemented");
                else topics.push(this._abiCoder.encode([
                    param.type
                ], [
                    value
                ]));
            } else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data, topics) {
        if (typeof eventFragment === "string") eventFragment = this.getEvent(eventFragment);
        if (topics != null && !eventFragment.anonymous) {
            let topicHash = this.getEventTopic(eventFragment);
            if (!(0, _bytes.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) logger.throwError("fragment/topic mismatch", (0, _logger.Logger).errors.INVALID_ARGUMENT, {
                argument: "topics[0]",
                expected: topicHash,
                value: topics[0]
            });
            topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index)=>{
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push((0, _fragments.ParamType).fromObject({
                        type: "bytes32",
                        name: param.name
                    }));
                    dynamic.push(true);
                } else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            } else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        let resultIndexed = topics != null ? this._abiCoder.decode(indexed, (0, _bytes.concat)(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index)=>{
            if (param.indexed) {
                if (resultIndexed == null) result[index] = new Indexed({
                    _isIndexed: true,
                    hash: null
                });
                else if (dynamic[index]) result[index] = new Indexed({
                    _isIndexed: true,
                    hash: resultIndexed[indexedIndex++]
                });
                else try {
                    result[index] = resultIndexed[indexedIndex++];
                } catch (error) {
                    result[index] = error;
                }
            } else try {
                result[index] = resultNonIndexed[nonIndexedIndex++];
            } catch (error) {
                result[index] = error;
            }
            // Add the keyword argument if named and safe
            if (param.name && result[param.name] == null) {
                const value = result[index];
                // Make error named values throw on access
                if (value instanceof Error) Object.defineProperty(result, param.name, {
                    enumerable: true,
                    get: ()=>{
                        throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
                    }
                });
                else result[param.name] = value;
            }
        });
        // Make all error indexed values throw on access
        for(let i = 0; i < result.length; i++){
            const value = result[i];
            if (value instanceof Error) Object.defineProperty(result, i, {
                enumerable: true,
                get: ()=>{
                    throw wrapAccessError(`index ${i}`, value);
                }
            });
        }
        return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) return null;
        return new TransactionDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: (0, _bignumber.BigNumber).from(tx.value || "0")
        });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) return null;
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
        });
    }
    parseError(data) {
        const hexData = (0, _bytes.hexlify)(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) return null;
        return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment)
        });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */ static isInterface(value) {
        return !!(value && value._isInterface);
    }
}

},{"@ethersproject/address":"9Jgcg","@ethersproject/bignumber":"gSTRF","@ethersproject/bytes":"5ReBN","@ethersproject/hash":"gr11a","@ethersproject/keccak256":"8rdQU","@ethersproject/properties":"2X633","./abi-coder":"5jMud","./coders/abstract-coder":"hjSwT","./fragments":"f0Wfs","@ethersproject/logger":"9rXfv","./_version":"3ZLIe","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hy1mJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "contracts/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4wW2T":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "defaultGasForPolygon", ()=>d);
parcelHelpers.export(exports, "getPolygonGasStationFees", ()=>c);
parcelHelpers.export(exports, "isPolygon", ()=>i);
var _units = require("@ethersproject/units");
var _fetchRetry = require("fetch-retry");
var _fetchRetryDefault = parcelHelpers.interopDefault(_fetchRetry);
var _chains = require("@privy-io/chains");
let o = (0, _fetchRetryDefault.default)(fetch, {
    retries: 3,
    retryDelay: 500
});
const i = (e)=>[
        (0, _chains.polygon).id,
        (0, _chains.polygonAmoy).id
    ].includes(e);
let s = (t)=>({
        maxPriorityFee: (0, _units.parseUnits)(t.maxPriorityFee.toFixed(9), "gwei").toHexString(),
        maxFee: (0, _units.parseUnits)(t.maxFee.toFixed(9), "gwei").toHexString()
    }), n = (e)=>({
        safeLow: s(e.safeLow),
        standard: s(e.standard),
        fast: s(e.fast)
    });
const c = async (e)=>{
    let t = "";
    switch(e){
        case (0, _chains.polygon).id:
            t = "https://gasstation.polygon.technology/v2";
            break;
        case (0, _chains.polygonAmoy).id:
            t = "https://gasstation.polygon.technology/amoy";
            break;
        default:
            throw Error(`chainId ${e} does not support polygon gas stations`);
    }
    let i = await o(t), s = await i.json();
    if (i.status > 399) throw s;
    return n(s);
};
async function d(e) {
    if (!i(e.chainId)) throw Error("Invalid chain ID for Polygon gas estimation.");
    if (void 0 === e.type && (e.type = 2), e.maxPriorityFeePerGas && e.maxFeePerGas) return e;
    try {
        let { standard: t } = await c(e.chainId);
        e.maxPriorityFeePerGas || (e.maxPriorityFeePerGas = t.maxPriorityFee), e.maxFeePerGas || (e.maxFeePerGas = t.maxFee), e.gasPrice && (console.warn("`gasPrice` is not supported on this chain and will be ignored. Use `maxPriorityFeePerGas` and/or `maxFeePerGas` instead."), delete e.gasPrice);
    } catch (e) {
        throw Error(`Failed to set gas prices from Polygon gas station with error: ${e}.`);
    }
    return e;
}

},{"@ethersproject/units":"4X8jY","fetch-retry":"knqh8","@privy-io/chains":"9r5Tr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4X8jY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// Some environments have issues with RegEx that contain back-tracking, so we cannot
// use them.
parcelHelpers.export(exports, "commify", ()=>commify);
parcelHelpers.export(exports, "formatUnits", ()=>formatUnits);
parcelHelpers.export(exports, "parseUnits", ()=>parseUnits);
parcelHelpers.export(exports, "formatEther", ()=>formatEther);
parcelHelpers.export(exports, "parseEther", ()=>parseEther);
var _bignumber = require("@ethersproject/bignumber");
var _logger = require("@ethersproject/logger");
var _version = require("./_version");
"use strict";
const logger = new (0, _logger.Logger)((0, _version.version));
const names = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether"
];
function commify(value) {
    const comps = String(value).split(".");
    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") logger.throwArgumentError("invalid value", "value", value);
    // Make sure we have at least one whole digit (0 if none)
    let whole = comps[0];
    let negative = "";
    if (whole.substring(0, 1) === "-") {
        negative = "-";
        whole = whole.substring(1);
    }
    // Make sure we have at least 1 whole digit with no leading zeros
    while(whole.substring(0, 1) === "0")whole = whole.substring(1);
    if (whole === "") whole = "0";
    let suffix = "";
    if (comps.length === 2) suffix = "." + (comps[1] || "0");
    while(suffix.length > 2 && suffix[suffix.length - 1] === "0")suffix = suffix.substring(0, suffix.length - 1);
    const formatted = [];
    while(whole.length)if (whole.length <= 3) {
        formatted.unshift(whole);
        break;
    } else {
        const index = whole.length - 3;
        formatted.unshift(whole.substring(index));
        whole = whole.substring(0, index);
    }
    return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
    if (typeof unitName === "string") {
        const index = names.indexOf(unitName);
        if (index !== -1) unitName = 3 * index;
    }
    return (0, _bignumber.formatFixed)(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
    if (typeof value !== "string") logger.throwArgumentError("value must be a string", "value", value);
    if (typeof unitName === "string") {
        const index = names.indexOf(unitName);
        if (index !== -1) unitName = 3 * index;
    }
    return (0, _bignumber.parseFixed)(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
    return formatUnits(wei, 18);
}
function parseEther(ether) {
    return parseUnits(ether, 18);
}

},{"@ethersproject/bignumber":"gSTRF","@ethersproject/logger":"9rXfv","./_version":"2PmZj","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2PmZj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "version", ()=>version);
const version = "units/5.8.0";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"knqh8":[function(require,module,exports,__globalThis) {
(function(global, factory) {
    module.exports = factory();
})(this, function() {
    'use strict';
    var fetchRetry = function(fetch, defaults) {
        defaults = defaults || {};
        if (typeof fetch !== 'function') throw new ArgumentError('fetch must be a function');
        if (typeof defaults !== 'object') throw new ArgumentError('defaults must be an object');
        if (defaults.retries !== undefined && !isPositiveInteger(defaults.retries)) throw new ArgumentError('retries must be a positive integer');
        if (defaults.retryDelay !== undefined && !isPositiveInteger(defaults.retryDelay) && typeof defaults.retryDelay !== 'function') throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');
        if (defaults.retryOn !== undefined && !Array.isArray(defaults.retryOn) && typeof defaults.retryOn !== 'function') throw new ArgumentError('retryOn property expects an array or function');
        var baseDefaults = {
            retries: 3,
            retryDelay: 1000,
            retryOn: []
        };
        defaults = Object.assign(baseDefaults, defaults);
        return function fetchRetry(input, init) {
            var retries = defaults.retries;
            var retryDelay = defaults.retryDelay;
            var retryOn = defaults.retryOn;
            if (init && init.retries !== undefined) {
                if (isPositiveInteger(init.retries)) retries = init.retries;
                else throw new ArgumentError('retries must be a positive integer');
            }
            if (init && init.retryDelay !== undefined) {
                if (isPositiveInteger(init.retryDelay) || typeof init.retryDelay === 'function') retryDelay = init.retryDelay;
                else throw new ArgumentError('retryDelay must be a positive integer or a function returning a positive integer');
            }
            if (init && init.retryOn) {
                if (Array.isArray(init.retryOn) || typeof init.retryOn === 'function') retryOn = init.retryOn;
                else throw new ArgumentError('retryOn property expects an array or function');
            }
            // eslint-disable-next-line no-undef
            return new Promise(function(resolve, reject) {
                var wrappedFetch = function(attempt) {
                    // As of node 18, this is no longer needed since node comes with native support for fetch:
                    /* istanbul ignore next */ var _input = typeof Request !== 'undefined' && input instanceof Request ? input.clone() : input;
                    fetch(_input, init).then(function(response) {
                        if (Array.isArray(retryOn) && retryOn.indexOf(response.status) === -1) resolve(response);
                        else if (typeof retryOn === 'function') try {
                            // eslint-disable-next-line no-undef
                            return Promise.resolve(retryOn(attempt, null, response)).then(function(retryOnResponse) {
                                if (retryOnResponse) retry(attempt, null, response);
                                else resolve(response);
                            }).catch(reject);
                        } catch (error) {
                            reject(error);
                        }
                        else if (attempt < retries) retry(attempt, null, response);
                        else resolve(response);
                    }).catch(function(error) {
                        if (typeof retryOn === 'function') try {
                            // eslint-disable-next-line no-undef
                            Promise.resolve(retryOn(attempt, error, null)).then(function(retryOnResponse) {
                                if (retryOnResponse) retry(attempt, error, null);
                                else reject(error);
                            }).catch(function(error) {
                                reject(error);
                            });
                        } catch (error) {
                            reject(error);
                        }
                        else if (attempt < retries) retry(attempt, error, null);
                        else reject(error);
                    });
                };
                function retry(attempt, error, response) {
                    var delay = typeof retryDelay === 'function' ? retryDelay(attempt, error, response) : retryDelay;
                    setTimeout(function() {
                        wrappedFetch(++attempt);
                    }, delay);
                }
                wrappedFetch(0);
            });
        };
    };
    function isPositiveInteger(value) {
        return Number.isInteger(value) && value >= 0;
    }
    function ArgumentError(message) {
        this.name = 'ArgumentError';
        this.message = message;
    }
    return fetchRetry;
});

},{}],"bzO8p":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "calculateTotalGasEstimate", ()=>o);
parcelHelpers.export(exports, "defaultGasForEvmChain", ()=>s);
parcelHelpers.export(exports, "defaultGasLimit", ()=>n);
var _bignumber = require("@ethersproject/bignumber");
var _errorsMjs = require("../errors.mjs");
var _opStackMjs = require("../gas/op-stack.mjs");
var _ethersMjs = require("./ethers.mjs");
var _typesMjs = require("../types.mjs");
var _contracts = require("@ethersproject/contracts");
var _transactions = require("@ethersproject/transactions");
var _chains = require("@privy-io/chains");
const s = async (e, t)=>{
    if (void 0 === e.type && (e.type = 2), 2 === e.type) {
        if (!e.maxFeePerGas || !e.maxPriorityFeePerGas) {
            let r = await t.getFeeData();
            e.maxFeePerGas || (e.maxFeePerGas = r.maxFeePerGas?.toHexString()), e.maxPriorityFeePerGas || (e.maxPriorityFeePerGas = r.maxPriorityFeePerGas?.toHexString());
        }
    } else if (!e.gasPrice) {
        let r = await t.getFeeData();
        e.gasPrice = r.gasPrice?.toHexString();
    }
    return e;
};
async function o(s, o) {
    if (!s.gasLimit) throw new (0, _errorsMjs.PrivyProviderRpcError)("gasLimit was not successfully set for transaction.");
    let n = (0, _ethersMjs.QuantityToBigNumber)(s.gasLimit), m = (0, _bignumber.BigNumber).from(0);
    if (2 == s.type) {
        if (!s.maxFeePerGas) throw new (0, _errorsMjs.PrivyProviderRpcError)("maxFeePerGas was not successfully set for transaction of type 2.");
        m = (0, _ethersMjs.QuantityToBigNumber)(s.maxFeePerGas);
    } else {
        if (!s.gasPrice) throw new (0, _errorsMjs.PrivyProviderRpcError)("gasPrice was not successfully set for transaction of type 0 or 1.");
        m = (0, _ethersMjs.QuantityToBigNumber)(s.gasPrice);
    }
    let c = n.mul(m), f = (0, _bignumber.BigNumber).from(0);
    if (s.chainId && (0, _opStackMjs.isOpStack)(s.chainId)) try {
        f = await (0, _opStackMjs.estimateOpStackL1Gas)(s, o), c = c.add(f);
    } catch (e) {}
    return {
        totalGasEstimate: c,
        l1ExecutionFeeEstimate: f
    };
}
async function n(e, t) {
    try {
        return (await t.estimateGas(e)).toHexString();
    } catch (r) {
        let a;
        if ("message" in r && r.message.includes("insufficient funds") && (console.warn(`Gas estimation failed with error: ${r}. Retrying gas estimation by omitting the 'value'`), a = await async function({ txRequest: e, provider: t }) {
            try {
                let r = {
                    ...e,
                    value: void 0
                };
                return (await t.estimateGas(r)).toHexString();
            } catch (e) {
                return console.warn(`Gas estimation failed with error: ${e} when omitting the 'value'`), null;
            }
        }({
            txRequest: e,
            provider: t
        })), a || (console.warn(`Gas estimation failed with error: ${r}. Retrying gas estimation by omitting the 'from'`), a = await async function({ txRequest: e, provider: t }) {
            try {
                let r = {
                    ...e,
                    from: void 0
                };
                return (await t.estimateGas(r)).toHexString();
            } catch (e) {
                return console.warn(`Gas estimation failed with error: ${e} when omitting the 'from' address`), null;
            }
        }({
            txRequest: e,
            provider: t
        })), !a) throw r;
        return a;
    }
}

},{"@ethersproject/bignumber":"gSTRF","../errors.mjs":"imCDj","../gas/op-stack.mjs":"KVI98","./ethers.mjs":"1PLH5","../types.mjs":"47MbA","@ethersproject/contracts":"26Zqo","@ethersproject/transactions":"lqSCl","@privy-io/chains":"9r5Tr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5BZHk":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isUnifiedWallet", ()=>e);
const e = (e)=>!!e.id && "privy-v2" === e.recovery_method;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gocS8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DEFAULT_WALLET_PROXY_TIMEOUT_MS", ()=>o);
parcelHelpers.export(exports, "EmbeddedWalletProxy", ()=>h);
var _sleepMjs = require("../utils/sleep.mjs");
var _eventCallbackQueueMjs = require("./EventCallbackQueue.mjs");
var _errorsMjs = require("./errors.mjs");
var _withMfaMjs = require("./withMfa.mjs");
var _typesMjs = require("./types.mjs");
var a;
const o = 15e3;
let s = (a = 0, ()=>"id-" + a++), n = (e, t)=>"bigint" == typeof t ? t.toString() : t, l = (t, { ms: i, msg: r })=>Promise.race([
        t,
        (0, _sleepMjs.sleep)(i ?? 15e3).then(()=>Promise.reject(Error(r)))
    ]), m = new (0, _eventCallbackQueueMjs.EventCallbacksQueue);
class h {
    invokeWithMfa(e, t) {
        return l((0, _withMfaMjs.withMfa)((i)=>l(this.waitForReady().then(()=>e(i)), {
                msg: t.timeoutMsg,
                ms: t.timeoutMs
            }), this.mfa.rootPromise, this.mfa.submitPromise, ()=>this.mfa.emit("mfaRequired"), t.mfaAlwaysRequired ?? !1, 4, 3e5), {
            msg: "Operation reached timeout: MFA verification",
            ms: 126e4
        });
    }
    reload() {
        return this.ready = !1, this._embeddedWalletMessagePoster.reload();
    }
    ping(e = 15e3) {
        return l(this.invoke("privy:iframe:ready", {}), {
            msg: "Ping reached timeout",
            ms: e
        });
    }
    create(e) {
        return l(this.waitForReady().then(()=>this.invoke("privy:wallet:create", e)), {
            msg: "Operation reached timeout: create"
        });
    }
    rpc(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:wallet:rpc", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: rpc"
        });
    }
    createSolana(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:solana-wallet:create", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: create",
            timeoutMs: 6e4
        });
    }
    createAdditionalSolana(e) {
        return l(this.waitForReady().then(()=>this.invoke("privy:solana-wallet:create-additional", e)), {
            msg: "Operation reached timeout: create"
        });
    }
    solanaRpc(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:solana-wallet:rpc", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: solana-rpc"
        });
    }
    delegateWallets(e) {
        return l(this.waitForReady().then(()=>this.invoke("privy:delegated-actions:consent", e)), {
            msg: "Operation reached timeout: delegated-actions:consent"
        });
    }
    verifyMfa(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:mfa:verify", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: mfa:verify",
            mfaAlwaysRequired: !0
        });
    }
    initEnrollMfa(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:mfa:init-enrollment", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: mfa:init-enrollment"
        });
    }
    submitEnrollMfa(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:mfa:submit-enrollment", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: mfa:submit-enrollment"
        });
    }
    unenrollMfa(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:mfa:unenroll", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: mfa:unenroll",
            mfaAlwaysRequired: !0
        });
    }
    clearMfa(e) {
        return l(this.waitForReady().then(()=>this.invoke("privy:mfa:clear", e)), {
            msg: "Operation reached timeout: mfa:clear"
        });
    }
    createWallet(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:wallets:create", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: create",
            timeoutMs: 6e4
        });
    }
    signWithUserSigner(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:user-signer:sign", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: user-signer:sign"
        });
    }
    addWallet(e) {
        return l(this.waitForReady().then(()=>this.invoke("privy:wallets:add", e)), {
            msg: "Operation reached timeout: wallets:add"
        });
    }
    setRecovery(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:wallets:set-recovery", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: wallets:set-recovery",
            timeoutMs: 6e4
        });
    }
    connect(e) {
        return l(this.waitForReady().then(()=>this.invoke("privy:wallets:connect", e)), {
            msg: "Operation reached timeout: wallets:connect"
        });
    }
    recover(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:wallets:recover", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: wallets:recover",
            timeoutMs: 6e4
        });
    }
    rpcWallet(e) {
        return this.invokeWithMfa((t)=>this.invoke("privy:wallets:rpc", {
                ...t,
                ...e
            }), {
            timeoutMsg: "Operation reached timeout: wallets:rpc"
        });
    }
    handleEmbeddedWalletMessages(e) {
        let { reject: t, resolve: r } = m.dequeue(e.event, e.id);
        return void 0 !== e.error ? t(new (0, _errorsMjs.PrivyIframeError)(e.error.type, e.error.message)) : r(e.data);
    }
    waitForReady() {
        return this.ready ? Promise.resolve() : new Promise(async (t, i)=>{
            for(; !this.ready;)this.invoke("privy:iframe:ready", {}).then(()=>{
                this.ready = !0, t();
            }).catch(i), await (0, _sleepMjs.sleep)(150);
        });
    }
    invoke(e, t) {
        let i = ((e, t)=>`${e}${JSON.stringify(t, n)}`)(e, t);
        if ("privy:wallet:create" === e || "privy:solana-wallet:create" === e) {
            let e = this.cache.get(i);
            if (e) return e;
        }
        let r = new Promise((i, r)=>{
            let a = s();
            m.enqueue(a, {
                resolve: i,
                reject: r
            }), this._embeddedWalletMessagePoster.postMessage(JSON.stringify({
                id: a,
                event: e,
                data: t
            }), "*");
        }).finally(()=>{
            this.cache.delete(i);
        });
        return this.cache.set(i, r), r;
    }
    constructor(e, t){
        this.ready = !1, this.cache = new Map, this._embeddedWalletMessagePoster = e, this.mfa = t;
    }
}

},{"../utils/sleep.mjs":"kvTiu","./EventCallbackQueue.mjs":"4FEdR","./errors.mjs":"imCDj","./withMfa.mjs":"1qfQQ","./types.mjs":"47MbA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kvTiu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sleep", ()=>e);
function e(e) {
    return new Promise((t)=>{
        setTimeout(()=>{
            t();
        }, e);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4FEdR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EventCallbacksQueue", ()=>e);
class e {
    enqueue(e, a) {
        this.callbacks[e] = a;
    }
    dequeue(e, a) {
        let r = this.callbacks[a];
        if (!r) throw Error(`cannot dequeue ${e} event: no event found for id ${a}`);
        switch(delete this.callbacks[a], e){
            case "privy:iframe:ready":
            case "privy:wallets:create":
            case "privy:user-signer:sign":
            case "privy:wallets:add":
            case "privy:wallets:set-recovery":
            case "privy:wallets:connect":
            case "privy:wallets:recover":
            case "privy:wallets:rpc":
            case "privy:wallet:create":
            case "privy:wallet:connect":
            case "privy:wallet:recover":
            case "privy:wallet:rpc":
            case "privy:solana-wallet:create":
            case "privy:solana-wallet:create-additional":
            case "privy:solana-wallet:connect":
            case "privy:solana-wallet:recover":
            case "privy:solana-wallet:rpc":
            case "privy:delegated-actions:consent":
            case "privy:mfa:verify":
            case "privy:mfa:init-enrollment":
            case "privy:mfa:submit-enrollment":
            case "privy:mfa:unenroll":
            case "privy:mfa:clear":
                return r;
            default:
                throw Error(`invalid wallet event type ${e}`);
        }
    }
    constructor(){
        this.callbacks = {};
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1qfQQ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "withMfa", ()=>r);
var _errorsMjs = require("./errors.mjs");
var _typesMjs = require("./types.mjs");
async function r(r1, t, i, a, n = !1, o, c) {
    let m = n, s = async (o)=>{
        if (m) {
            o === (n ? 0 : 1) ? a() : i.current?.reject(new (0, _errorsMjs.PrivyIframeError)("missing_or_invalid_mfa", "MFA verification failed, retry."));
            let m = await new Promise((r, a)=>{
                t.current = {
                    resolve: r,
                    reject: a
                }, setTimeout(()=>{
                    let r = new (0, _errorsMjs.PrivyIframeError)("mfa_timeout", "Timed out waiting for MFA code");
                    i.current?.reject(r), a(r);
                }, c);
            });
            return await r1(m);
        }
        return await r1();
    }, f = null;
    for(let e = 0; e < o; e++)try {
        f = await s(e), i.current?.resolve(void 0);
        break;
    } catch (e) {
        if ("missing_or_invalid_mfa" !== e.type) throw i.current?.resolve(void 0), e;
        m = !0;
    }
    if (null === f) {
        let r = new (0, _errorsMjs.PrivyIframeError)("mfa_verification_max_attempts_reached", "Max MFA verification attempts reached");
        throw i.current?.reject(r), r;
    }
    return f;
}

},{"./errors.mjs":"imCDj","./types.mjs":"47MbA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3vejn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmbeddedWalletProvider", ()=>c);
var _eventemitter3 = require("eventemitter3");
var _eventemitter3Default = parcelHelpers.interopDefault(_eventemitter3);
var _errorMjs = require("../Error.mjs");
var _unifiedWalletMjs = require("../wallet-api/unified-wallet.mjs");
var _errorsMjs = require("./errors.mjs");
var _methodsMjs = require("./methods.mjs");
var _walletRpcMjs = require("./stack/walletRpc.mjs");
var _indexMjs = require("./utils/index.mjs");
var _typesMjs = require("./types.mjs");
var _encodingsMjs = require("../utils/encodings.mjs");
var _rpcMjs = require("../wallet-api/rpc.mjs");
var _canonicalize = require("canonicalize");
var _publicApi = require("@privy-io/public-api");
var _walletApiEthTransactionMjs = require("./stack/wallet-api-eth-transaction.mjs");
var _walletApiEthTypedDataMjs = require("./stack/wallet-api-eth-typed-data.mjs");
var _abstractSigner = require("@ethersproject/abstract-signer");
var _providers = require("@ethersproject/providers");
var _arbitrumMjs = require("./gas/arbitrum.mjs");
var _bignumber = require("@ethersproject/bignumber");
var _chains = require("@privy-io/chains");
var _ethersMjs = require("./utils/ethers.mjs");
var _bscMjs = require("./gas/bsc.mjs");
var _opStackMjs = require("./gas/op-stack.mjs");
var _contracts = require("@ethersproject/contracts");
var _transactions = require("@ethersproject/transactions");
var _polygonMjs = require("./gas/polygon.mjs");
var _units = require("@ethersproject/units");
var _fetchRetry = require("fetch-retry");
var _gasMjs = require("./utils/gas.mjs");
class c extends (0, _eventemitter3Default.default) {
    async request(e) {
        if ((0, _methodsMjs.isSupportedIframeRpcMethod)(e.method)) return this.handleIFrameRpc(e);
        switch(e.method){
            case "eth_accounts":
            case "eth_requestAccounts":
                return this._account.address ? [
                    this._account.address
                ] : [];
            case "eth_chainId":
                return `0x${this._chainId.toString(16)}`;
            case "wallet_switchEthereumChain":
                return this.handleSwitchEthereumChain(e);
            case "eth_estimateGas":
                return this.handleEstimateGas(e);
            case "eth_sendTransaction":
                {
                    let t = e.params?.[0];
                    return this.handleSendTransaction(t);
                }
            case "eth_populateTransactionRequest":
                {
                    let t = e.params?.[0];
                    return this.handlePopulateTransaction(t);
                }
            default:
                return this.handleJsonRpc(e);
        }
    }
    ensureChainId(e) {
        let t = {
            chainId: this._chainId,
            ...e
        };
        return this.internalSwitchEthereumChain(t.chainId), t;
    }
    internalSwitchEthereumChain(e) {
        e && Number(e) !== this._chainId && (this._chainId = Number(e), this._jsonRpcProvider = (0, _indexMjs.getJsonRpcProvider)(this._chainId, this._chains, {
            rpcUrls: []
        }, {
            appId: this._privyInternal.appId
        }), this.emit("chainChanged", e));
    }
    async handlePopulateTransaction(e) {
        let t = this.ensureChainId(e);
        return (0, _indexMjs.populateTransactionRequest)(this._account.address, t, this._jsonRpcProvider);
    }
    async handleSendTransaction(e) {
        let t = this.ensureChainId(e), r = await (0, _indexMjs.populateTransactionRequest)(this._account.address, t, this._jsonRpcProvider), a = await this.handleIFrameRpc({
            method: "eth_signTransaction",
            params: [
                r
            ]
        });
        return await this.handleJsonRpc({
            method: "eth_sendRawTransaction",
            params: [
                a
            ]
        });
    }
    async handleEstimateGas(e) {
        if (!e.params || !Array.isArray(e.params)) throw Error("Invalid params for eth_estimateGas");
        delete e.params[0].gasPrice, delete e.params[0].maxFeePerGas, delete e.params[0].maxPriorityFeePerGas;
        let t = {
            ...e.params[0],
            chainId: `0x${this._chainId.toString(16)}`
        };
        this.internalSwitchEthereumChain(t.chainId);
        try {
            return await this._jsonRpcProvider.send("eth_estimateGas", [
                t
            ]);
        } catch (e) {
            console.warn(`Gas estimation failed with error: ${e}. Retrying gas estimation by omitting the 'from' address`);
            try {
                return delete t.from, await this._jsonRpcProvider.send("eth_estimateGas", [
                    t
                ]);
            } catch (t) {
                throw console.warn(`Gas estimation failed with error: ${t} when omitting the 'from' address`), e;
            }
        }
    }
    handleSwitchEthereumChain(e) {
        let t;
        if (!e.params || !Array.isArray(e.params)) throw new (0, _errorsMjs.EmbeddedProviderError)(`Invalid params for ${e.method}`, 4200);
        if ("string" == typeof e.params[0]) t = e.params[0];
        else {
            if (!("chainId" in e.params[0]) || "string" != typeof e.params[0].chainId) throw new (0, _errorsMjs.EmbeddedProviderError)(`Invalid params for ${e.method}`, 4200);
            t = e.params[0].chainId;
        }
        this.internalSwitchEthereumChain(t);
    }
    async handleIFrameRpc(e) {
        try {
            let a = await this._privyInternal.getAccessToken();
            if (!a) throw Error("Missing privy token. User must be logged in");
            this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started", {
                method: e.method,
                address: this._account.address
            });
            let i = this._account;
            if ((0, _unifiedWalletMjs.isUnifiedWallet)(i)) {
                let { data: t } = await (0, _walletRpcMjs.walletRpc)({
                    context: {
                        app: this._appApi,
                        fetchPrivyRoute: (...e)=>this._privyInternal.fetch(...e),
                        getCompiledPath: (...e)=>this._privyInternal.getPath(...e),
                        signRequest: ({ message: e })=>this._walletProxy.signWithUserSigner({
                                accessToken: a,
                                message: e
                            })
                    },
                    account: i,
                    rpcRequest: {
                        chainType: "ethereum",
                        request: e
                    }
                });
                return t;
            }
            try {
                await this._walletProxy.connect({
                    entropyId: this._entropyId,
                    entropyIdVerifier: this._entropyIdVerifier,
                    accessToken: a
                });
            } catch (e) {
                let r = (0, _errorsMjs.errorIndicatesRecoveryIsNeeded)(e);
                if (r && "privy" === this._account.recovery_method) await this._walletProxy.recover({
                    entropyId: this._entropyId,
                    entropyIdVerifier: this._entropyIdVerifier,
                    accessToken: a
                });
                else {
                    if (!r || !this._onNeedsRecovery) throw e;
                    {
                        let e;
                        await new Promise(async (r, a)=>{
                            e = setTimeout(()=>a(new (0, _errorMjs.PrivyClientError)({
                                    code: "embedded_wallet_recovery_error",
                                    error: "User-owned recovery timed out"
                                })), 12e4), await this._onNeedsRecovery?.({
                                recoveryMethod: this._account.recovery_method,
                                onRecovered: ()=>r(!0)
                            });
                        }).finally(()=>clearTimeout(e));
                    }
                }
            }
            return (await this._walletProxy.rpcWallet({
                accessToken: a,
                request: e,
                entropyId: this._entropyId,
                entropyIdVerifier: this._entropyIdVerifier,
                hdWalletIndex: this._account.wallet_index,
                chainType: "ethereum"
            })).response.data;
        } catch (r) {
            console.error(r);
            let a = r instanceof Error ? r.message : "Unable to make wallet request";
            throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed", {
                method: e.method,
                address: this._account.address,
                error: a
            }), new (0, _errorMjs.PrivyClientError)({
                code: "embedded_wallet_request_error",
                error: a
            });
        }
    }
    async handleJsonRpc(e) {
        return this._jsonRpcProvider.send(e.method, e.params ?? []);
    }
    toJSON() {
        return `PrivyEIP1193Provider { address: '${this._account.address}', chainId: ${this._chainId}, request: [Function] }`;
    }
    constructor({ walletProxy: e, privyInternal: t, account: r, entropyId: a, entropyIdVerifier: s, chains: i, onNeedsRecovery: n, chainId: h = i[0].id, appApi: c }){
        super(), this._walletProxy = e, this._privyInternal = t, this._account = r, this._entropyId = a, this._entropyIdVerifier = s, this._chainId = h, this._chains = i, this._onNeedsRecovery = n, this._jsonRpcProvider = (0, _indexMjs.getJsonRpcProvider)(h, i, {
            rpcUrls: []
        }, {
            appId: c.appId
        }), this._appApi = c;
    }
}

},{"eventemitter3":"8mZjp","../Error.mjs":"kMDGn","../wallet-api/unified-wallet.mjs":"5BZHk","./errors.mjs":"imCDj","./methods.mjs":"28Nn8","./stack/walletRpc.mjs":"i6bqj","./utils/index.mjs":"2aCHs","./types.mjs":"47MbA","../utils/encodings.mjs":"cllJf","../wallet-api/rpc.mjs":"fTVkX","canonicalize":"jVWhK","@privy-io/public-api":"3ZXNH","./stack/wallet-api-eth-transaction.mjs":"aQkVZ","./stack/wallet-api-eth-typed-data.mjs":"8pORF","@ethersproject/abstract-signer":"bq0ju","@ethersproject/providers":"8k75m","./gas/arbitrum.mjs":"hCPYQ","@ethersproject/bignumber":"gSTRF","@privy-io/chains":"9r5Tr","./utils/ethers.mjs":"1PLH5","./gas/bsc.mjs":"hbFMz","./gas/op-stack.mjs":"KVI98","@ethersproject/contracts":"26Zqo","@ethersproject/transactions":"lqSCl","./gas/polygon.mjs":"4wW2T","@ethersproject/units":"4X8jY","fetch-retry":"knqh8","./utils/gas.mjs":"bzO8p","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8mZjp":[function(require,module,exports,__globalThis) {
'use strict';
var has = Object.prototype.hasOwnProperty, prefix = '~';
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */ function Events() {}
//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
    Events.prototype = Object.create(null);
    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */ function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */ function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') throw new TypeError('The listener must be a function');
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [
        emitter._events[evt],
        listener
    ];
    return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */ function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */ function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */ EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for(name in events = this._events)if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));
    return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */ EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [
        handlers.fn
    ];
    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;
    return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */ EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch(len){
            case 1:
                return listeners.fn.call(listeners.context), true;
            case 2:
                return listeners.fn.call(listeners.context, a1), true;
            case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];
        listeners.fn.apply(listeners.context, args);
    } else {
        var length = listeners.length, j;
        for(i = 0; i < length; i++){
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
            switch(len){
                case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                default:
                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];
                    listeners[i].fn.apply(listeners[i].context, args);
            }
        }
    }
    return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
        clearEvent(this, evt);
        return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) clearEvent(this, evt);
    } else {
        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
    }
    return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
    } else {
        this._events = new Events();
        this._eventsCount = 0;
    }
    return this;
};
//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;
//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;
module.exports = EventEmitter;

},{}],"28Nn8":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isSupportedIframeRpcMethod", ()=>n);
let s = [
    "eth_sign",
    "eth_signTransaction",
    "personal_sign",
    "eth_signTypedData_v4",
    "csw_signUserOperation",
    "secp256k1_sign"
];
const n = (n)=>s.includes(n);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"i6bqj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "walletRpc", ()=>r);
var _encodingsMjs = require("../../utils/encodings.mjs");
var _rpcMjs = require("../../wallet-api/rpc.mjs");
var _walletApiEthTransactionMjs = require("./wallet-api-eth-transaction.mjs");
var _walletApiEthTypedDataMjs = require("./wallet-api-eth-typed-data.mjs");
var _canonicalize = require("canonicalize");
var _publicApi = require("@privy-io/public-api");
async function r({ context: r, account: o, rpcRequest: c }) {
    switch(c.chainType){
        case "ethereum":
            return async function({ context: r, account: o, rpcRequest: c }) {
                switch(c.method){
                    case "personal_sign":
                        {
                            let [e] = c.params, t = await (0, _rpcMjs.rpc)(r, r.signRequest, {
                                chain_type: "ethereum",
                                method: "personal_sign",
                                wallet_id: o.id,
                                params: e.startsWith("0x") ? {
                                    message: e.slice(2),
                                    encoding: "hex"
                                } : {
                                    message: e,
                                    encoding: "utf-8"
                                }
                            });
                            if ("personal_sign" !== t.method) throw Error("Unable to sign message");
                            return {
                                data: t.data.signature
                            };
                        }
                    case "eth_signTransaction":
                        {
                            let [e] = c.params, t = await (0, _rpcMjs.rpc)(r, r.signRequest, {
                                chain_type: "ethereum",
                                method: "eth_signTransaction",
                                wallet_id: o.id,
                                params: {
                                    transaction: (0, _walletApiEthTransactionMjs.toWalletApiUnsignedEthTransaction)(e)
                                }
                            });
                            if ("eth_signTransaction" !== t.method) throw Error("Unable to sign transaction");
                            return {
                                data: t.data.signed_transaction
                            };
                        }
                    case "eth_signTypedData_v4":
                        {
                            let [, e] = c.params, t = await (0, _rpcMjs.rpc)(r, r.signRequest, {
                                chain_type: "ethereum",
                                method: c.method,
                                wallet_id: o.id,
                                params: {
                                    typed_data: (0, _walletApiEthTypedDataMjs.toWalletApiTypedData)(e)
                                }
                            });
                            if ("eth_signTypedData_v4" !== t.method) throw Error("Unable to sign typed data");
                            return {
                                data: t.data.signature
                            };
                        }
                    case "eth_sign":
                        {
                            let [, n] = c.params, i = await (0, _rpcMjs.rpc)(r, r.signRequest, {
                                chain_type: "ethereum",
                                method: "secp256k1_sign",
                                wallet_id: o.id,
                                params: {
                                    hash: (0, _encodingsMjs.isHexEncoded)(n) ? n : (0, _encodingsMjs.bytesToHex)((0, _encodingsMjs.utf8ToBytes)(n))
                                }
                            });
                            if ("secp256k1_sign" !== i.method) throw Error("Unable to sign message");
                            return {
                                data: i.data.signature
                            };
                        }
                    case "secp256k1_sign":
                        {
                            let [n] = c.params, i = await (0, _rpcMjs.rpc)(r, r.signRequest, {
                                chain_type: "ethereum",
                                method: "secp256k1_sign",
                                wallet_id: o.id,
                                params: {
                                    hash: (0, _encodingsMjs.isHexEncoded)(n) ? n : (0, _encodingsMjs.bytesToHex)((0, _encodingsMjs.utf8ToBytes)(n))
                                }
                            });
                            if ("secp256k1_sign" !== i.method) throw Error("Unable to sign message");
                            return {
                                data: i.data.signature
                            };
                        }
                    case "csw_signUserOperation":
                    case "eth_sendTransaction":
                    case "eth_populateTransactionRequest":
                        throw Error(`This wallet does not support the method: ${c.method}`);
                }
            }({
                context: r,
                account: o,
                rpcRequest: c.request
            });
        case "solana":
            return async function({ context: e, account: t, rpcRequest: a }) {
                if ("signMessage" === a.method) {
                    let { message: n } = a.params, i = await (0, _rpcMjs.rpc)(e, e.signRequest, {
                        chain_type: "solana",
                        method: "signMessage",
                        wallet_id: t.id,
                        params: {
                            message: n,
                            encoding: "base64"
                        }
                    });
                    if ("signMessage" !== i.method) throw Error("Unable to sign message");
                    return {
                        data: i.data.signature
                    };
                }
            }({
                context: r,
                account: o,
                rpcRequest: c.request
            });
    }
}

},{"../../utils/encodings.mjs":"cllJf","../../wallet-api/rpc.mjs":"fTVkX","./wallet-api-eth-transaction.mjs":"aQkVZ","./wallet-api-eth-typed-data.mjs":"8pORF","canonicalize":"jVWhK","@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cllJf":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "bytesToHex", ()=>e);
parcelHelpers.export(exports, "isHexEncoded", ()=>t);
parcelHelpers.export(exports, "utf8ToBytes", ()=>f);
var Buffer = require("ebd013ee79b7a42e").Buffer;
const t = (t)=>/^0x[0-9a-fA-F]*$/.test(t), f = (t)=>Buffer.from(t, "utf8"), e = (t)=>`0x${t.toString("hex")}`;

},{"ebd013ee79b7a42e":"2IoUh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"2IoUh":[function(require,module,exports,__globalThis) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
var base64 = require("936d7d40ee51556e");
var ieee754 = require("a9454e8447bbf491");
var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
 ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    var b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for(var i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    var buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    var x = a.length;
    var y = b.length;
    for(var i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    var i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for(i = 0; i < list.length; ++i){
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) Buffer.from(buf).copy(buffer, pos);
            else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(var i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(var i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(var i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for(var i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            var found = true;
            for(var j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    var strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    for(var i = 0; i < length; ++i){
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    var loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while(i < end){
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for(var i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';
    for(var i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(var i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset + --byteLength];
    var mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for(var i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for(var i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for(var i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for(var i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = function() {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);
    for(var i = 0; i < 16; ++i){
        var i16 = i * 16;
        for(var j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();

},{"936d7d40ee51556e":"70yvn","a9454e8447bbf491":"jVlo5"}],"70yvn":[function(require,module,exports,__globalThis) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}

},{}],"jVlo5":[function(require,module,exports,__globalThis) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"fTVkX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rpc", ()=>e);
var _canonicalize = require("canonicalize");
var _canonicalizeDefault = parcelHelpers.interopDefault(_canonicalize);
var _publicApi = require("@privy-io/public-api");
var Buffer = require("f5ab2a180cc91afd").Buffer;
async function e(e, r, { wallet_id: t, ...o }) {
    let p = {
        version: 1,
        url: e.getCompiledPath((0, _publicApi.WalletRpc), {
            params: {
                wallet_id: t
            }
        }),
        method: (0, _publicApi.WalletRpc).method,
        headers: {
            "privy-app-id": e.app.appId
        },
        body: {
            ...o
        }
    }, d = Buffer.from((0, _canonicalizeDefault.default)(p)).toString("base64"), { signature: l } = await r({
        message: d
    });
    return await e.fetchPrivyRoute((0, _publicApi.WalletRpc), {
        body: o,
        params: {
            wallet_id: t
        },
        headers: {
            "privy-authorization-signature": l
        }
    });
}

},{"f5ab2a180cc91afd":"2IoUh","canonicalize":"jVWhK","@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jVWhK":[function(require,module,exports,__globalThis) {
/* jshint esversion: 6 */ /* jslint node: true */ 'use strict';
module.exports = function serialize(object) {
    if (typeof object === 'number' && isNaN(object)) throw new Error('NaN is not allowed');
    if (typeof object === 'number' && !isFinite(object)) throw new Error('Infinity is not allowed');
    if (object === null || typeof object !== 'object') return JSON.stringify(object);
    if (object.toJSON instanceof Function) return serialize(object.toJSON());
    if (Array.isArray(object)) {
        const values = object.reduce((t, cv, ci)=>{
            const comma = ci === 0 ? '' : ',';
            const value = cv === undefined || typeof cv === 'symbol' ? null : cv;
            return `${t}${comma}${serialize(value)}`;
        }, '');
        return `[${values}]`;
    }
    const values = Object.keys(object).sort().reduce((t, cv)=>{
        if (object[cv] === undefined || typeof object[cv] === 'symbol') return t;
        const comma = t.length === 0 ? '' : ',';
        return `${t}${comma}${serialize(cv)}:${serialize(object[cv])}`;
    }, '');
    return `{${values}}`;
};

},{}],"aQkVZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toWalletApiUnsignedEthTransaction", ()=>i);
var _encodingsMjs = require("../../utils/encodings.mjs");
var Buffer = require("2775a026d62d051d").Buffer;
function i(i) {
    return {
        from: i.from,
        to: i.to,
        nonce: n(i.nonce),
        chain_id: n(i.chainId),
        data: function(i) {
            if (void 0 !== i) return "string" == typeof i ? (0, _encodingsMjs.isHexEncoded)(i) ? i : (0, _encodingsMjs.bytesToHex)((0, _encodingsMjs.utf8ToBytes)(i)) : (0, _encodingsMjs.bytesToHex)(Buffer.from(Uint8Array.from(i)));
        }(i.data),
        value: n(i.value),
        type: i.type,
        gas_limit: n(i.gasLimit),
        gas_price: n(i.gasPrice),
        max_fee_per_gas: n(i.maxFeePerGas),
        max_priority_fee_per_gas: n(i.maxPriorityFeePerGas)
    };
}
function n(i) {
    if ("number" == typeof i || "bigint" == typeof i) return `0x${BigInt(i).toString(16)}`;
    if ("string" == typeof i) return (0, _encodingsMjs.isHexEncoded)(i) ? i : (0, _encodingsMjs.bytesToHex)((0, _encodingsMjs.utf8ToBytes)(i));
}

},{"2775a026d62d051d":"2IoUh","../../utils/encodings.mjs":"cllJf","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8pORF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toWalletApiTypedData", ()=>e);
function e(e) {
    return "string" == typeof e && (e = JSON.parse(e)), {
        types: e.types,
        primary_type: String(e.primaryType),
        domain: e.domain,
        message: e.message
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4XBtJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EmbeddedSolanaWalletProvider", ()=>n);
var _errorMjs = require("../Error.mjs");
var _getWalletPublicKeyFromTransactionMjs = require("../solana/getWalletPublicKeyFromTransaction.mjs");
var _isVersionedTransactionMjs = require("../solana/isVersionedTransaction.mjs");
var _unifiedWalletMjs = require("../wallet-api/unified-wallet.mjs");
var _errorsMjs = require("./errors.mjs");
var _walletRpcMjs = require("./stack/walletRpc.mjs");
var _typesMjs = require("./types.mjs");
var _encodingsMjs = require("../utils/encodings.mjs");
var _rpcMjs = require("../wallet-api/rpc.mjs");
var _canonicalize = require("canonicalize");
var _publicApi = require("@privy-io/public-api");
var _walletApiEthTransactionMjs = require("./stack/wallet-api-eth-transaction.mjs");
var _walletApiEthTypedDataMjs = require("./stack/wallet-api-eth-typed-data.mjs");
var Buffer = require("c1da75e8a4f5314a").Buffer;
class n {
    async request(t) {
        if (!await this._privyInternal.getAccessToken()) throw new (0, _errorMjs.PrivyClientError)({
            error: "Missing access token",
            code: "attempted_rpc_call_before_logged_in"
        });
        switch(t.method){
            case "signAndSendTransaction":
                return await this.handleSignAndSendTransaction(t);
            case "signTransaction":
                return await this.handleSignTransaction(t);
            default:
                return await this.handleIFrameRpc(t);
        }
    }
    get _publicKey() {
        return this._account.address;
    }
    async connectAndRecover(t) {
        if ("privy-v2" !== this._account.recovery_method) try {
            await this._proxy.connect({
                entropyId: this._entropyId,
                entropyIdVerifier: this._entropyIdVerifier,
                accessToken: t
            });
        } catch (r) {
            let s = (0, _errorsMjs.errorIndicatesRecoveryIsNeeded)(r);
            if (s && "privy" === this._account.recovery_method) await this._proxy.recover({
                entropyId: this._entropyId,
                entropyIdVerifier: this._entropyIdVerifier,
                accessToken: t
            });
            else {
                if (!s || !this._onNeedsRecovery) throw r;
                {
                    let t;
                    await new Promise(async (r, s)=>{
                        t = setTimeout(()=>s(new (0, _errorMjs.PrivyClientError)({
                                code: "embedded_wallet_recovery_error",
                                error: "User-owned recovery timed out"
                            })), 12e4), await this._onNeedsRecovery?.({
                            recoveryMethod: this._account.recovery_method,
                            onRecovered: ()=>r(!0)
                        });
                    }).finally(()=>clearTimeout(t));
                }
            }
        }
    }
    async signMessageRpc(e, t) {
        let r = this._account;
        if (!(0, _unifiedWalletMjs.isUnifiedWallet)(r)) return (await this._proxy.rpcWallet({
            accessToken: t,
            request: e,
            chainType: "solana",
            hdWalletIndex: this._account.wallet_index,
            entropyId: this._entropyId,
            entropyIdVerifier: this._entropyIdVerifier
        })).response.data;
        {
            let { data: s } = await (0, _walletRpcMjs.walletRpc)({
                context: {
                    app: this._app,
                    fetchPrivyRoute: (...e)=>this._privyInternal.fetch(...e),
                    getCompiledPath: (...e)=>this._privyInternal.getPath(...e),
                    signRequest: ({ message: e })=>this._proxy.signWithUserSigner({
                            accessToken: t,
                            message: e
                        })
                },
                account: r,
                rpcRequest: {
                    chainType: "solana",
                    request: e
                }
            });
            return {
                signature: s
            };
        }
    }
    async handleIFrameRpc(t) {
        try {
            let e = await this._privyInternal.getAccessToken();
            if (!e) throw Error("Missing privy token. User must be logged in");
            return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started", {
                method: t.method,
                address: this._account.address
            }), await this.connectAndRecover(e), await this.signMessageRpc(t, e);
        } catch (r) {
            console.error(r);
            let s = r instanceof Error ? r.message : "Unable to make wallet request";
            throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed", {
                method: t.method,
                address: this._account.address,
                error: s
            }), new (0, _errorMjs.PrivyClientError)({
                code: "embedded_wallet_request_error",
                error: s
            });
        }
    }
    async handleSignAndSendTransaction(s) {
        try {
            let e = await this._privyInternal.getAccessToken();
            if (!e) throw Error("Missing privy token. User must be logged in");
            this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started", {
                method: s.method,
                address: this._account.address
            }), await this.connectAndRecover(e);
            let { transaction: a, connection: i, options: n } = s.params, o = (0, _getWalletPublicKeyFromTransactionMjs.getWalletPublicKeyFromTransaction)(a, this._account.address), c = (0, _isVersionedTransactionMjs.isVersionedTransaction)(a) ? Buffer.from(a.message.serialize()) : a.serializeMessage(), { signature: d } = await this.signMessageRpc({
                method: "signMessage",
                params: {
                    message: c.toString("base64")
                }
            }, e);
            return a.addSignature(o, Buffer.from(d, "base64")), {
                signature: await i.sendRawTransaction(a.serialize(), n)
            };
        } catch (t) {
            console.error(t);
            let r = t instanceof Error ? t.message : "Unable to make wallet request";
            throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed", {
                method: s.method,
                address: this._account.address,
                error: r
            }), new (0, _errorMjs.PrivyClientError)({
                code: "embedded_wallet_request_error",
                error: r
            });
        }
    }
    async handleSignTransaction(s) {
        try {
            let e = await this._privyInternal.getAccessToken();
            if (!e) throw Error("Missing privy token. User must be logged in");
            this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started", {
                method: s.method,
                address: this._account.address
            }), await this.connectAndRecover(e);
            let { transaction: a } = s.params, i = (0, _getWalletPublicKeyFromTransactionMjs.getWalletPublicKeyFromTransaction)(a, this._account.address), n = (0, _isVersionedTransactionMjs.isVersionedTransaction)(a) ? Buffer.from(a.message.serialize()) : a.serializeMessage(), { signature: o } = await this.signMessageRpc({
                method: "signMessage",
                params: {
                    message: n.toString("base64")
                }
            }, e);
            return a.addSignature(i, Buffer.from(o, "base64")), {
                signedTransaction: a
            };
        } catch (t) {
            console.error(t);
            let r = t instanceof Error ? t.message : "Unable to make wallet request";
            throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed", {
                method: s.method,
                address: this._account.wallet_index,
                error: r
            }), new (0, _errorMjs.PrivyClientError)({
                code: "embedded_wallet_request_error",
                error: r
            });
        }
    }
    toJSON() {
        return `PrivyEmbeddedSolanaProvider { address: '${this._account.address}', request: [Function] }`;
    }
    constructor({ proxy: e, privyInternal: t, account: r, entropyId: s, entropyIdVerifier: a, onNeedsRecovery: i, app: n }){
        this._proxy = e, this._privyInternal = t, this._account = r, this._entropyId = s, this._entropyIdVerifier = a, this._onNeedsRecovery = i, this._app = n;
    }
}

},{"c1da75e8a4f5314a":"2IoUh","../Error.mjs":"kMDGn","../solana/getWalletPublicKeyFromTransaction.mjs":"gDAuD","../solana/isVersionedTransaction.mjs":"4CmTh","../wallet-api/unified-wallet.mjs":"5BZHk","./errors.mjs":"imCDj","./stack/walletRpc.mjs":"i6bqj","./types.mjs":"47MbA","../utils/encodings.mjs":"cllJf","../wallet-api/rpc.mjs":"fTVkX","canonicalize":"jVWhK","@privy-io/public-api":"3ZXNH","./stack/wallet-api-eth-transaction.mjs":"aQkVZ","./stack/wallet-api-eth-typed-data.mjs":"8pORF","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gDAuD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getWalletPublicKeyFromTransaction", ()=>e);
var _isVersionedTransactionMjs = require("./isVersionedTransaction.mjs");
function e(e, t) {
    let n = ((0, _isVersionedTransactionMjs.isVersionedTransaction)(e) ? e.message : e.compileMessage()).staticAccountKeys.find((o)=>o.toBase58() === t);
    if (!n) throw Error(`Transaction does not contain public key ${t}`);
    return n;
}

},{"./isVersionedTransaction.mjs":"4CmTh","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"4CmTh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isVersionedTransaction", ()=>n);
function n(n) {
    return "version" in n;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gvOKx":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>r);
var _eventemitter3 = require("eventemitter3");
var _eventemitter3Default = parcelHelpers.interopDefault(_eventemitter3);
class r extends (0, _eventemitter3Default.default) {
    constructor(){
        super(), this.rootPromise = {
            current: null
        }, this.submitPromise = {
            current: null
        };
    }
}

},{"eventemitter3":"8mZjp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7svVu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PrivyInternal", ()=>u);
var _fetchRetry = require("fetch-retry");
var _fetchRetryDefault = parcelHelpers.interopDefault(_fetchRetry);
var _uuid = require("uuid");
var _apiBase = require("@privy-io/api-base");
var _publicApi = require("@privy-io/public-api");
var _errorMjs = require("../Error.mjs");
var _sessionMjs = require("../Session.mjs");
var _toAbortSignalTimeoutMjs = require("../toAbortSignalTimeout.mjs");
var _toAbortSignalTimeoutMjsDefault = parcelHelpers.interopDefault(_toAbortSignalTimeoutMjs);
var _toSearchParamsMjs = require("../utils/toSearchParams.mjs");
var _loggerMjs = require("./logger.mjs");
var _eventemitter3 = require("eventemitter3");
var _jose = require("jose");
var _jsCookie = require("js-cookie");
var _tokenMjs = require("../Token.mjs");
var _allSettledMjs = require("../utils/allSettled.mjs");
var _noopMjs = require("../utils/noop.mjs");
let p = "privy:caid";
class u {
    setCallbacks(e) {
        this.callbacks = {
            ...this.callbacks,
            ...e
        };
    }
    get isReady() {
        return !!this._config;
    }
    get config() {
        return this._config;
    }
    get caid() {
        return this._analyticsId;
    }
    async _initialize() {
        if (this.isReady) this.callbacks?.setIsReady?.(!0);
        else {
            if (!await this.isStorageAccessible()) throw new (0, _errorMjs.PrivyClientError)({
                code: "storage_error",
                error: "Unable to access storage"
            });
            this._config = await this.getAppConfig(), this._config?.custom_api_url && (this.baseUrl = this._config.custom_api_url, this.session.isUsingServerCookies = !0), this.callbacks?.setIsReady?.(!0), this._sdkVersion.startsWith("react-auth:") || this.createAnalyticsEvent("sdk_initialize", {});
        }
    }
    getPath(e, { params: t, query: s }) {
        return `${this.baseUrl}${(0, _publicApi.getPathWithParams)(e.path, t)}${(0, _toSearchParamsMjs.toSearchParams)(s)}`;
    }
    async fetch(e, { body: t, params: s, query: i, headers: r, onRequest: a = this._beforeRequest.bind(this) }) {
        let n = new Request(this.getPath(e, {
            params: s,
            query: i
        }), {
            method: e.method,
            body: JSON.stringify(t),
            headers: r
        }), o = await a(n), l = await this._fetch(n, o), c = await l.json();
        if (l.status > 299) throw new (0, _errorMjs.PrivyApiError)(c);
        return c;
    }
    async _beforeRequestWithoutInitialize(e) {
        let t = await this.session.getToken(), s = new Headers(e.headers);
        s.set("privy-app-id", this.appId), this.appClientId && s.set("privy-client-id", this.appClientId), s.set("privy-client", this._sdkVersion), t && s.set("Authorization", `Bearer ${t}`), s.set("Content-Type", "application/json"), s.set("Accept", "application/json");
        let i = await this._getOrGenerateClientAnalyticsId();
        return i && s.set("privy-ca-id", i), this.nativeAppIdentifier && s.set("x-native-app-identifier", this.nativeAppIdentifier), {
            signal: (0, _toAbortSignalTimeoutMjsDefault.default)(2e4),
            headers: s,
            credentials: "include"
        };
    }
    async beforeRequestWithoutRefresh(e) {
        return await this._initialize(), this._beforeRequestWithoutInitialize(e);
    }
    async _beforeRequest(e) {
        return await this._initialize(), await this.getAccessToken(), this.beforeRequestWithoutRefresh(e);
    }
    async getAppConfig() {
        return await this.fetch((0, _publicApi.AppConfig), {
            params: {
                app_id: this.appId
            },
            onRequest: this._beforeRequestWithoutInitialize.bind(this)
        });
    }
    async _getOrGenerateClientAnalyticsId() {
        if (this._analyticsId) return this._analyticsId;
        try {
            let e = await this._storage.get(p);
            if ("string" == typeof e && e.length > 0) return this._analyticsId = e, e;
        } catch (e) {
            this.logger.error("Unable to load clientId", e);
        }
        try {
            this._analyticsId = (0, _uuid.v4)();
        } catch (e) {
            this.logger.error("Unable to generate uuidv4", e);
        }
        if (!this._analyticsId) return null;
        try {
            await this._storage.put(p, this._analyticsId);
        } catch (e) {
            this.logger.error(`Unable to store clientId: ${this._analyticsId}`, e);
        }
        return this._analyticsId;
    }
    async destroyClientAnalyticsId() {
        try {
            return await this._storage.del(p);
        } catch (e) {
            this.logger.error("Unable to delete clientId", e);
        }
    }
    async createAnalyticsEvent(e, t) {
        try {
            await this.fetch((0, _publicApi.AnalyticsEvent), {
                body: {
                    event_name: e,
                    client_id: await this._getOrGenerateClientAnalyticsId(),
                    payload: t
                },
                onRequest: this.beforeRequestWithoutRefresh.bind(this)
            });
        } catch (e) {}
    }
    async refreshSession(e = !1) {
        if (!await this.isStorageAccessible()) throw new (0, _errorMjs.PrivyClientError)({
            code: "storage_error",
            error: "Unable to access storage"
        });
        let t = await this.session.getRefreshToken() ?? void 0, s = t ?? "key", i = this._cache.get(s);
        if (i) return this.logger.debug("[privy:refresh] found in-flight session refresh request, deduping"), await i;
        let r = this._refreshSession(t, e);
        this._cache.set(s, r);
        try {
            return await r;
        } finally{
            this._cache.delete(s);
        }
    }
    async _refreshSession(e, t) {
        let i = await this.session.getToken();
        if (!this.session.hasRefreshCredentials(i, e ?? null)) throw this.logger.debug("[privy:refresh] missing tokens, skipping request"), await this._initialize(), new (0, _errorMjs.PrivyApiError)({
            code: (0, _apiBase.PrivyErrorCode).MISSING_OR_INVALID_TOKEN,
            error: "No tokens found in storage"
        });
        try {
            this.logger.debug(`[privy:refresh] fetching: ${(0, _publicApi.RefreshSession).path}`);
            let s = await this.fetch((0, _publicApi.RefreshSession), {
                body: {
                    refresh_token: e
                },
                onRequest: this.beforeRequestWithoutRefresh.bind(this)
            }), i = s.session_update_action;
            return this.logger.debug(`[privy:refresh] response: ${i}`), t || this.callbacks?.setUser?.(s.user), "set" === i && (await this.session.updateWithTokensResponse(s), this.logger.debug("[privy:refresh] tokens stored")), "clear" === i && (await this.session.destroyLocalState(), this.logger.debug("[privy:refresh] tokens cleared"), t || this.callbacks?.setUser?.(null)), "ignore" === i && s.token && (await this.session.storeToken(s.token), this.logger.debug("[privy:refresh] access token stored"), s.identity_token && (this.logger.debug("[privy:refresh] identity token stored"), await this.session.storeIdentityToken(s.identity_token))), this.logger.debug("[privy:refresh] returning response"), s;
        } catch (e) {
            throw this.logger.debug(`[privy:refresh] error: ${e.message ?? "unknown error"}`), e instanceof (0, _errorMjs.PrivyApiError) && e.code === (0, _apiBase.PrivyErrorCode).MISSING_OR_INVALID_TOKEN && (await this.session.destroyLocalState(), t || this.callbacks?.setUser?.(null)), e;
        }
    }
    async getAccessToken() {
        let [e, t] = await Promise.all([
            this.session.getToken(),
            this.session.getRefreshToken()
        ]);
        if (!this.session.tokenIsActive(e) && this.session.hasRefreshCredentials(e, t)) {
            let t = await this.refreshSession(), s = await this.session.getToken();
            return t.token || this.logger.debug("[privy:getAccessToken] expected token received null"), t.token === e && this.logger.debug("[privy:getAccessToken] expected new token in response received existing"), s === e && this.logger.debug("[privy:getAccessToken] expected new token in storage received existing"), t.token ?? s;
        }
        return e;
    }
    async getIdentityToken() {
        return await this.session.getIdentityToken();
    }
    async isStorageAccessible() {
        try {
            let e = `privy:__storage__test-${(0, _uuid.v4)()}`, s = "blobby";
            await this._storage.put(e, s);
            let i = await this._storage.get(e);
            return await this._storage.del(e), i === s;
        } catch (e) {
            return this.logger.error(e), !1;
        }
    }
    constructor(t){
        this._sdkVersion = "js-sdk-core:0.50.4", this._cache = new Map, this.logger = (0, _loggerMjs.toConsoleLogger)({
            level: t.logLevel ?? "ERROR"
        }), this._storage = t.storage, this._analyticsId = null, this._getOrGenerateClientAnalyticsId(), this.baseUrl = t.baseUrl ?? "https://auth.privy.io", this.appId = t.appId, this.appClientId = t.appClientId, this._sdkVersion = t.sdkVersion ?? this._sdkVersion, this.callbacks = t.callbacks, this.nativeAppIdentifier = t.nativeAppIdentifier, this.session = new (0, _sessionMjs.Session)({
            storage: this._storage,
            isUsingServerCookies: !1,
            appId: t.appId
        }), this._fetch = (0, _fetchRetryDefault.default)(globalThis.fetch, {
            retries: 3,
            retryDelay: (e)=>3 ** e * 500,
            retryOn: [
                408,
                409,
                425,
                500,
                502,
                503,
                504
            ]
        }), this.session.on("error_storing_tokens", (e)=>{
            this.createAnalyticsEvent("error_updating_tokens_in_storage", {
                reason: e
            });
        });
    }
}

},{"fetch-retry":"knqh8","uuid":"f1qTK","@privy-io/api-base":"lvLPC","@privy-io/public-api":"3ZXNH","../Error.mjs":"kMDGn","../Session.mjs":"bJKDO","../toAbortSignalTimeout.mjs":"8wsRn","../utils/toSearchParams.mjs":"lu4wu","./logger.mjs":"6jIFl","eventemitter3":"8mZjp","jose":"80NDr","js-cookie":"cEALr","../Token.mjs":"kjSV6","../utils/allSettled.mjs":"kFsnG","../utils/noop.mjs":"e1jCM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f1qTK":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "v1", ()=>(0, _v1JsDefault.default));
parcelHelpers.export(exports, "v3", ()=>(0, _v3JsDefault.default));
parcelHelpers.export(exports, "v4", ()=>(0, _v4JsDefault.default));
parcelHelpers.export(exports, "v5", ()=>(0, _v5JsDefault.default));
parcelHelpers.export(exports, "NIL", ()=>(0, _nilJsDefault.default));
parcelHelpers.export(exports, "version", ()=>(0, _versionJsDefault.default));
parcelHelpers.export(exports, "validate", ()=>(0, _validateJsDefault.default));
parcelHelpers.export(exports, "stringify", ()=>(0, _stringifyJsDefault.default));
parcelHelpers.export(exports, "parse", ()=>(0, _parseJsDefault.default));
var _v1Js = require("./v1.js");
var _v1JsDefault = parcelHelpers.interopDefault(_v1Js);
var _v3Js = require("./v3.js");
var _v3JsDefault = parcelHelpers.interopDefault(_v3Js);
var _v4Js = require("./v4.js");
var _v4JsDefault = parcelHelpers.interopDefault(_v4Js);
var _v5Js = require("./v5.js");
var _v5JsDefault = parcelHelpers.interopDefault(_v5Js);
var _nilJs = require("./nil.js");
var _nilJsDefault = parcelHelpers.interopDefault(_nilJs);
var _versionJs = require("./version.js");
var _versionJsDefault = parcelHelpers.interopDefault(_versionJs);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
var _stringifyJs = require("./stringify.js");
var _stringifyJsDefault = parcelHelpers.interopDefault(_stringifyJs);
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);

},{"./v1.js":"042CM","./v3.js":"fqBn5","./v4.js":"7Sd5x","./v5.js":"3itEG","./nil.js":"9xbEn","./version.js":"bY08K","./validate.js":"3wmxZ","./stringify.js":"9dsAN","./parse.js":"9yQPA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"042CM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js"); // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;
let _clockseq; // Previous uuid creation time
let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189
    if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || (0, _rngJsDefault.default))();
        if (node == null) // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
        node = _nodeId = [
            seedBytes[0] | 0x01,
            seedBytes[1],
            seedBytes[2],
            seedBytes[3],
            seedBytes[4],
            seedBytes[5]
        ];
        if (clockseq == null) // Per 4.2.2, randomize (14 bit) clockseq
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) clockseq = clockseq + 1 & 0x3fff;
     // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) nsecs = 0;
     // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000; // `time_low`
    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`
    const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`
    b[i++] = clockseq & 0xff; // `node`
    for(let n = 0; n < 6; ++n)b[i + n] = node[n];
    return buf || (0, _stringifyJs.unsafeStringify)(b);
}
exports.default = v1;

},{"./rng.js":"aMz2Q","./stringify.js":"9dsAN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aMz2Q":[function(require,module,exports,__globalThis) {
// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>rng);
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues) throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
    return getRandomValues(rnds8);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9dsAN":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsafeStringify", ()=>unsafeStringify);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i)byteToHex.push((i + 0x100).toString(16).slice(1));
function unsafeStringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError('Stringified UUID is invalid');
    return uuid;
}
exports.default = stringify;

},{"./validate.js":"3wmxZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3wmxZ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _regexJs = require("./regex.js");
var _regexJsDefault = parcelHelpers.interopDefault(_regexJs);
function validate(uuid) {
    return typeof uuid === 'string' && (0, _regexJsDefault.default).test(uuid);
}
exports.default = validate;

},{"./regex.js":"9mE1W","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9mE1W":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"fqBn5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _v35Js = require("./v35.js");
var _v35JsDefault = parcelHelpers.interopDefault(_v35Js);
var _md5Js = require("./md5.js");
var _md5JsDefault = parcelHelpers.interopDefault(_md5Js);
const v3 = (0, _v35JsDefault.default)('v3', 0x30, (0, _md5JsDefault.default));
exports.default = v3;

},{"./v35.js":"iruG5","./md5.js":"hhNhp","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"iruG5":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DNS", ()=>DNS);
parcelHelpers.export(exports, "URL", ()=>URL);
parcelHelpers.export(exports, "default", ()=>v35);
var _stringifyJs = require("./stringify.js");
var _parseJs = require("./parse.js");
var _parseJsDefault = parcelHelpers.interopDefault(_parseJs);
function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    const bytes = [];
    for(let i = 0; i < str.length; ++i)bytes.push(str.charCodeAt(i));
    return bytes;
}
const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === 'string') value = stringToBytes(value);
        if (typeof namespace === 'string') namespace = (0, _parseJsDefault.default)(namespace);
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
         // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;
        if (buf) {
            offset = offset || 0;
            for(let i = 0; i < 16; ++i)buf[offset + i] = bytes[i];
            return buf;
        }
        return (0, _stringifyJs.unsafeStringify)(bytes);
    } // Function#name is not settable on some platforms (#270)
    try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
    } catch (err) {} // For CommonJS default export support
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
}

},{"./stringify.js":"9dsAN","./parse.js":"9yQPA","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9yQPA":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
function parse(uuid) {
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError('Invalid UUID');
    let v;
    const arr = new Uint8Array(16); // Parse ########-....-....-....-............
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 0xff;
    arr[2] = v >>> 8 & 0xff;
    arr[3] = v & 0xff; // Parse ........-####-....-....-............
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 0xff; // Parse ........-....-####-....-............
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 0xff; // Parse ........-....-....-####-............
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 0xff; // Parse ........-....-....-....-############
    // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
    arr[11] = v / 0x100000000 & 0xff;
    arr[12] = v >>> 24 & 0xff;
    arr[13] = v >>> 16 & 0xff;
    arr[14] = v >>> 8 & 0xff;
    arr[15] = v & 0xff;
    return arr;
}
exports.default = parse;

},{"./validate.js":"3wmxZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hhNhp":[function(require,module,exports,__globalThis) {
/*
 * Browser-compatible JavaScript MD5
 *
 * Modification of JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function md5(bytes) {
    if (typeof bytes === 'string') {
        const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
        bytes = new Uint8Array(msg.length);
        for(let i = 0; i < msg.length; ++i)bytes[i] = msg.charCodeAt(i);
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
/*
 * Convert an array of little-endian words to an array of bytes
 */ function md5ToHexEncodedArray(input) {
    const output = [];
    const length32 = input.length * 32;
    const hexTab = '0123456789abcdef';
    for(let i = 0; i < length32; i += 8){
        const x = input[i >> 5] >>> i % 32 & 0xff;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
        output.push(hex);
    }
    return output;
}
/**
 * Calculate output length with padding and bit length
 */ function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */ function wordsToMd5(x, len) {
    /* append padding */ x[len >> 5] |= 0x80 << len % 32;
    x[getOutputLength(len) - 1] = len;
    let a = 1732584193;
    let b = -271733879;
    let c = -1732584194;
    let d = 271733878;
    for(let i = 0; i < x.length; i += 16){
        const olda = a;
        const oldb = b;
        const oldc = c;
        const oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
    }
    return [
        a,
        b,
        c,
        d
    ];
}
/*
 * Convert an array bytes to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */ function bytesToWords(input) {
    if (input.length === 0) return [];
    const length8 = input.length * 8;
    const output = new Uint32Array(getOutputLength(length8));
    for(let i = 0; i < length8; i += 8)output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
    return output;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */ function safeAdd(x, y) {
    const lsw = (x & 0xffff) + (y & 0xffff);
    const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xffff;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */ function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
}
/*
 * These functions implement the four basic operations the algorithm uses.
 */ function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
exports.default = md5;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7Sd5x":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _nativeJs = require("./native.js");
var _nativeJsDefault = parcelHelpers.interopDefault(_nativeJs);
var _rngJs = require("./rng.js");
var _rngJsDefault = parcelHelpers.interopDefault(_rngJs);
var _stringifyJs = require("./stringify.js");
function v4(options, buf, offset) {
    if ((0, _nativeJsDefault.default).randomUUID && !buf && !options) return (0, _nativeJsDefault.default).randomUUID();
    options = options || {};
    const rnds = options.random || (options.rng || (0, _rngJsDefault.default))(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i)buf[offset + i] = rnds[i];
        return buf;
    }
    return (0, _stringifyJs.unsafeStringify)(rnds);
}
exports.default = v4;

},{"./native.js":"kD2Fc","./rng.js":"aMz2Q","./stringify.js":"9dsAN","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kD2Fc":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
exports.default = {
    randomUUID
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3itEG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _v35Js = require("./v35.js");
var _v35JsDefault = parcelHelpers.interopDefault(_v35Js);
var _sha1Js = require("./sha1.js");
var _sha1JsDefault = parcelHelpers.interopDefault(_sha1Js);
const v5 = (0, _v35JsDefault.default)('v5', 0x50, (0, _sha1JsDefault.default));
exports.default = v5;

},{"./v35.js":"iruG5","./sha1.js":"glDwi","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"glDwi":[function(require,module,exports,__globalThis) {
// Adapted from Chris Veness' SHA1 code at
// http://www.movable-type.co.uk/scripts/sha1.html
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function f(s, x, y, z) {
    switch(s){
        case 0:
            return x & y ^ ~x & z;
        case 1:
            return x ^ y ^ z;
        case 2:
            return x & y ^ x & z ^ y & z;
        case 3:
            return x ^ y ^ z;
    }
}
function ROTL(x, n) {
    return x << n | x >>> 32 - n;
}
function sha1(bytes) {
    const K = [
        0x5a827999,
        0x6ed9eba1,
        0x8f1bbcdc,
        0xca62c1d6
    ];
    const H = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    if (typeof bytes === 'string') {
        const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape
        bytes = [];
        for(let i = 0; i < msg.length; ++i)bytes.push(msg.charCodeAt(i));
    } else if (!Array.isArray(bytes)) // Convert Array-like to Array
    bytes = Array.prototype.slice.call(bytes);
    bytes.push(0x80);
    const l = bytes.length / 4 + 2;
    const N = Math.ceil(l / 16);
    const M = new Array(N);
    for(let i = 0; i < N; ++i){
        const arr = new Uint32Array(16);
        for(let j = 0; j < 16; ++j)arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        M[i] = arr;
    }
    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;
    for(let i = 0; i < N; ++i){
        const W = new Uint32Array(80);
        for(let t = 0; t < 16; ++t)W[t] = M[i][t];
        for(let t = 16; t < 80; ++t)W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        let a = H[0];
        let b = H[1];
        let c = H[2];
        let d = H[3];
        let e = H[4];
        for(let t = 0; t < 80; ++t){
            const s = Math.floor(t / 20);
            const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
            e = d;
            d = c;
            c = ROTL(b, 30) >>> 0;
            b = a;
            a = T;
        }
        H[0] = H[0] + a >>> 0;
        H[1] = H[1] + b >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d >>> 0;
        H[4] = H[4] + e >>> 0;
    }
    return [
        H[0] >> 24 & 0xff,
        H[0] >> 16 & 0xff,
        H[0] >> 8 & 0xff,
        H[0] & 0xff,
        H[1] >> 24 & 0xff,
        H[1] >> 16 & 0xff,
        H[1] >> 8 & 0xff,
        H[1] & 0xff,
        H[2] >> 24 & 0xff,
        H[2] >> 16 & 0xff,
        H[2] >> 8 & 0xff,
        H[2] & 0xff,
        H[3] >> 24 & 0xff,
        H[3] >> 16 & 0xff,
        H[3] >> 8 & 0xff,
        H[3] & 0xff,
        H[4] >> 24 & 0xff,
        H[4] >> 16 & 0xff,
        H[4] >> 8 & 0xff,
        H[4] & 0xff
    ];
}
exports.default = sha1;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9xbEn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
exports.default = '00000000-0000-0000-0000-000000000000';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bY08K":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _validateJs = require("./validate.js");
var _validateJsDefault = parcelHelpers.interopDefault(_validateJs);
function version(uuid) {
    if (!(0, _validateJsDefault.default)(uuid)) throw TypeError('Invalid UUID');
    return parseInt(uuid.slice(14, 15), 16);
}
exports.default = version;

},{"./validate.js":"3wmxZ","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bJKDO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Session", ()=>k);
var _eventemitter3 = require("eventemitter3");
var _eventemitter3Default = parcelHelpers.interopDefault(_eventemitter3);
var _jose = require("jose");
var _jsCookie = require("js-cookie");
var _jsCookieDefault = parcelHelpers.interopDefault(_jsCookie);
var _tokenMjs = require("./Token.mjs");
var _allSettledMjs = require("./utils/allSettled.mjs");
let o = "privy:token", n = "privy-token", a = "privy:refresh_token", _ = "privy-refresh-token", h = "privy:id-token", g = "privy-id-token", l = "privy-session";
class k extends (0, _eventemitter3Default.default) {
    set isUsingServerCookies(e) {
        this._isUsingServerCookies = e;
    }
    async getToken() {
        let e = await this._storage.get(o);
        try {
            return "string" == typeof e ? new (0, _tokenMjs.Token)(e).value : null;
        } catch (e) {
            return console.error(e), await this.destroyLocalState({
                reason: "getToken_error"
            }), null;
        }
    }
    async getRefreshToken() {
        let e = await this._storage.get(a);
        return "string" == typeof e ? e : null;
    }
    async getIdentityToken() {
        let e = await this._storage.get(h);
        return "string" == typeof e ? e : null;
    }
    get mightHaveServerCookies() {
        try {
            let e = (0, _jsCookieDefault.default).get(l);
            return void 0 !== e && e.length > 0;
        } catch (e) {
            console.error(e);
        }
        return !1;
    }
    hasRefreshCredentials(e, t) {
        return this.mightHaveServerCookies || "string" == typeof e && "string" == typeof t;
    }
    tokenIsActive(e) {
        if (!e) return !1;
        let t = (0, _tokenMjs.Token).parse(e);
        return null !== t && !t.isExpired(30);
    }
    async destroyLocalState(e) {
        await (0, _allSettledMjs.allSettled)([
            this._storage.del(o),
            this._storage.del(a),
            this._storage.del(h),
            this._storage.del(this.GUEST_CREDENTIAL_STORAGE_KEY)
        ]), (0, _jsCookieDefault.default).remove(n), (0, _jsCookieDefault.default).remove(_), (0, _jsCookieDefault.default).remove(g), (0, _jsCookieDefault.default).remove(l), e?.reason && this.emit("storage_cleared", {
            reason: e.reason
        });
    }
    async storeToken(e) {
        if ("string" == typeof e) {
            let t = await this._storage.get(o);
            if (await this._storage.put(o, e), !this._isUsingServerCookies) {
                let t = (0, _tokenMjs.Token).parse(e)?.expiration;
                (0, _jsCookieDefault.default).set(n, e, {
                    sameSite: "Strict",
                    secure: !0,
                    expires: t ? new Date(1e3 * t) : void 0
                });
            }
            t !== e && this.emit("token_stored", {
                cookiesEnabled: this._isUsingServerCookies
            });
        } else {
            let e = await this._storage.get(o);
            await this._storage.del(o), (0, _jsCookieDefault.default).remove(n), null !== e && this.emit("token_cleared", {
                reason: "set_with_non_string_value"
            });
        }
    }
    async storeRefreshToken(e) {
        "string" == typeof e ? (await this._storage.put(a, e), this._isUsingServerCookies || ((0, _jsCookieDefault.default).set(l, "t", {
            sameSite: "Strict",
            secure: !0,
            expires: 30
        }), (0, _jsCookieDefault.default).set(_, e, {
            sameSite: "Strict",
            secure: !0,
            expires: 30
        })), this.emit("refresh_token_stored", {
            cookiesEnabled: this._isUsingServerCookies
        })) : (await this._storage.del(a), (0, _jsCookieDefault.default).remove(_), (0, _jsCookieDefault.default).remove(l), this.emit("refresh_token_cleared", {
            reason: "set_with_non_string_value"
        }));
    }
    async updateWithTokensResponse(e) {
        let t = (await (0, _allSettledMjs.allSettled)([
            this.storeToken(e.token),
            this.storeRefreshToken(e.refresh_token),
            this.storeIdentityToken(e.identity_token),
            this.processOAuthTokens(e.oauth_tokens)
        ])).filter((e)=>"rejected" === e.status);
        t.length > 0 && this.emit("error_storing_tokens", t.map((e)=>String(e.reason)).join(", "));
    }
    async processOAuthTokens(e) {
        e && this.emit("oauth_tokens_granted", e);
    }
    async storeIdentityToken(e) {
        if ("string" == typeof e) {
            let t = await this._storage.get(h);
            if (await this._storage.put(h, e), !this._isUsingServerCookies) {
                let t = (0, _tokenMjs.Token).parse(e)?.expiration;
                (0, _jsCookieDefault.default).set(g, e, {
                    sameSite: "Strict",
                    secure: !0,
                    expires: t ? new Date(1e3 * t) : void 0
                });
            }
            t !== e && this.emit("identity_token_stored", {
                cookiesEnabled: this._isUsingServerCookies
            });
        } else {
            let e = await this._storage.get(h);
            await this._storage.del(h), (0, _jsCookieDefault.default).remove(g), null !== e && this.emit("identity_token_cleared", {
                reason: "set_with_non_string_value"
            });
        }
    }
    async getOrCreateGuestCredential() {
        let e = this._storage.get(this.GUEST_CREDENTIAL_STORAGE_KEY);
        if (e && "string" == typeof e) return e;
        let s = (0, _jose.base64url).encode(crypto.getRandomValues(new Uint8Array(32)));
        return await this._storage.put(this.GUEST_CREDENTIAL_STORAGE_KEY, s), s;
    }
    constructor(e){
        super(), this._isUsingServerCookies = !1, this._storage = e.storage, this.GUEST_CREDENTIAL_STORAGE_KEY = `privy:guest:${e.appId}`;
    }
}
k.events = [
    "storage_cleared",
    "token_cleared",
    "refresh_token_cleared",
    "identity_token_cleared",
    "token_stored",
    "refresh_token_stored",
    "identity_token_stored",
    "oauth_tokens_granted",
    "error_storing_tokens"
];

},{"eventemitter3":"8mZjp","jose":"80NDr","js-cookie":"cEALr","./Token.mjs":"kjSV6","./utils/allSettled.mjs":"kFsnG","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cEALr":[function(require,module,exports,__globalThis) {
/*! js-cookie v3.0.5 | MIT */ (function(global, factory) {
    module.exports = factory();
})(this, function() {
    'use strict';
    /* eslint-disable no-var */ function assign(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)target[key] = source[key];
        }
        return target;
    }
    /* eslint-enable no-var */ /* eslint-disable no-var */ var defaultConverter = {
        read: function(value) {
            if (value[0] === '"') value = value.slice(1, -1);
            return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent);
        },
        write: function(value) {
            return encodeURIComponent(value).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g, decodeURIComponent);
        }
    };
    /* eslint-enable no-var */ /* eslint-disable no-var */ function init(converter, defaultAttributes) {
        function set(name, value, attributes) {
            if (typeof document === 'undefined') return;
            attributes = assign({}, defaultAttributes, attributes);
            if (typeof attributes.expires === 'number') attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
            if (attributes.expires) attributes.expires = attributes.expires.toUTCString();
            name = encodeURIComponent(name).replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent).replace(/[()]/g, escape);
            var stringifiedAttributes = '';
            for(var attributeName in attributes){
                if (!attributes[attributeName]) continue;
                stringifiedAttributes += '; ' + attributeName;
                if (attributes[attributeName] === true) continue;
                // Considers RFC 6265 section 5.2:
                // ...
                // 3.  If the remaining unparsed-attributes contains a %x3B (";")
                //     character:
                // Consume the characters of the unparsed-attributes up to,
                // not including, the first %x3B (";") character.
                // ...
                stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
            }
            return document.cookie = name + '=' + converter.write(value, name) + stringifiedAttributes;
        }
        function get(name) {
            if (typeof document === 'undefined' || arguments.length && !name) return;
            // To prevent the for loop in the first place assign an empty array
            // in case there are no cookies at all.
            var cookies = document.cookie ? document.cookie.split('; ') : [];
            var jar = {};
            for(var i = 0; i < cookies.length; i++){
                var parts = cookies[i].split('=');
                var value = parts.slice(1).join('=');
                try {
                    var found = decodeURIComponent(parts[0]);
                    jar[found] = converter.read(value, found);
                    if (name === found) break;
                } catch (e) {}
            }
            return name ? jar[name] : jar;
        }
        return Object.create({
            set,
            get,
            remove: function(name, attributes) {
                set(name, '', assign({}, attributes, {
                    expires: -1
                }));
            },
            withAttributes: function(attributes) {
                return init(this.converter, assign({}, this.attributes, attributes));
            },
            withConverter: function(converter) {
                return init(assign({}, this.converter, converter), this.attributes);
            }
        }, {
            attributes: {
                value: Object.freeze(defaultAttributes)
            },
            converter: {
                value: Object.freeze(converter)
            }
        });
    }
    var api = init(defaultConverter, {
        path: '/'
    });
    /* eslint-enable no-var */ return api;
});

},{}],"kFsnG":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "allSettled", ()=>e);
const e = Promise.allSettled.bind(Promise) ?? ((e)=>Promise.all(e.map((e)=>e.then((e)=>({
                status: "fulfilled",
                value: e
            })).catch((e)=>({
                status: "rejected",
                reason: e
            })))));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"8wsRn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>t);
var t = (t)=>{
    let e = new AbortController;
    return setTimeout(()=>e.abort(), t), e.signal;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lu4wu":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toSearchParams", ()=>r);
function r(r) {
    let n = new URLSearchParams;
    for(let t in r)null != r[t] && n.append(t, String(r[t]));
    return Array.from(n).length ? "?" + n.toString() : "";
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6jIFl":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toConsoleLogger", ()=>r);
var _noopMjs = require("../utils/noop.mjs");
let o = {
    NONE: Number.NEGATIVE_INFINITY,
    ERROR: 1,
    WARN: 2,
    INFO: 3,
    DEBUG: Number.POSITIVE_INFINITY
};
const r = ({ level: r } = {
    level: "ERROR"
})=>({
        get level () {
            return r;
        },
        error: o[r] >= o.ERROR ? console.error : (0, _noopMjs.noop),
        warn: o[r] >= o.WARN ? console.warn : (0, _noopMjs.noop),
        info: o[r] >= o.INFO ? console.info : (0, _noopMjs.noop),
        debug: o[r] >= o.DEBUG ? console.debug : (0, _noopMjs.noop)
    });

},{"../utils/noop.mjs":"e1jCM","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"e1jCM":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noop", ()=>o);
const o = ()=>{};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"j5bk2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>t);
var _publicApi = require("@privy-io/public-api");
class t {
    async get() {
        let { user: r } = await this._privyInternal.refreshSession();
        return {
            user: r
        };
    }
    async acceptTerms() {
        return {
            user: await this._privyInternal.fetch((0, _publicApi.AcceptTermsOnUser), {})
        };
    }
    constructor(r){
        this._privyInternal = r;
    }
}

},{"@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9j69Z":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>d);
var _publicApi = require("@privy-io/public-api");
var _customProviderApiMjs = require("./CustomProviderApi.mjs");
var _customProviderApiMjsDefault = parcelHelpers.interopDefault(_customProviderApiMjs);
var _emailApiMjs = require("./EmailApi.mjs");
var _emailApiMjsDefault = parcelHelpers.interopDefault(_emailApiMjs);
var _farcasterApiMjs = require("./FarcasterApi.mjs");
var _farcasterApiMjsDefault = parcelHelpers.interopDefault(_farcasterApiMjs);
var _farcasterV2ApiMjs = require("./FarcasterV2Api.mjs");
var _farcasterV2ApiMjsDefault = parcelHelpers.interopDefault(_farcasterV2ApiMjs);
var _guestApiMjs = require("./GuestApi.mjs");
var _guestApiMjsDefault = parcelHelpers.interopDefault(_guestApiMjs);
var _oauthApiMjs = require("./OAuthApi.mjs");
var _oauthApiMjsDefault = parcelHelpers.interopDefault(_oauthApiMjs);
var _passkeyApiMjs = require("./PasskeyApi.mjs");
var _passkeyApiMjsDefault = parcelHelpers.interopDefault(_passkeyApiMjs);
var _phoneApiMjs = require("./PhoneApi.mjs");
var _phoneApiMjsDefault = parcelHelpers.interopDefault(_phoneApiMjs);
var _siweApiMjs = require("./SiweApi.mjs");
var _siweApiMjsDefault = parcelHelpers.interopDefault(_siweApiMjs);
var _siwsApiMjs = require("./SiwsApi.mjs");
var _siwsApiMjsDefault = parcelHelpers.interopDefault(_siwsApiMjs);
var _smartWalletApiMjs = require("./SmartWalletApi.mjs");
var _smartWalletApiMjsDefault = parcelHelpers.interopDefault(_smartWalletApiMjs);
var _maybeCreateWalletOnLoginMjs = require("./maybeCreateWalletOnLogin.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
var _errorMjs = require("../../Error.mjs");
var _pkceMjs = require("../../pkce.mjs");
var _jose = require("jose");
class d {
    async logout() {
        try {
            let r = await this._privyInternal.session.getRefreshToken() ?? void 0;
            await this._privyInternal.fetch((0, _publicApi.Logout), {
                body: {
                    refresh_token: r
                }
            });
        } catch (t) {
            console.warn("Error destroying session");
        }
        await Promise.all([
            this._privyInternal.session.destroyLocalState({
                reason: "logout"
            }),
            this._privyInternal.destroyClientAnalyticsId()
        ]), this._privyInternal.callbacks?.setUser?.(null);
    }
    constructor(t, d, y, u){
        this._privyInternal = t, this.customProvider = new (0, _customProviderApiMjsDefault.default)(this._privyInternal, d), this.phone = new (0, _phoneApiMjsDefault.default)(this._privyInternal, d), this.email = new (0, _emailApiMjsDefault.default)(this._privyInternal, d), this.oauth = new (0, _oauthApiMjsDefault.default)(this._privyInternal, d, y, u), this.guest = new (0, _guestApiMjsDefault.default)(this._privyInternal, d), this.siwe = new (0, _siweApiMjsDefault.default)(this._privyInternal, d), this.siws = new (0, _siwsApiMjsDefault.default)(this._privyInternal, d), this.smartWallet = new (0, _smartWalletApiMjsDefault.default)(this._privyInternal), this.passkey = new (0, _passkeyApiMjsDefault.default)(this._privyInternal, d), this.farcaster = new (0, _farcasterApiMjsDefault.default)(this._privyInternal, d), this.farcasterV2 = new (0, _farcasterV2ApiMjsDefault.default)(this._privyInternal, d);
    }
}

},{"@privy-io/public-api":"3ZXNH","./CustomProviderApi.mjs":"kXaoy","./EmailApi.mjs":"kf0Pi","./FarcasterApi.mjs":"f0sj1","./FarcasterV2Api.mjs":"5IjHq","./GuestApi.mjs":"6IOoX","./OAuthApi.mjs":"crG4F","./PasskeyApi.mjs":"czhGm","./PhoneApi.mjs":"3aZL2","./SiweApi.mjs":"gs1hS","./SiwsApi.mjs":"ak6Eo","./SmartWalletApi.mjs":"brvJY","./maybeCreateWalletOnLogin.mjs":"1KXuD","../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","../../Error.mjs":"kMDGn","../../pkce.mjs":"hcRGH","jose":"80NDr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kXaoy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>s);
var _publicApi = require("@privy-io/public-api");
var _maybeCreateWalletOnLoginMjs = require("./maybeCreateWalletOnLogin.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
class s {
    async syncWithToken(s, l, i) {
        let r = await this._privyInternal.fetch((0, _publicApi.CustomJWTAuthenticate), {
            body: {
                token: s,
                mode: i
            }
        });
        await this._privyInternal.session.updateWithTokensResponse(r);
        let a = await (0, _maybeCreateWalletOnLoginMjs.maybeCreateWalletOnLogin)(this._embedded, r, l?.embedded);
        return this._privyInternal.callbacks?.setUser?.(a.user), a;
    }
    constructor(e, t){
        this._privyInternal = e, this._embedded = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","./maybeCreateWalletOnLogin.mjs":"1KXuD","../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"1KXuD":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "maybeCreateWalletOnLogin", ()=>o);
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
const o = async (o, a, l)=>{
    let u = (0, _shouldCreateEmbeddedEthWalletMjs.shouldCreateEmbeddedEthWallet)(a.user, l?.ethereum?.createOnLogin ?? "off"), i = (0, _shouldCreateEmbeddedSolWalletMjs.shouldCreateEmbeddedSolWallet)(a.user, l?.solana?.createOnLogin ?? "off");
    if (u && i) {
        let t = await o.create({
            recoveryMethod: "privy",
            skipCallbacks: !0
        });
        return {
            ...await o.createSolana({
                ethereumAccount: (0, _getUserEmbeddedEthereumWalletMjs.getUserEmbeddedEthereumWallet)(t.user) ?? void 0
            }),
            is_new_user: a.is_new_user,
            oauth_tokens: a.oauth_tokens
        };
    }
    return u ? {
        ...await o.create({
            recoveryMethod: "privy",
            solanaAccount: (0, _getUserEmbeddedSolanaWalletMjs.getUserEmbeddedSolanaWallet)(a.user) ?? void 0
        }),
        is_new_user: a.is_new_user,
        oauth_tokens: a.oauth_tokens
    } : i ? {
        ...await o.createSolana({
            ethereumAccount: (0, _getUserEmbeddedEthereumWalletMjs.getUserEmbeddedEthereumWallet)(a.user) ?? void 0
        }),
        is_new_user: a.is_new_user,
        oauth_tokens: a.oauth_tokens
    } : a;
};

},{"../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"aCefw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getUserEmbeddedEthereumWallet", ()=>l);
parcelHelpers.export(exports, "getUserEmbeddedWallet", ()=>t);
var _getAllUserEmbeddedEthereumWalletsMjs = require("./getAllUserEmbeddedEthereumWallets.mjs");
const l = (l)=>(0, _getAllUserEmbeddedEthereumWalletsMjs.getAllUserEmbeddedEthereumWallets)(l).find((e)=>0 === e.wallet_index) ?? null, t = l;

},{"./getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"87Vw1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAllUserEmbeddedEthereumWallets", ()=>e);
const e = (e)=>e ? e.linked_accounts.filter(t).sort((e, t)=>e.wallet_index - t.wallet_index) : [];
let t = (e)=>"wallet" === e.type && "privy" === e.wallet_client_type && "embedded" === e.connector_type && "ethereum" === e.chain_type;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gCZdX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getUserEmbeddedSolanaWallet", ()=>e);
var _getAllUserEmbeddedSolanaWalletsMjs = require("./getAllUserEmbeddedSolanaWallets.mjs");
const e = (e)=>(0, _getAllUserEmbeddedSolanaWalletsMjs.getAllUserEmbeddedSolanaWallets)(e).find((l)=>0 === l.wallet_index) ?? null;

},{"./getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5jVSn":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getAllUserEmbeddedSolanaWallets", ()=>e);
const e = (e)=>e ? e.linked_accounts.filter(t).sort((e, t)=>e.wallet_index - t.wallet_index) : [];
let t = (e)=>"wallet" === e.type && "privy" === e.wallet_client_type && "embedded" === e.connector_type && "solana" === e.chain_type;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jJIOp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shouldCreateEmbeddedEthWallet", ()=>t);
var _getAllUserEmbeddedEthereumWalletsMjs = require("./getAllUserEmbeddedEthereumWallets.mjs");
const t = (t, l)=>!("off" === l || (0, _getAllUserEmbeddedEthereumWalletsMjs.getAllUserEmbeddedEthereumWallets)(t).length > 0 || t.linked_accounts.filter((e)=>"wallet" === e.type && "ethereum" === e.chain_type).length > 0 && "all-users" !== l);

},{"./getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l6Q2b":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shouldCreateEmbeddedSolWallet", ()=>l);
var _getAllUserEmbeddedSolanaWalletsMjs = require("./getAllUserEmbeddedSolanaWallets.mjs");
const l = (l, t)=>!("off" === t || (0, _getAllUserEmbeddedSolanaWalletsMjs.getAllUserEmbeddedSolanaWallets)(l).length > 0 || l.linked_accounts.filter((e)=>"wallet" === e.type && "solana" === e.chain_type).length > 0 && "all-users" !== t);

},{"./getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"kf0Pi":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>d);
var _publicApi = require("@privy-io/public-api");
var _maybeCreateWalletOnLoginMjs = require("./maybeCreateWalletOnLogin.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
class d {
    async sendCode(t, i) {
        return this._privyInternal.fetch((0, _publicApi.PasswordlessInit), {
            body: {
                email: t,
                token: i
            }
        });
    }
    async loginWithCode(e, i, s, r) {
        let d = await this._privyInternal.fetch((0, _publicApi.PasswordlessAuthenticate), {
            body: {
                email: e,
                code: i,
                mode: s
            }
        });
        await this._privyInternal.session.updateWithTokensResponse(d);
        let n = await (0, _maybeCreateWalletOnLoginMjs.maybeCreateWalletOnLogin)(this._embedded, d, r?.embedded);
        return this._privyInternal.callbacks?.setUser?.(n.user), n;
    }
    async linkWithCode(e, t) {
        await this._privyInternal.fetch((0, _publicApi.PasswordlessLink), {
            body: {
                email: e,
                code: t
            }
        });
        let s = await this._privyInternal.refreshSession();
        return {
            user: s.user,
            identity_token: s.identity_token
        };
    }
    async updateEmail({ oldEmailAddress: e, newEmailAddress: t, code: i }) {
        await this._privyInternal.fetch((0, _publicApi.PasswordlessUpdate), {
            body: {
                oldAddress: e,
                newAddress: t,
                code: i
            }
        });
        let r = await this._privyInternal.refreshSession();
        return {
            user: r.user,
            identity_token: r.identity_token
        };
    }
    async unlink(e) {
        await this._privyInternal.fetch((0, _publicApi.PasswordlessUnlink), {
            body: {
                address: e
            }
        });
        let t = await this._privyInternal.refreshSession();
        return {
            user: t.user,
            identity_token: t.identity_token
        };
    }
    constructor(e, t){
        this._privyInternal = e, this._embedded = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","./maybeCreateWalletOnLogin.mjs":"1KXuD","../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"f0sj1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>s);
var _publicApi = require("@privy-io/public-api");
var _maybeCreateWalletOnLoginMjs = require("./maybeCreateWalletOnLogin.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
class s {
    async initializeAuth({ relyingParty: t, redirectUrl: i, token: r }) {
        return await this._privyInternal.fetch((0, _publicApi.FarcasterInit), {
            body: {
                relying_party: t,
                redirect_url: i,
                token: r
            }
        });
    }
    async getFarcasterStatus({ channel_token: e }) {
        return await this._privyInternal.fetch((0, _publicApi.FarcasterStatus), {
            headers: {
                "farcaster-channel-token": e
            }
        });
    }
    async authenticate({ channel_token: e, message: t, signature: r, fid: a, mode: s }, l) {
        let d = await this._privyInternal.fetch((0, _publicApi.FarcasterAuthenticate), {
            body: {
                channel_token: e,
                message: t,
                signature: r,
                fid: a,
                mode: s
            }
        });
        await this._privyInternal.session.updateWithTokensResponse(d);
        let o = await (0, _maybeCreateWalletOnLoginMjs.maybeCreateWalletOnLogin)(this._embedded, d, l?.embedded);
        return this._privyInternal.callbacks?.setUser?.(o.user), o;
    }
    async link({ channel_token: e, message: t, signature: i, fid: a }) {
        await this._privyInternal.fetch((0, _publicApi.FarcasterLink), {
            body: {
                channel_token: e,
                message: t,
                signature: i,
                fid: a
            }
        });
        let n = await this._privyInternal.refreshSession();
        return {
            user: n.user,
            identity_token: n.identity_token
        };
    }
    async unlink({ fid: e }) {
        await this._privyInternal.fetch((0, _publicApi.FarcasterUnlink), {
            body: {
                fid: e
            }
        });
        let t = await this._privyInternal.refreshSession();
        return {
            user: t.user,
            identity_token: t.identity_token
        };
    }
    constructor(e, t){
        this._privyInternal = e, this._embedded = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","./maybeCreateWalletOnLogin.mjs":"1KXuD","../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5IjHq":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>i);
var _publicApi = require("@privy-io/public-api");
var _maybeCreateWalletOnLoginMjs = require("./maybeCreateWalletOnLogin.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
class i {
    async initializeAuth() {
        return await this._privyInternal.fetch((0, _publicApi.FarcasterV2Init), {
            body: {}
        });
    }
    async authenticate({ message: e, signature: i, fid: a }, l) {
        let r = await this._privyInternal.fetch((0, _publicApi.FarcasterV2Authenticate), {
            body: {
                message: e,
                signature: i,
                fid: a
            }
        });
        await this._privyInternal.session.updateWithTokensResponse(r);
        let d = await (0, _maybeCreateWalletOnLoginMjs.maybeCreateWalletOnLogin)(this._embedded, r, l?.embedded);
        return this._privyInternal.callbacks?.setUser?.(d.user), d;
    }
    constructor(e, t){
        this._privyInternal = e, this._embedded = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","./maybeCreateWalletOnLogin.mjs":"1KXuD","../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"6IOoX":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>s);
var _publicApi = require("@privy-io/public-api");
var _maybeCreateWalletOnLoginMjs = require("./maybeCreateWalletOnLogin.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
class s {
    async create(s) {
        let l = await this._privyInternal.session.getOrCreateGuestCredential(), r = await this._privyInternal.fetch((0, _publicApi.GuestAuthenticate), {
            body: {
                guest_credential: l
            }
        });
        await this._privyInternal.session.updateWithTokensResponse(r);
        let a = await (0, _maybeCreateWalletOnLoginMjs.maybeCreateWalletOnLogin)(this._embedded, r, s?.embedded);
        return this._privyInternal.callbacks?.setUser?.(a.user), a;
    }
    constructor(e, t){
        this._privyInternal = e, this._embedded = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","./maybeCreateWalletOnLogin.mjs":"1KXuD","../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"crG4F":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>p);
var _publicApi = require("@privy-io/public-api");
var _errorMjs = require("../../Error.mjs");
var _pkceMjs = require("../../pkce.mjs");
var _maybeCreateWalletOnLoginMjs = require("./maybeCreateWalletOnLogin.mjs");
var _jose = require("jose");
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
class p {
    async generateURL(t, i) {
        let r = (0, _pkceMjs.createCodeVerifier)(), s = (0, _pkceMjs.createStateCode)(), h = await (0, _pkceMjs.deriveCodeChallengeFromCodeVerifier)({
            codeVerifier: r,
            digest: this._crypto?.digest
        });
        return await Promise.all([
            this._storage.put((0, _pkceMjs.CODE_VERIFIER_KEY), r),
            this._storage.put((0, _pkceMjs.STATE_CODE_KEY), s)
        ]), this._privyInternal.fetch((0, _publicApi.OAuthInit), {
            body: {
                redirect_to: i,
                provider: t,
                code_challenge: h,
                state_code: s
            }
        });
    }
    async loginWithCode(e, i, r, a, o, l) {
        let [p, _] = await Promise.all([
            this._storage.get((0, _pkceMjs.CODE_VERIFIER_KEY)),
            this._storage.get((0, _pkceMjs.STATE_CODE_KEY))
        ]);
        if (_ !== i) throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt", {
            flow: "oauth",
            provider: r,
            storedStateCode: _ ?? "",
            returnedStateCode: i ?? ""
        }), new (0, _errorMjs.PrivyClientError)({
            code: "pkce_state_code_mismatch",
            error: "Unexpected auth flow. This may be a phishing attempt."
        });
        let m = await this._privyInternal.fetch((0, _publicApi.OAuthAuthenticate), {
            body: {
                authorization_code: e,
                code_type: a,
                state_code: _,
                code_verifier: p,
                mode: o
            }
        });
        await this._privyInternal.session.updateWithTokensResponse(m);
        let c = await (0, _maybeCreateWalletOnLoginMjs.maybeCreateWalletOnLogin)(this._embedded, m, l?.embedded);
        return await Promise.all([
            this._storage.del((0, _pkceMjs.CODE_VERIFIER_KEY)),
            this._storage.del((0, _pkceMjs.STATE_CODE_KEY))
        ]), this._privyInternal.callbacks?.setUser?.(c.user), c;
    }
    async linkWithCode(e, t, r, a) {
        let [o, l] = await Promise.all([
            this._storage.get((0, _pkceMjs.CODE_VERIFIER_KEY)),
            this._storage.get((0, _pkceMjs.STATE_CODE_KEY))
        ]);
        if (l !== t) throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt", {
            flow: "oauth",
            provider: r,
            storedStateCode: l ?? "",
            returnedStateCode: t ?? ""
        }), new (0, _errorMjs.PrivyClientError)({
            code: "pkce_state_code_mismatch",
            error: "Unexpected auth flow. This may be a phishing attempt."
        });
        let h = await this._privyInternal.fetch((0, _publicApi.OAuthLink), {
            body: {
                authorization_code: e,
                code_type: a,
                state_code: l,
                code_verifier: o
            }
        });
        await this._privyInternal.session.processOAuthTokens(h.oauth_tokens);
        let p = await this._privyInternal.refreshSession();
        return await Promise.all([
            this._storage.del((0, _pkceMjs.CODE_VERIFIER_KEY)),
            this._storage.del((0, _pkceMjs.STATE_CODE_KEY))
        ]), {
            user: p.user,
            identity_token: p.identity_token
        };
    }
    async unlink(e, t) {
        await this._privyInternal.fetch((0, _publicApi.OAuthUnlink), {
            body: {
                provider: e,
                subject: t
            }
        });
        let i = await this._privyInternal.refreshSession();
        return {
            user: i.user,
            identity_token: i.identity_token
        };
    }
    constructor(e, t, i, r){
        this._privyInternal = e, this._embedded = t, this._storage = i, this._crypto = r;
    }
}

},{"@privy-io/public-api":"3ZXNH","../../Error.mjs":"kMDGn","../../pkce.mjs":"hcRGH","./maybeCreateWalletOnLogin.mjs":"1KXuD","jose":"80NDr","../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"hcRGH":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CODE_VERIFIER_KEY", ()=>n);
parcelHelpers.export(exports, "STATE_CODE_KEY", ()=>t);
parcelHelpers.export(exports, "createCodeVerifier", ()=>i);
parcelHelpers.export(exports, "createHashBuffer", ()=>r);
parcelHelpers.export(exports, "createStateCode", ()=>c);
parcelHelpers.export(exports, "deriveCodeChallengeFromCodeVerifier", ()=>u);
parcelHelpers.export(exports, "randomBytes", ()=>o);
var _jose = require("jose");
const t = "privy:state_code", n = "privy:code_verifier";
async function r(e, t) {
    let n = (new TextEncoder).encode(e);
    return new Uint8Array(await t("SHA-256", n));
}
function o(e) {
    return crypto.getRandomValues(new Uint8Array(e));
}
function i() {
    return (0, _jose.base64url).encode(o(36));
}
function c() {
    return i();
}
async function u({ codeVerifier: t, method: n = "S256", digest: o = crypto.subtle.digest.bind(crypto.subtle) }) {
    if ("S256" != n) return t;
    {
        let n = await r(t, o);
        return (0, _jose.base64url).encode(n);
    }
}

},{"jose":"80NDr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"czhGm":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>o);
var _publicApi = require("@privy-io/public-api");
var _maybeCreateWalletOnLoginMjs = require("./maybeCreateWalletOnLogin.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
class o {
    async generateRegistrationOptions(t) {
        return await this._privyInternal.fetch((0, _publicApi.PasskeyLinkInit), {
            body: {
                relying_party: t
            }
        });
    }
    async generateAuthenticationOptions(e) {
        return await this._privyInternal.fetch((0, _publicApi.PasskeyAuthenticateInit), {
            body: {
                relying_party: e
            }
        });
    }
    async generateSignupOptions(e) {
        return await this._privyInternal.fetch((0, _publicApi.PasskeyRegisterInit), {
            body: {
                relying_party: e
            }
        });
    }
    async loginWithPasskey(e, t, s, n) {
        let i = await this._privyInternal.fetch((0, _publicApi.PasskeyAuthenticate), {
            body: {
                relying_party: s,
                challenge: t,
                authenticator_response: this._transformAuthenticationResponseToSnakeCase(e)
            }
        });
        await this._privyInternal.session.updateWithTokensResponse(i);
        let o = await (0, _maybeCreateWalletOnLoginMjs.maybeCreateWalletOnLogin)(this._embedded, i, n?.embedded);
        return this._privyInternal.callbacks?.setUser?.(o.user), o;
    }
    async signupWithPasskey(e, t, s) {
        let a = await this._privyInternal.fetch((0, _publicApi.PasskeyRegister), {
            body: {
                relying_party: t,
                authenticator_response: this._transformRegistrationResponseToSnakeCase(e)
            }
        });
        await this._privyInternal.session.updateWithTokensResponse(a);
        let i = await (0, _maybeCreateWalletOnLoginMjs.maybeCreateWalletOnLogin)(this._embedded, a, s?.embedded);
        return this._privyInternal.callbacks?.setUser?.(i.user), i;
    }
    async linkWithPasskey(e, t) {
        await this._privyInternal.fetch((0, _publicApi.PasskeyLink), {
            body: {
                relying_party: t,
                authenticator_response: this._transformRegistrationResponseToSnakeCase(e)
            }
        });
        let s = await this._privyInternal.refreshSession();
        return {
            user: s.user,
            identity_token: s.identity_token
        };
    }
    _transformRegistrationResponseToSnakeCase(e) {
        return {
            type: e.type,
            id: e.id,
            raw_id: e.rawId,
            response: {
                client_data_json: e.response.clientDataJSON,
                attestation_object: e.response.attestationObject,
                authenticator_data: e.response.authenticatorData || void 0,
                transports: e.response.transports || void 0,
                public_key: e.response.publicKey || void 0,
                public_key_algorithm: e.response.publicKeyAlgorithm || void 0
            },
            authenticator_attachment: e.authenticatorAttachment || void 0,
            client_extension_results: {
                app_id: e.clientExtensionResults.appid || void 0,
                cred_props: e.clientExtensionResults.credProps || void 0,
                hmac_create_secret: e.clientExtensionResults.hmacCreateSecret || void 0
            }
        };
    }
    _transformAuthenticationResponseToSnakeCase(e) {
        return {
            type: e.type,
            id: e.id,
            raw_id: e.rawId,
            response: {
                signature: e.response.signature,
                client_data_json: e.response.clientDataJSON,
                authenticator_data: e.response.authenticatorData,
                user_handle: e.response.userHandle || void 0
            },
            authenticator_attachment: e.authenticatorAttachment || void 0,
            client_extension_results: {
                app_id: e.clientExtensionResults.appid || void 0,
                cred_props: e.clientExtensionResults.credProps || void 0,
                hmac_create_secret: e.clientExtensionResults.hmacCreateSecret || void 0
            }
        };
    }
    constructor(e, t){
        this._privyInternal = e, this._embedded = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","./maybeCreateWalletOnLogin.mjs":"1KXuD","../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"3aZL2":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>o);
var _publicApi = require("@privy-io/public-api");
var _maybeCreateWalletOnLoginMjs = require("./maybeCreateWalletOnLogin.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
class o {
    async sendCode(t, r) {
        return this._privyInternal.fetch((0, _publicApi.PasswordlessSmsInit), {
            body: {
                phoneNumber: t,
                token: r
            }
        });
    }
    async loginWithCode(e, r, i, n) {
        let o = await this._privyInternal.fetch((0, _publicApi.PasswordlessSmsAuthenticate), {
            body: {
                phoneNumber: e,
                code: r,
                mode: i
            }
        });
        await this._privyInternal.session.updateWithTokensResponse(o);
        let a = await (0, _maybeCreateWalletOnLoginMjs.maybeCreateWalletOnLogin)(this._embedded, o, n?.embedded);
        return this._privyInternal.callbacks?.setUser?.(a.user), a;
    }
    async linkWithCode(e, t) {
        await this._privyInternal.fetch((0, _publicApi.PasswordlessSmsLink), {
            body: {
                phoneNumber: e,
                code: t
            }
        });
        let i = await this._privyInternal.refreshSession();
        return {
            user: i.user,
            identity_token: i.identity_token
        };
    }
    async updatePhone({ oldPhoneNumber: e, newPhoneNumber: t, code: r }) {
        await this._privyInternal.fetch((0, _publicApi.PasswordlessSmsUpdate), {
            body: {
                old_phone_number: e,
                new_phone_number: t,
                code: r
            }
        });
        let n = await this._privyInternal.refreshSession();
        return {
            user: n.user,
            identity_token: n.identity_token
        };
    }
    async unlink(e) {
        await this._privyInternal.fetch((0, _publicApi.PasswordlessSmsUnlink), {
            body: {
                phoneNumber: e
            }
        });
        let t = await this._privyInternal.refreshSession();
        return {
            user: t.user,
            identity_token: t.identity_token
        };
    }
    constructor(e, t){
        this._privyInternal = e, this._embedded = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","./maybeCreateWalletOnLogin.mjs":"1KXuD","../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"gs1hS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>a);
var _publicApi = require("@privy-io/public-api");
var _maybeCreateWalletOnLoginMjs = require("./maybeCreateWalletOnLogin.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
class a {
    async unlinkWallet(t) {
        await this._privyInternal.fetch((0, _publicApi.SiweUnlink), {
            body: {
                address: t
            }
        });
        let i = await this._privyInternal.refreshSession();
        return {
            user: i.user,
            identity_token: i.identity_token
        };
    }
    async linkWithSiwe(e, i, n) {
        let s = i || this._wallet, a = n || this._preparedMessage;
        if (!s) throw Error("A wallet must be provided in the init step or as an argument to linkWithSiwe");
        if (!a) throw Error("A message must be generated and signed before being used to link a wallet to privy");
        await this._privyInternal.fetch((0, _publicApi.SiweLink), {
            body: {
                message: a,
                signature: e,
                chainId: s.chainId,
                walletClientType: s.walletClientType,
                connectorType: s.connectorType
            }
        });
        let r = await this._privyInternal.refreshSession();
        return {
            user: r.user,
            identity_token: r.identity_token
        };
    }
    async loginWithSiwe(e, t, n, a, r) {
        let o = t || this._wallet, l = n || this._preparedMessage;
        if (!o) throw Error("A wallet must be provided in the init step or as an argument to loginWithSiwe");
        if (!l) throw Error("A message must be generated and signed before being used to login to privy with a wallet");
        let d = await this._privyInternal.fetch((0, _publicApi.SiweAuthenticate), {
            body: {
                signature: e,
                message: l,
                chainId: o.chainId,
                walletClientType: o.walletClientType,
                connectorType: o.connectorType,
                mode: a
            }
        });
        await this._privyInternal.session.updateWithTokensResponse(d);
        let h = await (0, _maybeCreateWalletOnLoginMjs.maybeCreateWalletOnLogin)(this._embedded, d, r?.embedded);
        return this._privyInternal.callbacks?.setUser?.(h.user), h;
    }
    async init(e, t, i) {
        var s;
        this._wallet = e;
        let { nonce: a } = await this._privyInternal.fetch((0, _publicApi.SiweInit), {
            body: {
                address: e.address
            }
        }), r = `${(s = {
            chainId: e.chainId.toString().replace("eip155:", ""),
            address: e.address,
            issuedAt: (new Date).toISOString(),
            statement: "By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.",
            domain: t,
            nonce: a,
            uri: i
        }).domain} wants you to sign in with your Ethereum account:\n${s.address}\n\n${s.statement}\n\nURI: ${s.uri}\nVersion: 1\nChain ID: ${s.chainId}\nNonce: ${s.nonce}\nIssued At: ${s.issuedAt}\nResources:\n- https://privy.io`;
        return this._preparedMessage = r, {
            nonce: a,
            message: r
        };
    }
    constructor(e, t){
        this._wallet = void 0, this._privyInternal = e, this._embedded = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","./maybeCreateWalletOnLogin.mjs":"1KXuD","../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"ak6Eo":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>n);
var _publicApi = require("@privy-io/public-api");
var _maybeCreateWalletOnLoginMjs = require("./maybeCreateWalletOnLogin.mjs");
var _getUserEmbeddedEthereumWalletMjs = require("../../utils/getUserEmbeddedEthereumWallet.mjs");
var _getAllUserEmbeddedEthereumWalletsMjs = require("../../utils/getAllUserEmbeddedEthereumWallets.mjs");
var _getUserEmbeddedSolanaWalletMjs = require("../../utils/getUserEmbeddedSolanaWallet.mjs");
var _getAllUserEmbeddedSolanaWalletsMjs = require("../../utils/getAllUserEmbeddedSolanaWallets.mjs");
var _shouldCreateEmbeddedEthWalletMjs = require("../../utils/shouldCreateEmbeddedEthWallet.mjs");
var _shouldCreateEmbeddedSolWalletMjs = require("../../utils/shouldCreateEmbeddedSolWallet.mjs");
class n {
    async unlink({ address: t }) {
        await this._privyInternal.fetch((0, _publicApi.SiwsUnlink), {
            body: {
                address: t
            }
        });
        let s = await this._privyInternal.refreshSession();
        return {
            user: s.user,
            identity_token: s.identity_token
        };
    }
    async link({ message: e, signature: s, walletClientType: r, connectorType: i }) {
        await this._privyInternal.fetch((0, _publicApi.SiwsLink), {
            body: {
                message: e,
                signature: s,
                walletClientType: r,
                connectorType: i
            }
        });
        let n = await this._privyInternal.refreshSession();
        return {
            user: n.user,
            identity_token: n.identity_token
        };
    }
    async login({ mode: e, message: t, signature: r, walletClientType: n, connectorType: a, opts: l }) {
        let d = await this._privyInternal.fetch((0, _publicApi.SiwsAuthenticate), {
            body: {
                signature: r,
                message: t,
                walletClientType: n,
                connectorType: a,
                mode: e
            }
        });
        await this._privyInternal.session.updateWithTokensResponse(d);
        let o = await (0, _maybeCreateWalletOnLoginMjs.maybeCreateWalletOnLogin)(this._embedded, d, l?.embedded);
        return this._privyInternal.callbacks?.setUser?.(o.user), o;
    }
    async fetchNonce({ address: e }) {
        let { nonce: t } = await this._privyInternal.fetch((0, _publicApi.SiwsInit), {
            body: {
                address: e
            }
        });
        return {
            nonce: t
        };
    }
    constructor(e, t){
        this._privyInternal = e, this._embedded = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","./maybeCreateWalletOnLogin.mjs":"1KXuD","../../utils/getUserEmbeddedEthereumWallet.mjs":"aCefw","../../utils/getAllUserEmbeddedEthereumWallets.mjs":"87Vw1","../../utils/getUserEmbeddedSolanaWallet.mjs":"gCZdX","../../utils/getAllUserEmbeddedSolanaWallets.mjs":"5jVSn","../../utils/shouldCreateEmbeddedEthWallet.mjs":"jJIOp","../../utils/shouldCreateEmbeddedSolWallet.mjs":"l6Q2b","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"brvJY":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>e);
var _publicApi = require("@privy-io/public-api");
class e {
    async link(t, e, i) {
        await this._privyInternal.fetch((0, _publicApi.SiweLinkSmartWallet), {
            body: {
                message: t,
                signature: e,
                smart_wallet_type: i
            }
        });
        let s = await this._privyInternal.refreshSession();
        return {
            user: s.user,
            identity_token: s.identity_token
        };
    }
    async init(n) {
        var e;
        let { nonce: i } = await this._privyInternal.fetch((0, _publicApi.SiweInit), {
            body: {
                address: n.address
            }
        });
        return {
            nonce: i,
            message: `${(e = {
                chainId: n.chainId.toString().replace("eip155:", ""),
                address: n.address,
                issuedAt: (new Date).toISOString(),
                statement: "By signing, you are proving you own this wallet and logging in. This does not initiate a transaction or cost any fees.",
                domain: "privy.io",
                uri: "https://auth.privy.io",
                nonce: i
            }).domain} wants you to sign in with your Ethereum account:\n${e.address}\n\n${e.statement}\n\nURI: ${e.uri}\nVersion: 1\nChain ID: ${e.chainId}\nNonce: ${e.nonce}\nIssued At: ${e.issuedAt}\nResources:\n- https://privy.io`
        };
    }
    constructor(n){
        this._privyInternal = n;
    }
}

},{"@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jq5lJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>p);
var _coinbaseOnRampApiMjs = require("./CoinbaseOnRampApi.mjs");
var _coinbaseOnRampApiMjsDefault = parcelHelpers.interopDefault(_coinbaseOnRampApiMjs);
var _moonpayOnRampApiMjs = require("./MoonpayOnRampApi.mjs");
var _moonpayOnRampApiMjsDefault = parcelHelpers.interopDefault(_moonpayOnRampApiMjs);
var _publicApi = require("@privy-io/public-api");
var _fetchRetry = require("fetch-retry");
var _errorMjs = require("../../Error.mjs");
var _moonpayMjs = require("../../funding/moonpay.mjs");
var _chains = require("@privy-io/chains");
class p {
    constructor(p){
        this.moonpay = new (0, _moonpayOnRampApiMjsDefault.default)(p), this.coinbase = new (0, _coinbaseOnRampApiMjsDefault.default)(p);
    }
}

},{"./CoinbaseOnRampApi.mjs":"bC60B","./MoonpayOnRampApi.mjs":"jXFhd","@privy-io/public-api":"3ZXNH","fetch-retry":"knqh8","../../Error.mjs":"kMDGn","../../funding/moonpay.mjs":"MCxsh","@privy-io/chains":"9r5Tr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"bC60B":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>a);
var _publicApi = require("@privy-io/public-api");
class a {
    async initOnRampSession(r) {
        return await this._privyInternal.fetch((0, _publicApi.CoinbaseOnRampInit), {
            body: r
        });
    }
    async getStatus(t) {
        return await this._privyInternal.fetch((0, _publicApi.CoinbaseOnRampStatus), {
            query: {
                partnerUserId: t
            }
        });
    }
    constructor(t){
        this._privyInternal = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"jXFhd":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>i);
var _fetchRetry = require("fetch-retry");
var _fetchRetryDefault = parcelHelpers.interopDefault(_fetchRetry);
var _publicApi = require("@privy-io/public-api");
var _errorMjs = require("../../Error.mjs");
var _moonpayMjs = require("../../funding/moonpay.mjs");
var _chains = require("@privy-io/chains");
let i = class {
    async sign(t) {
        return await this._privyInternal.fetch((0, _publicApi.MoonpayOnRampSign), {
            body: t
        });
    }
    async getTransactionStatus({ transactionId: r, useSandbox: i }) {
        let { url: n, key: e } = (0, _moonpayMjs.MoonpayEnvironments)[i ? "sandbox" : "prod"], s = await (0, _fetchRetryDefault.default)(fetch, {
            retries: 3,
            retryDelay: 500
        })(`${n}/transactions/ext/${r}?apiKey=${e}`);
        if (!s.ok) throw new (0, _errorMjs.MoonpayApiError)({
            error: `Failed to fetch transaction status for Transaction ${r}`,
            code: "failed_to_fetch_moonpay_transaction_status",
            response: s
        });
        let c = await s.json();
        return Array.isArray(c) ? c.at(0) : void 0;
    }
    constructor(t){
        this._privyInternal = t;
    }
};

},{"fetch-retry":"knqh8","@privy-io/public-api":"3ZXNH","../../Error.mjs":"kMDGn","../../funding/moonpay.mjs":"MCxsh","@privy-io/chains":"9r5Tr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"MCxsh":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MoonpayEnvironments", ()=>o);
parcelHelpers.export(exports, "chainToMoonpayCurrency", ()=>p);
parcelHelpers.export(exports, "fundingMethodToMoonpayPaymentMethod", ()=>E);
parcelHelpers.export(exports, "isSupportedChainIdForMoonpay", ()=>u);
var _chains = require("@privy-io/chains");
const o = {
    prod: {
        url: "https://api.moonpay.com/v1",
        key: "pk_live_hirbpu0cVcLHrjktC9l7fbc9ctjv0SL"
    },
    sandbox: {
        url: "https://api.moonpay.com/v1",
        key: "pk_test_fqWjXZMSFwloh7orvJsRfjiUHXJqFzI"
    }
};
let d = new Set([
    (0, _chains.mainnet).id,
    (0, _chains.arbitrum).id,
    (0, _chains.base).id,
    (0, _chains.polygon).id,
    (0, _chains.avalanche).id,
    (0, _chains.celo).id
]), s = new Set([
    (0, _chains.mainnet).id,
    (0, _chains.arbitrum).id,
    (0, _chains.optimism).id,
    (0, _chains.base).id,
    (0, _chains.polygon).id
]);
function u(e, r) {
    switch(r){
        case "native-currency":
            return d.has(e);
        case "USDC":
            return s.has(e);
        default:
            return console.warn("Unknown asset passed to MoonPay Onramp"), !1;
    }
}
function p(c, o) {
    switch(c){
        case (0, _chains.arbitrum).id:
            return "native-currency" === o ? "ETH_ARBITRUM" : "USDC_ARBITRUM";
        case (0, _chains.avalanche).id:
            return "AVAX_CCHAIN";
        case (0, _chains.base).id:
            return "native-currency" === o ? "ETH_BASE" : "USDC_BASE";
        case (0, _chains.celo).id:
            return "CELO_CELO";
        case (0, _chains.polygon).id:
            return "native-currency" === o ? "MATIC_POLYGON" : "USDC_POLYGON";
        case (0, _chains.mainnet).id:
            return "native-currency" === o ? "ETH_ETHEREUM" : "USDC_ETHEREUM";
        default:
            return console.warn(`Chain ${c} not supported by Moonpay, defaulting to Ethereum mainnet`), "ETH_ETHEREUM";
    }
}
function E(e) {
    switch(e){
        case "card":
        case "payment-request":
            return "credit_debit_card";
        default:
            throw Error(`Unsupported Moonpay funding method ${e}`);
    }
}

},{"@privy-io/chains":"9r5Tr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"9TIdV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>r);
var _errorMjs = require("../../Error.mjs");
var _mfaPasskeyApiMjs = require("./MfaPasskeyApi.mjs");
var _mfaPasskeyApiMjsDefault = parcelHelpers.interopDefault(_mfaPasskeyApiMjs);
var _mfaSmsApiMjs = require("./MfaSmsApi.mjs");
var _mfaSmsApiMjsDefault = parcelHelpers.interopDefault(_mfaSmsApiMjs);
var _publicApi = require("@privy-io/public-api");
class r {
    setProxy(e) {
        this.proxy = e;
    }
    async getAccessToken() {
        let t = await this.privyInternal.getAccessToken();
        if (!t) throw new (0, _errorMjs.PrivyClientError)({
            error: "Missing access token",
            code: "attempted_rpc_call_before_logged_in"
        });
        return t;
    }
    async verifyMfa() {
        if (!this.proxy) throw new (0, _errorMjs.PrivyClientError)({
            error: "Embedded wallet proxy not initialized",
            code: "embedded_wallet_webview_not_loaded"
        });
        return await this.proxy.verifyMfa({
            accessToken: await this.getAccessToken()
        });
    }
    async initEnrollMfa(t) {
        if (!this.proxy) throw new (0, _errorMjs.PrivyClientError)({
            error: "Embedded wallet proxy not initialized",
            code: "embedded_wallet_webview_not_loaded"
        });
        return await this.proxy.initEnrollMfa({
            ...t,
            accessToken: await this.getAccessToken()
        });
    }
    async submitEnrollMfa(t) {
        if (!this.proxy) throw new (0, _errorMjs.PrivyClientError)({
            error: "Embedded wallet proxy not initialized",
            code: "embedded_wallet_webview_not_loaded"
        });
        let i = await this.proxy.submitEnrollMfa({
            ...t,
            accessToken: await this.getAccessToken()
        });
        return await this.privyInternal.refreshSession(), i;
    }
    async unenrollMfa(t) {
        if (!this.proxy) throw new (0, _errorMjs.PrivyClientError)({
            error: "Embedded wallet proxy not initialized",
            code: "embedded_wallet_webview_not_loaded"
        });
        let i = await this.proxy.unenrollMfa({
            method: t,
            accessToken: await this.getAccessToken()
        });
        return await this.privyInternal.refreshSession(), i;
    }
    async clearMfa(t) {
        if (!this.proxy) throw new (0, _errorMjs.PrivyClientError)({
            error: "Embedded wallet proxy not initialized",
            code: "embedded_wallet_webview_not_loaded"
        });
        return await this.proxy.clearMfa(t);
    }
    constructor(e, r){
        this.proxy = r, this.privyInternal = e, this.sms = new (0, _mfaSmsApiMjsDefault.default)(e), this.passkey = new (0, _mfaPasskeyApiMjsDefault.default)(e);
    }
}

},{"../../Error.mjs":"kMDGn","./MfaPasskeyApi.mjs":"7bCXO","./MfaSmsApi.mjs":"l4DbS","@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"7bCXO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>i);
var _publicApi = require("@privy-io/public-api");
let i = class {
    async generateAuthenticationOptions(i) {
        return await this._privyInternal.fetch((0, _publicApi.MfaPasskeyInit), {
            body: i
        });
    }
    constructor(t){
        this._privyInternal = t;
    }
};

},{"@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"l4DbS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>t);
var _publicApi = require("@privy-io/public-api");
class t {
    async sendCode(t) {
        return await this._privyInternal.fetch((0, _publicApi.MfaPasswordlessSmsInit), {
            body: t
        });
    }
    constructor(r){
        this._privyInternal = r;
    }
}

},{"@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"lWzxj":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>e);
var _publicApi = require("@privy-io/public-api");
var _recoveryICloudApiMjs = require("./RecoveryICloudApi.mjs");
var _recoveryICloudApiMjsDefault = parcelHelpers.interopDefault(_recoveryICloudApiMjs);
var _recoveryOAuthApiMjs = require("./RecoveryOAuthApi.mjs");
var _recoveryOAuthApiMjsDefault = parcelHelpers.interopDefault(_recoveryOAuthApiMjs);
var _errorMjs = require("../../Error.mjs");
var _pkceMjs = require("../../pkce.mjs");
var _jose = require("jose");
class e {
    async getRecoveryKeyMaterial(t, i) {
        return this._privyInternal.fetch((0, _publicApi.RecoveryKeyMaterial), {
            body: {
                chain_type: i
            },
            params: {
                address: t
            }
        });
    }
    constructor(r, e, o){
        this._privyInternal = r, this.auth = new (0, _recoveryOAuthApiMjsDefault.default)(this._privyInternal, e, o), this.icloudAuth = new (0, _recoveryICloudApiMjsDefault.default)(this._privyInternal);
    }
}

},{"@privy-io/public-api":"3ZXNH","./RecoveryICloudApi.mjs":"cLDet","./RecoveryOAuthApi.mjs":"5BJea","../../Error.mjs":"kMDGn","../../pkce.mjs":"hcRGH","jose":"80NDr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"cLDet":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>r);
var _publicApi = require("@privy-io/public-api");
class r {
    async init(i) {
        return this._privyInternal.fetch((0, _publicApi.RecoveryOAuthInitICloud), {
            body: {
                client_type: i
            }
        });
    }
    async getICloudConfiguration(t) {
        return this._privyInternal.fetch((0, _publicApi.RecoveryConfigurationICloud), {
            body: {
                client_type: t
            }
        });
    }
    constructor(t){
        this._privyInternal = t;
    }
}

},{"@privy-io/public-api":"3ZXNH","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}],"5BJea":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>h);
var _publicApi = require("@privy-io/public-api");
var _errorMjs = require("../../Error.mjs");
var _pkceMjs = require("../../pkce.mjs");
var _jose = require("jose");
class h {
    async generateURL(e) {
        let r = (0, _pkceMjs.createCodeVerifier)(), h = (0, _pkceMjs.createStateCode)(), _ = await (0, _pkceMjs.deriveCodeChallengeFromCodeVerifier)({
            codeVerifier: r,
            digest: this._crypto?.digest
        });
        return await Promise.all([
            this._storage.put((0, _pkceMjs.CODE_VERIFIER_KEY), r),
            this._storage.put((0, _pkceMjs.STATE_CODE_KEY), h)
        ]), this._privyInternal.fetch((0, _publicApi.RecoveryOAuthInit), {
            body: {
                redirect_to: e,
                code_challenge: _,
                state_code: h
            }
        });
    }
    async authorize(t, i) {
        let [a, o] = await Promise.all([
            this._storage.get((0, _pkceMjs.CODE_VERIFIER_KEY)),
            this._storage.get((0, _pkceMjs.STATE_CODE_KEY))
        ]);
        if (o !== i) throw this._privyInternal.createAnalyticsEvent("possible_phishing_attempt", {
            flow: "recovery_oauth",
            storedStateCode: o ?? "",
            returnedStateCode: i ?? ""
        }), new (0, _errorMjs.PrivyClientError)({
            code: "pkce_state_code_mismatch",
            error: "Unexpected auth flow. This may be a phishing attempt."
        });
        let h = await this._privyInternal.fetch((0, _publicApi.RecoveryOAuthAuthenticate), {
            body: {
                authorization_code: t,
                state_code: o,
                code_verifier: a
            }
        });
        return await Promise.all([
            this._storage.del((0, _pkceMjs.CODE_VERIFIER_KEY)),
            this._storage.del((0, _pkceMjs.STATE_CODE_KEY))
        ]), h;
    }
    constructor(t, e, r){
        this._privyInternal = t, this._storage = e, this._crypto = r;
    }
}

},{"@privy-io/public-api":"3ZXNH","../../Error.mjs":"kMDGn","../../pkce.mjs":"hcRGH","jose":"80NDr","@parcel/transformer-js/src/esmodule-helpers.js":"jnFvT"}]},["n0fw4","kTBnD"], "kTBnD", "parcelRequire32f3", {})

//# sourceMappingURL=NFC Passkey.3c14d121.js.map
