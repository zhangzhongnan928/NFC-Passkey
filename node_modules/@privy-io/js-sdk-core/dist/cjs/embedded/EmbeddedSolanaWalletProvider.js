"use strict";var e=require("../Error.js"),r=require("../solana/getWalletPublicKeyFromTransaction.js"),t=require("../solana/isVersionedTransaction.js"),s=require("../wallet-api/unified-wallet.js"),a=require("./errors.js"),i=require("./stack/walletRpc.js");require("./types.js"),require("../utils/encodings.js"),require("../wallet-api/rpc.js"),require("canonicalize"),require("@privy-io/public-api"),require("./stack/wallet-api-eth-transaction.js"),require("./stack/wallet-api-eth-typed-data.js");exports.EmbeddedSolanaWalletProvider=class{async request(r){if(!await this._privyInternal.getAccessToken())throw new e.PrivyClientError({error:"Missing access token",code:"attempted_rpc_call_before_logged_in"});switch(r.method){case"signAndSendTransaction":return await this.handleSignAndSendTransaction(r);case"signTransaction":return await this.handleSignTransaction(r);default:return await this.handleIFrameRpc(r)}}get _publicKey(){return this._account.address}async connectAndRecover(r){if("privy-v2"!==this._account.recovery_method)try{await this._proxy.connect({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:r})}catch(t){let s=a.errorIndicatesRecoveryIsNeeded(t);if(s&&"privy"===this._account.recovery_method)await this._proxy.recover({entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier,accessToken:r});else{if(!s||!this._onNeedsRecovery)throw t;{let r;await new Promise((async(t,s)=>{r=setTimeout((()=>s(new e.PrivyClientError({code:"embedded_wallet_recovery_error",error:"User-owned recovery timed out"}))),12e4),await(this._onNeedsRecovery?.({recoveryMethod:this._account.recovery_method,onRecovered:()=>t(!0)}))})).finally((()=>clearTimeout(r)))}}}}async signMessageRpc(e,r){let t=this._account;if(!s.isUnifiedWallet(t))return(await this._proxy.rpcWallet({accessToken:r,request:e,chainType:"solana",hdWalletIndex:this._account.wallet_index,entropyId:this._entropyId,entropyIdVerifier:this._entropyIdVerifier})).response.data;{let{data:s}=await i.walletRpc({context:{app:this._app,fetchPrivyRoute:(...e)=>this._privyInternal.fetch(...e),getCompiledPath:(...e)=>this._privyInternal.getPath(...e),signRequest:({message:e})=>this._proxy.signWithUserSigner({accessToken:r,message:e})},account:t,rpcRequest:{chainType:"solana",request:e}});return{signature:s}}}async handleIFrameRpc(r){try{let e=await this._privyInternal.getAccessToken();if(!e)throw Error("Missing privy token. User must be logged in");return this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:r.method,address:this._account.address}),await this.connectAndRecover(e),await this.signMessageRpc(r,e)}catch(t){console.error(t);let s=t instanceof Error?t.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:r.method,address:this._account.address,error:s}),new e.PrivyClientError({code:"embedded_wallet_request_error",error:s})}}async handleSignAndSendTransaction(s){try{let e=await this._privyInternal.getAccessToken();if(!e)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:s.method,address:this._account.address}),await this.connectAndRecover(e);let{transaction:a,connection:i,options:n}=s.params,o=r.getWalletPublicKeyFromTransaction(a,this._account.address),c=t.isVersionedTransaction(a)?Buffer.from(a.message.serialize()):a.serializeMessage(),{signature:d}=await this.signMessageRpc({method:"signMessage",params:{message:c.toString("base64")}},e);return a.addSignature(o,Buffer.from(d,"base64")),{signature:await i.sendRawTransaction(a.serialize(),n)}}catch(r){console.error(r);let t=r instanceof Error?r.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:s.method,address:this._account.address,error:t}),new e.PrivyClientError({code:"embedded_wallet_request_error",error:t})}}async handleSignTransaction(s){try{let e=await this._privyInternal.getAccessToken();if(!e)throw Error("Missing privy token. User must be logged in");this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_started",{method:s.method,address:this._account.address}),await this.connectAndRecover(e);let{transaction:a}=s.params,i=r.getWalletPublicKeyFromTransaction(a,this._account.address),n=t.isVersionedTransaction(a)?Buffer.from(a.message.serialize()):a.serializeMessage(),{signature:o}=await this.signMessageRpc({method:"signMessage",params:{message:n.toString("base64")}},e);return a.addSignature(i,Buffer.from(o,"base64")),{signedTransaction:a}}catch(r){console.error(r);let t=r instanceof Error?r.message:"Unable to make wallet request";throw this._privyInternal.createAnalyticsEvent("embedded_wallet_sdk_rpc_failed",{method:s.method,address:this._account.wallet_index,error:t}),new e.PrivyClientError({code:"embedded_wallet_request_error",error:t})}}toJSON(){return`PrivyEmbeddedSolanaProvider { address: '${this._account.address}', request: [Function] }`}constructor({proxy:e,privyInternal:r,account:t,entropyId:s,entropyIdVerifier:a,onNeedsRecovery:i,app:n}){this._proxy=e,this._privyInternal=r,this._account=t,this._entropyId=s,this._entropyIdVerifier=a,this._onNeedsRecovery=i,this._app=n}};
