import{isHexEncoded as e,bytesToHex as t,utf8ToBytes as a}from"../../utils/encodings.mjs";import{rpc as s}from"../../wallet-api/rpc.mjs";import{toWalletApiUnsignedEthTransaction as n}from"./wallet-api-eth-transaction.mjs";import{toWalletApiTypedData as i}from"./wallet-api-eth-typed-data.mjs";import"canonicalize";import"@privy-io/public-api";async function r({context:r,account:o,rpcRequest:c}){switch(c.chainType){case"ethereum":return async function({context:r,account:o,rpcRequest:c}){switch(c.method){case"personal_sign":{let[e]=c.params,t=await s(r,r.signRequest,{chain_type:"ethereum",method:"personal_sign",wallet_id:o.id,params:e.startsWith("0x")?{message:e.slice(2),encoding:"hex"}:{message:e,encoding:"utf-8"}});if("personal_sign"!==t.method)throw Error("Unable to sign message");return{data:t.data.signature}}case"eth_signTransaction":{let[e]=c.params,t=await s(r,r.signRequest,{chain_type:"ethereum",method:"eth_signTransaction",wallet_id:o.id,params:{transaction:n(e)}});if("eth_signTransaction"!==t.method)throw Error("Unable to sign transaction");return{data:t.data.signed_transaction}}case"eth_signTypedData_v4":{let[,e]=c.params,t=await s(r,r.signRequest,{chain_type:"ethereum",method:c.method,wallet_id:o.id,params:{typed_data:i(e)}});if("eth_signTypedData_v4"!==t.method)throw Error("Unable to sign typed data");return{data:t.data.signature}}case"eth_sign":{let[,n]=c.params,i=await s(r,r.signRequest,{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:o.id,params:{hash:e(n)?n:t(a(n))}});if("secp256k1_sign"!==i.method)throw Error("Unable to sign message");return{data:i.data.signature}}case"secp256k1_sign":{let[n]=c.params,i=await s(r,r.signRequest,{chain_type:"ethereum",method:"secp256k1_sign",wallet_id:o.id,params:{hash:e(n)?n:t(a(n))}});if("secp256k1_sign"!==i.method)throw Error("Unable to sign message");return{data:i.data.signature}}case"csw_signUserOperation":case"eth_sendTransaction":case"eth_populateTransactionRequest":throw Error(`This wallet does not support the method: ${c.method}`)}}({context:r,account:o,rpcRequest:c.request});case"solana":return async function({context:e,account:t,rpcRequest:a}){if("signMessage"===a.method){let{message:n}=a.params,i=await s(e,e.signRequest,{chain_type:"solana",method:"signMessage",wallet_id:t.id,params:{message:n,encoding:"base64"}});if("signMessage"!==i.method)throw Error("Unable to sign message");return{data:i.data.signature}}}({context:r,account:o,rpcRequest:c.request})}}export{r as walletRpc};
