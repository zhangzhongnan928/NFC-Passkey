import{createSmartAccountClient as e}from"permissionless";import{toThirdwebSmartAccount as r,toLightSmartAccount as t,toBiconomySmartAccount as a,toEcdsaKernelSmartAccount as i,toSafeSmartAccount as n}from"permissionless/accounts";import{createPimlicoClient as s}from"permissionless/clients/pimlico";import{http as o}from"viem";import{toCoinbaseSmartAccount as c,entryPoint06Address as l,entryPoint07Address as m}from"viem/account-abstraction";import{THIRDWEB as p,COINBASE_SMART_WALLET as u,LIGHT_ACCOUNT as y,BICONOMY as P,KERNEL as d,SAFE as w}from"@privy-io/public-api";let f={address:l,version:"0.6"},h={address:m,version:"0.7"},b=({owner:e,smartWalletType:s,publicClient:o})=>{switch(s){case w:return n({client:o,entryPoint:h,owners:[e],version:"1.4.1"});case d:return i({client:o,version:"0.3.1",entryPoint:h,owners:[e]});case P:return a({client:o,owners:[e],entryPoint:f});case y:return t({client:o,entryPoint:f,owner:e,version:"1.1.0"});case u:return async function({client:e,owner:r}){let[t]=await r.request({method:"eth_accounts"});if(!t)throw Error("Unable to request embedded owner for eth_accounts");return await c({client:e,owners:[{type:"local",source:"privy",address:t,sign:async({hash:e})=>await r.request({method:"secp256k1_sign",params:[e]})}]})}({client:o,owner:e});case p:return r({client:o,entryPoint:h,owner:e});default:throw Error(`Invalid smart account type: ${s}.`)}};const G=async({owner:r,smartWalletType:t,chain:a,publicClient:i,bundlerUrl:n,paymasterUrl:c,paymasterContext:l})=>{let m=await b({owner:r,smartWalletType:t,publicClient:i}),p=s({transport:o(n),entryPoint:m.entryPoint}),u=c?s({transport:o(c),entryPoint:m.entryPoint}):void 0;return e({account:m,chain:a,paymaster:u,paymasterContext:l,bundlerTransport:o(n),userOperation:{estimateFeesPerGas:async()=>{if(["public.pimlico.io","api.pimlico.io"].some((e=>n.includes(e))))return await p.getUserOperationGasPrice().then((e=>e.fast));if(["rpc.zerodev.app"].some((e=>n.includes(e))))return(await p.request({method:"zd_getUserOperationGasPrice",params:[]})).fast;if(["g.alchemy.com"].some((e=>n.includes(e)))){let[e,r]=await Promise.all([i.getBlock({blockTag:"latest"}),p.request({method:"rundler_maxPriorityFeePerGas",params:[]})]);if(!e.baseFeePerGas||!r)throw Error("Failed to get block or maxPriorityFeePerGasEstimate");return{maxFeePerGas:150n*e.baseFeePerGas/100n+BigInt(r.toString()),maxPriorityFeePerGas:BigInt(r.toString())}}{let e=await i.estimateFeesPerGas(),r=n.includes("api.developer.coinbase.com")?175n:150n;return{...e,maxFeePerGas:e.maxFeePerGas*r/100n,maxPriorityFeePerGas:e.maxPriorityFeePerGas*r/100n}}}}})};export{G as signerToSmartAccountClient};
